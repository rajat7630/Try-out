
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.head.appendChild(r) })(window.document);
var app = (function () {
    'use strict';

    function noop() { }
    const identity = x => x;
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function is_promise(value) {
        return value && typeof value === 'object' && typeof value.then === 'function';
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function get_store_value(store) {
        let value;
        subscribe(store, _ => value = _)();
        return value;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if (typeof $$scope.dirty === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function set_store_value(store, ret, value = ret) {
        store.set(value);
        return ret;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }

    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn) {
        return function (event) {
            event.preventDefault();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function get_binding_group_value(group) {
        const value = [];
        for (let i = 0; i < group.length; i += 1) {
            if (group[i].checked)
                value.push(group[i].__value);
        }
        return value;
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        if (value != null || input.value) {
            input.value = value;
        }
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, false, false, detail);
        return e;
    }

    let stylesheet;
    let active = 0;
    let current_rules = {};
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        if (!current_rules[name]) {
            if (!stylesheet) {
                const style = element('style');
                document.head.appendChild(style);
                stylesheet = style.sheet;
            }
            current_rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ``}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        node.style.animation = (node.style.animation || '')
            .split(', ')
            .filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        )
            .join(', ');
        if (name && !--active)
            clear_rules();
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            let i = stylesheet.cssRules.length;
            while (i--)
                stylesheet.deleteRule(i);
            current_rules = {};
        });
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error(`Function called outside component initialization`);
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
    }
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    const seen_callbacks = new Set();
    function flush() {
        do {
            // first, call beforeUpdate functions
            // and update components
            while (dirty_components.length) {
                const component = dirty_components.shift();
                set_current_component(component);
                update(component.$$);
            }
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    const null_transition = { duration: 0 };
    function create_bidirectional_transition(node, fn, params, intro) {
        let config = fn(node, params);
        let t = intro ? 0 : 1;
        let running_program = null;
        let pending_program = null;
        let animation_name = null;
        function clear_animation() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function init(program, duration) {
            const d = program.b - t;
            duration *= Math.abs(d);
            return {
                a: t,
                b: program.b,
                d,
                duration,
                start: program.start,
                end: program.start + duration,
                group: program.group
            };
        }
        function go(b) {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            const program = {
                start: now() + delay,
                b
            };
            if (!b) {
                // @ts-ignore todo: improve typings
                program.group = outros;
                outros.r += 1;
            }
            if (running_program) {
                pending_program = program;
            }
            else {
                // if this is an intro, and there's a delay, we need to do
                // an initial tick and/or apply CSS animation immediately
                if (css) {
                    clear_animation();
                    animation_name = create_rule(node, t, b, duration, delay, easing, css);
                }
                if (b)
                    tick(0, 1);
                running_program = init(program, duration);
                add_render_callback(() => dispatch(node, b, 'start'));
                loop(now => {
                    if (pending_program && now > pending_program.start) {
                        running_program = init(pending_program, duration);
                        pending_program = null;
                        dispatch(node, running_program.b, 'start');
                        if (css) {
                            clear_animation();
                            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                        }
                    }
                    if (running_program) {
                        if (now >= running_program.end) {
                            tick(t = running_program.b, 1 - t);
                            dispatch(node, running_program.b, 'end');
                            if (!pending_program) {
                                // we're done
                                if (running_program.b) {
                                    // intro — we can tidy up immediately
                                    clear_animation();
                                }
                                else {
                                    // outro — needs to be coordinated
                                    if (!--running_program.group.r)
                                        run_all(running_program.group.c);
                                }
                            }
                            running_program = null;
                        }
                        else if (now >= running_program.start) {
                            const p = now - running_program.start;
                            t = running_program.a + running_program.d * easing(p / running_program.duration);
                            tick(t, 1 - t);
                        }
                    }
                    return !!(running_program || pending_program);
                });
            }
        }
        return {
            run(b) {
                if (is_function(config)) {
                    wait().then(() => {
                        // @ts-ignore
                        config = config();
                        go(b);
                    });
                }
                else {
                    go(b);
                }
            },
            end() {
                clear_animation();
                running_program = pending_program = null;
            }
        };
    }

    function handle_promise(promise, info) {
        const token = info.token = {};
        function update(type, index, key, value) {
            if (info.token !== token)
                return;
            info.resolved = value;
            let child_ctx = info.ctx;
            if (key !== undefined) {
                child_ctx = child_ctx.slice();
                child_ctx[key] = value;
            }
            const block = type && (info.current = type)(child_ctx);
            let needs_flush = false;
            if (info.block) {
                if (info.blocks) {
                    info.blocks.forEach((block, i) => {
                        if (i !== index && block) {
                            group_outros();
                            transition_out(block, 1, 1, () => {
                                info.blocks[i] = null;
                            });
                            check_outros();
                        }
                    });
                }
                else {
                    info.block.d(1);
                }
                block.c();
                transition_in(block, 1);
                block.m(info.mount(), info.anchor);
                needs_flush = true;
            }
            info.block = block;
            if (info.blocks)
                info.blocks[index] = block;
            if (needs_flush) {
                flush();
            }
        }
        if (is_promise(promise)) {
            const current_component = get_current_component();
            promise.then(value => {
                set_current_component(current_component);
                update(info.then, 1, info.value, value);
                set_current_component(null);
            }, error => {
                set_current_component(current_component);
                update(info.catch, 2, info.error, error);
                set_current_component(null);
            });
            // if we previously had a then/catch block, destroy it
            if (info.current !== info.pending) {
                update(info.pending, 0);
                return true;
            }
        }
        else {
            if (info.current !== info.then) {
                update(info.then, 1, info.value, promise);
                return true;
            }
            info.resolved = promise;
        }
    }

    const globals = (typeof window !== 'undefined' ? window : global);

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const prop_values = options.props || {};
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : []),
            // everything else
            callbacks: blank_object(),
            dirty
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, prop_values, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if ($$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(children(options.target));
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor);
            flush();
        }
        set_current_component(parent_component);
    }
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set() {
            // overridden by instance, if it has props
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.18.1' }, detail)));
    }
    function append_dev(target, node) {
        dispatch_dev("SvelteDOMInsert", { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev("SvelteDOMInsert", { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev("SvelteDOMRemove", { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ["capture"] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev("SvelteDOMAddEventListener", { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev("SvelteDOMRemoveEventListener", { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev("SvelteDOMRemoveAttribute", { node, attribute });
        else
            dispatch_dev("SvelteDOMSetAttribute", { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev("SvelteDOMSetProperty", { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.data === data)
            return;
        dispatch_dev("SvelteDOMSetData", { node: text, data });
        text.data = data;
    }
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error(`'target' is a required option`);
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn(`Component was already destroyed`); // eslint-disable-line no-console
            };
        }
    }

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe,
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = [];
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (let i = 0; i < subscribers.length; i += 1) {
                        const s = subscribers[i];
                        s[1]();
                        subscriber_queue.push(s, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.push(subscriber);
            if (subscribers.length === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                const index = subscribers.indexOf(subscriber);
                if (index !== -1) {
                    subscribers.splice(index, 1);
                }
                if (subscribers.length === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    var store = /*#__PURE__*/Object.freeze({
        __proto__: null,
        derived: derived,
        readable: readable,
        writable: writable,
        get: get_store_value
    });

    function unwrapExports (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    function getCjsExportFromNamespace (n) {
    	return n && n['default'] || n;
    }

    var require$$0 = getCjsExportFromNamespace(store);

    const writable$1 = require$$0.writable;

    const router = writable$1({});

    function set(route) {
      router.set(route);
    }

    function remove() {
      router.set({});
    }

    const activeRoute = {
      subscribe: router.subscribe,
      set,
      remove
    };

    var store$1 = { activeRoute };
    var store_1 = store$1.activeRoute;

    const UrlParser = (urlString, namedUrl = "") => {
      const urlBase = new URL(urlString);

      /**
       * Wrapper for URL.host
       *
       **/
      function host() {
        return urlBase.host;
      }

      /**
       * Wrapper for URL.hostname
       *
       **/
      function hostname() {
        return urlBase.hostname;
      }

      /**
       * Returns an object with all the named params and their values
       *
       **/
      function namedParams() {
        const allPathName = pathNames();
        const allNamedParamsKeys = namedParamsWithIndex();

        return allNamedParamsKeys.reduce((values, paramKey) => {
          values[paramKey.value] = allPathName[paramKey.index];
          return values;
        }, {});
      }

      /**
       * Returns an array with all the named param keys
       *
       **/
      function namedParamsKeys() {
        const allNamedParamsKeys = namedParamsWithIndex();

        return allNamedParamsKeys.reduce((values, paramKey) => {
          values.push(paramKey.value);
          return values;
        }, []);
      }

      /**
       * Returns an array with all the named param values
       *
       **/
      function namedParamsValues() {
        const allPathName = pathNames();
        const allNamedParamsKeys = namedParamsWithIndex();

        return allNamedParamsKeys.reduce((values, paramKey) => {
          values.push(allPathName[paramKey.index]);
          return values;
        }, []);
      }

      /**
       * Returns an array with all named param ids and their position in the path
       * Private
       **/
      function namedParamsWithIndex() {
        const namedUrlParams = getPathNames(namedUrl);

        return namedUrlParams.reduce((validParams, param, index) => {
          if (param[0] === ":") {
            validParams.push({ value: param.slice(1), index });
          }
          return validParams;
        }, []);
      }

      /**
       * Wrapper for URL.port
       *
       **/
      function port() {
        return urlBase.port;
      }

      /**
       * Wrapper for URL.pathname
       *
       **/
      function pathname() {
        return urlBase.pathname;
      }

      /**
       * Wrapper for URL.protocol
       *
       **/
      function protocol() {
        return urlBase.protocol;
      }

      /**
       * Wrapper for URL.search
       *
       **/
      function search() {
        return urlBase.search;
      }

      /**
       * Returns an object with all query params and their values
       *
       **/
      function queryParams() {
        const params = {};
        urlBase.searchParams.forEach((value, key) => {
          params[key] = value;
        });

        return params;
      }

      /**
       * Returns an array with all the query param keys
       *
       **/
      function queryParamsKeys() {
        const params = [];
        urlBase.searchParams.forEach((_value, key) => {
          params.push(key);
        });

        return params;
      }

      /**
       * Returns an array with all the query param values
       *
       **/
      function queryParamsValues() {
        const params = [];
        urlBase.searchParams.forEach(value => {
          params.push(value);
        });

        return params;
      }

      /**
       * Returns an array with all the elements of a pathname
       *
       **/
      function pathNames() {
        return getPathNames(urlBase.pathname);
      }

      /**
       * Returns an array with all the parts of a pathname
       * Private method
       **/
      function getPathNames(pathName) {
        if (pathName === "/" || pathName.trim().length === 0) return [pathName];
        if (pathName.slice(-1) === "/") {
          pathName = pathName.slice(0, -1);
        }
        if (pathName[0] === "/") {
          pathName = pathName.slice(1);
        }

        return pathName.split("/");
      }

      return Object.freeze({
        host: host(),
        hostname: hostname(),
        namedParams: namedParams(),
        namedParamsKeys: namedParamsKeys(),
        namedParamsValues: namedParamsValues(),
        pathNames: pathNames(),
        port: port(),
        pathname: pathname(),
        protocol: protocol(),
        search: search(),
        queryParams: queryParams(),
        queryParamsKeys: queryParamsKeys(),
        queryParamsValues: queryParamsValues()
      });
    };

    var url_parser = { UrlParser };

    const UrlParser$1 = url_parser.UrlParser;

    var urlParamsParser = {
      UrlParser: UrlParser$1
    };

    /**
     * Returns true if object has any nested routes empty
     * @param routeObject
     **/
    function anyEmptyNestedRoutes(routeObject) {
      let result = false;
      if (Object.keys(routeObject).length === 0) {
        return true
      }

      if (routeObject.childRoute && Object.keys(routeObject.childRoute).length === 0) {
        result = true;
      } else if (routeObject.childRoute) {
        result = anyEmptyNestedRoutes(routeObject.childRoute);
      }

      return result
    }

    /**
     * Compare two routes ignoring named params
     * @param pathName string
     * @param routeName string
     **/

    function compareRoutes(pathName, routeName) {
      routeName = removeSlash(routeName);

      if (routeName.includes(':')) {
        return routeName.includes(pathName)
      } else {
        return routeName.startsWith(pathName)
      }
    }

    /**
     * Returns a boolean indicating if the name of path exists in the route based on the language parameter
     * @param pathName string
     * @param route object
     * @param language string
     **/

    function findLocalisedRoute(pathName, route, language) {
      let exists = false;

      if (language) {
        return { exists: route.lang && route.lang[language] && route.lang[language].includes(pathName), language }
      }

      exists = compareRoutes(pathName, route.name);

      if (!exists && route.lang && typeof route.lang === 'object') {
        for (const [key, value] of Object.entries(route.lang)) {
          if (compareRoutes(pathName, value)) {
            exists = true;
            language = key;
          }
        }
      }

      return { exists, language }
    }

    /**
     * Return all the consecutive named param (placeholders) of a pathname
     * @param pathname
     **/
    function getNamedParams(pathName = '') {
      if (pathName.trim().length === 0) return []
      const namedUrlParams = getPathNames(pathName);
      return namedUrlParams.reduce((validParams, param) => {
        if (param[0] === ':') {
          validParams.push(param.slice(1));
        }

        return validParams
      }, [])
    }

    /**
     * Split a pathname based on /
     * @param pathName
     * Private method
     **/
    function getPathNames(pathName) {
      if (pathName === '/' || pathName.trim().length === 0) return [pathName]

      pathName = removeSlash(pathName, 'both');

      return pathName.split('/')
    }

    /**
     * Return the first part of a pathname until the first named param is found
     * @param name
     **/
    function nameToPath(name = '') {
      let routeName;
      if (name === '/' || name.trim().length === 0) return name
      name = removeSlash(name, 'lead');
      routeName = name.split(':')[0];
      routeName = removeSlash(routeName, 'trail');

      return routeName.toLowerCase()
    }

    /**
     * Return the path name including query params
     * @param name
     **/
    function pathWithQueryParams(currentRoute) {
      let queryParams = [];
      if (currentRoute.queryParams) {
        for (let [key, value] of Object.entries(currentRoute.queryParams)) {
          queryParams.push(`${key}=${value}`);
        }
      }

      if (queryParams.length > 0) {
        return `${currentRoute.path}?${queryParams.join('&')}`
      } else {
        return currentRoute.path
      }
    }

    /**
     * Returns a string with trailing or leading slash character removed
     * @param pathName string
     * @param position string - lead, trail, both
     **/
    function removeExtraPaths(pathNames, basePathNames) {
      const names = basePathNames.split('/');
      if (names.length > 1) {
        names.forEach(function(name, index) {
          if (name.length > 0 && index > 0) {
            pathNames.shift();
          }
        });
      }

      return pathNames
    }

    /**
     * Returns a string with trailing or leading slash character removed
     * @param pathName string
     * @param position string - lead, trail, both
     **/

    function removeSlash(pathName, position = 'lead') {
      if (pathName.trim().length < 1) {
        return ''
      }

      if (position === 'trail' || position === 'both') {
        if (pathName.slice(-1) === '/') {
          pathName = pathName.slice(0, -1);
        }
      }

      if (position === 'lead' || position === 'both') {
        if (pathName[0] === '/') {
          pathName = pathName.slice(1);
        }
      }

      return pathName
    }

    /**
     * Returns the name of the route based on the language parameter
     * @param route object
     * @param language string
     **/

    function routeNameLocalised(route, language = null) {
      if (!language || !route.lang || !route.lang[language]) {
        return route.name
      } else {
        return route.lang[language]
      }
    }

    /**
     * Updates the base route path.
     * Route objects can have nested routes (childRoutes) or just a long name like "admin/employees/show/:id"
     *
     * @param basePath string
     * @param pathNames array
     * @param route object
     * @param language string
     **/

    function updateRoutePath(basePath, pathNames, route, language, convert = false) {
      if (basePath === '/' || basePath.trim().length === 0) return { result: basePath, language: null }

      let basePathResult = basePath;
      let routeName = route.name;
      let currentLanguage = language;

      if (convert) {
        currentLanguage = '';
      }

      routeName = removeSlash(routeName);
      basePathResult = removeSlash(basePathResult);

      if (!route.childRoute) {
        let localisedRoute = findLocalisedRoute(basePathResult, route, currentLanguage);

        if (localisedRoute.exists && convert) {
          basePathResult = routeNameLocalised(route, language);
        }

        let routeNames = routeName.split(':')[0];
        routeNames = removeSlash(routeNames, 'trail');
        routeNames = routeNames.split('/');
        routeNames.shift();
        routeNames.forEach(() => {
          const currentPathName = pathNames[0];
          localisedRoute = findLocalisedRoute(`${basePathResult}/${currentPathName}`, route, currentLanguage);

          if (currentPathName && localisedRoute.exists) {
            if (convert) {
              basePathResult = routeNameLocalised(route, language);
            } else {
              basePathResult = `${basePathResult}/${currentPathName}`;
            }
            pathNames.shift();
          } else {
            return { result: basePathResult, language: localisedRoute.language }
          }
        });
        return { result: basePathResult, language: localisedRoute.language }
      } else {
        return { result: basePath, language: currentLanguage }
      }
    }

    var utils = {
      anyEmptyNestedRoutes,
      compareRoutes,
      findLocalisedRoute,
      getNamedParams,
      getPathNames,
      nameToPath,
      pathWithQueryParams,
      removeExtraPaths,
      removeSlash,
      routeNameLocalised,
      updateRoutePath
    };

    const { UrlParser: UrlParser$2 } = urlParamsParser;

    const { pathWithQueryParams: pathWithQueryParams$1, removeSlash: removeSlash$1 } = utils;

    function RouterCurrent(trackPage) {
      const trackPageview = trackPage || false;
      let activeRoute = '';

      function setActive(newRoute) {
        activeRoute = newRoute.path;
        pushActiveRoute(newRoute);
      }

      function active() {
        return activeRoute
      }

      /**
       * Returns true if pathName is current active route
       * @param pathName String The path name to check against the current route.
       * @param includePath Boolean if true checks that pathName is included in current route. If false should match it.
       **/
      function isActive(queryPath, includePath = false) {
        if (queryPath[0] !== '/') {
          queryPath = '/' + queryPath;
        }

        // remove query params for comparison
        let pathName = UrlParser$2(`http://fake.com${queryPath}`).pathname;
        let activeRoutePath = UrlParser$2(`http://fake.com${activeRoute}`).pathname;

        pathName = removeSlash$1(pathName, 'trail');

        activeRoutePath = removeSlash$1(activeRoutePath, 'trail');

        if (includePath) {
          return activeRoutePath.includes(pathName)
        } else {
          return activeRoutePath === pathName
        }
      }

      function pushActiveRoute(newRoute) {
        if (typeof window !== 'undefined') {
          const pathAndSearch = pathWithQueryParams$1(newRoute);
          window.history.pushState({ page: pathAndSearch }, '', pathAndSearch);
          if (trackPageview) {
            gaTracking(pathAndSearch);
          }
        }
      }

      function gaTracking(newPage) {
        if (typeof ga !== 'undefined') {
          ga('set', 'page', newPage);
          ga('send', 'pageview');
        }
      }

      return Object.freeze({ active, isActive, setActive })
    }

    var current = { RouterCurrent };

    function RouterGuard(onlyIf) {
      const guardInfo = onlyIf;

      function valid() {
        return guardInfo && guardInfo.guard && typeof guardInfo.guard === 'function'
      }

      function redirect() {
        return !guardInfo.guard()
      }

      function redirectPath() {
        let destinationUrl = '/';
        if (guardInfo.redirect && guardInfo.redirect.length > 0) {
          destinationUrl = guardInfo.redirect;
        }

        return destinationUrl
      }

      return Object.freeze({ valid, redirect, redirectPath })
    }

    var guard = { RouterGuard };

    const { RouterGuard: RouterGuard$1 } = guard;

    function RouterRedirect(route, currentPath) {
      const guard = RouterGuard$1(route.onlyIf);

      function path() {
        let redirectTo = currentPath;
        if (route.redirectTo && route.redirectTo.length > 0) {
          redirectTo = route.redirectTo;
        }

        if (guard.valid() && guard.redirect()) {
          redirectTo = guard.redirectPath();
        }

        return redirectTo
      }

      return Object.freeze({ path })
    }

    var redirect = { RouterRedirect };

    const { UrlParser: UrlParser$3 } = urlParamsParser;

    function RouterRoute({ routeInfo, path, routeNamedParams, urlParser, namedPath, language }) {
      function namedParams() {
        const parsedParams = UrlParser$3(`https://fake.com${urlParser.pathname}`, namedPath).namedParams;

        return { ...routeNamedParams, ...parsedParams }
      }

      function get() {
        return {
          name: path,
          component: routeInfo.component,
          layout: routeInfo.layout,
          queryParams: urlParser.queryParams,
          namedParams: namedParams(),
          path,
          language
        }
      }

      return Object.freeze({ get, namedParams })
    }

    var route = { RouterRoute };

    const { updateRoutePath: updateRoutePath$1, getNamedParams: getNamedParams$1, nameToPath: nameToPath$1, removeExtraPaths: removeExtraPaths$1, routeNameLocalised: routeNameLocalised$1 } = utils;

    function RouterPath({ basePath, basePathName, pathNames, convert, currentLanguage }) {
      let updatedPathRoute;
      let route;
      let routePathLanguage = currentLanguage;

      function updatedPath(currentRoute) {
        route = currentRoute;
        updatedPathRoute = updateRoutePath$1(basePathName, pathNames, route, routePathLanguage, convert);
        routePathLanguage = convert ? currentLanguage : updatedPathRoute.language;

        return updatedPathRoute
      }

      function localisedPathName() {
        return routeNameLocalised$1(route, routePathLanguage)
      }

      function localisedRouteWithoutNamedParams() {
        return nameToPath$1(localisedPathName())
      }

      function basePathNameWithoutNamedParams() {
        return nameToPath$1(updatedPathRoute.result)
      }

      function namedPath() {
        const localisedPath = localisedPathName();

        return basePath ? `${basePath}/${localisedPath}` : localisedPath
      }

      function routePath() {
        let routePathValue = `${basePath}/${basePathNameWithoutNamedParams()}`;
        if (routePathValue === '//') {
          routePathValue = '/';
        }

        if (routePathLanguage) {
          pathNames = removeExtraPaths$1(pathNames, localisedRouteWithoutNamedParams());
        }

        const namedParams = getNamedParams$1(localisedPathName());
        if (namedParams && namedParams.length > 0) {
          namedParams.forEach(function() {
            if (pathNames.length > 0) {
              routePathValue += `/${pathNames.shift()}`;
            }
          });
        }

        return routePathValue
      }

      function routeLanguage() {
        return routePathLanguage
      }

      function basePathSameAsLocalised() {
        return basePathNameWithoutNamedParams() === localisedRouteWithoutNamedParams()
      }

      return Object.freeze({
        basePathSameAsLocalised,
        updatedPath,
        basePathNameWithoutNamedParams,
        localisedPathName,
        localisedRouteWithoutNamedParams,
        namedPath,
        pathNames,
        routeLanguage,
        routePath
      })
    }

    var path = { RouterPath };

    const { UrlParser: UrlParser$4 } = urlParamsParser;

    const { RouterRedirect: RouterRedirect$1 } = redirect;
    const { RouterRoute: RouterRoute$1 } = route;
    const { RouterPath: RouterPath$1 } = path;
    const { anyEmptyNestedRoutes: anyEmptyNestedRoutes$1, pathWithQueryParams: pathWithQueryParams$2 } = utils;

    const NotFoundPage = '/404.html';

    function RouterFinder(routes, currentUrl, language, convert) {
      let redirectTo = '';
      let routeNamedParams = {};
      const urlParser = UrlParser$4(currentUrl);

      function findActiveRoute() {
        let searchActiveRoute = searchActiveRoutes(routes, '', urlParser.pathNames, language, convert);

        if (!searchActiveRoute || !Object.keys(searchActiveRoute).length || anyEmptyNestedRoutes$1(searchActiveRoute)) {
          if (typeof window !== 'undefined') {
            searchActiveRoute = { name: '404', component: '', path: '404', redirectTo: NotFoundPage };
          }
        } else {
          searchActiveRoute.path = pathWithQueryParams$2(searchActiveRoute);
        }

        return searchActiveRoute
      }

      /**
       * Gets an array of routes and the browser pathname and return the active route
       * @param routes
       * @param basePath
       * @param pathNames
       **/
      function searchActiveRoutes(routes, basePath, pathNames, currentLanguage, convert) {
        let currentRoute = {};
        let basePathName = pathNames.shift().toLowerCase();
        const routerPath = RouterPath$1({ basePath, basePathName, pathNames, convert, currentLanguage });

        routes.forEach(function(route) {
          routerPath.updatedPath(route);
          if (routerPath.basePathSameAsLocalised()) {
            let routePath = routerPath.routePath();

            redirectTo = RouterRedirect$1(route, redirectTo).path();

            if (currentRoute.name !== routePath) {
              currentRoute = setCurrentRoute({
                route,
                routePath,
                routeLanguage: routerPath.routeLanguage(),
                urlParser,
                namedPath: routerPath.namedPath()
              });
            }

            if (route.nestedRoutes && route.nestedRoutes.length > 0 && routerPath.pathNames.length > 0) {
              currentRoute.childRoute = searchActiveRoutes(
                route.nestedRoutes,
                routePath,
                routerPath.pathNames,
                routerPath.routeLanguage(),
                convert
              );
              currentRoute.path = currentRoute.childRoute.path;
              currentRoute.language = currentRoute.childRoute.language;
            } else if (nestedRoutesAndNoPath(route, routerPath.pathNames)) {
              const indexRoute = searchActiveRoutes(
                route.nestedRoutes,
                routePath,
                ['index'],
                routerPath.routeLanguage(),
                convert
              );
              if (indexRoute && Object.keys(indexRoute).length > 0) {
                currentRoute.childRoute = indexRoute;
                currentRoute.language = currentRoute.childRoute.language;
              }
            }
          }
        });

        if (redirectTo) {
          currentRoute.redirectTo = redirectTo;
        }

        return currentRoute
      }

      function nestedRoutesAndNoPath(route, pathNames) {
        return route.nestedRoutes && route.nestedRoutes.length > 0 && pathNames.length === 0
      }

      function setCurrentRoute({ route, routePath, routeLanguage, urlParser, namedPath }) {
        const routerRoute = RouterRoute$1({
          routeInfo: route,
          urlParser,
          path: routePath,
          routeNamedParams,
          namedPath,
          language: routeLanguage
        });
        routeNamedParams = routerRoute.namedParams();

        return routerRoute.get()
      }

      return Object.freeze({ findActiveRoute })
    }

    var finder = { RouterFinder };

    const { activeRoute: activeRoute$1 } = store$1;
    const { RouterCurrent: RouterCurrent$1 } = current;
    const { RouterFinder: RouterFinder$1 } = finder;
    const { removeSlash: removeSlash$2 } = utils;

    const NotFoundPage$1 = '/404.html';

    let userDefinedRoutes = [];
    let routerOptions = {};
    let routerCurrent;

    /**
     * Object exposes one single property: activeRoute
     * @param routes  Array of routes
     * @param currentUrl current url
     * @param options configuration options
     **/
    function SpaRouter(routes, currentUrl, options = {}) {
      routerOptions = { ...options };
      if (typeof currentUrl === 'undefined' || currentUrl === '') {
        currentUrl = document.location.href;
      }

      routerCurrent = RouterCurrent$1(routerOptions.gaPageviews);

      currentUrl = removeSlash$2(currentUrl, 'trail');
      userDefinedRoutes = routes;

      function findActiveRoute() {
        let convert = false;

        if (routerOptions.langConvertTo) {
          routerOptions.lang = routerOptions.langConvertTo;
          convert = true;
        }

        return RouterFinder$1(routes, currentUrl, routerOptions.lang, convert).findActiveRoute()
      }

      /**
       * Redirect current route to another
       * @param destinationUrl
       **/
      function navigateNow(destinationUrl) {
        if (typeof window !== 'undefined') {
          if (destinationUrl === NotFoundPage$1) {
            routerCurrent.setActive({ path: NotFoundPage$1 });
          } else {
            navigateTo(destinationUrl);
          }
        }

        return destinationUrl
      }

      function setActiveRoute() {
        const currentRoute = findActiveRoute();
        if (currentRoute.redirectTo) {
          return navigateNow(currentRoute.redirectTo)
        }

        routerCurrent.setActive(currentRoute);
        activeRoute$1.set(currentRoute);

        return currentRoute
      }

      return Object.freeze({
        setActiveRoute,
        findActiveRoute
      })
    }

    /**
     * Converts a route to its localised version
     * @param pathName
     **/
    function localisedRoute(pathName, language) {
      pathName = removeSlash$2(pathName, 'lead');
      routerOptions.langConvertTo = language;

      return SpaRouter(userDefinedRoutes, 'http://fake.com/' + pathName, routerOptions).findActiveRoute()
    }

    /**
     * Updates the current active route and updates the browser pathname
     * @param pathName String
     * @param language String
     **/
    function navigateTo(pathName, language = null) {
      pathName = removeSlash$2(pathName, 'lead');

      if (language) {
        routerOptions.langConvertTo = language;
      }
      const activeRoute = SpaRouter(userDefinedRoutes, 'http://fake.com/' + pathName, routerOptions).setActiveRoute();

      return activeRoute
    }

    /**
     * Returns true if pathName is current active route
     * @param pathName String The path name to check against the current route.
     * @param includePath Boolean if true checks that pathName is included in current route. If false should match it.
     **/
    function routeIsActive(queryPath, includePath = false) {
      return routerCurrent.isActive(queryPath, includePath)
    }

    if (typeof window !== 'undefined') {
      // Avoid full page reload on local routes
      window.addEventListener('click', event => {
        if (event.target.pathname && event.target.hostname === window.location.hostname && event.target.localName === 'a') {
          event.preventDefault();
          // event.stopPropagation()
          navigateTo(event.target.pathname + event.target.search);
        }
      });

      window.onpopstate = function(_event) {
        navigateTo(window.location.pathname + window.location.search);
      };
    }

    var spa_router = { SpaRouter, localisedRoute, navigateTo, routeIsActive };
    var spa_router_1 = spa_router.SpaRouter;
    var spa_router_2 = spa_router.localisedRoute;
    var spa_router_3 = spa_router.navigateTo;
    var spa_router_4 = spa_router.routeIsActive;

    /* node_modules/svelte-router-spa/src/components/route.svelte generated by Svelte v3.18.1 */

    // (10:34) 
    function create_if_block_2(ctx) {
    	let current;

    	const route = new Route({
    			props: {
    				currentRoute: /*currentRoute*/ ctx[0].childRoute,
    				params: /*params*/ ctx[1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(route.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(route, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const route_changes = {};
    			if (dirty & /*currentRoute*/ 1) route_changes.currentRoute = /*currentRoute*/ ctx[0].childRoute;
    			if (dirty & /*params*/ 2) route_changes.params = /*params*/ ctx[1];
    			route.$set(route_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(route.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(route.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(route, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(10:34) ",
    		ctx
    	});

    	return block;
    }

    // (8:33) 
    function create_if_block_1(ctx) {
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*currentRoute*/ ctx[0].component;

    	function switch_props(ctx) {
    		return {
    			props: {
    				currentRoute: {
    					.../*currentRoute*/ ctx[0],
    					component: ""
    				},
    				params: /*params*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		var switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};

    			if (dirty & /*currentRoute*/ 1) switch_instance_changes.currentRoute = {
    				.../*currentRoute*/ ctx[0],
    				component: ""
    			};

    			if (dirty & /*params*/ 2) switch_instance_changes.params = /*params*/ ctx[1];

    			if (switch_value !== (switch_value = /*currentRoute*/ ctx[0].component)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(8:33) ",
    		ctx
    	});

    	return block;
    }

    // (6:0) {#if currentRoute.layout}
    function create_if_block(ctx) {
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*currentRoute*/ ctx[0].layout;

    	function switch_props(ctx) {
    		return {
    			props: {
    				currentRoute: { .../*currentRoute*/ ctx[0], layout: "" },
    				params: /*params*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		var switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*currentRoute*/ 1) switch_instance_changes.currentRoute = { .../*currentRoute*/ ctx[0], layout: "" };
    			if (dirty & /*params*/ 2) switch_instance_changes.params = /*params*/ ctx[1];

    			if (switch_value !== (switch_value = /*currentRoute*/ ctx[0].layout)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(6:0) {#if currentRoute.layout}",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block, create_if_block_1, create_if_block_2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*currentRoute*/ ctx[0].layout) return 0;
    		if (/*currentRoute*/ ctx[0].component) return 1;
    		if (/*currentRoute*/ ctx[0].childRoute) return 2;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { currentRoute = {} } = $$props;
    	let { params = {} } = $$props;
    	const writable_props = ["currentRoute", "params"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Route> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ("currentRoute" in $$props) $$invalidate(0, currentRoute = $$props.currentRoute);
    		if ("params" in $$props) $$invalidate(1, params = $$props.params);
    	};

    	$$self.$capture_state = () => {
    		return { currentRoute, params };
    	};

    	$$self.$inject_state = $$props => {
    		if ("currentRoute" in $$props) $$invalidate(0, currentRoute = $$props.currentRoute);
    		if ("params" in $$props) $$invalidate(1, params = $$props.params);
    	};

    	return [currentRoute, params];
    }

    class Route extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, { currentRoute: 0, params: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Route",
    			options,
    			id: create_fragment.name
    		});
    	}

    	get currentRoute() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set currentRoute(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get params() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var route$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Route
    });

    /* node_modules/svelte-router-spa/src/components/router.svelte generated by Svelte v3.18.1 */

    function create_fragment$1(ctx) {
    	let current;

    	const route = new Route({
    			props: { currentRoute: /*$activeRoute*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(route.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(route, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const route_changes = {};
    			if (dirty & /*$activeRoute*/ 1) route_changes.currentRoute = /*$activeRoute*/ ctx[0];
    			route.$set(route_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(route.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(route.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(route, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let $activeRoute;
    	validate_store(store_1, "activeRoute");
    	component_subscribe($$self, store_1, $$value => $$invalidate(0, $activeRoute = $$value));
    	let { routes = [] } = $$props;
    	let { options = {} } = $$props;

    	onMount(function () {
    		spa_router_1(routes, document.location.href, options).setActiveRoute();
    	});

    	const writable_props = ["routes", "options"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Router> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ("routes" in $$props) $$invalidate(1, routes = $$props.routes);
    		if ("options" in $$props) $$invalidate(2, options = $$props.options);
    	};

    	$$self.$capture_state = () => {
    		return { routes, options, $activeRoute };
    	};

    	$$self.$inject_state = $$props => {
    		if ("routes" in $$props) $$invalidate(1, routes = $$props.routes);
    		if ("options" in $$props) $$invalidate(2, options = $$props.options);
    		if ("$activeRoute" in $$props) store_1.set($activeRoute = $$props.$activeRoute);
    	};

    	return [$activeRoute, routes, options];
    }

    class Router extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, { routes: 1, options: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Router",
    			options,
    			id: create_fragment$1.name
    		});
    	}

    	get routes() {
    		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set routes(value) {
    		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get options() {
    		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set options(value) {
    		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var router$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Router
    });

    /* node_modules/svelte-router-spa/src/components/navigate.svelte generated by Svelte v3.18.1 */
    const file = "node_modules/svelte-router-spa/src/components/navigate.svelte";

    function create_fragment$2(ctx) {
    	let a;
    	let current;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (default_slot) default_slot.c();
    			attr_dev(a, "href", /*to*/ ctx[0]);
    			attr_dev(a, "title", /*title*/ ctx[1]);
    			attr_dev(a, "class", /*styles*/ ctx[2]);
    			toggle_class(a, "active", spa_router_4(/*to*/ ctx[0]));
    			add_location(a, file, 24, 0, 482);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			current = true;
    			dispose = listen_dev(a, "click", /*navigate*/ ctx[3], false, false, false);
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot && default_slot.p && dirty & /*$$scope*/ 32) {
    				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[5], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null));
    			}

    			if (!current || dirty & /*to*/ 1) {
    				attr_dev(a, "href", /*to*/ ctx[0]);
    			}

    			if (!current || dirty & /*title*/ 2) {
    				attr_dev(a, "title", /*title*/ ctx[1]);
    			}

    			if (!current || dirty & /*styles*/ 4) {
    				attr_dev(a, "class", /*styles*/ ctx[2]);
    			}

    			if (dirty & /*styles, routeIsActive, to*/ 5) {
    				toggle_class(a, "active", spa_router_4(/*to*/ ctx[0]));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot) default_slot.d(detaching);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { to = "/" } = $$props;
    	let { title = "" } = $$props;
    	let { styles = "" } = $$props;
    	let { lang = null } = $$props;

    	onMount(function () {
    		if (lang) {
    			const route = spa_router_2(to, lang);

    			if (route) {
    				$$invalidate(0, to = route.path);
    			}
    		}
    	});

    	function navigate(event) {
    		event.preventDefault();
    		event.stopPropagation();
    		spa_router_3(to);
    	}

    	const writable_props = ["to", "title", "styles", "lang"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Navigate> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;

    	$$self.$set = $$props => {
    		if ("to" in $$props) $$invalidate(0, to = $$props.to);
    		if ("title" in $$props) $$invalidate(1, title = $$props.title);
    		if ("styles" in $$props) $$invalidate(2, styles = $$props.styles);
    		if ("lang" in $$props) $$invalidate(4, lang = $$props.lang);
    		if ("$$scope" in $$props) $$invalidate(5, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => {
    		return { to, title, styles, lang };
    	};

    	$$self.$inject_state = $$props => {
    		if ("to" in $$props) $$invalidate(0, to = $$props.to);
    		if ("title" in $$props) $$invalidate(1, title = $$props.title);
    		if ("styles" in $$props) $$invalidate(2, styles = $$props.styles);
    		if ("lang" in $$props) $$invalidate(4, lang = $$props.lang);
    	};

    	return [to, title, styles, navigate, lang, $$scope, $$slots];
    }

    class Navigate extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, { to: 0, title: 1, styles: 2, lang: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Navigate",
    			options,
    			id: create_fragment$2.name
    		});
    	}

    	get to() {
    		throw new Error("<Navigate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set to(value) {
    		throw new Error("<Navigate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Navigate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Navigate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get styles() {
    		throw new Error("<Navigate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set styles(value) {
    		throw new Error("<Navigate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lang() {
    		throw new Error("<Navigate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lang(value) {
    		throw new Error("<Navigate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var navigate = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Navigate
    });

    var Route$1 = getCjsExportFromNamespace(route$1);

    var Router$1 = getCjsExportFromNamespace(router$1);

    var Navigate$1 = getCjsExportFromNamespace(navigate);

    const { SpaRouter: SpaRouter$1, navigateTo: navigateTo$1, localisedRoute: localisedRoute$1, routeIsActive: routeIsActive$1 } = spa_router;




    var src = {
      SpaRouter: SpaRouter$1,
      localisedRoute: localisedRoute$1,
      navigateTo: navigateTo$1,
      routeIsActive: routeIsActive$1,
      Route: Route$1,
      Router: Router$1,
      Navigate: Navigate$1
    };
    var src_6 = src.Router;

    var ace_1 = createCommonjsModule(function (module, exports) {
    /* ***** BEGIN LICENSE BLOCK *****
     * Distributed under the BSD license:
     *
     * Copyright (c) 2010, Ajax.org B.V.
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *     * Redistributions of source code must retain the above copyright
     *       notice, this list of conditions and the following disclaimer.
     *     * Redistributions in binary form must reproduce the above copyright
     *       notice, this list of conditions and the following disclaimer in the
     *       documentation and/or other materials provided with the distribution.
     *     * Neither the name of Ajax.org B.V. nor the
     *       names of its contributors may be used to endorse or promote products
     *       derived from this software without specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
     * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
     * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     *
     * ***** END LICENSE BLOCK ***** */

    /**
     * Define a module along with a payload
     * @param module a name for the payload
     * @param payload a function to call with (require, exports, module) params
     */

    (function() {

    var ACE_NAMESPACE = "ace";

    var global = (function() { return this; })();
    if (!global && typeof window != "undefined") global = window; // strict mode


    var define = function(module, deps, payload) {
        if (typeof module !== "string") {
            if (define.original)
                define.original.apply(this, arguments);
            else {
                console.error("dropping module because define wasn\'t a string.");
                console.trace();
            }
            return;
        }
        if (arguments.length == 2)
            payload = deps;
        if (!define.modules[module]) {
            define.payloads[module] = payload;
            define.modules[module] = null;
        }
    };

    define.modules = {};
    define.payloads = {};

    /**
     * Get at functionality define()ed using the function above
     */
    var _require = function(parentId, module, callback) {
        if (typeof module === "string") {
            var payload = lookup(parentId, module);
            if (payload != undefined) {
                callback && callback();
                return payload;
            }
        } else if (Object.prototype.toString.call(module) === "[object Array]") {
            var params = [];
            for (var i = 0, l = module.length; i < l; ++i) {
                var dep = lookup(parentId, module[i]);
                if (dep == undefined && require.original)
                    return;
                params.push(dep);
            }
            return callback && callback.apply(null, params) || true;
        }
    };

    var require = function(module, callback) {
        var packagedModule = _require("", module, callback);
        if (packagedModule == undefined && require.original)
            return require.original.apply(this, arguments);
        return packagedModule;
    };

    var normalizeModule = function(parentId, moduleName) {
        // normalize plugin requires
        if (moduleName.indexOf("!") !== -1) {
            var chunks = moduleName.split("!");
            return normalizeModule(parentId, chunks[0]) + "!" + normalizeModule(parentId, chunks[1]);
        }
        // normalize relative requires
        if (moduleName.charAt(0) == ".") {
            var base = parentId.split("/").slice(0, -1).join("/");
            moduleName = base + "/" + moduleName;

            while(moduleName.indexOf(".") !== -1 && previous != moduleName) {
                var previous = moduleName;
                moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
            }
        }
        return moduleName;
    };

    /**
     * Internal function to lookup moduleNames and resolve them by calling the
     * definition function if needed.
     */
    var lookup = function(parentId, moduleName) {
        moduleName = normalizeModule(parentId, moduleName);

        var module = define.modules[moduleName];
        if (!module) {
            module = define.payloads[moduleName];
            if (typeof module === 'function') {
                var exports = {};
                var mod = {
                    id: moduleName,
                    uri: '',
                    exports: exports,
                    packaged: true
                };

                var req = function(module, callback) {
                    return _require(moduleName, module, callback);
                };

                var returnValue = module(req, exports, mod);
                exports = returnValue || mod.exports;
                define.modules[moduleName] = exports;
                delete define.payloads[moduleName];
            }
            module = define.modules[moduleName] = exports || module;
        }
        return module;
    };

    function exportAce(ns) {
        var root = global;
        if (ns) {
            if (!global[ns])
                global[ns] = {};
            root = global[ns];
        }

        if (!root.define || !root.define.packaged) {
            define.original = root.define;
            root.define = define;
            root.define.packaged = true;
        }

        if (!root.require || !root.require.packaged) {
            require.original = root.require;
            root.require = require;
            root.require.packaged = true;
        }
    }

    exportAce(ACE_NAMESPACE);

    })();

    ace.define("ace/lib/regexp",["require","exports","module"], function(require, exports, module) {

        var real = {
                exec: RegExp.prototype.exec,
                test: RegExp.prototype.test,
                match: String.prototype.match,
                replace: String.prototype.replace,
                split: String.prototype.split
            },
            compliantExecNpcg = real.exec.call(/()??/, "")[1] === undefined, // check `exec` handling of nonparticipating capturing groups
            compliantLastIndexIncrement = function () {
                var x = /^/g;
                real.test.call(x, "");
                return !x.lastIndex;
            }();

        if (compliantLastIndexIncrement && compliantExecNpcg)
            return;
        RegExp.prototype.exec = function (str) {
            var match = real.exec.apply(this, arguments),
                name, r2;
            if ( typeof(str) == 'string' && match) {
                if (!compliantExecNpcg && match.length > 1 && indexOf(match, "") > -1) {
                    r2 = RegExp(this.source, real.replace.call(getNativeFlags(this), "g", ""));
                    real.replace.call(str.slice(match.index), r2, function () {
                        for (var i = 1; i < arguments.length - 2; i++) {
                            if (arguments[i] === undefined)
                                match[i] = undefined;
                        }
                    });
                }
                if (this._xregexp && this._xregexp.captureNames) {
                    for (var i = 1; i < match.length; i++) {
                        name = this._xregexp.captureNames[i - 1];
                        if (name)
                           match[name] = match[i];
                    }
                }
                if (!compliantLastIndexIncrement && this.global && !match[0].length && (this.lastIndex > match.index))
                    this.lastIndex--;
            }
            return match;
        };
        if (!compliantLastIndexIncrement) {
            RegExp.prototype.test = function (str) {
                var match = real.exec.call(this, str);
                if (match && this.global && !match[0].length && (this.lastIndex > match.index))
                    this.lastIndex--;
                return !!match;
            };
        }

        function getNativeFlags (regex) {
            return (regex.global     ? "g" : "") +
                   (regex.ignoreCase ? "i" : "") +
                   (regex.multiline  ? "m" : "") +
                   (regex.extended   ? "x" : "") + // Proposed for ES4; included in AS3
                   (regex.sticky     ? "y" : "");
        }

        function indexOf (array, item, from) {
            if (Array.prototype.indexOf) // Use the native array method if available
                return array.indexOf(item, from);
            for (var i = from || 0; i < array.length; i++) {
                if (array[i] === item)
                    return i;
            }
            return -1;
        }

    });

    ace.define("ace/lib/es5-shim",["require","exports","module"], function(require, exports, module) {

    function Empty() {}

    if (!Function.prototype.bind) {
        Function.prototype.bind = function bind(that) { // .length is 1
            var target = this;
            if (typeof target != "function") {
                throw new TypeError("Function.prototype.bind called on incompatible " + target);
            }
            var args = slice.call(arguments, 1); // for normal call
            var bound = function () {

                if (this instanceof bound) {

                    var result = target.apply(
                        this,
                        args.concat(slice.call(arguments))
                    );
                    if (Object(result) === result) {
                        return result;
                    }
                    return this;

                } else {
                    return target.apply(
                        that,
                        args.concat(slice.call(arguments))
                    );

                }

            };
            if(target.prototype) {
                Empty.prototype = target.prototype;
                bound.prototype = new Empty();
                Empty.prototype = null;
            }
            return bound;
        };
    }
    var call = Function.prototype.call;
    var prototypeOfArray = Array.prototype;
    var prototypeOfObject = Object.prototype;
    var slice = prototypeOfArray.slice;
    var _toString = call.bind(prototypeOfObject.toString);
    var owns = call.bind(prototypeOfObject.hasOwnProperty);
    var defineGetter;
    var defineSetter;
    var lookupGetter;
    var lookupSetter;
    var supportsAccessors;
    if ((supportsAccessors = owns(prototypeOfObject, "__defineGetter__"))) {
        defineGetter = call.bind(prototypeOfObject.__defineGetter__);
        defineSetter = call.bind(prototypeOfObject.__defineSetter__);
        lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
        lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
    }
    if ([1,2].splice(0).length != 2) {
        if(function() { // test IE < 9 to splice bug - see issue #138
            function makeArray(l) {
                var a = new Array(l+2);
                a[0] = a[1] = 0;
                return a;
            }
            var array = [], lengthBefore;
            
            array.splice.apply(array, makeArray(20));
            array.splice.apply(array, makeArray(26));

            lengthBefore = array.length; //46
            array.splice(5, 0, "XXX"); // add one element

            if (lengthBefore + 1 == array.length) {
                return true;// has right splice implementation without bugs
            }
        }()) {//IE 6/7
            var array_splice = Array.prototype.splice;
            Array.prototype.splice = function(start, deleteCount) {
                if (!arguments.length) {
                    return [];
                } else {
                    return array_splice.apply(this, [
                        start === void 0 ? 0 : start,
                        deleteCount === void 0 ? (this.length - start) : deleteCount
                    ].concat(slice.call(arguments, 2)))
                }
            };
        } else {//IE8
            Array.prototype.splice = function(pos, removeCount){
                var length = this.length;
                if (pos > 0) {
                    if (pos > length)
                        pos = length;
                } else if (pos == void 0) {
                    pos = 0;
                } else if (pos < 0) {
                    pos = Math.max(length + pos, 0);
                }

                if (!(pos+removeCount < length))
                    removeCount = length - pos;

                var removed = this.slice(pos, pos+removeCount);
                var insert = slice.call(arguments, 2);
                var add = insert.length;            
                if (pos === length) {
                    if (add) {
                        this.push.apply(this, insert);
                    }
                } else {
                    var remove = Math.min(removeCount, length - pos);
                    var tailOldPos = pos + remove;
                    var tailNewPos = tailOldPos + add - remove;
                    var tailCount = length - tailOldPos;
                    var lengthAfterRemove = length - remove;

                    if (tailNewPos < tailOldPos) { // case A
                        for (var i = 0; i < tailCount; ++i) {
                            this[tailNewPos+i] = this[tailOldPos+i];
                        }
                    } else if (tailNewPos > tailOldPos) { // case B
                        for (i = tailCount; i--; ) {
                            this[tailNewPos+i] = this[tailOldPos+i];
                        }
                    } // else, add == remove (nothing to do)

                    if (add && pos === lengthAfterRemove) {
                        this.length = lengthAfterRemove; // truncate array
                        this.push.apply(this, insert);
                    } else {
                        this.length = lengthAfterRemove + add; // reserves space
                        for (i = 0; i < add; ++i) {
                            this[pos+i] = insert[i];
                        }
                    }
                }
                return removed;
            };
        }
    }
    if (!Array.isArray) {
        Array.isArray = function isArray(obj) {
            return _toString(obj) == "[object Array]";
        };
    }
    var boxedString = Object("a"),
        splitString = boxedString[0] != "a" || !(0 in boxedString);

    if (!Array.prototype.forEach) {
        Array.prototype.forEach = function forEach(fun /*, thisp*/) {
            var object = toObject(this),
                self = splitString && _toString(this) == "[object String]" ?
                    this.split("") :
                    object,
                thisp = arguments[1],
                i = -1,
                length = self.length >>> 0;
            if (_toString(fun) != "[object Function]") {
                throw new TypeError(); // TODO message
            }

            while (++i < length) {
                if (i in self) {
                    fun.call(thisp, self[i], i, object);
                }
            }
        };
    }
    if (!Array.prototype.map) {
        Array.prototype.map = function map(fun /*, thisp*/) {
            var object = toObject(this),
                self = splitString && _toString(this) == "[object String]" ?
                    this.split("") :
                    object,
                length = self.length >>> 0,
                result = Array(length),
                thisp = arguments[1];
            if (_toString(fun) != "[object Function]") {
                throw new TypeError(fun + " is not a function");
            }

            for (var i = 0; i < length; i++) {
                if (i in self)
                    result[i] = fun.call(thisp, self[i], i, object);
            }
            return result;
        };
    }
    if (!Array.prototype.filter) {
        Array.prototype.filter = function filter(fun /*, thisp */) {
            var object = toObject(this),
                self = splitString && _toString(this) == "[object String]" ?
                    this.split("") :
                        object,
                length = self.length >>> 0,
                result = [],
                value,
                thisp = arguments[1];
            if (_toString(fun) != "[object Function]") {
                throw new TypeError(fun + " is not a function");
            }

            for (var i = 0; i < length; i++) {
                if (i in self) {
                    value = self[i];
                    if (fun.call(thisp, value, i, object)) {
                        result.push(value);
                    }
                }
            }
            return result;
        };
    }
    if (!Array.prototype.every) {
        Array.prototype.every = function every(fun /*, thisp */) {
            var object = toObject(this),
                self = splitString && _toString(this) == "[object String]" ?
                    this.split("") :
                    object,
                length = self.length >>> 0,
                thisp = arguments[1];
            if (_toString(fun) != "[object Function]") {
                throw new TypeError(fun + " is not a function");
            }

            for (var i = 0; i < length; i++) {
                if (i in self && !fun.call(thisp, self[i], i, object)) {
                    return false;
                }
            }
            return true;
        };
    }
    if (!Array.prototype.some) {
        Array.prototype.some = function some(fun /*, thisp */) {
            var object = toObject(this),
                self = splitString && _toString(this) == "[object String]" ?
                    this.split("") :
                    object,
                length = self.length >>> 0,
                thisp = arguments[1];
            if (_toString(fun) != "[object Function]") {
                throw new TypeError(fun + " is not a function");
            }

            for (var i = 0; i < length; i++) {
                if (i in self && fun.call(thisp, self[i], i, object)) {
                    return true;
                }
            }
            return false;
        };
    }
    if (!Array.prototype.reduce) {
        Array.prototype.reduce = function reduce(fun /*, initial*/) {
            var object = toObject(this),
                self = splitString && _toString(this) == "[object String]" ?
                    this.split("") :
                    object,
                length = self.length >>> 0;
            if (_toString(fun) != "[object Function]") {
                throw new TypeError(fun + " is not a function");
            }
            if (!length && arguments.length == 1) {
                throw new TypeError("reduce of empty array with no initial value");
            }

            var i = 0;
            var result;
            if (arguments.length >= 2) {
                result = arguments[1];
            } else {
                do {
                    if (i in self) {
                        result = self[i++];
                        break;
                    }
                    if (++i >= length) {
                        throw new TypeError("reduce of empty array with no initial value");
                    }
                } while (true);
            }

            for (; i < length; i++) {
                if (i in self) {
                    result = fun.call(void 0, result, self[i], i, object);
                }
            }

            return result;
        };
    }
    if (!Array.prototype.reduceRight) {
        Array.prototype.reduceRight = function reduceRight(fun /*, initial*/) {
            var object = toObject(this),
                self = splitString && _toString(this) == "[object String]" ?
                    this.split("") :
                    object,
                length = self.length >>> 0;
            if (_toString(fun) != "[object Function]") {
                throw new TypeError(fun + " is not a function");
            }
            if (!length && arguments.length == 1) {
                throw new TypeError("reduceRight of empty array with no initial value");
            }

            var result, i = length - 1;
            if (arguments.length >= 2) {
                result = arguments[1];
            } else {
                do {
                    if (i in self) {
                        result = self[i--];
                        break;
                    }
                    if (--i < 0) {
                        throw new TypeError("reduceRight of empty array with no initial value");
                    }
                } while (true);
            }

            do {
                if (i in this) {
                    result = fun.call(void 0, result, self[i], i, object);
                }
            } while (i--);

            return result;
        };
    }
    if (!Array.prototype.indexOf || ([0, 1].indexOf(1, 2) != -1)) {
        Array.prototype.indexOf = function indexOf(sought /*, fromIndex */ ) {
            var self = splitString && _toString(this) == "[object String]" ?
                    this.split("") :
                    toObject(this),
                length = self.length >>> 0;

            if (!length) {
                return -1;
            }

            var i = 0;
            if (arguments.length > 1) {
                i = toInteger(arguments[1]);
            }
            i = i >= 0 ? i : Math.max(0, length + i);
            for (; i < length; i++) {
                if (i in self && self[i] === sought) {
                    return i;
                }
            }
            return -1;
        };
    }
    if (!Array.prototype.lastIndexOf || ([0, 1].lastIndexOf(0, -3) != -1)) {
        Array.prototype.lastIndexOf = function lastIndexOf(sought /*, fromIndex */) {
            var self = splitString && _toString(this) == "[object String]" ?
                    this.split("") :
                    toObject(this),
                length = self.length >>> 0;

            if (!length) {
                return -1;
            }
            var i = length - 1;
            if (arguments.length > 1) {
                i = Math.min(i, toInteger(arguments[1]));
            }
            i = i >= 0 ? i : length - Math.abs(i);
            for (; i >= 0; i--) {
                if (i in self && sought === self[i]) {
                    return i;
                }
            }
            return -1;
        };
    }
    if (!Object.getPrototypeOf) {
        Object.getPrototypeOf = function getPrototypeOf(object) {
            return object.__proto__ || (
                object.constructor ?
                object.constructor.prototype :
                prototypeOfObject
            );
        };
    }
    if (!Object.getOwnPropertyDescriptor) {
        var ERR_NON_OBJECT = "Object.getOwnPropertyDescriptor called on a " +
                             "non-object: ";
        Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
            if ((typeof object != "object" && typeof object != "function") || object === null)
                throw new TypeError(ERR_NON_OBJECT + object);
            if (!owns(object, property))
                return;

            var descriptor, getter, setter;
            descriptor =  { enumerable: true, configurable: true };
            if (supportsAccessors) {
                var prototype = object.__proto__;
                object.__proto__ = prototypeOfObject;

                var getter = lookupGetter(object, property);
                var setter = lookupSetter(object, property);
                object.__proto__ = prototype;

                if (getter || setter) {
                    if (getter) descriptor.get = getter;
                    if (setter) descriptor.set = setter;
                    return descriptor;
                }
            }
            descriptor.value = object[property];
            return descriptor;
        };
    }
    if (!Object.getOwnPropertyNames) {
        Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
            return Object.keys(object);
        };
    }
    if (!Object.create) {
        var createEmpty;
        if (Object.prototype.__proto__ === null) {
            createEmpty = function () {
                return { "__proto__": null };
            };
        } else {
            createEmpty = function () {
                var empty = {};
                for (var i in empty)
                    empty[i] = null;
                empty.constructor =
                empty.hasOwnProperty =
                empty.propertyIsEnumerable =
                empty.isPrototypeOf =
                empty.toLocaleString =
                empty.toString =
                empty.valueOf =
                empty.__proto__ = null;
                return empty;
            };
        }

        Object.create = function create(prototype, properties) {
            var object;
            if (prototype === null) {
                object = createEmpty();
            } else {
                if (typeof prototype != "object")
                    throw new TypeError("typeof prototype["+(typeof prototype)+"] != 'object'");
                var Type = function () {};
                Type.prototype = prototype;
                object = new Type();
                object.__proto__ = prototype;
            }
            if (properties !== void 0)
                Object.defineProperties(object, properties);
            return object;
        };
    }

    function doesDefinePropertyWork(object) {
        try {
            Object.defineProperty(object, "sentinel", {});
            return "sentinel" in object;
        } catch (exception) {
        }
    }
    if (Object.defineProperty) {
        var definePropertyWorksOnObject = doesDefinePropertyWork({});
        var definePropertyWorksOnDom = typeof document == "undefined" ||
            doesDefinePropertyWork(document.createElement("div"));
        if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
            var definePropertyFallback = Object.defineProperty;
        }
    }

    if (!Object.defineProperty || definePropertyFallback) {
        var ERR_NON_OBJECT_DESCRIPTOR = "Property description must be an object: ";
        var ERR_NON_OBJECT_TARGET = "Object.defineProperty called on non-object: ";
        var ERR_ACCESSORS_NOT_SUPPORTED = "getters & setters can not be defined " +
                                          "on this javascript engine";

        Object.defineProperty = function defineProperty(object, property, descriptor) {
            if ((typeof object != "object" && typeof object != "function") || object === null)
                throw new TypeError(ERR_NON_OBJECT_TARGET + object);
            if ((typeof descriptor != "object" && typeof descriptor != "function") || descriptor === null)
                throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
            if (definePropertyFallback) {
                try {
                    return definePropertyFallback.call(Object, object, property, descriptor);
                } catch (exception) {
                }
            }
            if (owns(descriptor, "value")) {

                if (supportsAccessors && (lookupGetter(object, property) ||
                                          lookupSetter(object, property)))
                {
                    var prototype = object.__proto__;
                    object.__proto__ = prototypeOfObject;
                    delete object[property];
                    object[property] = descriptor.value;
                    object.__proto__ = prototype;
                } else {
                    object[property] = descriptor.value;
                }
            } else {
                if (!supportsAccessors)
                    throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
                if (owns(descriptor, "get"))
                    defineGetter(object, property, descriptor.get);
                if (owns(descriptor, "set"))
                    defineSetter(object, property, descriptor.set);
            }

            return object;
        };
    }
    if (!Object.defineProperties) {
        Object.defineProperties = function defineProperties(object, properties) {
            for (var property in properties) {
                if (owns(properties, property))
                    Object.defineProperty(object, property, properties[property]);
            }
            return object;
        };
    }
    if (!Object.seal) {
        Object.seal = function seal(object) {
            return object;
        };
    }
    if (!Object.freeze) {
        Object.freeze = function freeze(object) {
            return object;
        };
    }
    try {
        Object.freeze(function () {});
    } catch (exception) {
        Object.freeze = (function freeze(freezeObject) {
            return function freeze(object) {
                if (typeof object == "function") {
                    return object;
                } else {
                    return freezeObject(object);
                }
            };
        })(Object.freeze);
    }
    if (!Object.preventExtensions) {
        Object.preventExtensions = function preventExtensions(object) {
            return object;
        };
    }
    if (!Object.isSealed) {
        Object.isSealed = function isSealed(object) {
            return false;
        };
    }
    if (!Object.isFrozen) {
        Object.isFrozen = function isFrozen(object) {
            return false;
        };
    }
    if (!Object.isExtensible) {
        Object.isExtensible = function isExtensible(object) {
            if (Object(object) === object) {
                throw new TypeError(); // TODO message
            }
            var name = '';
            while (owns(object, name)) {
                name += '?';
            }
            object[name] = true;
            var returnValue = owns(object, name);
            delete object[name];
            return returnValue;
        };
    }
    if (!Object.keys) {
        var hasDontEnumBug = true,
            dontEnums = [
                "toString",
                "toLocaleString",
                "valueOf",
                "hasOwnProperty",
                "isPrototypeOf",
                "propertyIsEnumerable",
                "constructor"
            ],
            dontEnumsLength = dontEnums.length;

        for (var key in {"toString": null}) {
            hasDontEnumBug = false;
        }

        Object.keys = function keys(object) {

            if (
                (typeof object != "object" && typeof object != "function") ||
                object === null
            ) {
                throw new TypeError("Object.keys called on a non-object");
            }

            var keys = [];
            for (var name in object) {
                if (owns(object, name)) {
                    keys.push(name);
                }
            }

            if (hasDontEnumBug) {
                for (var i = 0, ii = dontEnumsLength; i < ii; i++) {
                    var dontEnum = dontEnums[i];
                    if (owns(object, dontEnum)) {
                        keys.push(dontEnum);
                    }
                }
            }
            return keys;
        };

    }
    if (!Date.now) {
        Date.now = function now() {
            return new Date().getTime();
        };
    }
    var ws = "\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u2000\u2001\u2002\u2003" +
        "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028" +
        "\u2029\uFEFF";
    if (!String.prototype.trim) {
        ws = "[" + ws + "]";
        var trimBeginRegexp = new RegExp("^" + ws + ws + "*"),
            trimEndRegexp = new RegExp(ws + ws + "*$");
        String.prototype.trim = function trim() {
            return String(this).replace(trimBeginRegexp, "").replace(trimEndRegexp, "");
        };
    }

    function toInteger(n) {
        n = +n;
        if (n !== n) { // isNaN
            n = 0;
        } else if (n !== 0 && n !== (1/0) && n !== -(1/0)) {
            n = (n > 0 || -1) * Math.floor(Math.abs(n));
        }
        return n;
    }
    var toObject = function (o) {
        if (o == null) { // this matches both null and undefined
            throw new TypeError("can't convert "+o+" to object");
        }
        return Object(o);
    };

    });

    ace.define("ace/lib/fixoldbrowsers",["require","exports","module","ace/lib/regexp","ace/lib/es5-shim"], function(require, exports, module) {

    require("./regexp");
    require("./es5-shim");
    if (typeof Element != "undefined" && !Element.prototype.remove) {
        Object.defineProperty(Element.prototype, "remove", {
            enumerable: false,
            writable: true,
            configurable: true,
            value: function() { this.parentNode && this.parentNode.removeChild(this); }
        });
    }


    });

    ace.define("ace/lib/useragent",["require","exports","module"], function(require, exports, module) {
    exports.OS = {
        LINUX: "LINUX",
        MAC: "MAC",
        WINDOWS: "WINDOWS"
    };
    exports.getOS = function() {
        if (exports.isMac) {
            return exports.OS.MAC;
        } else if (exports.isLinux) {
            return exports.OS.LINUX;
        } else {
            return exports.OS.WINDOWS;
        }
    };
    var _navigator = typeof navigator == "object" ? navigator : {};

    var os = (/mac|win|linux/i.exec(_navigator.platform) || ["other"])[0].toLowerCase();
    var ua = _navigator.userAgent || "";
    var appName = _navigator.appName || "";
    exports.isWin = (os == "win");
    exports.isMac = (os == "mac");
    exports.isLinux = (os == "linux");
    exports.isIE = 
        (appName == "Microsoft Internet Explorer" || appName.indexOf("MSAppHost") >= 0)
        ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1])
        : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1]); // for ie
        
    exports.isOldIE = exports.isIE && exports.isIE < 9;
    exports.isGecko = exports.isMozilla = ua.match(/ Gecko\/\d+/);
    exports.isOpera = typeof opera == "object" && Object.prototype.toString.call(window.opera) == "[object Opera]";
    exports.isWebKit = parseFloat(ua.split("WebKit/")[1]) || undefined;

    exports.isChrome = parseFloat(ua.split(" Chrome/")[1]) || undefined;

    exports.isEdge = parseFloat(ua.split(" Edge/")[1]) || undefined;

    exports.isAIR = ua.indexOf("AdobeAIR") >= 0;

    exports.isAndroid = ua.indexOf("Android") >= 0;

    exports.isChromeOS = ua.indexOf(" CrOS ") >= 0;

    exports.isIOS = /iPad|iPhone|iPod/.test(ua) && !window.MSStream;

    if (exports.isIOS) exports.isMac = true;

    exports.isMobile = exports.isIOS || exports.isAndroid;

    });

    ace.define("ace/lib/dom",["require","exports","module","ace/lib/useragent"], function(require, exports, module) {

    var useragent = require("./useragent"); 
    var XHTML_NS = "http://www.w3.org/1999/xhtml";

    exports.buildDom = function buildDom(arr, parent, refs) {
        if (typeof arr == "string" && arr) {
            var txt = document.createTextNode(arr);
            if (parent)
                parent.appendChild(txt);
            return txt;
        }
        
        if (!Array.isArray(arr))
            return arr;
        if (typeof arr[0] != "string" || !arr[0]) {
            var els = [];
            for (var i = 0; i < arr.length; i++) {
                var ch = buildDom(arr[i], parent, refs);
                ch && els.push(ch);
            }
            return els;
        }
        
        var el = document.createElement(arr[0]);
        var options = arr[1];
        var childIndex = 1;
        if (options && typeof options == "object" && !Array.isArray(options))
            childIndex = 2;
        for (var i = childIndex; i < arr.length; i++)
            buildDom(arr[i], el, refs);
        if (childIndex == 2) {
            Object.keys(options).forEach(function(n) {
                var val = options[n];
                if (n === "class") {
                    el.className = Array.isArray(val) ? val.join(" ") : val;
                } else if (typeof val == "function" || n == "value") {
                    el[n] = val;
                } else if (n === "ref") {
                    if (refs) refs[val] = el;
                } else if (val != null) {
                    el.setAttribute(n, val);
                }
            });
        }
        if (parent)
            parent.appendChild(el);
        return el;
    };

    exports.getDocumentHead = function(doc) {
        if (!doc)
            doc = document;
        return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
    };

    exports.createElement = function(tag, ns) {
        return document.createElementNS ?
               document.createElementNS(ns || XHTML_NS, tag) :
               document.createElement(tag);
    };

    exports.removeChildren = function(element) {
        element.innerHTML = "";
    };

    exports.createTextNode = function(textContent, element) {
        var doc = element ? element.ownerDocument : document;
        return doc.createTextNode(textContent);
    };

    exports.createFragment = function(element) {
        var doc = element ? element.ownerDocument : document;
        return doc.createDocumentFragment();
    };

    exports.hasCssClass = function(el, name) {
        var classes = (el.className + "").split(/\s+/g);
        return classes.indexOf(name) !== -1;
    };
    exports.addCssClass = function(el, name) {
        if (!exports.hasCssClass(el, name)) {
            el.className += " " + name;
        }
    };
    exports.removeCssClass = function(el, name) {
        var classes = el.className.split(/\s+/g);
        while (true) {
            var index = classes.indexOf(name);
            if (index == -1) {
                break;
            }
            classes.splice(index, 1);
        }
        el.className = classes.join(" ");
    };

    exports.toggleCssClass = function(el, name) {
        var classes = el.className.split(/\s+/g), add = true;
        while (true) {
            var index = classes.indexOf(name);
            if (index == -1) {
                break;
            }
            add = false;
            classes.splice(index, 1);
        }
        if (add)
            classes.push(name);

        el.className = classes.join(" ");
        return add;
    };
    exports.setCssClass = function(node, className, include) {
        if (include) {
            exports.addCssClass(node, className);
        } else {
            exports.removeCssClass(node, className);
        }
    };

    exports.hasCssString = function(id, doc) {
        var index = 0, sheets;
        doc = doc || document;
        if ((sheets = doc.querySelectorAll("style"))) {
            while (index < sheets.length)
                if (sheets[index++].id === id)
                    return true;
        }
    };

    exports.importCssString = function importCssString(cssText, id, target) {
        var container = target;
        if (!target || !target.getRootNode) {
            container = document;
        } else {
            container = target.getRootNode();
            if (!container || container == target)
                container = document;
        }
        
        var doc = container.ownerDocument || container;
        if (id && exports.hasCssString(id, container))
            return null;
        
        if (id)
            cssText += "\n/*# sourceURL=ace/css/" + id + " */";
        
        var style = exports.createElement("style");
        style.appendChild(doc.createTextNode(cssText));
        if (id)
            style.id = id;

        if (container == doc)
            container = exports.getDocumentHead(doc);
        container.insertBefore(style, container.firstChild);
    };

    exports.importCssStylsheet = function(uri, doc) {
        exports.buildDom(["link", {rel: "stylesheet", href: uri}], exports.getDocumentHead(doc));
    };
    exports.scrollbarWidth = function(document) {
        var inner = exports.createElement("ace_inner");
        inner.style.width = "100%";
        inner.style.minWidth = "0px";
        inner.style.height = "200px";
        inner.style.display = "block";

        var outer = exports.createElement("ace_outer");
        var style = outer.style;

        style.position = "absolute";
        style.left = "-10000px";
        style.overflow = "hidden";
        style.width = "200px";
        style.minWidth = "0px";
        style.height = "150px";
        style.display = "block";

        outer.appendChild(inner);

        var body = document.documentElement;
        body.appendChild(outer);

        var noScrollbar = inner.offsetWidth;

        style.overflow = "scroll";
        var withScrollbar = inner.offsetWidth;

        if (noScrollbar == withScrollbar) {
            withScrollbar = outer.clientWidth;
        }

        body.removeChild(outer);

        return noScrollbar-withScrollbar;
    };

    if (typeof document == "undefined") {
        exports.importCssString = function() {};
    }

    exports.computedStyle = function(element, style) {
        return window.getComputedStyle(element, "") || {};
    };

    exports.setStyle = function(styles, property, value) {
        if (styles[property] !== value) {
            styles[property] = value;
        }
    };

    exports.HAS_CSS_ANIMATION = false;
    exports.HAS_CSS_TRANSFORMS = false;
    exports.HI_DPI = useragent.isWin
        ? typeof window !== "undefined" && window.devicePixelRatio >= 1.5
        : true;

    if (typeof document !== "undefined") {
        var div = document.createElement("div");
        if (exports.HI_DPI && div.style.transform  !== undefined)
            exports.HAS_CSS_TRANSFORMS = true;
        if (!useragent.isEdge && typeof div.style.animationName !== "undefined")
            exports.HAS_CSS_ANIMATION = true;
        div = null;
    }

    if (exports.HAS_CSS_TRANSFORMS) {
        exports.translate = function(element, tx, ty) {
            element.style.transform = "translate(" + Math.round(tx) + "px, " + Math.round(ty) +"px)";
        };
    } else {
        exports.translate = function(element, tx, ty) {
            element.style.top = Math.round(ty) + "px";
            element.style.left = Math.round(tx) + "px";
        };
    }

    });

    ace.define("ace/lib/oop",["require","exports","module"], function(require, exports, module) {

    exports.inherits = function(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
    };

    exports.mixin = function(obj, mixin) {
        for (var key in mixin) {
            obj[key] = mixin[key];
        }
        return obj;
    };

    exports.implement = function(proto, mixin) {
        exports.mixin(proto, mixin);
    };

    });

    ace.define("ace/lib/keys",["require","exports","module","ace/lib/oop"], function(require, exports, module) {

    var oop = require("./oop");
    var Keys = (function() {
        var ret = {
            MODIFIER_KEYS: {
                16: 'Shift', 17: 'Ctrl', 18: 'Alt', 224: 'Meta',
                91: 'MetaLeft', 92: 'MetaRight', 93: 'ContextMenu'
            },

            KEY_MODS: {
                "ctrl": 1, "alt": 2, "option" : 2, "shift": 4,
                "super": 8, "meta": 8, "command": 8, "cmd": 8
            },

            FUNCTION_KEYS : {
                8  : "Backspace",
                9  : "Tab",
                13 : "Return",
                19 : "Pause",
                27 : "Esc",
                32 : "Space",
                33 : "PageUp",
                34 : "PageDown",
                35 : "End",
                36 : "Home",
                37 : "Left",
                38 : "Up",
                39 : "Right",
                40 : "Down",
                44 : "Print",
                45 : "Insert",
                46 : "Delete",
                96 : "Numpad0",
                97 : "Numpad1",
                98 : "Numpad2",
                99 : "Numpad3",
                100: "Numpad4",
                101: "Numpad5",
                102: "Numpad6",
                103: "Numpad7",
                104: "Numpad8",
                105: "Numpad9",
                '-13': "NumpadEnter",
                112: "F1",
                113: "F2",
                114: "F3",
                115: "F4",
                116: "F5",
                117: "F6",
                118: "F7",
                119: "F8",
                120: "F9",
                121: "F10",
                122: "F11",
                123: "F12",
                144: "Numlock",
                145: "Scrolllock"
            },

            PRINTABLE_KEYS: {
               32: ' ',  48: '0',  49: '1',  50: '2',  51: '3',  52: '4', 53:  '5',
               54: '6',  55: '7',  56: '8',  57: '9',  59: ';',  61: '=', 65:  'a',
               66: 'b',  67: 'c',  68: 'd',  69: 'e',  70: 'f',  71: 'g', 72:  'h',
               73: 'i',  74: 'j',  75: 'k',  76: 'l',  77: 'm',  78: 'n', 79:  'o',
               80: 'p',  81: 'q',  82: 'r',  83: 's',  84: 't',  85: 'u', 86:  'v',
               87: 'w',  88: 'x',  89: 'y',  90: 'z', 107: '+', 109: '-', 110: '.',
              186: ';', 187: '=', 188: ',', 189: '-', 190: '.', 191: '/', 192: '`',
              219: '[', 220: '\\',221: ']', 222: "'", 111: '/', 106: '*'
            }
        };
        var name, i;
        for (i in ret.FUNCTION_KEYS) {
            name = ret.FUNCTION_KEYS[i].toLowerCase();
            ret[name] = parseInt(i, 10);
        }
        for (i in ret.PRINTABLE_KEYS) {
            name = ret.PRINTABLE_KEYS[i].toLowerCase();
            ret[name] = parseInt(i, 10);
        }
        oop.mixin(ret, ret.MODIFIER_KEYS);
        oop.mixin(ret, ret.PRINTABLE_KEYS);
        oop.mixin(ret, ret.FUNCTION_KEYS);
        ret.enter = ret["return"];
        ret.escape = ret.esc;
        ret.del = ret["delete"];
        ret[173] = '-';
        
        (function() {
            var mods = ["cmd", "ctrl", "alt", "shift"];
            for (var i = Math.pow(2, mods.length); i--;) {            
                ret.KEY_MODS[i] = mods.filter(function(x) {
                    return i & ret.KEY_MODS[x];
                }).join("-") + "-";
            }
        })();

        ret.KEY_MODS[0] = "";
        ret.KEY_MODS[-1] = "input-";

        return ret;
    })();
    oop.mixin(exports, Keys);

    exports.keyCodeToString = function(keyCode) {
        var keyString = Keys[keyCode];
        if (typeof keyString != "string")
            keyString = String.fromCharCode(keyCode);
        return keyString.toLowerCase();
    };

    });

    ace.define("ace/lib/event",["require","exports","module","ace/lib/keys","ace/lib/useragent"], function(require, exports, module) {

    var keys = require("./keys");
    var useragent = require("./useragent");

    var pressedKeys = null;
    var ts = 0;

    var activeListenerOptions;
    function detectListenerOptionsSupport() {
        activeListenerOptions = false;
        try {
            document.createComment("").addEventListener("test", function() {}, { 
                get passive() { 
                    activeListenerOptions = {passive: false};
                }
            });
        } catch(e) {}
    }

    function getListenerOptions() {
        if (activeListenerOptions == undefined)
            detectListenerOptionsSupport();
        return activeListenerOptions;
    }

    exports.addListener = function(elem, type, callback) {
        return elem.addEventListener(type, callback, getListenerOptions());
    };

    exports.removeListener = function(elem, type, callback) {
        return elem.removeEventListener(type, callback, getListenerOptions());
    };
    exports.stopEvent = function(e) {
        exports.stopPropagation(e);
        exports.preventDefault(e);
        return false;
    };

    exports.stopPropagation = function(e) {
        if (e.stopPropagation)
            e.stopPropagation();
    };

    exports.preventDefault = function(e) {
        if (e.preventDefault)
            e.preventDefault();
    };
    exports.getButton = function(e) {
        if (e.type == "dblclick")
            return 0;
        if (e.type == "contextmenu" || (useragent.isMac && (e.ctrlKey && !e.altKey && !e.shiftKey)))
            return 2;
        return e.button;
    };

    exports.capture = function(el, eventHandler, releaseCaptureHandler) {
        function onMouseUp(e) {
            eventHandler && eventHandler(e);
            releaseCaptureHandler && releaseCaptureHandler(e);

            exports.removeListener(document, "mousemove", eventHandler, true);
            exports.removeListener(document, "mouseup", onMouseUp, true);
            exports.removeListener(document, "dragstart", onMouseUp, true);
        }

        exports.addListener(document, "mousemove", eventHandler, true);
        exports.addListener(document, "mouseup", onMouseUp, true);
        exports.addListener(document, "dragstart", onMouseUp, true);
        
        return onMouseUp;
    };

    exports.addMouseWheelListener = function(el, callback) {
        if ("onmousewheel" in el) {
            exports.addListener(el, "mousewheel", function(e) {
                var factor = 8;
                if (e.wheelDeltaX !== undefined) {
                    e.wheelX = -e.wheelDeltaX / factor;
                    e.wheelY = -e.wheelDeltaY / factor;
                } else {
                    e.wheelX = 0;
                    e.wheelY = -e.wheelDelta / factor;
                }
                callback(e);
            });
        } else if ("onwheel" in el) {
            exports.addListener(el, "wheel",  function(e) {
                var factor = 0.35;
                switch (e.deltaMode) {
                    case e.DOM_DELTA_PIXEL:
                        e.wheelX = e.deltaX * factor || 0;
                        e.wheelY = e.deltaY * factor || 0;
                        break;
                    case e.DOM_DELTA_LINE:
                    case e.DOM_DELTA_PAGE:
                        e.wheelX = (e.deltaX || 0) * 5;
                        e.wheelY = (e.deltaY || 0) * 5;
                        break;
                }
                
                callback(e);
            });
        } else {
            exports.addListener(el, "DOMMouseScroll", function(e) {
                if (e.axis && e.axis == e.HORIZONTAL_AXIS) {
                    e.wheelX = (e.detail || 0) * 5;
                    e.wheelY = 0;
                } else {
                    e.wheelX = 0;
                    e.wheelY = (e.detail || 0) * 5;
                }
                callback(e);
            });
        }
    };

    exports.addMultiMouseDownListener = function(elements, timeouts, eventHandler, callbackName) {
        var clicks = 0;
        var startX, startY, timer; 
        var eventNames = {
            2: "dblclick",
            3: "tripleclick",
            4: "quadclick"
        };

        function onMousedown(e) {
            if (exports.getButton(e) !== 0) {
                clicks = 0;
            } else if (e.detail > 1) {
                clicks++;
                if (clicks > 4)
                    clicks = 1;
            } else {
                clicks = 1;
            }
            if (useragent.isIE) {
                var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
                if (!timer || isNewClick)
                    clicks = 1;
                if (timer)
                    clearTimeout(timer);
                timer = setTimeout(function() {timer = null;}, timeouts[clicks - 1] || 600);

                if (clicks == 1) {
                    startX = e.clientX;
                    startY = e.clientY;
                }
            }
            
            e._clicks = clicks;

            eventHandler[callbackName]("mousedown", e);

            if (clicks > 4)
                clicks = 0;
            else if (clicks > 1)
                return eventHandler[callbackName](eventNames[clicks], e);
        }
        if (!Array.isArray(elements))
            elements = [elements];
        elements.forEach(function(el) {
            exports.addListener(el, "mousedown", onMousedown);
        });
    };

    var getModifierHash = function(e) {
        return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
    };

    exports.getModifierString = function(e) {
        return keys.KEY_MODS[getModifierHash(e)];
    };

    function normalizeCommandKeys(callback, e, keyCode) {
        var hashId = getModifierHash(e);

        if (!useragent.isMac && pressedKeys) {
            if (e.getModifierState && (e.getModifierState("OS") || e.getModifierState("Win")))
                hashId |= 8;
            if (pressedKeys.altGr) {
                if ((3 & hashId) != 3)
                    pressedKeys.altGr = 0;
                else
                    return;
            }
            if (keyCode === 18 || keyCode === 17) {
                var location = "location" in e ? e.location : e.keyLocation;
                if (keyCode === 17 && location === 1) {
                    if (pressedKeys[keyCode] == 1)
                        ts = e.timeStamp;
                } else if (keyCode === 18 && hashId === 3 && location === 2) {
                    var dt = e.timeStamp - ts;
                    if (dt < 50)
                        pressedKeys.altGr = true;
                }
            }
        }
        
        if (keyCode in keys.MODIFIER_KEYS) {
            keyCode = -1;
        }
        
        if (!hashId && keyCode === 13) {
            var location = "location" in e ? e.location : e.keyLocation;
            if (location === 3) {
                callback(e, hashId, -keyCode);
                if (e.defaultPrevented)
                    return;
            }
        }
        
        if (useragent.isChromeOS && hashId & 8) {
            callback(e, hashId, keyCode);
            if (e.defaultPrevented)
                return;
            else
                hashId &= ~8;
        }
        if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
            return false;
        }
        
        return callback(e, hashId, keyCode);
    }


    exports.addCommandKeyListener = function(el, callback) {
        var addListener = exports.addListener;
        if (useragent.isOldGecko || (useragent.isOpera && !("KeyboardEvent" in window))) {
            var lastKeyDownKeyCode = null;
            addListener(el, "keydown", function(e) {
                lastKeyDownKeyCode = e.keyCode;
            });
            addListener(el, "keypress", function(e) {
                return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);
            });
        } else {
            var lastDefaultPrevented = null;

            addListener(el, "keydown", function(e) {
                pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;
                var result = normalizeCommandKeys(callback, e, e.keyCode);
                lastDefaultPrevented = e.defaultPrevented;
                return result;
            });

            addListener(el, "keypress", function(e) {
                if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
                    exports.stopEvent(e);
                    lastDefaultPrevented = null;
                }
            });

            addListener(el, "keyup", function(e) {
                pressedKeys[e.keyCode] = null;
            });

            if (!pressedKeys) {
                resetPressedKeys();
                addListener(window, "focus", resetPressedKeys);
            }
        }
    };
    function resetPressedKeys() {
        pressedKeys = Object.create(null);
    }

    if (typeof window == "object" && window.postMessage && !useragent.isOldIE) {
        var postMessageId = 1;
        exports.nextTick = function(callback, win) {
            win = win || window;
            var messageName = "zero-timeout-message-" + (postMessageId++);
            
            var listener = function(e) {
                if (e.data == messageName) {
                    exports.stopPropagation(e);
                    exports.removeListener(win, "message", listener);
                    callback();
                }
            };
            
            exports.addListener(win, "message", listener);
            win.postMessage(messageName, "*");
        };
    }

    exports.$idleBlocked = false;
    exports.onIdle = function(cb, timeout) {
        return setTimeout(function handler() {
            if (!exports.$idleBlocked) {
                cb();
            } else {
                setTimeout(handler, 100);
            }
        }, timeout);
    };

    exports.$idleBlockId = null;
    exports.blockIdle = function(delay) {
        if (exports.$idleBlockId)
            clearTimeout(exports.$idleBlockId);
            
        exports.$idleBlocked = true;
        exports.$idleBlockId = setTimeout(function() {
            exports.$idleBlocked = false;
        }, delay || 100);
    };

    exports.nextFrame = typeof window == "object" && (window.requestAnimationFrame
        || window.mozRequestAnimationFrame
        || window.webkitRequestAnimationFrame
        || window.msRequestAnimationFrame
        || window.oRequestAnimationFrame);

    if (exports.nextFrame)
        exports.nextFrame = exports.nextFrame.bind(window);
    else
        exports.nextFrame = function(callback) {
            setTimeout(callback, 17);
        };
    });

    ace.define("ace/range",["require","exports","module"], function(require, exports, module) {
    var comparePoints = function(p1, p2) {
        return p1.row - p2.row || p1.column - p2.column;
    };
    var Range = function(startRow, startColumn, endRow, endColumn) {
        this.start = {
            row: startRow,
            column: startColumn
        };

        this.end = {
            row: endRow,
            column: endColumn
        };
    };

    (function() {
        this.isEqual = function(range) {
            return this.start.row === range.start.row &&
                this.end.row === range.end.row &&
                this.start.column === range.start.column &&
                this.end.column === range.end.column;
        };
        this.toString = function() {
            return ("Range: [" + this.start.row + "/" + this.start.column +
                "] -> [" + this.end.row + "/" + this.end.column + "]");
        };

        this.contains = function(row, column) {
            return this.compare(row, column) == 0;
        };
        this.compareRange = function(range) {
            var cmp,
                end = range.end,
                start = range.start;

            cmp = this.compare(end.row, end.column);
            if (cmp == 1) {
                cmp = this.compare(start.row, start.column);
                if (cmp == 1) {
                    return 2;
                } else if (cmp == 0) {
                    return 1;
                } else {
                    return 0;
                }
            } else if (cmp == -1) {
                return -2;
            } else {
                cmp = this.compare(start.row, start.column);
                if (cmp == -1) {
                    return -1;
                } else if (cmp == 1) {
                    return 42;
                } else {
                    return 0;
                }
            }
        };
        this.comparePoint = function(p) {
            return this.compare(p.row, p.column);
        };
        this.containsRange = function(range) {
            return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
        };
        this.intersects = function(range) {
            var cmp = this.compareRange(range);
            return (cmp == -1 || cmp == 0 || cmp == 1);
        };
        this.isEnd = function(row, column) {
            return this.end.row == row && this.end.column == column;
        };
        this.isStart = function(row, column) {
            return this.start.row == row && this.start.column == column;
        };
        this.setStart = function(row, column) {
            if (typeof row == "object") {
                this.start.column = row.column;
                this.start.row = row.row;
            } else {
                this.start.row = row;
                this.start.column = column;
            }
        };
        this.setEnd = function(row, column) {
            if (typeof row == "object") {
                this.end.column = row.column;
                this.end.row = row.row;
            } else {
                this.end.row = row;
                this.end.column = column;
            }
        };
        this.inside = function(row, column) {
            if (this.compare(row, column) == 0) {
                if (this.isEnd(row, column) || this.isStart(row, column)) {
                    return false;
                } else {
                    return true;
                }
            }
            return false;
        };
        this.insideStart = function(row, column) {
            if (this.compare(row, column) == 0) {
                if (this.isEnd(row, column)) {
                    return false;
                } else {
                    return true;
                }
            }
            return false;
        };
        this.insideEnd = function(row, column) {
            if (this.compare(row, column) == 0) {
                if (this.isStart(row, column)) {
                    return false;
                } else {
                    return true;
                }
            }
            return false;
        };
        this.compare = function(row, column) {
            if (!this.isMultiLine()) {
                if (row === this.start.row) {
                    return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);
                }
            }

            if (row < this.start.row)
                return -1;

            if (row > this.end.row)
                return 1;

            if (this.start.row === row)
                return column >= this.start.column ? 0 : -1;

            if (this.end.row === row)
                return column <= this.end.column ? 0 : 1;

            return 0;
        };
        this.compareStart = function(row, column) {
            if (this.start.row == row && this.start.column == column) {
                return -1;
            } else {
                return this.compare(row, column);
            }
        };
        this.compareEnd = function(row, column) {
            if (this.end.row == row && this.end.column == column) {
                return 1;
            } else {
                return this.compare(row, column);
            }
        };
        this.compareInside = function(row, column) {
            if (this.end.row == row && this.end.column == column) {
                return 1;
            } else if (this.start.row == row && this.start.column == column) {
                return -1;
            } else {
                return this.compare(row, column);
            }
        };
        this.clipRows = function(firstRow, lastRow) {
            if (this.end.row > lastRow)
                var end = {row: lastRow + 1, column: 0};
            else if (this.end.row < firstRow)
                var end = {row: firstRow, column: 0};

            if (this.start.row > lastRow)
                var start = {row: lastRow + 1, column: 0};
            else if (this.start.row < firstRow)
                var start = {row: firstRow, column: 0};

            return Range.fromPoints(start || this.start, end || this.end);
        };
        this.extend = function(row, column) {
            var cmp = this.compare(row, column);

            if (cmp == 0)
                return this;
            else if (cmp == -1)
                var start = {row: row, column: column};
            else
                var end = {row: row, column: column};

            return Range.fromPoints(start || this.start, end || this.end);
        };

        this.isEmpty = function() {
            return (this.start.row === this.end.row && this.start.column === this.end.column);
        };
        this.isMultiLine = function() {
            return (this.start.row !== this.end.row);
        };
        this.clone = function() {
            return Range.fromPoints(this.start, this.end);
        };
        this.collapseRows = function() {
            if (this.end.column == 0)
                return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row-1), 0);
            else
                return new Range(this.start.row, 0, this.end.row, 0);
        };
        this.toScreenRange = function(session) {
            var screenPosStart = session.documentToScreenPosition(this.start);
            var screenPosEnd = session.documentToScreenPosition(this.end);

            return new Range(
                screenPosStart.row, screenPosStart.column,
                screenPosEnd.row, screenPosEnd.column
            );
        };
        this.moveBy = function(row, column) {
            this.start.row += row;
            this.start.column += column;
            this.end.row += row;
            this.end.column += column;
        };

    }).call(Range.prototype);
    Range.fromPoints = function(start, end) {
        return new Range(start.row, start.column, end.row, end.column);
    };
    Range.comparePoints = comparePoints;

    Range.comparePoints = function(p1, p2) {
        return p1.row - p2.row || p1.column - p2.column;
    };


    exports.Range = Range;
    });

    ace.define("ace/lib/lang",["require","exports","module"], function(require, exports, module) {

    exports.last = function(a) {
        return a[a.length - 1];
    };

    exports.stringReverse = function(string) {
        return string.split("").reverse().join("");
    };

    exports.stringRepeat = function (string, count) {
        var result = '';
        while (count > 0) {
            if (count & 1)
                result += string;

            if (count >>= 1)
                string += string;
        }
        return result;
    };

    var trimBeginRegexp = /^\s\s*/;
    var trimEndRegexp = /\s\s*$/;

    exports.stringTrimLeft = function (string) {
        return string.replace(trimBeginRegexp, '');
    };

    exports.stringTrimRight = function (string) {
        return string.replace(trimEndRegexp, '');
    };

    exports.copyObject = function(obj) {
        var copy = {};
        for (var key in obj) {
            copy[key] = obj[key];
        }
        return copy;
    };

    exports.copyArray = function(array){
        var copy = [];
        for (var i=0, l=array.length; i<l; i++) {
            if (array[i] && typeof array[i] == "object")
                copy[i] = this.copyObject(array[i]);
            else 
                copy[i] = array[i];
        }
        return copy;
    };

    exports.deepCopy = function deepCopy(obj) {
        if (typeof obj !== "object" || !obj)
            return obj;
        var copy;
        if (Array.isArray(obj)) {
            copy = [];
            for (var key = 0; key < obj.length; key++) {
                copy[key] = deepCopy(obj[key]);
            }
            return copy;
        }
        if (Object.prototype.toString.call(obj) !== "[object Object]")
            return obj;
        
        copy = {};
        for (var key in obj)
            copy[key] = deepCopy(obj[key]);
        return copy;
    };

    exports.arrayToMap = function(arr) {
        var map = {};
        for (var i=0; i<arr.length; i++) {
            map[arr[i]] = 1;
        }
        return map;

    };

    exports.createMap = function(props) {
        var map = Object.create(null);
        for (var i in props) {
            map[i] = props[i];
        }
        return map;
    };
    exports.arrayRemove = function(array, value) {
      for (var i = 0; i <= array.length; i++) {
        if (value === array[i]) {
          array.splice(i, 1);
        }
      }
    };

    exports.escapeRegExp = function(str) {
        return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
    };

    exports.escapeHTML = function(str) {
        return ("" + str).replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
    };

    exports.getMatchOffsets = function(string, regExp) {
        var matches = [];

        string.replace(regExp, function(str) {
            matches.push({
                offset: arguments[arguments.length-2],
                length: str.length
            });
        });

        return matches;
    };
    exports.deferredCall = function(fcn) {
        var timer = null;
        var callback = function() {
            timer = null;
            fcn();
        };

        var deferred = function(timeout) {
            deferred.cancel();
            timer = setTimeout(callback, timeout || 0);
            return deferred;
        };

        deferred.schedule = deferred;

        deferred.call = function() {
            this.cancel();
            fcn();
            return deferred;
        };

        deferred.cancel = function() {
            clearTimeout(timer);
            timer = null;
            return deferred;
        };
        
        deferred.isPending = function() {
            return timer;
        };

        return deferred;
    };


    exports.delayedCall = function(fcn, defaultTimeout) {
        var timer = null;
        var callback = function() {
            timer = null;
            fcn();
        };

        var _self = function(timeout) {
            if (timer == null)
                timer = setTimeout(callback, timeout || defaultTimeout);
        };

        _self.delay = function(timeout) {
            timer && clearTimeout(timer);
            timer = setTimeout(callback, timeout || defaultTimeout);
        };
        _self.schedule = _self;

        _self.call = function() {
            this.cancel();
            fcn();
        };

        _self.cancel = function() {
            timer && clearTimeout(timer);
            timer = null;
        };

        _self.isPending = function() {
            return timer;
        };

        return _self;
    };
    });

    ace.define("ace/clipboard",["require","exports","module"], function(require, exports, module) {

    var $cancelT;
    module.exports = { 
        lineMode: false,
        pasteCancelled: function() {
            if ($cancelT && $cancelT > Date.now() - 50)
                return true;
            return $cancelT = false;
        },
        cancel: function() {
            $cancelT = Date.now();
        }
    };

    });

    ace.define("ace/keyboard/textinput",["require","exports","module","ace/lib/event","ace/lib/useragent","ace/lib/dom","ace/lib/lang","ace/clipboard","ace/lib/keys"], function(require, exports, module) {

    var event = require("../lib/event");
    var useragent = require("../lib/useragent");
    var dom = require("../lib/dom");
    var lang = require("../lib/lang");
    var clipboard = require("../clipboard");
    var BROKEN_SETDATA = useragent.isChrome < 18;
    var USE_IE_MIME_TYPE =  useragent.isIE;
    var HAS_FOCUS_ARGS = useragent.isChrome > 63;
    var MAX_LINE_LENGTH = 400;

    var KEYS = require("../lib/keys");
    var MODS = KEYS.KEY_MODS;
    var isIOS = useragent.isIOS;
    var valueResetRegex = isIOS ? /\s/ : /\n/;

    var TextInput = function(parentNode, host) {
        var text = dom.createElement("textarea");
        text.className = "ace_text-input";

        text.setAttribute("wrap", "off");
        text.setAttribute("autocorrect", "off");
        text.setAttribute("autocapitalize", "off");
        text.setAttribute("spellcheck", false);

        text.style.opacity = "0";
        parentNode.insertBefore(text, parentNode.firstChild);

        var copied = false;
        var pasted = false;
        var inComposition = false;
        var sendingText = false;
        var tempStyle = '';
        
        if (!useragent.isMobile)
            text.style.fontSize = "1px";

        var commandMode = false;
        var ignoreFocusEvents = false;
        
        var lastValue = "";
        var lastSelectionStart = 0;
        var lastSelectionEnd = 0;
        var lastRestoreEnd = 0;
        try { var isFocused = document.activeElement === text; } catch(e) {}
        
        event.addListener(text, "blur", function(e) {
            if (ignoreFocusEvents) return;
            host.onBlur(e);
            isFocused = false;
        });
        event.addListener(text, "focus", function(e) {
            if (ignoreFocusEvents) return;
            isFocused = true;
            if (useragent.isEdge) {
                try {
                    if (!document.hasFocus())
                        return;
                } catch(e) {}
            }
            host.onFocus(e);
            if (useragent.isEdge)
                setTimeout(resetSelection);
            else
                resetSelection();
        });
        this.$focusScroll = false;
        this.focus = function() {
            if (tempStyle || HAS_FOCUS_ARGS || this.$focusScroll == "browser")
                return text.focus({ preventScroll: true });

            var top = text.style.top;
            text.style.position = "fixed";
            text.style.top = "0px";
            try {
                var isTransformed = text.getBoundingClientRect().top != 0;
            } catch(e) {
                return;
            }
            var ancestors = [];
            if (isTransformed) {
                var t = text.parentElement;
                while (t && t.nodeType == 1) {
                    ancestors.push(t);
                    t.setAttribute("ace_nocontext", true);
                    if (!t.parentElement && t.getRootNode)
                        t = t.getRootNode().host;
                    else
                        t = t.parentElement;
                }
            }
            text.focus({ preventScroll: true });
            if (isTransformed) {
                ancestors.forEach(function(p) {
                    p.removeAttribute("ace_nocontext");
                });
            }
            setTimeout(function() {
                text.style.position = "";
                if (text.style.top == "0px")
                    text.style.top = top;
            }, 0);
        };
        this.blur = function() {
            text.blur();
        };
        this.isFocused = function() {
            return isFocused;
        };
        
        host.on("beforeEndOperation", function() {
            if (host.curOp && host.curOp.command.name == "insertstring")
                return;
            if (inComposition) {
                lastValue = text.value = "";
                onCompositionEnd();
            }
            resetSelection();
        });
        
        var resetSelection = isIOS
        ? function(value) {
            if (!isFocused || (copied && !value) || sendingText) return;
            if (!value) 
                value = "";
            var newValue = "\n ab" + value + "cde fg\n";
            if (newValue != text.value)
                text.value = lastValue = newValue;
            
            var selectionStart = 4;
            var selectionEnd = 4 + (value.length || (host.selection.isEmpty() ? 0 : 1));

            if (lastSelectionStart != selectionStart || lastSelectionEnd != selectionEnd) {
                text.setSelectionRange(selectionStart, selectionEnd);
            }
            lastSelectionStart = selectionStart;
            lastSelectionEnd = selectionEnd;
        }
        : function() {
            if (inComposition || sendingText)
                return;
            if (!isFocused && !afterContextMenu)
                return;
            inComposition = true;
            
            var selection = host.selection;
            var range = selection.getRange();
            var row = selection.cursor.row;
            var selectionStart = range.start.column;
            var selectionEnd = range.end.column;
            var line = host.session.getLine(row);

            if (range.start.row != row) {
                var prevLine = host.session.getLine(row - 1);
                selectionStart = range.start.row < row - 1 ? 0 : selectionStart;
                selectionEnd += prevLine.length + 1;
                line = prevLine + "\n" + line;
            }
            else if (range.end.row != row) {
                var nextLine = host.session.getLine(row + 1);
                selectionEnd = range.end.row > row  + 1 ? nextLine.length : selectionEnd;
                selectionEnd += line.length + 1;
                line = line + "\n" + nextLine;
            }

            if (line.length > MAX_LINE_LENGTH) {
                if (selectionStart < MAX_LINE_LENGTH && selectionEnd < MAX_LINE_LENGTH) {
                    line = line.slice(0, MAX_LINE_LENGTH);
                } else {
                    line = "\n";
                    selectionStart = 0;
                    selectionEnd = 1;
                }
            }

            var newValue = line + "\n\n";
            if (newValue != lastValue) {
                text.value = lastValue = newValue;
                lastSelectionStart = lastSelectionEnd = newValue.length;
            }
            if (afterContextMenu) {
                lastSelectionStart = text.selectionStart;
                lastSelectionEnd = text.selectionEnd;
            }
            if (
                lastSelectionEnd != selectionEnd 
                || lastSelectionStart != selectionStart 
                || text.selectionEnd != lastSelectionEnd // on ie edge selectionEnd changes silently after the initialization
            ) {
                try {
                    text.setSelectionRange(selectionStart, selectionEnd);
                    lastSelectionStart = selectionStart;
                    lastSelectionEnd = selectionEnd;
                } catch(e){}
            }
            inComposition = false;
        };

        if (isFocused)
            host.onFocus();


        var isAllSelected = function(text) {
            return text.selectionStart === 0 && text.selectionEnd >= lastValue.length
                && text.value === lastValue && lastValue
                && text.selectionEnd !== lastSelectionEnd;
        };

        var onSelect = function(e) {
            if (inComposition)
                return;
            if (copied) {
                copied = false;
            } else if (isAllSelected(text)) {
                host.selectAll();
                resetSelection();
            }
        };

        var inputHandler = null;
        this.setInputHandler = function(cb) {inputHandler = cb;};
        this.getInputHandler = function() {return inputHandler;};
        var afterContextMenu = false;
        
        var sendText = function(value, fromInput) {
            if (afterContextMenu)
                afterContextMenu = false;
            if (pasted) {
                resetSelection();
                if (value)
                    host.onPaste(value);
                pasted = false;
                return "";
            } else {
                var selectionStart = text.selectionStart;
                var selectionEnd = text.selectionEnd;
            
                var extendLeft = lastSelectionStart;
                var extendRight = lastValue.length - lastSelectionEnd;
                
                var inserted = value;
                var restoreStart = value.length - selectionStart;
                var restoreEnd = value.length - selectionEnd;
            
                var i = 0;
                while (extendLeft > 0 && lastValue[i] == value[i]) {
                    i++;
                    extendLeft--;
                }
                inserted = inserted.slice(i);
                i = 1;
                while (extendRight > 0 && lastValue.length - i > lastSelectionStart - 1  && lastValue[lastValue.length - i] == value[value.length - i]) {
                    i++;
                    extendRight--;
                }
                restoreStart -= i-1;
                restoreEnd -= i-1;
                var endIndex = inserted.length - i + 1;
                if (endIndex < 0) {
                    extendLeft = -endIndex;
                    endIndex = 0;
                } 
                inserted = inserted.slice(0, endIndex);
                if (!fromInput && !inserted && !restoreStart && !extendLeft && !extendRight && !restoreEnd)
                    return "";
                sendingText = true;
                if (inserted && !extendLeft && !extendRight && !restoreStart && !restoreEnd || commandMode) {
                    host.onTextInput(inserted);
                } else {
                    host.onTextInput(inserted, {
                        extendLeft: extendLeft,
                        extendRight: extendRight,
                        restoreStart: restoreStart,
                        restoreEnd: restoreEnd
                    });
                }
                sendingText = false;
                
                lastValue = value;
                lastSelectionStart = selectionStart;
                lastSelectionEnd = selectionEnd;
                lastRestoreEnd = restoreEnd;
                return inserted;
            }
        };
        var onInput = function(e) {
            if (inComposition)
                return onCompositionUpdate();
            if (e && e.inputType) {
                if (e.inputType == "historyUndo") return host.execCommand("undo");
                if (e.inputType == "historyRedo") return host.execCommand("redo");
            }
            var data = text.value;
            var inserted = sendText(data, true);
            if (data.length > MAX_LINE_LENGTH + 100 || valueResetRegex.test(inserted))
                resetSelection();
        };
        
        var handleClipboardData = function(e, data, forceIEMime) {
            var clipboardData = e.clipboardData || window.clipboardData;
            if (!clipboardData || BROKEN_SETDATA)
                return;
            var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
            try {
                if (data) {
                    return clipboardData.setData(mime, data) !== false;
                } else {
                    return clipboardData.getData(mime);
                }
            } catch(e) {
                if (!forceIEMime)
                    return handleClipboardData(e, data, true);
            }
        };

        var doCopy = function(e, isCut) {
            var data = host.getCopyText();
            if (!data)
                return event.preventDefault(e);

            if (handleClipboardData(e, data)) {
                if (isIOS) {
                    resetSelection(data);
                    copied = data;
                    setTimeout(function () {
                        copied = false;
                    }, 10);
                }
                isCut ? host.onCut() : host.onCopy();
                event.preventDefault(e);
            } else {
                copied = true;
                text.value = data;
                text.select();
                setTimeout(function(){
                    copied = false;
                    resetSelection();
                    isCut ? host.onCut() : host.onCopy();
                });
            }
        };
        
        var onCut = function(e) {
            doCopy(e, true);
        };
        
        var onCopy = function(e) {
            doCopy(e, false);
        };
        
        var onPaste = function(e) {
            var data = handleClipboardData(e);
            if (clipboard.pasteCancelled())
                return;
            if (typeof data == "string") {
                if (data)
                    host.onPaste(data, e);
                if (useragent.isIE)
                    setTimeout(resetSelection);
                event.preventDefault(e);
            }
            else {
                text.value = "";
                pasted = true;
            }
        };

        event.addCommandKeyListener(text, host.onCommandKey.bind(host));

        event.addListener(text, "select", onSelect);
        event.addListener(text, "input", onInput);

        event.addListener(text, "cut", onCut);
        event.addListener(text, "copy", onCopy);
        event.addListener(text, "paste", onPaste);
        if (!('oncut' in text) || !('oncopy' in text) || !('onpaste' in text)) {
            event.addListener(parentNode, "keydown", function(e) {
                if ((useragent.isMac && !e.metaKey) || !e.ctrlKey)
                    return;

                switch (e.keyCode) {
                    case 67:
                        onCopy(e);
                        break;
                    case 86:
                        onPaste(e);
                        break;
                    case 88:
                        onCut(e);
                        break;
                }
            });
        }
        var onCompositionStart = function(e) {
            if (inComposition || !host.onCompositionStart || host.$readOnly) 
                return;
            
            inComposition = {};

            if (commandMode)
                return;
            
            setTimeout(onCompositionUpdate, 0);
            host.on("mousedown", cancelComposition);
            
            var range = host.getSelectionRange();
            range.end.row = range.start.row;
            range.end.column = range.start.column;
            inComposition.markerRange = range;
            inComposition.selectionStart = lastSelectionStart;
            host.onCompositionStart(inComposition);
            
            if (inComposition.useTextareaForIME) {
                text.value = "";
                lastValue = "";
                lastSelectionStart = 0;
                lastSelectionEnd = 0;
            }
            else {
                if (text.msGetInputContext)
                    inComposition.context = text.msGetInputContext();
                if (text.getInputContext)
                    inComposition.context = text.getInputContext();
            }
        };

        var onCompositionUpdate = function() {
            if (!inComposition || !host.onCompositionUpdate || host.$readOnly)
                return;
            if (commandMode)
                return cancelComposition();
            
            if (inComposition.useTextareaForIME) {
                host.onCompositionUpdate(text.value);
            }
            else {
                var data = text.value;
                sendText(data);
                if (inComposition.markerRange) {
                    if (inComposition.context) {
                        inComposition.markerRange.start.column = inComposition.selectionStart
                            = inComposition.context.compositionStartOffset;
                    }
                    inComposition.markerRange.end.column = inComposition.markerRange.start.column
                        + lastSelectionEnd - inComposition.selectionStart + lastRestoreEnd;
                }
            }
        };

        var onCompositionEnd = function(e) {
            if (!host.onCompositionEnd || host.$readOnly) return;
            inComposition = false;
            host.onCompositionEnd();
            host.off("mousedown", cancelComposition);
            if (e) onInput();
        };
        

        function cancelComposition() {
            ignoreFocusEvents = true;
            text.blur();
            text.focus();
            ignoreFocusEvents = false;
        }

        var syncComposition = lang.delayedCall(onCompositionUpdate, 50).schedule.bind(null, null);
        
        function onKeyup(e) {
            if (e.keyCode == 27 && text.value.length < text.selectionStart) {
                if (!inComposition)
                    lastValue = text.value;
                lastSelectionStart = lastSelectionEnd = -1;
                resetSelection();
            }
            syncComposition();
        }

        event.addListener(text, "compositionstart", onCompositionStart);
        event.addListener(text, "compositionupdate", onCompositionUpdate);
        event.addListener(text, "keyup", onKeyup);
        event.addListener(text, "keydown", syncComposition);
        event.addListener(text, "compositionend", onCompositionEnd);

        this.getElement = function() {
            return text;
        };
        this.setCommandMode = function(value) {
           commandMode = value;
           text.readOnly = false;
        };
        
        this.setReadOnly = function(readOnly) {
            if (!commandMode)
                text.readOnly = readOnly;
        };

        this.setCopyWithEmptySelection = function(value) {
        };

        this.onContextMenu = function(e) {
            afterContextMenu = true;
            resetSelection();
            host._emit("nativecontextmenu", {target: host, domEvent: e});
            this.moveToMouse(e, true);
        };
        
        this.moveToMouse = function(e, bringToFront) {
            if (!tempStyle)
                tempStyle = text.style.cssText;
            text.style.cssText = (bringToFront ? "z-index:100000;" : "")
                + (useragent.isIE ? "opacity:0.1;" : "")
                + "text-indent: -" + (lastSelectionStart + lastSelectionEnd) * host.renderer.characterWidth * 0.5 + "px;";

            var rect = host.container.getBoundingClientRect();
            var style = dom.computedStyle(host.container);
            var top = rect.top + (parseInt(style.borderTopWidth) || 0);
            var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
            var maxTop = rect.bottom - top - text.clientHeight -2;
            var move = function(e) {
                dom.translate(text, e.clientX - left - 2, Math.min(e.clientY - top - 2, maxTop));
            }; 
            move(e);

            if (e.type != "mousedown")
                return;

            host.renderer.$isMousePressed = true;

            clearTimeout(closeTimeout);
            if (useragent.isWin)
                event.capture(host.container, move, onContextMenuClose);
        };

        this.onContextMenuClose = onContextMenuClose;
        var closeTimeout;
        function onContextMenuClose() {
            clearTimeout(closeTimeout);
            closeTimeout = setTimeout(function () {
                if (tempStyle) {
                    text.style.cssText = tempStyle;
                    tempStyle = '';
                }
                host.renderer.$isMousePressed = false;
                if (host.renderer.$keepTextAreaAtCursor)
                    host.renderer.$moveTextAreaToCursor();
            }, 0);
        }

        var onContextMenu = function(e) {
            host.textInput.onContextMenu(e);
            onContextMenuClose();
        };
        event.addListener(text, "mouseup", onContextMenu);
        event.addListener(text, "mousedown", function(e) {
            e.preventDefault();
            onContextMenuClose();
        });
        event.addListener(host.renderer.scroller, "contextmenu", onContextMenu);
        event.addListener(text, "contextmenu", onContextMenu);
        
        if (isIOS)
            addIosSelectionHandler(parentNode, host, text);

        function addIosSelectionHandler(parentNode, host, text) {
            var typingResetTimeout = null;
            var typing = false;
     
            text.addEventListener("keydown", function (e) {
                if (typingResetTimeout) clearTimeout(typingResetTimeout);
                typing = true;
            }, true);

            text.addEventListener("keyup", function (e) {
                typingResetTimeout = setTimeout(function () {
                    typing = false;
                }, 100);
            }, true);
            var detectArrowKeys = function(e) {
                if (document.activeElement !== text) return;
                if (typing || inComposition || host.$mouseHandler.isMousePressed) return;

                if (copied) {
                    return;
                }
                var selectionStart = text.selectionStart;
                var selectionEnd = text.selectionEnd;
                
                var key = null;
                var modifier = 0;
                if (selectionStart == 0) {
                    key = KEYS.up;
                } else if (selectionStart == 1) {
                    key = KEYS.home;
                } else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd] == "\n") {
                    key = KEYS.end;
                } else if (selectionStart < lastSelectionStart && lastValue[selectionStart - 1] == " ") {
                    key = KEYS.left;
                    modifier = MODS.option;
                } else if (
                    selectionStart < lastSelectionStart
                    || (
                        selectionStart == lastSelectionStart 
                        && lastSelectionEnd != lastSelectionStart
                        && selectionStart == selectionEnd
                    )
                ) {
                    key = KEYS.left;
                } else if (selectionEnd > lastSelectionEnd && lastValue.slice(0, selectionEnd).split("\n").length > 2) {
                    key = KEYS.down;
                } else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd - 1] == " ") {
                    key = KEYS.right;
                    modifier = MODS.option;
                } else if (
                    selectionEnd > lastSelectionEnd
                    || (
                        selectionEnd == lastSelectionEnd 
                        && lastSelectionEnd != lastSelectionStart
                        && selectionStart == selectionEnd
                    )
                ) {
                    key = KEYS.right;
                }
                
                if (selectionStart !== selectionEnd)
                    modifier |= MODS.shift;

                if (key) {
                    var result = host.onCommandKey({}, modifier, key);
                    if (!result && host.commands) {
                        key = KEYS.keyCodeToString(key);
                        var command = host.commands.findKeyCommand(modifier, key);
                        if (command)
                            host.execCommand(command);
                    }
                    lastSelectionStart = selectionStart;
                    lastSelectionEnd = selectionEnd;
                    resetSelection("");
                }
            };
            document.addEventListener("selectionchange", detectArrowKeys);
            host.on("destroy", function() {
                document.removeEventListener("selectionchange", detectArrowKeys);
            });
        }

    };

    exports.TextInput = TextInput;
    });

    ace.define("ace/mouse/default_handlers",["require","exports","module","ace/lib/useragent"], function(require, exports, module) {

    var useragent = require("../lib/useragent");

    var DRAG_OFFSET = 0; // pixels
    var SCROLL_COOLDOWN_T = 550; // milliseconds

    function DefaultHandlers(mouseHandler) {
        mouseHandler.$clickSelection = null;

        var editor = mouseHandler.editor;
        editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
        editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
        editor.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
        editor.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
        editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));

        var exports = ["select", "startSelect", "selectEnd", "selectAllEnd", "selectByWordsEnd",
            "selectByLinesEnd", "dragWait", "dragWaitEnd", "focusWait"];

        exports.forEach(function(x) {
            mouseHandler[x] = this[x];
        }, this);

        mouseHandler.selectByLines = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
        mouseHandler.selectByWords = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
    }

    (function() {

        this.onMouseDown = function(ev) {
            var inSelection = ev.inSelection();
            var pos = ev.getDocumentPosition();
            this.mousedownEvent = ev;
            var editor = this.editor;

            var button = ev.getButton();
            if (button !== 0) {
                var selectionRange = editor.getSelectionRange();
                var selectionEmpty = selectionRange.isEmpty();
                if (selectionEmpty || button == 1)
                    editor.selection.moveToPosition(pos);
                if (button == 2) {
                    editor.textInput.onContextMenu(ev.domEvent);
                    if (!useragent.isMozilla)
                        ev.preventDefault();
                }
                return;
            }

            this.mousedownEvent.time = Date.now();
            if (inSelection && !editor.isFocused()) {
                editor.focus();
                if (this.$focusTimeout && !this.$clickSelection && !editor.inMultiSelectMode) {
                    this.setState("focusWait");
                    this.captureMouse(ev);
                    return;
                }
            }

            this.captureMouse(ev);
            this.startSelect(pos, ev.domEvent._clicks > 1);
            return ev.preventDefault();
        };

        this.startSelect = function(pos, waitForClickSelection) {
            pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
            var editor = this.editor;
            if (!this.mousedownEvent) return;
            if (this.mousedownEvent.getShiftKey())
                editor.selection.selectToPosition(pos);
            else if (!waitForClickSelection)
                editor.selection.moveToPosition(pos);
            if (!waitForClickSelection)
                this.select();
            if (editor.renderer.scroller.setCapture) {
                editor.renderer.scroller.setCapture();
            }
            editor.setStyle("ace_selecting");
            this.setState("select");
        };

        this.select = function() {
            var anchor, editor = this.editor;
            var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
            if (this.$clickSelection) {
                var cmp = this.$clickSelection.comparePoint(cursor);

                if (cmp == -1) {
                    anchor = this.$clickSelection.end;
                } else if (cmp == 1) {
                    anchor = this.$clickSelection.start;
                } else {
                    var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                    cursor = orientedRange.cursor;
                    anchor = orientedRange.anchor;
                }
                editor.selection.setSelectionAnchor(anchor.row, anchor.column);
            }
            editor.selection.selectToPosition(cursor);
            editor.renderer.scrollCursorIntoView();
        };

        this.extendSelectionBy = function(unitName) {
            var anchor, editor = this.editor;
            var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
            var range = editor.selection[unitName](cursor.row, cursor.column);
            if (this.$clickSelection) {
                var cmpStart = this.$clickSelection.comparePoint(range.start);
                var cmpEnd = this.$clickSelection.comparePoint(range.end);

                if (cmpStart == -1 && cmpEnd <= 0) {
                    anchor = this.$clickSelection.end;
                    if (range.end.row != cursor.row || range.end.column != cursor.column)
                        cursor = range.start;
                } else if (cmpEnd == 1 && cmpStart >= 0) {
                    anchor = this.$clickSelection.start;
                    if (range.start.row != cursor.row || range.start.column != cursor.column)
                        cursor = range.end;
                } else if (cmpStart == -1 && cmpEnd == 1) {
                    cursor = range.end;
                    anchor = range.start;
                } else {
                    var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                    cursor = orientedRange.cursor;
                    anchor = orientedRange.anchor;
                }
                editor.selection.setSelectionAnchor(anchor.row, anchor.column);
            }
            editor.selection.selectToPosition(cursor);
            editor.renderer.scrollCursorIntoView();
        };

        this.selectEnd =
        this.selectAllEnd =
        this.selectByWordsEnd =
        this.selectByLinesEnd = function() {
            this.$clickSelection = null;
            this.editor.unsetStyle("ace_selecting");
            if (this.editor.renderer.scroller.releaseCapture) {
                this.editor.renderer.scroller.releaseCapture();
            }
        };

        this.focusWait = function() {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            var time = Date.now();

            if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimeout)
                this.startSelect(this.mousedownEvent.getDocumentPosition());
        };

        this.onDoubleClick = function(ev) {
            var pos = ev.getDocumentPosition();
            var editor = this.editor;
            var session = editor.session;

            var range = session.getBracketRange(pos);
            if (range) {
                if (range.isEmpty()) {
                    range.start.column--;
                    range.end.column++;
                }
                this.setState("select");
            } else {
                range = editor.selection.getWordRange(pos.row, pos.column);
                this.setState("selectByWords");
            }
            this.$clickSelection = range;
            this.select();
        };

        this.onTripleClick = function(ev) {
            var pos = ev.getDocumentPosition();
            var editor = this.editor;

            this.setState("selectByLines");
            var range = editor.getSelectionRange();
            if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
                this.$clickSelection = editor.selection.getLineRange(range.start.row);
                this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
            } else {
                this.$clickSelection = editor.selection.getLineRange(pos.row);
            }
            this.select();
        };

        this.onQuadClick = function(ev) {
            var editor = this.editor;

            editor.selectAll();
            this.$clickSelection = editor.getSelectionRange();
            this.setState("selectAll");
        };

        this.onMouseWheel = function(ev) {
            if (ev.getAccelKey())
                return;
            if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
                ev.wheelX = ev.wheelY;
                ev.wheelY = 0;
            }
            
            var editor = this.editor;
            
            if (!this.$lastScroll)
                this.$lastScroll = { t: 0, vx: 0, vy: 0, allowed: 0 };
            
            var prevScroll = this.$lastScroll;
            var t = ev.domEvent.timeStamp;
            var dt = t - prevScroll.t;
            var vx = dt ? ev.wheelX / dt : prevScroll.vx;
            var vy = dt ? ev.wheelY / dt : prevScroll.vy;
            if (dt < SCROLL_COOLDOWN_T) {
                vx = (vx + prevScroll.vx) / 2;
                vy = (vy + prevScroll.vy) / 2;
            }
            
            var direction = Math.abs(vx / vy);
            
            var canScroll = false;
            if (direction >= 1 && editor.renderer.isScrollableBy(ev.wheelX * ev.speed, 0))
                canScroll = true;
            if (direction <= 1 && editor.renderer.isScrollableBy(0, ev.wheelY * ev.speed))
                canScroll = true;
                
            if (canScroll) {
                prevScroll.allowed = t;
            } else if (t - prevScroll.allowed < SCROLL_COOLDOWN_T) {
                var isSlower = Math.abs(vx) <= 1.5 * Math.abs(prevScroll.vx)
                    && Math.abs(vy) <= 1.5 * Math.abs(prevScroll.vy);
                if (isSlower) {
                    canScroll = true;
                    prevScroll.allowed = t;
                }
                else {
                    prevScroll.allowed = 0;
                }
            }
            
            prevScroll.t = t;
            prevScroll.vx = vx;
            prevScroll.vy = vy;

            if (canScroll) {
                editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
                return ev.stop();
            }
        };

    }).call(DefaultHandlers.prototype);

    exports.DefaultHandlers = DefaultHandlers;

    function calcDistance(ax, ay, bx, by) {
        return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
    }

    function calcRangeOrientation(range, cursor) {
        if (range.start.row == range.end.row)
            var cmp = 2 * cursor.column - range.start.column - range.end.column;
        else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)
            var cmp = cursor.column - 4;
        else
            var cmp = 2 * cursor.row - range.start.row - range.end.row;

        if (cmp < 0)
            return {cursor: range.start, anchor: range.end};
        else
            return {cursor: range.end, anchor: range.start};
    }

    });

    ace.define("ace/tooltip",["require","exports","module","ace/lib/oop","ace/lib/dom"], function(require, exports, module) {

    var oop = require("./lib/oop");
    var dom = require("./lib/dom");
    function Tooltip (parentNode) {
        this.isOpen = false;
        this.$element = null;
        this.$parentNode = parentNode;
    }

    (function() {
        this.$init = function() {
            this.$element = dom.createElement("div");
            this.$element.className = "ace_tooltip";
            this.$element.style.display = "none";
            this.$parentNode.appendChild(this.$element);
            return this.$element;
        };
        this.getElement = function() {
            return this.$element || this.$init();
        };
        this.setText = function(text) {
            this.getElement().textContent = text;
        };
        this.setHtml = function(html) {
            this.getElement().innerHTML = html;
        };
        this.setPosition = function(x, y) {
            this.getElement().style.left = x + "px";
            this.getElement().style.top = y + "px";
        };
        this.setClassName = function(className) {
            dom.addCssClass(this.getElement(), className);
        };
        this.show = function(text, x, y) {
            if (text != null)
                this.setText(text);
            if (x != null && y != null)
                this.setPosition(x, y);
            if (!this.isOpen) {
                this.getElement().style.display = "block";
                this.isOpen = true;
            }
        };

        this.hide = function() {
            if (this.isOpen) {
                this.getElement().style.display = "none";
                this.isOpen = false;
            }
        };
        this.getHeight = function() {
            return this.getElement().offsetHeight;
        };
        this.getWidth = function() {
            return this.getElement().offsetWidth;
        };
        
        this.destroy = function() {
            this.isOpen = false;
            if (this.$element && this.$element.parentNode) {
                this.$element.parentNode.removeChild(this.$element);
            }
        };

    }).call(Tooltip.prototype);

    exports.Tooltip = Tooltip;
    });

    ace.define("ace/mouse/default_gutter_handler",["require","exports","module","ace/lib/dom","ace/lib/oop","ace/lib/event","ace/tooltip"], function(require, exports, module) {
    var dom = require("../lib/dom");
    var oop = require("../lib/oop");
    var event = require("../lib/event");
    var Tooltip = require("../tooltip").Tooltip;

    function GutterHandler(mouseHandler) {
        var editor = mouseHandler.editor;
        var gutter = editor.renderer.$gutterLayer;
        var tooltip = new GutterTooltip(editor.container);

        mouseHandler.editor.setDefaultHandler("guttermousedown", function(e) {
            if (!editor.isFocused() || e.getButton() != 0)
                return;
            var gutterRegion = gutter.getRegion(e);

            if (gutterRegion == "foldWidgets")
                return;

            var row = e.getDocumentPosition().row;
            var selection = editor.session.selection;

            if (e.getShiftKey())
                selection.selectTo(row, 0);
            else {
                if (e.domEvent.detail == 2) {
                    editor.selectAll();
                    return e.preventDefault();
                }
                mouseHandler.$clickSelection = editor.selection.getLineRange(row);
            }
            mouseHandler.setState("selectByLines");
            mouseHandler.captureMouse(e);
            return e.preventDefault();
        });


        var tooltipTimeout, mouseEvent, tooltipAnnotation;

        function showTooltip() {
            var row = mouseEvent.getDocumentPosition().row;
            var annotation = gutter.$annotations[row];
            if (!annotation)
                return hideTooltip();

            var maxRow = editor.session.getLength();
            if (row == maxRow) {
                var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
                var pos = mouseEvent.$pos;
                if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column))
                    return hideTooltip();
            }

            if (tooltipAnnotation == annotation)
                return;
            tooltipAnnotation = annotation.text.join("<br/>");

            tooltip.setHtml(tooltipAnnotation);
            tooltip.show();
            editor._signal("showGutterTooltip", tooltip);
            editor.on("mousewheel", hideTooltip);

            if (mouseHandler.$tooltipFollowsMouse) {
                moveTooltip(mouseEvent);
            } else {
                var gutterElement = mouseEvent.domEvent.target;
                var rect = gutterElement.getBoundingClientRect();
                var style = tooltip.getElement().style;
                style.left = rect.right + "px";
                style.top = rect.bottom + "px";
            }
        }

        function hideTooltip() {
            if (tooltipTimeout)
                tooltipTimeout = clearTimeout(tooltipTimeout);
            if (tooltipAnnotation) {
                tooltip.hide();
                tooltipAnnotation = null;
                editor._signal("hideGutterTooltip", tooltip);
                editor.removeEventListener("mousewheel", hideTooltip);
            }
        }

        function moveTooltip(e) {
            tooltip.setPosition(e.x, e.y);
        }

        mouseHandler.editor.setDefaultHandler("guttermousemove", function(e) {
            var target = e.domEvent.target || e.domEvent.srcElement;
            if (dom.hasCssClass(target, "ace_fold-widget"))
                return hideTooltip();

            if (tooltipAnnotation && mouseHandler.$tooltipFollowsMouse)
                moveTooltip(e);

            mouseEvent = e;
            if (tooltipTimeout)
                return;
            tooltipTimeout = setTimeout(function() {
                tooltipTimeout = null;
                if (mouseEvent && !mouseHandler.isMousePressed)
                    showTooltip();
                else
                    hideTooltip();
            }, 50);
        });

        event.addListener(editor.renderer.$gutter, "mouseout", function(e) {
            mouseEvent = null;
            if (!tooltipAnnotation || tooltipTimeout)
                return;

            tooltipTimeout = setTimeout(function() {
                tooltipTimeout = null;
                hideTooltip();
            }, 50);
        });
        
        editor.on("changeSession", hideTooltip);
    }

    function GutterTooltip(parentNode) {
        Tooltip.call(this, parentNode);
    }

    oop.inherits(GutterTooltip, Tooltip);

    (function(){
        this.setPosition = function(x, y) {
            var windowWidth = window.innerWidth || document.documentElement.clientWidth;
            var windowHeight = window.innerHeight || document.documentElement.clientHeight;
            var width = this.getWidth();
            var height = this.getHeight();
            x += 15;
            y += 15;
            if (x + width > windowWidth) {
                x -= (x + width) - windowWidth;
            }
            if (y + height > windowHeight) {
                y -= 20 + height;
            }
            Tooltip.prototype.setPosition.call(this, x, y);
        };

    }).call(GutterTooltip.prototype);



    exports.GutterHandler = GutterHandler;

    });

    ace.define("ace/mouse/mouse_event",["require","exports","module","ace/lib/event","ace/lib/useragent"], function(require, exports, module) {

    var event = require("../lib/event");
    var useragent = require("../lib/useragent");
    var MouseEvent = exports.MouseEvent = function(domEvent, editor) {
        this.domEvent = domEvent;
        this.editor = editor;
        
        this.x = this.clientX = domEvent.clientX;
        this.y = this.clientY = domEvent.clientY;

        this.$pos = null;
        this.$inSelection = null;
        
        this.propagationStopped = false;
        this.defaultPrevented = false;
    };

    (function() {  
        
        this.stopPropagation = function() {
            event.stopPropagation(this.domEvent);
            this.propagationStopped = true;
        };
        
        this.preventDefault = function() {
            event.preventDefault(this.domEvent);
            this.defaultPrevented = true;
        };
        
        this.stop = function() {
            this.stopPropagation();
            this.preventDefault();
        };
        this.getDocumentPosition = function() {
            if (this.$pos)
                return this.$pos;
            
            this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
            return this.$pos;
        };
        this.inSelection = function() {
            if (this.$inSelection !== null)
                return this.$inSelection;
                
            var editor = this.editor;
            

            var selectionRange = editor.getSelectionRange();
            if (selectionRange.isEmpty())
                this.$inSelection = false;
            else {
                var pos = this.getDocumentPosition();
                this.$inSelection = selectionRange.contains(pos.row, pos.column);
            }

            return this.$inSelection;
        };
        this.getButton = function() {
            return event.getButton(this.domEvent);
        };
        this.getShiftKey = function() {
            return this.domEvent.shiftKey;
        };
        
        this.getAccelKey = useragent.isMac
            ? function() { return this.domEvent.metaKey; }
            : function() { return this.domEvent.ctrlKey; };
        
    }).call(MouseEvent.prototype);

    });

    ace.define("ace/mouse/dragdrop_handler",["require","exports","module","ace/lib/dom","ace/lib/event","ace/lib/useragent"], function(require, exports, module) {

    var dom = require("../lib/dom");
    var event = require("../lib/event");
    var useragent = require("../lib/useragent");

    var AUTOSCROLL_DELAY = 200;
    var SCROLL_CURSOR_DELAY = 200;
    var SCROLL_CURSOR_HYSTERESIS = 5;

    function DragdropHandler(mouseHandler) {

        var editor = mouseHandler.editor;

        var blankImage = dom.createElement("img");
        blankImage.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
        if (useragent.isOpera)
            blankImage.style.cssText = "width:1px;height:1px;position:fixed;top:0;left:0;z-index:2147483647;opacity:0;";

        var exports = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];

         exports.forEach(function(x) {
             mouseHandler[x] = this[x];
        }, this);
        editor.addEventListener("mousedown", this.onMouseDown.bind(mouseHandler));


        var mouseTarget = editor.container;
        var dragSelectionMarker, x, y;
        var timerId, range;
        var dragCursor, counter = 0;
        var dragOperation;
        var isInternal;
        var autoScrollStartTime;
        var cursorMovedTime;
        var cursorPointOnCaretMoved;

        this.onDragStart = function(e) {
            if (this.cancelDrag || !mouseTarget.draggable) {
                var self = this;
                setTimeout(function(){
                    self.startSelect();
                    self.captureMouse(e);
                }, 0);
                return e.preventDefault();
            }
            range = editor.getSelectionRange();

            var dataTransfer = e.dataTransfer;
            dataTransfer.effectAllowed = editor.getReadOnly() ? "copy" : "copyMove";
            if (useragent.isOpera) {
                editor.container.appendChild(blankImage);
                blankImage.scrollTop = 0;
            }
            dataTransfer.setDragImage && dataTransfer.setDragImage(blankImage, 0, 0);
            if (useragent.isOpera) {
                editor.container.removeChild(blankImage);
            }
            dataTransfer.clearData();
            dataTransfer.setData("Text", editor.session.getTextRange());

            isInternal = true;
            this.setState("drag");
        };

        this.onDragEnd = function(e) {
            mouseTarget.draggable = false;
            isInternal = false;
            this.setState(null);
            if (!editor.getReadOnly()) {
                var dropEffect = e.dataTransfer.dropEffect;
                if (!dragOperation && dropEffect == "move")
                    editor.session.remove(editor.getSelectionRange());
                editor.$resetCursorStyle();
            }
            this.editor.unsetStyle("ace_dragging");
            this.editor.renderer.setCursorStyle("");
        };

        this.onDragEnter = function(e) {
            if (editor.getReadOnly() || !canAccept(e.dataTransfer))
                return;
            x = e.clientX;
            y = e.clientY;
            if (!dragSelectionMarker)
                addDragMarker();
            counter++;
            e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
            return event.preventDefault(e);
        };

        this.onDragOver = function(e) {
            if (editor.getReadOnly() || !canAccept(e.dataTransfer))
                return;
            x = e.clientX;
            y = e.clientY;
            if (!dragSelectionMarker) {
                addDragMarker();
                counter++;
            }
            if (onMouseMoveTimer !== null)
                onMouseMoveTimer = null;

            e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
            return event.preventDefault(e);
        };

        this.onDragLeave = function(e) {
            counter--;
            if (counter <= 0 && dragSelectionMarker) {
                clearDragMarker();
                dragOperation = null;
                return event.preventDefault(e);
            }
        };

        this.onDrop = function(e) {
            if (!dragCursor)
                return;
            var dataTransfer = e.dataTransfer;
            if (isInternal) {
                switch (dragOperation) {
                    case "move":
                        if (range.contains(dragCursor.row, dragCursor.column)) {
                            range = {
                                start: dragCursor,
                                end: dragCursor
                            };
                        } else {
                            range = editor.moveText(range, dragCursor);
                        }
                        break;
                    case "copy":
                        range = editor.moveText(range, dragCursor, true);
                        break;
                }
            } else {
                var dropData = dataTransfer.getData('Text');
                range = {
                    start: dragCursor,
                    end: editor.session.insert(dragCursor, dropData)
                };
                editor.focus();
                dragOperation = null;
            }
            clearDragMarker();
            return event.preventDefault(e);
        };

        event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler));
        event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler));
        event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler));
        event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler));
        event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler));
        event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler));

        function scrollCursorIntoView(cursor, prevCursor) {
            var now = Date.now();
            var vMovement = !prevCursor || cursor.row != prevCursor.row;
            var hMovement = !prevCursor || cursor.column != prevCursor.column;
            if (!cursorMovedTime || vMovement || hMovement) {
                editor.moveCursorToPosition(cursor);
                cursorMovedTime = now;
                cursorPointOnCaretMoved = {x: x, y: y};
            } else {
                var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);
                if (distance > SCROLL_CURSOR_HYSTERESIS) {
                    cursorMovedTime = null;
                } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
                    editor.renderer.scrollCursorIntoView();
                    cursorMovedTime = null;
                }
            }
        }

        function autoScroll(cursor, prevCursor) {
            var now = Date.now();
            var lineHeight = editor.renderer.layerConfig.lineHeight;
            var characterWidth = editor.renderer.layerConfig.characterWidth;
            var editorRect = editor.renderer.scroller.getBoundingClientRect();
            var offsets = {
               x: {
                   left: x - editorRect.left,
                   right: editorRect.right - x
               },
               y: {
                   top: y - editorRect.top,
                   bottom: editorRect.bottom - y
               }
            };
            var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
            var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
            var scrollCursor = {row: cursor.row, column: cursor.column};
            if (nearestXOffset / characterWidth <= 2) {
                scrollCursor.column += (offsets.x.left < offsets.x.right ? -3 : +2);
            }
            if (nearestYOffset / lineHeight <= 1) {
                scrollCursor.row += (offsets.y.top < offsets.y.bottom ? -1 : +1);
            }
            var vScroll = cursor.row != scrollCursor.row;
            var hScroll = cursor.column != scrollCursor.column;
            var vMovement = !prevCursor || cursor.row != prevCursor.row;
            if (vScroll || (hScroll && !vMovement)) {
                if (!autoScrollStartTime)
                    autoScrollStartTime = now;
                else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)
                    editor.renderer.scrollCursorIntoView(scrollCursor);
            } else {
                autoScrollStartTime = null;
            }
        }

        function onDragInterval() {
            var prevCursor = dragCursor;
            dragCursor = editor.renderer.screenToTextCoordinates(x, y);
            scrollCursorIntoView(dragCursor, prevCursor);
            autoScroll(dragCursor, prevCursor);
        }

        function addDragMarker() {
            range = editor.selection.toOrientedRange();
            dragSelectionMarker = editor.session.addMarker(range, "ace_selection", editor.getSelectionStyle());
            editor.clearSelection();
            if (editor.isFocused())
                editor.renderer.$cursorLayer.setBlinking(false);
            clearInterval(timerId);
            onDragInterval();
            timerId = setInterval(onDragInterval, 20);
            counter = 0;
            event.addListener(document, "mousemove", onMouseMove);
        }

        function clearDragMarker() {
            clearInterval(timerId);
            editor.session.removeMarker(dragSelectionMarker);
            dragSelectionMarker = null;
            editor.selection.fromOrientedRange(range);
            if (editor.isFocused() && !isInternal)
                editor.$resetCursorStyle();
            range = null;
            dragCursor = null;
            counter = 0;
            autoScrollStartTime = null;
            cursorMovedTime = null;
            event.removeListener(document, "mousemove", onMouseMove);
        }
        var onMouseMoveTimer = null;
        function onMouseMove() {
            if (onMouseMoveTimer == null) {
                onMouseMoveTimer = setTimeout(function() {
                    if (onMouseMoveTimer != null && dragSelectionMarker)
                        clearDragMarker();
                }, 20);
            }
        }

        function canAccept(dataTransfer) {
            var types = dataTransfer.types;
            return !types || Array.prototype.some.call(types, function(type) {
                return type == 'text/plain' || type == 'Text';
            });
        }

        function getDropEffect(e) {
            var copyAllowed = ['copy', 'copymove', 'all', 'uninitialized'];
            var moveAllowed = ['move', 'copymove', 'linkmove', 'all', 'uninitialized'];

            var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;
            var effectAllowed = "uninitialized";
            try {
                effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();
            } catch (e) {}
            var dropEffect = "none";

            if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)
                dropEffect = "copy";
            else if (moveAllowed.indexOf(effectAllowed) >= 0)
                dropEffect = "move";
            else if (copyAllowed.indexOf(effectAllowed) >= 0)
                dropEffect = "copy";

            return dropEffect;
        }
    }

    (function() {

        this.dragWait = function() {
            var interval = Date.now() - this.mousedownEvent.time;
            if (interval > this.editor.getDragDelay())
                this.startDrag();
        };

        this.dragWaitEnd = function() {
            var target = this.editor.container;
            target.draggable = false;
            this.startSelect(this.mousedownEvent.getDocumentPosition());
            this.selectEnd();
        };

        this.dragReadyEnd = function(e) {
            this.editor.$resetCursorStyle();
            this.editor.unsetStyle("ace_dragging");
            this.editor.renderer.setCursorStyle("");
            this.dragWaitEnd();
        };

        this.startDrag = function(){
            this.cancelDrag = false;
            var editor = this.editor;
            var target = editor.container;
            target.draggable = true;
            editor.renderer.$cursorLayer.setBlinking(false);
            editor.setStyle("ace_dragging");
            var cursorStyle = useragent.isWin ? "default" : "move";
            editor.renderer.setCursorStyle(cursorStyle);
            this.setState("dragReady");
        };

        this.onMouseDrag = function(e) {
            var target = this.editor.container;
            if (useragent.isIE && this.state == "dragReady") {
                var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
                if (distance > 3)
                    target.dragDrop();
            }
            if (this.state === "dragWait") {
                var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
                if (distance > 0) {
                    target.draggable = false;
                    this.startSelect(this.mousedownEvent.getDocumentPosition());
                }
            }
        };

        this.onMouseDown = function(e) {
            if (!this.$dragEnabled)
                return;
            this.mousedownEvent = e;
            var editor = this.editor;

            var inSelection = e.inSelection();
            var button = e.getButton();
            var clickCount = e.domEvent.detail || 1;
            if (clickCount === 1 && button === 0 && inSelection) {
                if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey()))
                    return;
                this.mousedownEvent.time = Date.now();
                var eventTarget = e.domEvent.target || e.domEvent.srcElement;
                if ("unselectable" in eventTarget)
                    eventTarget.unselectable = "on";
                if (editor.getDragDelay()) {
                    if (useragent.isWebKit) {
                        this.cancelDrag = true;
                        var mouseTarget = editor.container;
                        mouseTarget.draggable = true;
                    }
                    this.setState("dragWait");
                } else {
                    this.startDrag();
                }
                this.captureMouse(e, this.onMouseDrag.bind(this));
                e.defaultPrevented = true;
            }
        };

    }).call(DragdropHandler.prototype);


    function calcDistance(ax, ay, bx, by) {
        return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
    }

    exports.DragdropHandler = DragdropHandler;

    });

    ace.define("ace/mouse/touch_handler",["require","exports","module","ace/mouse/mouse_event","ace/lib/event","ace/lib/dom"], function(require, exports, module) {

    var MouseEvent = require("./mouse_event").MouseEvent;
    var event = require("../lib/event");
    var dom = require("../lib/dom");

    exports.addTouchListeners = function(el, editor) {
        var mode = "scroll";
        var startX;
        var startY;
        var touchStartT;
        var lastT;
        var longTouchTimer;
        var animationTimer;
        var animationSteps = 0;
        var pos;
        var clickCount = 0;
        var vX = 0;
        var vY = 0;
        var pressed;
        var contextMenu;
        
        function createContextMenu() {
            var clipboard = window.navigator && window.navigator.clipboard;
            var isOpen = false;
            var updateMenu = function() {
                var selected = editor.getCopyText();
                var hasUndo = editor.session.getUndoManager().hasUndo();
                contextMenu.replaceChild(
                    dom.buildDom(isOpen ? ["span",
                        !selected && ["span", { class: "ace_mobile-button", action: "selectall" }, "Select All"],
                        selected && ["span", { class: "ace_mobile-button", action: "copy" }, "Copy"],
                        selected && ["span", { class: "ace_mobile-button", action: "cut" }, "Cut"],
                        clipboard && ["span", { class: "ace_mobile-button", action: "paste" }, "Paste"],
                        hasUndo && ["span", { class: "ace_mobile-button", action: "undo" }, "Undo"],
                        ["span", { class: "ace_mobile-button", action: "find" }, "Find"],
                        ["span", { class: "ace_mobile-button", action: "openCommandPallete" }, "Pallete"]
                    ] : ["span"]),
                    contextMenu.firstChild
                );
            };
            var handleClick = function(e) {
                var action = e.target.getAttribute("action");

                if (action == "more" || !isOpen) {
                    isOpen = !isOpen;
                    return updateMenu();
                }
                if (action == "paste") {
                    clipboard.readText().then(function (text) {
                        editor.execCommand(action, text);
                    });
                }
                else if (action) {
                    if (action == "cut" || action == "copy") {
                        if (clipboard)
                            clipboard.writeText(editor.getCopyText());
                        else
                            document.execCommand("copy");
                    }
                    editor.execCommand(action);
                }
                contextMenu.firstChild.style.display = "none";
                isOpen = false;
                if (action != "openCommandPallete")
                    editor.focus();
            };
            contextMenu = dom.buildDom(["div",
                {
                    class: "ace_mobile-menu",
                    ontouchstart: function(e) {
                        mode = "menu";
                        e.stopPropagation();
                        e.preventDefault();
                        editor.textInput.focus();
                    },
                    ontouchend: function(e) {
                        e.stopPropagation();
                        e.preventDefault();
                        handleClick(e);
                    },
                    onclick: handleClick
                },
                ["span"],
                ["span", { class: "ace_mobile-button", action: "more" }, "..."]
            ], editor.container);
        }
        function showContextMenu() {
            if (!contextMenu) createContextMenu();
            var cursor = editor.selection.cursor;
            var pagePos = editor.renderer.textToScreenCoordinates(cursor.row, cursor.column);
            var rect = editor.container.getBoundingClientRect();
            contextMenu.style.top = pagePos.pageY - rect.top - 3 + "px";
            contextMenu.style.right = "10px";
            contextMenu.style.display = "";
            contextMenu.firstChild.style.display = "none";
            editor.on("input", hideContextMenu);
        }
        function hideContextMenu(e) {
            if (contextMenu)
                contextMenu.style.display = "none";
            editor.off("input", hideContextMenu);
        }

        function handleLongTap() {
            longTouchTimer = null;
            clearTimeout(longTouchTimer);
            var range = editor.selection.getRange();
            var inSelection = range.contains(pos.row, pos.column);
            if (range.isEmpty() || !inSelection) {
                editor.selection.moveToPosition(pos);
                editor.selection.selectWord();
            }
            mode = "wait";
            showContextMenu();
        }
        function switchToSelectionMode() {
            longTouchTimer = null;
            clearTimeout(longTouchTimer);
            editor.selection.moveToPosition(pos);
            var range = clickCount >= 2
                ? editor.selection.getLineRange(pos.row)
                : editor.session.getBracketRange(pos);
            if (range && !range.isEmpty()) {
                editor.selection.setRange(range);
            } else {
                editor.selection.selectWord();
            }
            mode = "wait";
        }
        event.addListener(el, "contextmenu", function(e) {
            if (!pressed) return;
            var textarea = editor.textInput.getElement();
            textarea.focus();
        });
        event.addListener(el, "touchstart", function (e) {
            var touches = e.touches;
            if (longTouchTimer || touches.length > 1) {
                clearTimeout(longTouchTimer);
                longTouchTimer = null;
                touchStartT = -1;
                mode = "zoom";
                return;
            }
            
            pressed = editor.$mouseHandler.isMousePressed = true;
            var h = editor.renderer.layerConfig.lineHeight;
            var w = editor.renderer.layerConfig.lineHeight;
            var t = e.timeStamp;
            lastT = t;
            var touchObj = touches[0];
            var x = touchObj.clientX;
            var y = touchObj.clientY;
            if (Math.abs(startX - x) + Math.abs(startY - y) > h)
                touchStartT = -1;
            
            startX = e.clientX = x;
            startY = e.clientY = y;
            vX = vY = 0;
            
            var ev = new MouseEvent(e, editor);
            pos = ev.getDocumentPosition();

            if (t - touchStartT < 500 && touches.length == 1 && !animationSteps) {
                clickCount++;
                e.preventDefault();
                e.button = 0;
                switchToSelectionMode();
            } else {
                clickCount = 0;
                var cursor = editor.selection.cursor;
                var anchor = editor.selection.isEmpty() ? cursor : editor.selection.anchor;
                
                var cursorPos = editor.renderer.$cursorLayer.getPixelPosition(cursor, true);
                var anchorPos = editor.renderer.$cursorLayer.getPixelPosition(anchor, true);
                var rect = editor.renderer.scroller.getBoundingClientRect();
                var weightedDistance = function(x, y) {
                    x = x / w;
                    y = y / h - 0.75;
                    return x * x + y * y;
                };
                
                if (e.clientX < rect.left) {
                    mode = "zoom";
                    return;
                }
                
                var diff1 = weightedDistance(
                    e.clientX - rect.left - cursorPos.left,
                    e.clientY - rect.top - cursorPos.top
                );
                var diff2 = weightedDistance(
                    e.clientX - rect.left - anchorPos.left,
                    e.clientY - rect.top - anchorPos.top
                );
                if (diff1 < 3.5 && diff2 < 3.5)
                    mode = diff1 > diff2 ? "cursor" : "anchor";
                    
                if (diff2 < 3.5)
                    mode = "anchor";
                else if (diff1 < 3.5)
                    mode = "cursor";
                else
                    mode = "scroll";
                longTouchTimer = setTimeout(handleLongTap, 450);
            }
            touchStartT = t;
        });

        event.addListener(el, "touchend", function (e) {
            pressed = editor.$mouseHandler.isMousePressed = false;
            if (animationTimer) clearInterval(animationTimer);
            if (mode == "zoom") {
                mode = "";
                animationSteps = 0;
            } else if (longTouchTimer) {
                editor.selection.moveToPosition(pos);
                animationSteps = 0;
                showContextMenu();
            } else if (mode == "scroll") {
                animate();
                e.preventDefault();
                hideContextMenu();
            } else {
                showContextMenu();
            }
            clearTimeout(longTouchTimer);
            longTouchTimer = null;
        });
        event.addListener(el, "touchmove", function (e) {
            if (longTouchTimer) {
                clearTimeout(longTouchTimer);
                longTouchTimer = null;
            }
            var touches = e.touches;
            if (touches.length > 1 || mode == "zoom") return;

            var touchObj = touches[0];

            var wheelX = startX - touchObj.clientX;
            var wheelY = startY - touchObj.clientY;

            if (mode == "wait") {
                if (wheelX * wheelX + wheelY * wheelY > 4)
                    mode = "cursor";
                else
                    return e.preventDefault();
            }

            startX = touchObj.clientX;
            startY = touchObj.clientY;

            e.clientX = touchObj.clientX;
            e.clientY = touchObj.clientY;

            var t = e.timeStamp;
            var dt = t - lastT;
            lastT = t;
            if (mode == "scroll") {
                var mouseEvent = new MouseEvent(e, editor);
                mouseEvent.speed = 1;
                mouseEvent.wheelX = wheelX;
                mouseEvent.wheelY = wheelY;
                if (10 * Math.abs(wheelX) < Math.abs(wheelY)) wheelX = 0;
                if (10 * Math.abs(wheelY) < Math.abs(wheelX)) wheelY = 0;
                if (dt != 0) {
                    vX = wheelX / dt;
                    vY = wheelY / dt;
                }
                editor._emit("mousewheel", mouseEvent);
                if (!mouseEvent.propagationStopped) {
                    vX = vY = 0;
                }
            }
            else {
                var ev = new MouseEvent(e, editor);
                var pos = ev.getDocumentPosition();
                if (mode == "cursor")
                    editor.selection.moveCursorToPosition(pos);
                else if (mode == "anchor")
                    editor.selection.setSelectionAnchor(pos.row, pos.column);
                editor.renderer.scrollCursorIntoView(pos);
                e.preventDefault();
            }
        });

        function animate() {
            animationSteps += 60;
            animationTimer = setInterval(function() {
                if (animationSteps-- <= 0) {
                    clearInterval(animationTimer);
                    animationTimer = null;
                }
                if (Math.abs(vX) < 0.01) vX = 0;
                if (Math.abs(vY) < 0.01) vY = 0;
                if (animationSteps < 20) vX = 0.9 * vX;
                if (animationSteps < 20) vY = 0.9 * vY;
                var oldScrollTop = editor.session.getScrollTop();
                editor.renderer.scrollBy(10 * vX, 10 * vY);
                if (oldScrollTop == editor.session.getScrollTop())
                    animationSteps = 0;
            }, 10);
        }
    };

    });

    ace.define("ace/lib/net",["require","exports","module","ace/lib/dom"], function(require, exports, module) {
    var dom = require("./dom");

    exports.get = function (url, callback) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4) {
                callback(xhr.responseText);
            }
        };
        xhr.send(null);
    };

    exports.loadScript = function(path, callback) {
        var head = dom.getDocumentHead();
        var s = document.createElement('script');

        s.src = path;
        head.appendChild(s);

        s.onload = s.onreadystatechange = function(_, isAbort) {
            if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
                s = s.onload = s.onreadystatechange = null;
                if (!isAbort)
                    callback();
            }
        };
    };
    exports.qualifyURL = function(url) {
        var a = document.createElement('a');
        a.href = url;
        return a.href;
    };

    });

    ace.define("ace/lib/event_emitter",["require","exports","module"], function(require, exports, module) {

    var EventEmitter = {};
    var stopPropagation = function() { this.propagationStopped = true; };
    var preventDefault = function() { this.defaultPrevented = true; };

    EventEmitter._emit =
    EventEmitter._dispatchEvent = function(eventName, e) {
        this._eventRegistry || (this._eventRegistry = {});
        this._defaultHandlers || (this._defaultHandlers = {});

        var listeners = this._eventRegistry[eventName] || [];
        var defaultHandler = this._defaultHandlers[eventName];
        if (!listeners.length && !defaultHandler)
            return;

        if (typeof e != "object" || !e)
            e = {};

        if (!e.type)
            e.type = eventName;
        if (!e.stopPropagation)
            e.stopPropagation = stopPropagation;
        if (!e.preventDefault)
            e.preventDefault = preventDefault;

        listeners = listeners.slice();
        for (var i=0; i<listeners.length; i++) {
            listeners[i](e, this);
            if (e.propagationStopped)
                break;
        }
        
        if (defaultHandler && !e.defaultPrevented)
            return defaultHandler(e, this);
    };


    EventEmitter._signal = function(eventName, e) {
        var listeners = (this._eventRegistry || {})[eventName];
        if (!listeners)
            return;
        listeners = listeners.slice();
        for (var i=0; i<listeners.length; i++)
            listeners[i](e, this);
    };

    EventEmitter.once = function(eventName, callback) {
        var _self = this;
        this.addEventListener(eventName, function newCallback() {
            _self.removeEventListener(eventName, newCallback);
            callback.apply(null, arguments);
        });
        if (!callback) {
            return new Promise(function(resolve) {
                callback = resolve;
            });
        }
    };


    EventEmitter.setDefaultHandler = function(eventName, callback) {
        var handlers = this._defaultHandlers;
        if (!handlers)
            handlers = this._defaultHandlers = {_disabled_: {}};
        
        if (handlers[eventName]) {
            var old = handlers[eventName];
            var disabled = handlers._disabled_[eventName];
            if (!disabled)
                handlers._disabled_[eventName] = disabled = [];
            disabled.push(old);
            var i = disabled.indexOf(callback);
            if (i != -1) 
                disabled.splice(i, 1);
        }
        handlers[eventName] = callback;
    };
    EventEmitter.removeDefaultHandler = function(eventName, callback) {
        var handlers = this._defaultHandlers;
        if (!handlers)
            return;
        var disabled = handlers._disabled_[eventName];
        
        if (handlers[eventName] == callback) {
            if (disabled)
                this.setDefaultHandler(eventName, disabled.pop());
        } else if (disabled) {
            var i = disabled.indexOf(callback);
            if (i != -1)
                disabled.splice(i, 1);
        }
    };

    EventEmitter.on =
    EventEmitter.addEventListener = function(eventName, callback, capturing) {
        this._eventRegistry = this._eventRegistry || {};

        var listeners = this._eventRegistry[eventName];
        if (!listeners)
            listeners = this._eventRegistry[eventName] = [];

        if (listeners.indexOf(callback) == -1)
            listeners[capturing ? "unshift" : "push"](callback);
        return callback;
    };

    EventEmitter.off =
    EventEmitter.removeListener =
    EventEmitter.removeEventListener = function(eventName, callback) {
        this._eventRegistry = this._eventRegistry || {};

        var listeners = this._eventRegistry[eventName];
        if (!listeners)
            return;

        var index = listeners.indexOf(callback);
        if (index !== -1)
            listeners.splice(index, 1);
    };

    EventEmitter.removeAllListeners = function(eventName) {
        if (this._eventRegistry) this._eventRegistry[eventName] = [];
    };

    exports.EventEmitter = EventEmitter;

    });

    ace.define("ace/lib/app_config",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(require, exports, module) {
    "no use strict";

    var oop = require("./oop");
    var EventEmitter = require("./event_emitter").EventEmitter;

    var optionsProvider = {
        setOptions: function(optList) {
            Object.keys(optList).forEach(function(key) {
                this.setOption(key, optList[key]);
            }, this);
        },
        getOptions: function(optionNames) {
            var result = {};
            if (!optionNames) {
                var options = this.$options;
                optionNames = Object.keys(options).filter(function(key) {
                    return !options[key].hidden;
                });
            } else if (!Array.isArray(optionNames)) {
                result = optionNames;
                optionNames = Object.keys(result);
            }
            optionNames.forEach(function(key) {
                result[key] = this.getOption(key);
            }, this);
            return result;
        },
        setOption: function(name, value) {
            if (this["$" + name] === value)
                return;
            var opt = this.$options[name];
            if (!opt) {
                return warn('misspelled option "' + name + '"');
            }
            if (opt.forwardTo)
                return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);

            if (!opt.handlesSet)
                this["$" + name] = value;
            if (opt && opt.set)
                opt.set.call(this, value);
        },
        getOption: function(name) {
            var opt = this.$options[name];
            if (!opt) {
                return warn('misspelled option "' + name + '"');
            }
            if (opt.forwardTo)
                return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
            return opt && opt.get ? opt.get.call(this) : this["$" + name];
        }
    };

    function warn(message) {
        if (typeof console != "undefined" && console.warn)
            console.warn.apply(console, arguments);
    }

    function reportError(msg, data) {
        var e = new Error(msg);
        e.data = data;
        if (typeof console == "object" && console.error)
            console.error(e);
        setTimeout(function() { throw e; });
    }

    var AppConfig = function() {
        this.$defaultOptions = {};
    };

    (function() {
        oop.implement(this, EventEmitter);
        this.defineOptions = function(obj, path, options) {
            if (!obj.$options)
                this.$defaultOptions[path] = obj.$options = {};

            Object.keys(options).forEach(function(key) {
                var opt = options[key];
                if (typeof opt == "string")
                    opt = {forwardTo: opt};

                opt.name || (opt.name = key);
                obj.$options[opt.name] = opt;
                if ("initialValue" in opt)
                    obj["$" + opt.name] = opt.initialValue;
            });
            oop.implement(obj, optionsProvider);

            return this;
        };

        this.resetOptions = function(obj) {
            Object.keys(obj.$options).forEach(function(key) {
                var opt = obj.$options[key];
                if ("value" in opt)
                    obj.setOption(key, opt.value);
            });
        };

        this.setDefaultValue = function(path, name, value) {
            if (!path) {
                for (path in this.$defaultOptions)
                    if (this.$defaultOptions[path][name])
                        break;
                if (!this.$defaultOptions[path][name])
                    return false;
            }
            var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
            if (opts[name]) {
                if (opts.forwardTo)
                    this.setDefaultValue(opts.forwardTo, name, value);
                else
                    opts[name].value = value;
            }
        };

        this.setDefaultValues = function(path, optionHash) {
            Object.keys(optionHash).forEach(function(key) {
                this.setDefaultValue(path, key, optionHash[key]);
            }, this);
        };
        
        this.warn = warn;
        this.reportError = reportError;
        
    }).call(AppConfig.prototype);

    exports.AppConfig = AppConfig;

    });

    ace.define("ace/config",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/lib/net","ace/lib/app_config"], function(require, exports, module) {
    "no use strict";

    var lang = require("./lib/lang");
    var oop = require("./lib/oop");
    var net = require("./lib/net");
    var AppConfig = require("./lib/app_config").AppConfig;

    module.exports = exports = new AppConfig();

    var global = (function() {
        return this || typeof window != "undefined" && window;
    })();

    var options = {
        packaged: false,
        workerPath: null,
        modePath: null,
        themePath: null,
        basePath: "",
        suffix: ".js",
        $moduleUrls: {},
        loadWorkerFromBlob: true,
        sharedPopups: false
    };

    exports.get = function(key) {
        if (!options.hasOwnProperty(key))
            throw new Error("Unknown config key: " + key);

        return options[key];
    };

    exports.set = function(key, value) {
        if (options.hasOwnProperty(key))
            options[key] = value;
        else if (this.setDefaultValue("", key, value) == false)
            throw new Error("Unknown config key: " + key);
    };

    exports.all = function() {
        return lang.copyObject(options);
    };

    exports.$modes = {};
    exports.moduleUrl = function(name, component) {
        if (options.$moduleUrls[name])
            return options.$moduleUrls[name];

        var parts = name.split("/");
        component = component || parts[parts.length - 2] || "";
        var sep = component == "snippets" ? "/" : "-";
        var base = parts[parts.length - 1];
        if (component == "worker" && sep == "-") {
            var re = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
            base = base.replace(re, "");
        }

        if ((!base || base == component) && parts.length > 1)
            base = parts[parts.length - 2];
        var path = options[component + "Path"];
        if (path == null) {
            path = options.basePath;
        } else if (sep == "/") {
            component = sep = "";
        }
        if (path && path.slice(-1) != "/")
            path += "/";
        return path + component + sep + base + this.get("suffix");
    };

    exports.setModuleUrl = function(name, subst) {
        return options.$moduleUrls[name] = subst;
    };

    exports.$loading = {};
    exports.loadModule = function(moduleName, onLoad) {
        var module, moduleType;
        if (Array.isArray(moduleName)) {
            moduleType = moduleName[0];
            moduleName = moduleName[1];
        }

        try {
            module = require(moduleName);
        } catch (e) {}
        if (module && !exports.$loading[moduleName])
            return onLoad && onLoad(module);

        if (!exports.$loading[moduleName])
            exports.$loading[moduleName] = [];

        exports.$loading[moduleName].push(onLoad);

        if (exports.$loading[moduleName].length > 1)
            return;

        var afterLoad = function() {
            require([moduleName], function(module) {
                exports._emit("load.module", {name: moduleName, module: module});
                var listeners = exports.$loading[moduleName];
                exports.$loading[moduleName] = null;
                listeners.forEach(function(onLoad) {
                    onLoad && onLoad(module);
                });
            });
        };

        if (!exports.get("packaged"))
            return afterLoad();
        
        net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);
        reportErrorIfPathIsNotConfigured();
    };

    var reportErrorIfPathIsNotConfigured = function() {
        if (
            !options.basePath && !options.workerPath 
            && !options.modePath && !options.themePath
            && !Object.keys(options.$moduleUrls).length
        ) {
            console.error(
                "Unable to infer path to ace from script src,",
                "use ace.config.set('basePath', 'path') to enable dynamic loading of modes and themes",
                "or with webpack use ace/webpack-resolver"
            );
            reportErrorIfPathIsNotConfigured = function() {};
        }
    };
    init(true);function init(packaged) {

        if (!global || !global.document)
            return;
        
        options.packaged = packaged || require.packaged || module.packaged || (global.define && undefined.packaged);

        var scriptOptions = {};
        var scriptUrl = "";
        var currentScript = (document.currentScript || document._currentScript ); // native or polyfill
        var currentDocument = currentScript && currentScript.ownerDocument || document;
        
        var scripts = currentDocument.getElementsByTagName("script");
        for (var i=0; i<scripts.length; i++) {
            var script = scripts[i];

            var src = script.src || script.getAttribute("src");
            if (!src)
                continue;

            var attributes = script.attributes;
            for (var j=0, l=attributes.length; j < l; j++) {
                var attr = attributes[j];
                if (attr.name.indexOf("data-ace-") === 0) {
                    scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ""))] = attr.value;
                }
            }

            var m = src.match(/^(.*)\/ace(\-\w+)?\.js(\?|$)/);
            if (m)
                scriptUrl = m[1];
        }

        if (scriptUrl) {
            scriptOptions.base = scriptOptions.base || scriptUrl;
            scriptOptions.packaged = true;
        }

        scriptOptions.basePath = scriptOptions.base;
        scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
        scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
        scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
        delete scriptOptions.base;

        for (var key in scriptOptions)
            if (typeof scriptOptions[key] !== "undefined")
                exports.set(key, scriptOptions[key]);
    }

    exports.init = init;

    function deHyphenate(str) {
        return str.replace(/-(.)/g, function(m, m1) { return m1.toUpperCase(); });
    }

    exports.version = "1.4.8";

    });

    ace.define("ace/mouse/mouse_handler",["require","exports","module","ace/lib/event","ace/lib/useragent","ace/mouse/default_handlers","ace/mouse/default_gutter_handler","ace/mouse/mouse_event","ace/mouse/dragdrop_handler","ace/mouse/touch_handler","ace/config"], function(require, exports, module) {

    var event = require("../lib/event");
    var useragent = require("../lib/useragent");
    var DefaultHandlers = require("./default_handlers").DefaultHandlers;
    var DefaultGutterHandler = require("./default_gutter_handler").GutterHandler;
    var MouseEvent = require("./mouse_event").MouseEvent;
    var DragdropHandler = require("./dragdrop_handler").DragdropHandler;
    var addTouchListeners = require("./touch_handler").addTouchListeners;
    var config = require("../config");

    var MouseHandler = function(editor) {
        var _self = this;
        this.editor = editor;

        new DefaultHandlers(this);
        new DefaultGutterHandler(this);
        new DragdropHandler(this);

        var focusEditor = function(e) {
            var windowBlurred = !document.hasFocus || !document.hasFocus()
                || !editor.isFocused() && document.activeElement == (editor.textInput && editor.textInput.getElement());
            if (windowBlurred)
                window.focus();
            editor.focus();
        };

        var mouseTarget = editor.renderer.getMouseEventTarget();
        event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"));
        event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"));
        event.addMultiMouseDownListener([
            mouseTarget,
            editor.renderer.scrollBarV && editor.renderer.scrollBarV.inner,
            editor.renderer.scrollBarH && editor.renderer.scrollBarH.inner,
            editor.textInput && editor.textInput.getElement()
        ].filter(Boolean), [400, 300, 250], this, "onMouseEvent");
        event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"));
        addTouchListeners(editor.container, editor);

        var gutterEl = editor.renderer.$gutter;
        event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"));
        event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"));
        event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"));
        event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"));

        event.addListener(mouseTarget, "mousedown", focusEditor);
        event.addListener(gutterEl, "mousedown", focusEditor);
        if (useragent.isIE && editor.renderer.scrollBarV) {
            event.addListener(editor.renderer.scrollBarV.element, "mousedown", focusEditor);
            event.addListener(editor.renderer.scrollBarH.element, "mousedown", focusEditor);
        }

        editor.on("mousemove", function(e){
            if (_self.state || _self.$dragDelay || !_self.$dragEnabled)
                return;

            var character = editor.renderer.screenToTextCoordinates(e.x, e.y);
            var range = editor.session.selection.getRange();
            var renderer = editor.renderer;

            if (!range.isEmpty() && range.insideStart(character.row, character.column)) {
                renderer.setCursorStyle("default");
            } else {
                renderer.setCursorStyle("");
            }
        });
    };

    (function() {
        this.onMouseEvent = function(name, e) {
            this.editor._emit(name, new MouseEvent(e, this.editor));
        };

        this.onMouseMove = function(name, e) {
            var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
            if (!listeners || !listeners.length)
                return;

            this.editor._emit(name, new MouseEvent(e, this.editor));
        };

        this.onMouseWheel = function(name, e) {
            var mouseEvent = new MouseEvent(e, this.editor);
            mouseEvent.speed = this.$scrollSpeed * 2;
            mouseEvent.wheelX = e.wheelX;
            mouseEvent.wheelY = e.wheelY;

            this.editor._emit(name, mouseEvent);
        };
        
        this.setState = function(state) {
            this.state = state;
        };

        this.captureMouse = function(ev, mouseMoveHandler) {
            this.x = ev.x;
            this.y = ev.y;

            this.isMousePressed = true;
            var editor = this.editor;
            var renderer = this.editor.renderer;
            renderer.$isMousePressed = true;

            var self = this;
            var onMouseMove = function(e) {
                if (!e) return;
                if (useragent.isWebKit && !e.which && self.releaseMouse)
                    return self.releaseMouse();

                self.x = e.clientX;
                self.y = e.clientY;
                mouseMoveHandler && mouseMoveHandler(e);
                self.mouseEvent = new MouseEvent(e, self.editor);
                self.$mouseMoved = true;
            };

            var onCaptureEnd = function(e) {
                editor.off("beforeEndOperation", onOperationEnd);
                clearInterval(timerId);
                onCaptureInterval();
                self[self.state + "End"] && self[self.state + "End"](e);
                self.state = "";
                self.isMousePressed = renderer.$isMousePressed = false;
                if (renderer.$keepTextAreaAtCursor)
                    renderer.$moveTextAreaToCursor();
                self.$onCaptureMouseMove = self.releaseMouse = null;
                e && self.onMouseEvent("mouseup", e);
                editor.endOperation();
            };

            var onCaptureInterval = function() {
                self[self.state] && self[self.state]();
                self.$mouseMoved = false;
            };

            if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
                return setTimeout(function() {onCaptureEnd(ev);});
            }

            var onOperationEnd = function(e) {
                if (!self.releaseMouse) return;
                if (editor.curOp.command.name && editor.curOp.selectionChanged) {
                    self[self.state + "End"] && self[self.state + "End"]();
                    self.state = "";
                    self.releaseMouse();
                }
            };

            editor.on("beforeEndOperation", onOperationEnd);
            editor.startOperation({command: {name: "mouse"}});

            self.$onCaptureMouseMove = onMouseMove;
            self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
            var timerId = setInterval(onCaptureInterval, 20);
        };
        this.releaseMouse = null;
        this.cancelContextMenu = function() {
            var stop = function(e) {
                if (e && e.domEvent && e.domEvent.type != "contextmenu")
                    return;
                this.editor.off("nativecontextmenu", stop);
                if (e && e.domEvent)
                    event.stopEvent(e.domEvent);
            }.bind(this);
            setTimeout(stop, 10);
            this.editor.on("nativecontextmenu", stop);
        };
    }).call(MouseHandler.prototype);

    config.defineOptions(MouseHandler.prototype, "mouseHandler", {
        scrollSpeed: {initialValue: 2},
        dragDelay: {initialValue: (useragent.isMac ? 150 : 0)},
        dragEnabled: {initialValue: true},
        focusTimeout: {initialValue: 0},
        tooltipFollowsMouse: {initialValue: true}
    });


    exports.MouseHandler = MouseHandler;
    });

    ace.define("ace/mouse/fold_handler",["require","exports","module","ace/lib/dom"], function(require, exports, module) {
    var dom = require("../lib/dom");

    function FoldHandler(editor) {

        editor.on("click", function(e) {
            var position = e.getDocumentPosition();
            var session = editor.session;
            var fold = session.getFoldAt(position.row, position.column, 1);
            if (fold) {
                if (e.getAccelKey())
                    session.removeFold(fold);
                else
                    session.expandFold(fold);

                e.stop();
            }
            
            var target = e.domEvent && e.domEvent.target;
            if (target && dom.hasCssClass(target, "ace_inline_button")) {
                if (dom.hasCssClass(target, "ace_toggle_wrap")) {
                    session.setOption("wrap", !session.getUseWrapMode());
                    editor.renderer.scrollCursorIntoView();
                }
            }
        });

        editor.on("gutterclick", function(e) {
            var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

            if (gutterRegion == "foldWidgets") {
                var row = e.getDocumentPosition().row;
                var session = editor.session;
                if (session.foldWidgets && session.foldWidgets[row])
                    editor.session.onFoldWidgetClick(row, e);
                if (!editor.isFocused())
                    editor.focus();
                e.stop();
            }
        });

        editor.on("gutterdblclick", function(e) {
            var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

            if (gutterRegion == "foldWidgets") {
                var row = e.getDocumentPosition().row;
                var session = editor.session;
                var data = session.getParentFoldRangeData(row, true);
                var range = data.range || data.firstRange;

                if (range) {
                    row = range.start.row;
                    var fold = session.getFoldAt(row, session.getLine(row).length, 1);

                    if (fold) {
                        session.removeFold(fold);
                    } else {
                        session.addFold("...", range);
                        editor.renderer.scrollCursorIntoView({row: range.start.row, column: 0});
                    }
                }
                e.stop();
            }
        });
    }

    exports.FoldHandler = FoldHandler;

    });

    ace.define("ace/keyboard/keybinding",["require","exports","module","ace/lib/keys","ace/lib/event"], function(require, exports, module) {

    var keyUtil  = require("../lib/keys");
    var event = require("../lib/event");

    var KeyBinding = function(editor) {
        this.$editor = editor;
        this.$data = {editor: editor};
        this.$handlers = [];
        this.setDefaultHandler(editor.commands);
    };

    (function() {
        this.setDefaultHandler = function(kb) {
            this.removeKeyboardHandler(this.$defaultHandler);
            this.$defaultHandler = kb;
            this.addKeyboardHandler(kb, 0);
        };

        this.setKeyboardHandler = function(kb) {
            var h = this.$handlers;
            if (h[h.length - 1] == kb)
                return;

            while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)
                this.removeKeyboardHandler(h[h.length - 1]);

            this.addKeyboardHandler(kb, 1);
        };

        this.addKeyboardHandler = function(kb, pos) {
            if (!kb)
                return;
            if (typeof kb == "function" && !kb.handleKeyboard)
                kb.handleKeyboard = kb;
            var i = this.$handlers.indexOf(kb);
            if (i != -1)
                this.$handlers.splice(i, 1);

            if (pos == undefined)
                this.$handlers.push(kb);
            else
                this.$handlers.splice(pos, 0, kb);

            if (i == -1 && kb.attach)
                kb.attach(this.$editor);
        };

        this.removeKeyboardHandler = function(kb) {
            var i = this.$handlers.indexOf(kb);
            if (i == -1)
                return false;
            this.$handlers.splice(i, 1);
            kb.detach && kb.detach(this.$editor);
            return true;
        };

        this.getKeyboardHandler = function() {
            return this.$handlers[this.$handlers.length - 1];
        };
        
        this.getStatusText = function() {
            var data = this.$data;
            var editor = data.editor;
            return this.$handlers.map(function(h) {
                return h.getStatusText && h.getStatusText(editor, data) || "";
            }).filter(Boolean).join(" ");
        };

        this.$callKeyboardHandlers = function(hashId, keyString, keyCode, e) {
            var toExecute;
            var success = false;
            var commands = this.$editor.commands;

            for (var i = this.$handlers.length; i--;) {
                toExecute = this.$handlers[i].handleKeyboard(
                    this.$data, hashId, keyString, keyCode, e
                );
                if (!toExecute || !toExecute.command)
                    continue;
                if (toExecute.command == "null") {
                    success = true;
                } else {
                    success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);
                }
                if (success && e && hashId != -1 && 
                    toExecute.passEvent != true && toExecute.command.passEvent != true
                ) {
                    event.stopEvent(e);
                }
                if (success)
                    break;
            }
            
            if (!success && hashId == -1) {
                toExecute = {command: "insertstring"};
                success = commands.exec("insertstring", this.$editor, keyString);
            }
            
            if (success && this.$editor._signal)
                this.$editor._signal("keyboardActivity", toExecute);
            
            return success;
        };

        this.onCommandKey = function(e, hashId, keyCode) {
            var keyString = keyUtil.keyCodeToString(keyCode);
            return this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
        };

        this.onTextInput = function(text) {
            return this.$callKeyboardHandlers(-1, text);
        };

    }).call(KeyBinding.prototype);

    exports.KeyBinding = KeyBinding;
    });

    ace.define("ace/lib/bidiutil",["require","exports","module"], function(require, exports, module) {
    var dir = 0, hiLevel = 0;
    var lastArabic = false, hasUBAT_B = false,  hasUBAT_S = false;

    var impTab_LTR = [	[	0,		3,		0,		1,		0,		0,		0	],	[	0,		3,		0,		1,		2,		2,		0	],	[	0,		3,		0,		0x11,		2,		0,		1	],	[	0,		3,		5,		5,		4,		1,		0	],	[	0,		3,		0x15,		0x15,		4,		0,		1	],	[	0,		3,		5,		5,		4,		2,		0	]
    ];

    var impTab_RTL = [	[	2,		0,		1,		1,		0,		1,		0	],	[	2,		0,		1,		1,		0,		2,		0	],	[	2,		0,		2,		1,		3,		2,		0	],	[	2,		0,		2,		0x21,		3,		1,		1	]
    ];

    var LTR = 0, RTL = 1;

    var L = 0;
    var R = 1;
    var EN = 2;
    var AN = 3;
    var ON = 4;
    var B = 5;
    var S = 6;
    var AL = 7;
    var WS = 8;
    var CS = 9;
    var ES = 10;
    var ET = 11;
    var NSM = 12;
    var LRE = 13;
    var RLE = 14;
    var PDF = 15;
    var LRO = 16;
    var RLO = 17;
    var BN = 18;

    var UnicodeTBL00 = [
    BN,BN,BN,BN,BN,BN,BN,BN,BN,S,B,S,WS,B,BN,BN,
    BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,B,B,B,S,
    WS,ON,ON,ET,ET,ET,ON,ON,ON,ON,ON,ES,CS,ES,CS,CS,
    EN,EN,EN,EN,EN,EN,EN,EN,EN,EN,CS,ON,ON,ON,ON,ON,
    ON,L,L,L,L,L,L,L,L,L,L,L,L,L,L,L,
    L,L,L,L,L,L,L,L,L,L,L,ON,ON,ON,ON,ON,
    ON,L,L,L,L,L,L,L,L,L,L,L,L,L,L,L,
    L,L,L,L,L,L,L,L,L,L,L,ON,ON,ON,ON,BN,
    BN,BN,BN,BN,BN,B,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,
    BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,
    CS,ON,ET,ET,ET,ET,ON,ON,ON,ON,L,ON,ON,BN,ON,ON,
    ET,ET,EN,EN,ON,L,ON,ON,ON,EN,L,ON,ON,ON,ON,ON
    ];

    var UnicodeTBL20 = [
    WS,WS,WS,WS,WS,WS,WS,WS,WS,WS,WS,BN,BN,BN,L,R	,
    ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,
    ON,ON,ON,ON,ON,ON,ON,ON,WS,B,LRE,RLE,PDF,LRO,RLO,CS,
    ET,ET,ET,ET,ET,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,
    ON,ON,ON,ON,CS,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,
    ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,WS
    ];

    function _computeLevels(chars, levels, len, charTypes) {
    	var impTab = dir ? impTab_RTL : impTab_LTR
    		, prevState = null, newClass = null, newLevel = null, newState = 0
    		, action = null, cond = null, condPos = -1, i = null, ix = null, classes = [];

    	if (!charTypes) {
    		for (i = 0, charTypes = []; i < len; i++) {
    			charTypes[i] = _getCharacterType(chars[i]);
    		}
    	}
    	hiLevel = dir;
    	lastArabic = false;
    	hasUBAT_B = false;
    	hasUBAT_S = false;
    	for (ix = 0; ix < len; ix++){
    		prevState = newState;
    		classes[ix] = newClass = _getCharClass(chars, charTypes, classes, ix);
    		newState = impTab[prevState][newClass];
    		action = newState & 0xF0;
    		newState &= 0x0F;
    		levels[ix] = newLevel = impTab[newState][5];
    		if (action > 0){
    			if (action == 0x10){
    				for(i = condPos; i < ix; i++){
    					levels[i] = 1;
    				}
    				condPos = -1;
    			} else {
    				condPos = -1;
    			}
    		}
    		cond = impTab[newState][6];
    		if (cond){
    			if(condPos == -1){
    				condPos = ix;
    			}
    		}else{
    			if (condPos > -1){
    				for(i = condPos; i < ix; i++){
    					levels[i] = newLevel;
    				}
    				condPos = -1;
    			}
    		}
    		if (charTypes[ix] == B){
    			levels[ix] = 0;
    		}
    		hiLevel |= newLevel;
    	}
    	if (hasUBAT_S){
    		for(i = 0; i < len; i++){
    			if(charTypes[i] == S){
    				levels[i] = dir;
    				for(var j = i - 1; j >= 0; j--){
    					if(charTypes[j] == WS){
    						levels[j] = dir;
    					}else{
    						break;
    					}
    				}
    			}
    		}
    	}
    }

    function _invertLevel(lev, levels, _array) {
    	if (hiLevel < lev){
    		return;
    	}
    	if (lev == 1 && dir == RTL && !hasUBAT_B){
    		_array.reverse();
    		return;
    	}
    	var len = _array.length, start = 0, end, lo, hi, tmp;
    	while(start < len){
    		if (levels[start] >= lev){
    			end = start + 1;
    		while(end < len && levels[end] >= lev){
    			end++;
    		}
    		for(lo = start, hi = end - 1 ; lo < hi; lo++, hi--){
    			tmp = _array[lo];
    			_array[lo] = _array[hi];
    			_array[hi] = tmp;
    		}
    		start = end;
    	}
    	start++;
    	}
    }

    function _getCharClass(chars, types, classes, ix) {			
    	var cType = types[ix], wType, nType, len, i;
    	switch(cType){
    		case L:
    		case R:
    			lastArabic = false;
    		case ON:
    		case AN:
    			return cType;
    		case EN:
    			return lastArabic ? AN : EN;
    		case AL:
    			lastArabic = true;
    			return R;
    		case WS:
    			return ON;
    		case CS:
    			if (ix < 1 || (ix + 1) >= types.length ||
    				((wType = classes[ix - 1]) != EN && wType != AN) ||
    				((nType = types[ix + 1]) != EN && nType != AN)){
    				return ON;
    			}
    			if (lastArabic){nType = AN;}
    			return nType == wType ? nType : ON;
    		case ES:
    			wType = ix > 0 ? classes[ix - 1] : B;
    			if (wType == EN && (ix + 1) < types.length && types[ix + 1] == EN){
    				return EN;
    			}
    			return ON;
    		case ET:
    			if (ix > 0 && classes[ix - 1] == EN){
    				return EN;
    			}
    			if (lastArabic){
    				return ON;
    			}
    			i = ix + 1;
    			len = types.length;
    			while (i < len && types[i] == ET){
    				i++;
    			}
    			if (i < len && types[i] == EN){
    				return EN;
    			}
    			return ON;
    		case NSM:
    			len = types.length;
    			i = ix + 1;
    			while (i < len && types[i] == NSM){
    				i++;
    			}
    			if (i < len){
    				var c = chars[ix], rtlCandidate = (c >= 0x0591 && c <= 0x08FF) || c == 0xFB1E;
    				
    				wType = types[i];
    				if (rtlCandidate && (wType == R || wType == AL)){
    					return R;
    				}
    			}

    			if (ix < 1 || (wType = types[ix - 1]) == B){
    				return ON;
    			}
    			return classes[ix - 1];
    		case B:
    			lastArabic = false;
    			hasUBAT_B = true;
    			return dir;
    		case S:
    			hasUBAT_S = true;
    			return ON;
    		case LRE:
    		case RLE:
    		case LRO:
    		case RLO:
    		case PDF:
    			lastArabic = false;
    		case BN:
    			return ON;
    	}
    }

    function _getCharacterType( ch ) {		
    	var uc = ch.charCodeAt(0), hi = uc >> 8;
    	
    	if (hi == 0) {		
    		return ((uc > 0x00BF) ? L : UnicodeTBL00[uc]);
    	} else if (hi == 5) {
    		return (/[\u0591-\u05f4]/.test(ch) ? R : L);
    	} else if (hi == 6) {
    		if (/[\u0610-\u061a\u064b-\u065f\u06d6-\u06e4\u06e7-\u06ed]/.test(ch))
    			return NSM;
    		else if (/[\u0660-\u0669\u066b-\u066c]/.test(ch))
    			return AN;
    		else if (uc == 0x066A)
    			return ET;
    		else if (/[\u06f0-\u06f9]/.test(ch))
    			return EN;			
    		else
    			return AL;
    	} else if (hi == 0x20 && uc <= 0x205F) {
    		return UnicodeTBL20[uc & 0xFF];
    	} else if (hi == 0xFE) {
    		return (uc >= 0xFE70 ? AL : ON);
    	}		
    	return ON;	
    }
    exports.L = L;
    exports.R = R;
    exports.EN = EN;
    exports.ON_R = 3;
    exports.AN = 4;
    exports.R_H = 5;
    exports.B = 6;
    exports.RLE = 7;

    exports.DOT = "\xB7";
    exports.doBidiReorder = function(text, textCharTypes, isRtl) {
    	if (text.length < 2)
    		return {};
    		
    	var chars = text.split(""), logicalFromVisual = new Array(chars.length),
    		bidiLevels = new Array(chars.length), levels = []; 

    	dir = isRtl ? RTL : LTR;

    	_computeLevels(chars, levels, chars.length, textCharTypes);

    	for (var i = 0; i < logicalFromVisual.length; logicalFromVisual[i] = i, i++);

    	_invertLevel(2, levels, logicalFromVisual);
    	_invertLevel(1, levels, logicalFromVisual);

    	for (var i = 0; i < logicalFromVisual.length - 1; i++) { //fix levels to reflect character width
    		if (textCharTypes[i] === AN) {
    			levels[i] = exports.AN;
    		} else if (levels[i] === R && ((textCharTypes[i] > AL && textCharTypes[i] < LRE) 
    			|| textCharTypes[i] === ON || textCharTypes[i] === BN)) {
    			levels[i] = exports.ON_R;
    		} else if ((i > 0 && chars[i - 1] === '\u0644') && /\u0622|\u0623|\u0625|\u0627/.test(chars[i])) {
    			levels[i - 1] = levels[i] = exports.R_H;
    			i++;
    		}
    	}
    	if (chars[chars.length - 1] === exports.DOT)
    		levels[chars.length - 1] = exports.B;
    				
    	if (chars[0] === '\u202B')
    		levels[0] = exports.RLE;
    				
    	for (var i = 0; i < logicalFromVisual.length; i++) {
    		bidiLevels[i] = levels[logicalFromVisual[i]];
    	}

    	return {'logicalFromVisual': logicalFromVisual, 'bidiLevels': bidiLevels};
    };
    exports.hasBidiCharacters = function(text, textCharTypes){
    	var ret = false;
    	for (var i = 0; i < text.length; i++){
    		textCharTypes[i] = _getCharacterType(text.charAt(i));
    		if (!ret && (textCharTypes[i] == R || textCharTypes[i] == AL || textCharTypes[i] == AN))
    			ret = true;
    	}
    	return ret;
    };	
    exports.getVisualFromLogicalIdx = function(logIdx, rowMap) {
    	for (var i = 0; i < rowMap.logicalFromVisual.length; i++) {
    		if (rowMap.logicalFromVisual[i] == logIdx)
    			return i;
    	}
    	return 0;
    };

    });

    ace.define("ace/bidihandler",["require","exports","module","ace/lib/bidiutil","ace/lib/lang"], function(require, exports, module) {

    var bidiUtil = require("./lib/bidiutil");
    var lang = require("./lib/lang");
    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\u202B]/;
    var BidiHandler = function(session) {
        this.session = session;
        this.bidiMap = {};
        this.currentRow = null;
        this.bidiUtil = bidiUtil;
        this.charWidths = [];
        this.EOL = "\xAC";
        this.showInvisibles = true;
        this.isRtlDir = false;
        this.$isRtl = false;
        this.line = "";
        this.wrapIndent = 0;
        this.EOF = "\xB6";
        this.RLE = "\u202B";
        this.contentWidth = 0;
        this.fontMetrics = null;
        this.rtlLineOffset = 0;
        this.wrapOffset = 0;
        this.isMoveLeftOperation = false;
        this.seenBidi = bidiRE.test(session.getValue());
    };

    (function() {
        this.isBidiRow = function(screenRow, docRow, splitIndex) {
            if (!this.seenBidi)
                return false;
            if (screenRow !== this.currentRow) {
                this.currentRow = screenRow;
                this.updateRowLine(docRow, splitIndex);
                this.updateBidiMap();
            }
            return this.bidiMap.bidiLevels;
        };

        this.onChange = function(delta) {
            if (!this.seenBidi) {
                if (delta.action == "insert" && bidiRE.test(delta.lines.join("\n"))) {
                    this.seenBidi = true;
                    this.currentRow = null;
                }
            } 
            else {
                this.currentRow = null;
            }
        };

        this.getDocumentRow = function() {
            var docRow = 0;
            var rowCache = this.session.$screenRowCache;
            if (rowCache.length) {
                var index = this.session.$getRowCacheIndex(rowCache, this.currentRow);
                if (index >= 0)
                    docRow = this.session.$docRowCache[index];
            }

            return docRow;
        };

        this.getSplitIndex = function() {
            var splitIndex = 0;
            var rowCache = this.session.$screenRowCache;
            if (rowCache.length) {
                var currentIndex, prevIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow);
                while (this.currentRow - splitIndex > 0) {
                    currentIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow - splitIndex - 1);
                    if (currentIndex !== prevIndex)
                        break;

                    prevIndex = currentIndex;
                    splitIndex++;
                }
            } else {
                splitIndex = this.currentRow;
            }

            return splitIndex;
        };

        this.updateRowLine = function(docRow, splitIndex) {
            if (docRow === undefined)
                docRow = this.getDocumentRow();
                
            var isLastRow = (docRow === this.session.getLength() - 1),
                endOfLine = isLastRow ? this.EOF : this.EOL;

            this.wrapIndent = 0;
            this.line = this.session.getLine(docRow);
            this.isRtlDir = this.$isRtl || this.line.charAt(0) === this.RLE;
            if (this.session.$useWrapMode) {
                var splits = this.session.$wrapData[docRow];
                if (splits) {
                    if (splitIndex === undefined)
                        splitIndex = this.getSplitIndex();

                    if(splitIndex > 0 && splits.length) {
                        this.wrapIndent = splits.indent;
                        this.wrapOffset = this.wrapIndent * this.charWidths[bidiUtil.L];
                        this.line = (splitIndex < splits.length) ?
                            this.line.substring(splits[splitIndex - 1], splits[splitIndex]) :
                                this.line.substring(splits[splits.length - 1]);
                    } else {
                        this.line = this.line.substring(0, splits[splitIndex]);
                    }
                }
                if (splitIndex == splits.length)
                    this.line += (this.showInvisibles) ? endOfLine : bidiUtil.DOT;
            } else {
                this.line += this.showInvisibles ? endOfLine : bidiUtil.DOT;
            }
            var session = this.session, shift = 0, size;
            this.line = this.line.replace(/\t|[\u1100-\u2029, \u202F-\uFFE6]/g, function(ch, i){
                if (ch === '\t' || session.isFullWidth(ch.charCodeAt(0))) {
                    size = (ch === '\t') ? session.getScreenTabSize(i + shift) : 2;
                    shift += size - 1;
                    return lang.stringRepeat(bidiUtil.DOT, size);
                }
                return ch;
            });

            if (this.isRtlDir) {
                this.fontMetrics.$main.textContent = (this.line.charAt(this.line.length - 1) == bidiUtil.DOT) ? this.line.substr(0, this.line.length - 1) : this.line;
                this.rtlLineOffset = this.contentWidth - this.fontMetrics.$main.getBoundingClientRect().width;
            }
        };
        
        this.updateBidiMap = function() {
            var textCharTypes = [];
            if (bidiUtil.hasBidiCharacters(this.line, textCharTypes) || this.isRtlDir) {
                 this.bidiMap = bidiUtil.doBidiReorder(this.line, textCharTypes, this.isRtlDir);
            } else {
                this.bidiMap = {};
            }
        };
        this.markAsDirty = function() {
            this.currentRow = null;
        };
        this.updateCharacterWidths = function(fontMetrics) {
            if (this.characterWidth === fontMetrics.$characterSize.width)
                return;

            this.fontMetrics = fontMetrics;
            var characterWidth = this.characterWidth = fontMetrics.$characterSize.width;
            var bidiCharWidth = fontMetrics.$measureCharWidth("\u05d4");

            this.charWidths[bidiUtil.L] = this.charWidths[bidiUtil.EN] = this.charWidths[bidiUtil.ON_R] = characterWidth;
            this.charWidths[bidiUtil.R] = this.charWidths[bidiUtil.AN] = bidiCharWidth;
            this.charWidths[bidiUtil.R_H] = bidiCharWidth * 0.45;
            this.charWidths[bidiUtil.B] = this.charWidths[bidiUtil.RLE] = 0;

            this.currentRow = null;
        };

        this.setShowInvisibles = function(showInvisibles) {
            this.showInvisibles = showInvisibles;
            this.currentRow = null;
        };

        this.setEolChar = function(eolChar) {
            this.EOL = eolChar; 
        };

        this.setContentWidth = function(width) {
            this.contentWidth = width;
        };

        this.isRtlLine = function(row) {
            if (this.$isRtl) return true;
            if (row != undefined)
                return (this.session.getLine(row).charAt(0) == this.RLE);
            else
                return this.isRtlDir; 
        };

        this.setRtlDirection = function(editor, isRtlDir) {
            var cursor = editor.getCursorPosition(); 
            for (var row = editor.selection.getSelectionAnchor().row; row <= cursor.row; row++) {
                if (!isRtlDir && editor.session.getLine(row).charAt(0) === editor.session.$bidiHandler.RLE)
                    editor.session.doc.removeInLine(row, 0, 1);
                else if (isRtlDir && editor.session.getLine(row).charAt(0) !== editor.session.$bidiHandler.RLE)
                    editor.session.doc.insert({column: 0, row: row}, editor.session.$bidiHandler.RLE);
            }
        };
        this.getPosLeft = function(col) {
            col -= this.wrapIndent;
            var leftBoundary = (this.line.charAt(0) === this.RLE) ? 1 : 0;
            var logicalIdx = (col > leftBoundary) ? (this.session.getOverwrite() ? col : col - 1) : leftBoundary;
            var visualIdx = bidiUtil.getVisualFromLogicalIdx(logicalIdx, this.bidiMap),
                levels = this.bidiMap.bidiLevels, left = 0;

            if (!this.session.getOverwrite() && col <= leftBoundary && levels[visualIdx] % 2 !== 0)
                visualIdx++;
                
            for (var i = 0; i < visualIdx; i++) {
                left += this.charWidths[levels[i]];
            }

            if (!this.session.getOverwrite() && (col > leftBoundary) && (levels[visualIdx] % 2 === 0))
                left += this.charWidths[levels[visualIdx]];

            if (this.wrapIndent)
                left += this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;

            if (this.isRtlDir)
                left += this.rtlLineOffset;

            return left;
        };
        this.getSelections = function(startCol, endCol) {
            var map = this.bidiMap, levels = map.bidiLevels, level, selections = [], offset = 0,
                selColMin = Math.min(startCol, endCol) - this.wrapIndent, selColMax = Math.max(startCol, endCol) - this.wrapIndent,
                    isSelected = false, isSelectedPrev = false, selectionStart = 0;
                
            if (this.wrapIndent)
                offset += this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;

            for (var logIdx, visIdx = 0; visIdx < levels.length; visIdx++) {
                logIdx = map.logicalFromVisual[visIdx];
                level = levels[visIdx];
                isSelected = (logIdx >= selColMin) && (logIdx < selColMax);
                if (isSelected && !isSelectedPrev) {
                    selectionStart = offset;
                } else if (!isSelected && isSelectedPrev) {
                    selections.push({left: selectionStart, width: offset - selectionStart});
                }
                offset += this.charWidths[level];
                isSelectedPrev = isSelected;
            }

            if (isSelected && (visIdx === levels.length)) {
                selections.push({left: selectionStart, width: offset - selectionStart});
            }

            if(this.isRtlDir) {
                for (var i = 0; i < selections.length; i++) {
                    selections[i].left += this.rtlLineOffset;
                }
            }
            return selections;
        };
        this.offsetToCol = function(posX) {
            if(this.isRtlDir)
                posX -= this.rtlLineOffset;

            var logicalIdx = 0, posX = Math.max(posX, 0),
                offset = 0, visualIdx = 0, levels = this.bidiMap.bidiLevels,
                    charWidth = this.charWidths[levels[visualIdx]];

            if (this.wrapIndent)
               posX -= this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;
        
            while(posX > offset + charWidth/2) {
                offset += charWidth;
                if(visualIdx === levels.length - 1) {
                    charWidth = 0;
                    break;
                }
                charWidth = this.charWidths[levels[++visualIdx]];
            }
        
            if (visualIdx > 0 && (levels[visualIdx - 1] % 2 !== 0) && (levels[visualIdx] % 2 === 0)){
                if(posX < offset)
                    visualIdx--;
                logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];

            } else if (visualIdx > 0 && (levels[visualIdx - 1] % 2 === 0) && (levels[visualIdx] % 2 !== 0)){
                logicalIdx = 1 + ((posX > offset) ? this.bidiMap.logicalFromVisual[visualIdx]
                        : this.bidiMap.logicalFromVisual[visualIdx - 1]);

            } else if ((this.isRtlDir && visualIdx === levels.length - 1 && charWidth === 0 && (levels[visualIdx - 1] % 2 === 0))
                    || (!this.isRtlDir && visualIdx === 0 && (levels[visualIdx] % 2 !== 0))){
                logicalIdx = 1 + this.bidiMap.logicalFromVisual[visualIdx];
            } else {
                if (visualIdx > 0 && (levels[visualIdx - 1] % 2 !== 0) && charWidth !== 0)
                    visualIdx--;
                logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
            }

            if (logicalIdx === 0 && this.isRtlDir)
                logicalIdx++;

            return (logicalIdx + this.wrapIndent);
        };

    }).call(BidiHandler.prototype);

    exports.BidiHandler = BidiHandler;
    });

    ace.define("ace/selection",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/lib/event_emitter","ace/range"], function(require, exports, module) {

    var oop = require("./lib/oop");
    var lang = require("./lib/lang");
    var EventEmitter = require("./lib/event_emitter").EventEmitter;
    var Range = require("./range").Range;
    var Selection = function(session) {
        this.session = session;
        this.doc = session.getDocument();

        this.clearSelection();
        this.cursor = this.lead = this.doc.createAnchor(0, 0);
        this.anchor = this.doc.createAnchor(0, 0);
        this.$silent = false;

        var self = this;
        this.cursor.on("change", function(e) {
            self.$cursorChanged = true;
            if (!self.$silent)
                self._emit("changeCursor");
            if (!self.$isEmpty && !self.$silent)
                self._emit("changeSelection");
            if (!self.$keepDesiredColumnOnChange && e.old.column != e.value.column)
                self.$desiredColumn = null;
        });

        this.anchor.on("change", function() {
            self.$anchorChanged = true;
            if (!self.$isEmpty && !self.$silent)
                self._emit("changeSelection");
        });
    };

    (function() {

        oop.implement(this, EventEmitter);
        this.isEmpty = function() {
            return this.$isEmpty || (
                this.anchor.row == this.lead.row &&
                this.anchor.column == this.lead.column
            );
        };
        this.isMultiLine = function() {
            return !this.$isEmpty && this.anchor.row != this.cursor.row;
        };
        this.getCursor = function() {
            return this.lead.getPosition();
        };
        this.setSelectionAnchor = function(row, column) {
            this.$isEmpty = false;
            this.anchor.setPosition(row, column);
        };
        this.getAnchor = 
        this.getSelectionAnchor = function() {
            if (this.$isEmpty)
                return this.getSelectionLead();
            
            return this.anchor.getPosition();
        };
        this.getSelectionLead = function() {
            return this.lead.getPosition();
        };
        this.isBackwards = function() {
            var anchor = this.anchor;
            var lead = this.lead;
            return (anchor.row > lead.row || (anchor.row == lead.row && anchor.column > lead.column));
        };
        this.getRange = function() {
            var anchor = this.anchor;
            var lead = this.lead;

            if (this.$isEmpty)
                return Range.fromPoints(lead, lead);

            return this.isBackwards()
                ? Range.fromPoints(lead, anchor)
                : Range.fromPoints(anchor, lead);
        };
        this.clearSelection = function() {
            if (!this.$isEmpty) {
                this.$isEmpty = true;
                this._emit("changeSelection");
            }
        };
        this.selectAll = function() {
            this.$setSelection(0, 0, Number.MAX_VALUE, Number.MAX_VALUE);
        };
        this.setRange =
        this.setSelectionRange = function(range, reverse) {
            var start = reverse ? range.end : range.start;
            var end = reverse ? range.start : range.end;
            this.$setSelection(start.row, start.column, end.row, end.column);
        };

        this.$setSelection = function(anchorRow, anchorColumn, cursorRow, cursorColumn) {
            if (this.$silent)
                return;
            var wasEmpty = this.$isEmpty;
            var wasMultiselect = this.inMultiSelectMode;
            this.$silent = true;
            this.$cursorChanged = this.$anchorChanged = false;
            this.anchor.setPosition(anchorRow, anchorColumn);
            this.cursor.setPosition(cursorRow, cursorColumn);
            this.$isEmpty = !Range.comparePoints(this.anchor, this.cursor);
            this.$silent = false;
            if (this.$cursorChanged)
                this._emit("changeCursor");
            if (this.$cursorChanged || this.$anchorChanged || wasEmpty != this.$isEmpty || wasMultiselect)
                this._emit("changeSelection");
        };

        this.$moveSelection = function(mover) {
            var lead = this.lead;
            if (this.$isEmpty)
                this.setSelectionAnchor(lead.row, lead.column);

            mover.call(this);
        };
        this.selectTo = function(row, column) {
            this.$moveSelection(function() {
                this.moveCursorTo(row, column);
            });
        };
        this.selectToPosition = function(pos) {
            this.$moveSelection(function() {
                this.moveCursorToPosition(pos);
            });
        };
        this.moveTo = function(row, column) {
            this.clearSelection();
            this.moveCursorTo(row, column);
        };
        this.moveToPosition = function(pos) {
            this.clearSelection();
            this.moveCursorToPosition(pos);
        };
        this.selectUp = function() {
            this.$moveSelection(this.moveCursorUp);
        };
        this.selectDown = function() {
            this.$moveSelection(this.moveCursorDown);
        };
        this.selectRight = function() {
            this.$moveSelection(this.moveCursorRight);
        };
        this.selectLeft = function() {
            this.$moveSelection(this.moveCursorLeft);
        };
        this.selectLineStart = function() {
            this.$moveSelection(this.moveCursorLineStart);
        };
        this.selectLineEnd = function() {
            this.$moveSelection(this.moveCursorLineEnd);
        };
        this.selectFileEnd = function() {
            this.$moveSelection(this.moveCursorFileEnd);
        };
        this.selectFileStart = function() {
            this.$moveSelection(this.moveCursorFileStart);
        };
        this.selectWordRight = function() {
            this.$moveSelection(this.moveCursorWordRight);
        };
        this.selectWordLeft = function() {
            this.$moveSelection(this.moveCursorWordLeft);
        };
        this.getWordRange = function(row, column) {
            if (typeof column == "undefined") {
                var cursor = row || this.lead;
                row = cursor.row;
                column = cursor.column;
            }
            return this.session.getWordRange(row, column);
        };
        this.selectWord = function() {
            this.setSelectionRange(this.getWordRange());
        };
        this.selectAWord = function() {
            var cursor = this.getCursor();
            var range = this.session.getAWordRange(cursor.row, cursor.column);
            this.setSelectionRange(range);
        };

        this.getLineRange = function(row, excludeLastChar) {
            var rowStart = typeof row == "number" ? row : this.lead.row;
            var rowEnd;

            var foldLine = this.session.getFoldLine(rowStart);
            if (foldLine) {
                rowStart = foldLine.start.row;
                rowEnd = foldLine.end.row;
            } else {
                rowEnd = rowStart;
            }
            if (excludeLastChar === true)
                return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
            else
                return new Range(rowStart, 0, rowEnd + 1, 0);
        };
        this.selectLine = function() {
            this.setSelectionRange(this.getLineRange());
        };
        this.moveCursorUp = function() {
            this.moveCursorBy(-1, 0);
        };
        this.moveCursorDown = function() {
            this.moveCursorBy(1, 0);
        };
        this.wouldMoveIntoSoftTab = function(cursor, tabSize, direction) {
            var start = cursor.column;
            var end = cursor.column + tabSize;

            if (direction < 0) {
                start = cursor.column - tabSize;
                end = cursor.column;
            }
            return this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(start, end).split(" ").length-1 == tabSize;
        };
        this.moveCursorLeft = function() {
            var cursor = this.lead.getPosition(),
                fold;

            if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
                this.moveCursorTo(fold.start.row, fold.start.column);
            } else if (cursor.column === 0) {
                if (cursor.row > 0) {
                    this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
                }
            }
            else {
                var tabSize = this.session.getTabSize();
                if (this.wouldMoveIntoSoftTab(cursor, tabSize, -1) && !this.session.getNavigateWithinSoftTabs()) {
                    this.moveCursorBy(0, -tabSize);
                } else {
                    this.moveCursorBy(0, -1);
                }
            }
        };
        this.moveCursorRight = function() {
            var cursor = this.lead.getPosition(),
                fold;
            if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
                this.moveCursorTo(fold.end.row, fold.end.column);
            }
            else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
                if (this.lead.row < this.doc.getLength() - 1) {
                    this.moveCursorTo(this.lead.row + 1, 0);
                }
            }
            else {
                var tabSize = this.session.getTabSize();
                var cursor = this.lead;
                if (this.wouldMoveIntoSoftTab(cursor, tabSize, 1) && !this.session.getNavigateWithinSoftTabs()) {
                    this.moveCursorBy(0, tabSize);
                } else {
                    this.moveCursorBy(0, 1);
                }
            }
        };
        this.moveCursorLineStart = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var screenRow = this.session.documentToScreenRow(row, column);
            var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
            var beforeCursor = this.session.getDisplayLine(
                row, null, firstColumnPosition.row,
                firstColumnPosition.column
            );

            var leadingSpace = beforeCursor.match(/^\s*/);
            if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)
                firstColumnPosition.column += leadingSpace[0].length;
            this.moveCursorToPosition(firstColumnPosition);
        };
        this.moveCursorLineEnd = function() {
            var lead = this.lead;
            var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
            if (this.lead.column == lineEnd.column) {
                var line = this.session.getLine(lineEnd.row);
                if (lineEnd.column == line.length) {
                    var textEnd = line.search(/\s+$/);
                    if (textEnd > 0)
                        lineEnd.column = textEnd;
                }
            }

            this.moveCursorTo(lineEnd.row, lineEnd.column);
        };
        this.moveCursorFileEnd = function() {
            var row = this.doc.getLength() - 1;
            var column = this.doc.getLine(row).length;
            this.moveCursorTo(row, column);
        };
        this.moveCursorFileStart = function() {
            this.moveCursorTo(0, 0);
        };
        this.moveCursorLongWordRight = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var line = this.doc.getLine(row);
            var rightOfCursor = line.substring(column);

            this.session.nonTokenRe.lastIndex = 0;
            this.session.tokenRe.lastIndex = 0;
            var fold = this.session.getFoldAt(row, column, 1);
            if (fold) {
                this.moveCursorTo(fold.end.row, fold.end.column);
                return;
            }
            if (this.session.nonTokenRe.exec(rightOfCursor)) {
                column += this.session.nonTokenRe.lastIndex;
                this.session.nonTokenRe.lastIndex = 0;
                rightOfCursor = line.substring(column);
            }
            if (column >= line.length) {
                this.moveCursorTo(row, line.length);
                this.moveCursorRight();
                if (row < this.doc.getLength() - 1)
                    this.moveCursorWordRight();
                return;
            }
            if (this.session.tokenRe.exec(rightOfCursor)) {
                column += this.session.tokenRe.lastIndex;
                this.session.tokenRe.lastIndex = 0;
            }

            this.moveCursorTo(row, column);
        };
        this.moveCursorLongWordLeft = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var fold;
            if (fold = this.session.getFoldAt(row, column, -1)) {
                this.moveCursorTo(fold.start.row, fold.start.column);
                return;
            }

            var str = this.session.getFoldStringAt(row, column, -1);
            if (str == null) {
                str = this.doc.getLine(row).substring(0, column);
            }

            var leftOfCursor = lang.stringReverse(str);
            this.session.nonTokenRe.lastIndex = 0;
            this.session.tokenRe.lastIndex = 0;
            if (this.session.nonTokenRe.exec(leftOfCursor)) {
                column -= this.session.nonTokenRe.lastIndex;
                leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
                this.session.nonTokenRe.lastIndex = 0;
            }
            if (column <= 0) {
                this.moveCursorTo(row, 0);
                this.moveCursorLeft();
                if (row > 0)
                    this.moveCursorWordLeft();
                return;
            }
            if (this.session.tokenRe.exec(leftOfCursor)) {
                column -= this.session.tokenRe.lastIndex;
                this.session.tokenRe.lastIndex = 0;
            }

            this.moveCursorTo(row, column);
        };

        this.$shortWordEndIndex = function(rightOfCursor) {
            var index = 0, ch;
            var whitespaceRe = /\s/;
            var tokenRe = this.session.tokenRe;

            tokenRe.lastIndex = 0;
            if (this.session.tokenRe.exec(rightOfCursor)) {
                index = this.session.tokenRe.lastIndex;
            } else {
                while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                    index ++;

                if (index < 1) {
                    tokenRe.lastIndex = 0;
                     while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {
                        tokenRe.lastIndex = 0;
                        index ++;
                        if (whitespaceRe.test(ch)) {
                            if (index > 2) {
                                index--;
                                break;
                            } else {
                                while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                                    index ++;
                                if (index > 2)
                                    break;
                            }
                        }
                    }
                }
            }
            tokenRe.lastIndex = 0;

            return index;
        };

        this.moveCursorShortWordRight = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var line = this.doc.getLine(row);
            var rightOfCursor = line.substring(column);

            var fold = this.session.getFoldAt(row, column, 1);
            if (fold)
                return this.moveCursorTo(fold.end.row, fold.end.column);

            if (column == line.length) {
                var l = this.doc.getLength();
                do {
                    row++;
                    rightOfCursor = this.doc.getLine(row);
                } while (row < l && /^\s*$/.test(rightOfCursor));

                if (!/^\s+/.test(rightOfCursor))
                    rightOfCursor = "";
                column = 0;
            }

            var index = this.$shortWordEndIndex(rightOfCursor);

            this.moveCursorTo(row, column + index);
        };

        this.moveCursorShortWordLeft = function() {
            var row = this.lead.row;
            var column = this.lead.column;

            var fold;
            if (fold = this.session.getFoldAt(row, column, -1))
                return this.moveCursorTo(fold.start.row, fold.start.column);

            var line = this.session.getLine(row).substring(0, column);
            if (column === 0) {
                do {
                    row--;
                    line = this.doc.getLine(row);
                } while (row > 0 && /^\s*$/.test(line));

                column = line.length;
                if (!/\s+$/.test(line))
                    line = "";
            }

            var leftOfCursor = lang.stringReverse(line);
            var index = this.$shortWordEndIndex(leftOfCursor);

            return this.moveCursorTo(row, column - index);
        };

        this.moveCursorWordRight = function() {
            if (this.session.$selectLongWords)
                this.moveCursorLongWordRight();
            else
                this.moveCursorShortWordRight();
        };

        this.moveCursorWordLeft = function() {
            if (this.session.$selectLongWords)
                this.moveCursorLongWordLeft();
            else
                this.moveCursorShortWordLeft();
        };
        this.moveCursorBy = function(rows, chars) {
            var screenPos = this.session.documentToScreenPosition(
                this.lead.row,
                this.lead.column
            );

            var offsetX;

            if (chars === 0) {
                if (rows !== 0) {
                    if (this.session.$bidiHandler.isBidiRow(screenPos.row, this.lead.row)) {
                        offsetX = this.session.$bidiHandler.getPosLeft(screenPos.column);
                        screenPos.column = Math.round(offsetX / this.session.$bidiHandler.charWidths[0]);
                    } else {
                        offsetX = screenPos.column * this.session.$bidiHandler.charWidths[0];
                    }
                }

                if (this.$desiredColumn)
                    screenPos.column = this.$desiredColumn;
                else
                    this.$desiredColumn = screenPos.column;
            }
            
            if (rows != 0 && this.session.lineWidgets && this.session.lineWidgets[this.lead.row]) {
                var widget = this.session.lineWidgets[this.lead.row];
                if (rows < 0)
                    rows -= widget.rowsAbove || 0;
                else if (rows > 0)
                    rows += widget.rowCount - (widget.rowsAbove || 0);
            }
            
            var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column, offsetX);
            
            if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) ;
            this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
        };
        this.moveCursorToPosition = function(position) {
            this.moveCursorTo(position.row, position.column);
        };
        this.moveCursorTo = function(row, column, keepDesiredColumn) {
            var fold = this.session.getFoldAt(row, column, 1);
            if (fold) {
                row = fold.start.row;
                column = fold.start.column;
            }

            this.$keepDesiredColumnOnChange = true;
            var line = this.session.getLine(row);
            if (/[\uDC00-\uDFFF]/.test(line.charAt(column)) && line.charAt(column - 1)) {
                if (this.lead.row == row && this.lead.column == column + 1)
                    column = column - 1;
                else
                    column = column + 1;
            }
            this.lead.setPosition(row, column);
            this.$keepDesiredColumnOnChange = false;

            if (!keepDesiredColumn)
                this.$desiredColumn = null;
        };
        this.moveCursorToScreen = function(row, column, keepDesiredColumn) {
            var pos = this.session.screenToDocumentPosition(row, column);
            this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
        };
        this.detach = function() {
            this.lead.detach();
            this.anchor.detach();
            this.session = this.doc = null;
        };

        this.fromOrientedRange = function(range) {
            this.setSelectionRange(range, range.cursor == range.start);
            this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
        };

        this.toOrientedRange = function(range) {
            var r = this.getRange();
            if (range) {
                range.start.column = r.start.column;
                range.start.row = r.start.row;
                range.end.column = r.end.column;
                range.end.row = r.end.row;
            } else {
                range = r;
            }

            range.cursor = this.isBackwards() ? range.start : range.end;
            range.desiredColumn = this.$desiredColumn;
            return range;
        };
        this.getRangeOfMovements = function(func) {
            var start = this.getCursor();
            try {
                func(this);
                var end = this.getCursor();
                return Range.fromPoints(start, end);
            } catch(e) {
                return Range.fromPoints(start, start);
            } finally {
                this.moveCursorToPosition(start);
            }
        };

        this.toJSON = function() {
            if (this.rangeCount) {
                var data = this.ranges.map(function(r) {
                    var r1 = r.clone();
                    r1.isBackwards = r.cursor == r.start;
                    return r1;
                });
            } else {
                var data = this.getRange();
                data.isBackwards = this.isBackwards();
            }
            return data;
        };

        this.fromJSON = function(data) {
            if (data.start == undefined) {
                if (this.rangeList && data.length > 1) {
                    this.toSingleRange(data[0]);
                    for (var i = data.length; i--; ) {
                        var r = Range.fromPoints(data[i].start, data[i].end);
                        if (data[i].isBackwards)
                            r.cursor = r.start;
                        this.addRange(r, true);
                    }
                    return;
                } else {
                    data = data[0];
                }
            }
            if (this.rangeList)
                this.toSingleRange(data);
            this.setSelectionRange(data, data.isBackwards);
        };

        this.isEqual = function(data) {
            if ((data.length || this.rangeCount) && data.length != this.rangeCount)
                return false;
            if (!data.length || !this.ranges)
                return this.getRange().isEqual(data);

            for (var i = this.ranges.length; i--; ) {
                if (!this.ranges[i].isEqual(data[i]))
                    return false;
            }
            return true;
        };

    }).call(Selection.prototype);

    exports.Selection = Selection;
    });

    ace.define("ace/tokenizer",["require","exports","module","ace/config"], function(require, exports, module) {

    var config = require("./config");
    var MAX_TOKEN_COUNT = 2000;
    var Tokenizer = function(rules) {
        this.states = rules;

        this.regExps = {};
        this.matchMappings = {};
        for (var key in this.states) {
            var state = this.states[key];
            var ruleRegExps = [];
            var matchTotal = 0;
            var mapping = this.matchMappings[key] = {defaultToken: "text"};
            var flag = "g";

            var splitterRurles = [];
            for (var i = 0; i < state.length; i++) {
                var rule = state[i];
                if (rule.defaultToken)
                    mapping.defaultToken = rule.defaultToken;
                if (rule.caseInsensitive)
                    flag = "gi";
                if (rule.regex == null)
                    continue;

                if (rule.regex instanceof RegExp)
                    rule.regex = rule.regex.toString().slice(1, -1);
                var adjustedregex = rule.regex;
                var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
                if (Array.isArray(rule.token)) {
                    if (rule.token.length == 1 || matchcount == 1) {
                        rule.token = rule.token[0];
                    } else if (matchcount - 1 != rule.token.length) {
                        this.reportError("number of classes and regexp groups doesn't match", { 
                            rule: rule,
                            groupCount: matchcount - 1
                        });
                        rule.token = rule.token[0];
                    } else {
                        rule.tokenArray = rule.token;
                        rule.token = null;
                        rule.onMatch = this.$arrayTokens;
                    }
                } else if (typeof rule.token == "function" && !rule.onMatch) {
                    if (matchcount > 1)
                        rule.onMatch = this.$applyToken;
                    else
                        rule.onMatch = rule.token;
                }

                if (matchcount > 1) {
                    if (/\\\d/.test(rule.regex)) {
                        adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function(match, digit) {
                            return "\\" + (parseInt(digit, 10) + matchTotal + 1);
                        });
                    } else {
                        matchcount = 1;
                        adjustedregex = this.removeCapturingGroups(rule.regex);
                    }
                    if (!rule.splitRegex && typeof rule.token != "string")
                        splitterRurles.push(rule); // flag will be known only at the very end
                }

                mapping[matchTotal] = i;
                matchTotal += matchcount;

                ruleRegExps.push(adjustedregex);
                if (!rule.onMatch)
                    rule.onMatch = null;
            }
            
            if (!ruleRegExps.length) {
                mapping[0] = 0;
                ruleRegExps.push("$");
            }
            
            splitterRurles.forEach(function(rule) {
                rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);
            }, this);

            this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
        }
    };

    (function() {
        this.$setMaxTokenCount = function(m) {
            MAX_TOKEN_COUNT = m | 0;
        };
        
        this.$applyToken = function(str) {
            var values = this.splitRegex.exec(str).slice(1);
            var types = this.token.apply(this, values);
            if (typeof types === "string")
                return [{type: types, value: str}];

            var tokens = [];
            for (var i = 0, l = types.length; i < l; i++) {
                if (values[i])
                    tokens[tokens.length] = {
                        type: types[i],
                        value: values[i]
                    };
            }
            return tokens;
        };

        this.$arrayTokens = function(str) {
            if (!str)
                return [];
            var values = this.splitRegex.exec(str);
            if (!values)
                return "text";
            var tokens = [];
            var types = this.tokenArray;
            for (var i = 0, l = types.length; i < l; i++) {
                if (values[i + 1])
                    tokens[tokens.length] = {
                        type: types[i],
                        value: values[i + 1]
                    };
            }
            return tokens;
        };

        this.removeCapturingGroups = function(src) {
            var r = src.replace(
                /\\.|\[(?:\\.|[^\\\]])*|\(\?[:=!]|(\()/g,
                function(x, y) {return y ? "(?:" : x;}
            );
            return r;
        };

        this.createSplitterRegexp = function(src, flag) {
            if (src.indexOf("(?=") != -1) {
                var stack = 0;
                var inChClass = false;
                var lastCapture = {};
                src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(
                    m, esc, parenOpen, parenClose, square, index
                ) {
                    if (inChClass) {
                        inChClass = square != "]";
                    } else if (square) {
                        inChClass = true;
                    } else if (parenClose) {
                        if (stack == lastCapture.stack) {
                            lastCapture.end = index+1;
                            lastCapture.stack = -1;
                        }
                        stack--;
                    } else if (parenOpen) {
                        stack++;
                        if (parenOpen.length != 1) {
                            lastCapture.stack = stack;
                            lastCapture.start = index;
                        }
                    }
                    return m;
                });

                if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end)))
                    src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
            }
            if (src.charAt(0) != "^") src = "^" + src;
            if (src.charAt(src.length - 1) != "$") src += "$";
            
            return new RegExp(src, (flag||"").replace("g", ""));
        };
        this.getLineTokens = function(line, startState) {
            if (startState && typeof startState != "string") {
                var stack = startState.slice(0);
                startState = stack[0];
                if (startState === "#tmp") {
                    stack.shift();
                    startState = stack.shift();
                }
            } else
                var stack = [];

            var currentState = startState || "start";
            var state = this.states[currentState];
            if (!state) {
                currentState = "start";
                state = this.states[currentState];
            }
            var mapping = this.matchMappings[currentState];
            var re = this.regExps[currentState];
            re.lastIndex = 0;

            var match, tokens = [];
            var lastIndex = 0;
            var matchAttempts = 0;

            var token = {type: null, value: ""};

            while (match = re.exec(line)) {
                var type = mapping.defaultToken;
                var rule = null;
                var value = match[0];
                var index = re.lastIndex;

                if (index - value.length > lastIndex) {
                    var skipped = line.substring(lastIndex, index - value.length);
                    if (token.type == type) {
                        token.value += skipped;
                    } else {
                        if (token.type)
                            tokens.push(token);
                        token = {type: type, value: skipped};
                    }
                }

                for (var i = 0; i < match.length-2; i++) {
                    if (match[i + 1] === undefined)
                        continue;

                    rule = state[mapping[i]];

                    if (rule.onMatch)
                        type = rule.onMatch(value, currentState, stack, line);
                    else
                        type = rule.token;

                    if (rule.next) {
                        if (typeof rule.next == "string") {
                            currentState = rule.next;
                        } else {
                            currentState = rule.next(currentState, stack);
                        }
                        
                        state = this.states[currentState];
                        if (!state) {
                            this.reportError("state doesn't exist", currentState);
                            currentState = "start";
                            state = this.states[currentState];
                        }
                        mapping = this.matchMappings[currentState];
                        lastIndex = index;
                        re = this.regExps[currentState];
                        re.lastIndex = index;
                    }
                    if (rule.consumeLineEnd)
                        lastIndex = index;
                    break;
                }

                if (value) {
                    if (typeof type === "string") {
                        if ((!rule || rule.merge !== false) && token.type === type) {
                            token.value += value;
                        } else {
                            if (token.type)
                                tokens.push(token);
                            token = {type: type, value: value};
                        }
                    } else if (type) {
                        if (token.type)
                            tokens.push(token);
                        token = {type: null, value: ""};
                        for (var i = 0; i < type.length; i++)
                            tokens.push(type[i]);
                    }
                }

                if (lastIndex == line.length)
                    break;

                lastIndex = index;

                if (matchAttempts++ > MAX_TOKEN_COUNT) {
                    if (matchAttempts > 2 * line.length) {
                        this.reportError("infinite loop with in ace tokenizer", {
                            startState: startState,
                            line: line
                        });
                    }
                    while (lastIndex < line.length) {
                        if (token.type)
                            tokens.push(token);
                        token = {
                            value: line.substring(lastIndex, lastIndex += 500),
                            type: "overflow"
                        };
                    }
                    currentState = "start";
                    stack = [];
                    break;
                }
            }

            if (token.type)
                tokens.push(token);
            
            if (stack.length > 1) {
                if (stack[0] !== currentState)
                    stack.unshift("#tmp", currentState);
            }
            return {
                tokens : tokens,
                state : stack.length ? stack : currentState
            };
        };
        
        this.reportError = config.reportError;
        
    }).call(Tokenizer.prototype);

    exports.Tokenizer = Tokenizer;
    });

    ace.define("ace/mode/text_highlight_rules",["require","exports","module","ace/lib/lang"], function(require, exports, module) {

    var lang = require("../lib/lang");

    var TextHighlightRules = function() {

        this.$rules = {
            "start" : [{
                token : "empty_line",
                regex : '^$'
            }, {
                defaultToken : "text"
            }]
        };
    };

    (function() {

        this.addRules = function(rules, prefix) {
            if (!prefix) {
                for (var key in rules)
                    this.$rules[key] = rules[key];
                return;
            }
            for (var key in rules) {
                var state = rules[key];
                for (var i = 0; i < state.length; i++) {
                    var rule = state[i];
                    if (rule.next || rule.onMatch) {
                        if (typeof rule.next == "string") {
                            if (rule.next.indexOf(prefix) !== 0)
                                rule.next = prefix + rule.next;
                        }
                        if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)
                            rule.nextState = prefix + rule.nextState;
                    }
                }
                this.$rules[prefix + key] = state;
            }
        };

        this.getRules = function() {
            return this.$rules;
        };

        this.embedRules = function (HighlightRules, prefix, escapeRules, states, append) {
            var embedRules = typeof HighlightRules == "function"
                ? new HighlightRules().getRules()
                : HighlightRules;
            if (states) {
                for (var i = 0; i < states.length; i++)
                    states[i] = prefix + states[i];
            } else {
                states = [];
                for (var key in embedRules)
                    states.push(prefix + key);
            }

            this.addRules(embedRules, prefix);

            if (escapeRules) {
                var addRules = Array.prototype[append ? "push" : "unshift"];
                for (var i = 0; i < states.length; i++)
                    addRules.apply(this.$rules[states[i]], lang.deepCopy(escapeRules));
            }

            if (!this.$embeds)
                this.$embeds = [];
            this.$embeds.push(prefix);
        };

        this.getEmbeds = function() {
            return this.$embeds;
        };

        var pushState = function(currentState, stack) {
            if (currentState != "start" || stack.length)
                stack.unshift(this.nextState, currentState);
            return this.nextState;
        };
        var popState = function(currentState, stack) {
            stack.shift();
            return stack.shift() || "start";
        };

        this.normalizeRules = function() {
            var id = 0;
            var rules = this.$rules;
            function processState(key) {
                var state = rules[key];
                state.processed = true;
                for (var i = 0; i < state.length; i++) {
                    var rule = state[i];
                    var toInsert = null;
                    if (Array.isArray(rule)) {
                        toInsert = rule;
                        rule = {};
                    }
                    if (!rule.regex && rule.start) {
                        rule.regex = rule.start;
                        if (!rule.next)
                            rule.next = [];
                        rule.next.push({
                            defaultToken: rule.token
                        }, {
                            token: rule.token + ".end",
                            regex: rule.end || rule.start,
                            next: "pop"
                        });
                        rule.token = rule.token + ".start";
                        rule.push = true;
                    }
                    var next = rule.next || rule.push;
                    if (next && Array.isArray(next)) {
                        var stateName = rule.stateName;
                        if (!stateName)  {
                            stateName = rule.token;
                            if (typeof stateName != "string")
                                stateName = stateName[0] || "";
                            if (rules[stateName])
                                stateName += id++;
                        }
                        rules[stateName] = next;
                        rule.next = stateName;
                        processState(stateName);
                    } else if (next == "pop") {
                        rule.next = popState;
                    }

                    if (rule.push) {
                        rule.nextState = rule.next || rule.push;
                        rule.next = pushState;
                        delete rule.push;
                    }

                    if (rule.rules) {
                        for (var r in rule.rules) {
                            if (rules[r]) {
                                if (rules[r].push)
                                    rules[r].push.apply(rules[r], rule.rules[r]);
                            } else {
                                rules[r] = rule.rules[r];
                            }
                        }
                    }
                    var includeName = typeof rule == "string" ? rule : rule.include;
                    if (includeName) {
                        if (Array.isArray(includeName))
                            toInsert = includeName.map(function(x) { return rules[x]; });
                        else
                            toInsert = rules[includeName];
                    }

                    if (toInsert) {
                        var args = [i, 1].concat(toInsert);
                        if (rule.noEscape)
                            args = args.filter(function(x) {return !x.next;});
                        state.splice.apply(state, args);
                        i--;
                    }
                    
                    if (rule.keywordMap) {
                        rule.token = this.createKeywordMapper(
                            rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive
                        );
                        delete rule.defaultToken;
                    }
                }
            }
            Object.keys(rules).forEach(processState, this);
        };

        this.createKeywordMapper = function(map, defaultToken, ignoreCase, splitChar) {
            var keywords = Object.create(null);
            Object.keys(map).forEach(function(className) {
                var a = map[className];
                if (ignoreCase)
                    a = a.toLowerCase();
                var list = a.split(splitChar || "|");
                for (var i = list.length; i--; )
                    keywords[list[i]] = className;
            });
            if (Object.getPrototypeOf(keywords)) {
                keywords.__proto__ = null;
            }
            this.$keywordList = Object.keys(keywords);
            map = null;
            return ignoreCase
                ? function(value) {return keywords[value.toLowerCase()] || defaultToken; }
                : function(value) {return keywords[value] || defaultToken; };
        };

        this.getKeywords = function() {
            return this.$keywords;
        };

    }).call(TextHighlightRules.prototype);

    exports.TextHighlightRules = TextHighlightRules;
    });

    ace.define("ace/mode/behaviour",["require","exports","module"], function(require, exports, module) {

    var Behaviour = function() {
       this.$behaviours = {};
    };

    (function () {

        this.add = function (name, action, callback) {
            switch (undefined) {
              case this.$behaviours:
                  this.$behaviours = {};
              case this.$behaviours[name]:
                  this.$behaviours[name] = {};
            }
            this.$behaviours[name][action] = callback;
        };
        
        this.addBehaviours = function (behaviours) {
            for (var key in behaviours) {
                for (var action in behaviours[key]) {
                    this.add(key, action, behaviours[key][action]);
                }
            }
        };
        
        this.remove = function (name) {
            if (this.$behaviours && this.$behaviours[name]) {
                delete this.$behaviours[name];
            }
        };
        
        this.inherit = function (mode, filter) {
            if (typeof mode === "function") {
                var behaviours = new mode().getBehaviours(filter);
            } else {
                var behaviours = mode.getBehaviours(filter);
            }
            this.addBehaviours(behaviours);
        };
        
        this.getBehaviours = function (filter) {
            if (!filter) {
                return this.$behaviours;
            } else {
                var ret = {};
                for (var i = 0; i < filter.length; i++) {
                    if (this.$behaviours[filter[i]]) {
                        ret[filter[i]] = this.$behaviours[filter[i]];
                    }
                }
                return ret;
            }
        };

    }).call(Behaviour.prototype);

    exports.Behaviour = Behaviour;
    });

    ace.define("ace/token_iterator",["require","exports","module","ace/range"], function(require, exports, module) {

    var Range = require("./range").Range;
    var TokenIterator = function(session, initialRow, initialColumn) {
        this.$session = session;
        this.$row = initialRow;
        this.$rowTokens = session.getTokens(initialRow);

        var token = session.getTokenAt(initialRow, initialColumn);
        this.$tokenIndex = token ? token.index : -1;
    };

    (function() { 
        this.stepBackward = function() {
            this.$tokenIndex -= 1;
            
            while (this.$tokenIndex < 0) {
                this.$row -= 1;
                if (this.$row < 0) {
                    this.$row = 0;
                    return null;
                }
                    
                this.$rowTokens = this.$session.getTokens(this.$row);
                this.$tokenIndex = this.$rowTokens.length - 1;
            }
                
            return this.$rowTokens[this.$tokenIndex];
        };   
        this.stepForward = function() {
            this.$tokenIndex += 1;
            var rowCount;
            while (this.$tokenIndex >= this.$rowTokens.length) {
                this.$row += 1;
                if (!rowCount)
                    rowCount = this.$session.getLength();
                if (this.$row >= rowCount) {
                    this.$row = rowCount - 1;
                    return null;
                }

                this.$rowTokens = this.$session.getTokens(this.$row);
                this.$tokenIndex = 0;
            }
                
            return this.$rowTokens[this.$tokenIndex];
        };      
        this.getCurrentToken = function () {
            return this.$rowTokens[this.$tokenIndex];
        };      
        this.getCurrentTokenRow = function () {
            return this.$row;
        };     
        this.getCurrentTokenColumn = function() {
            var rowTokens = this.$rowTokens;
            var tokenIndex = this.$tokenIndex;
            var column = rowTokens[tokenIndex].start;
            if (column !== undefined)
                return column;
                
            column = 0;
            while (tokenIndex > 0) {
                tokenIndex -= 1;
                column += rowTokens[tokenIndex].value.length;
            }
            
            return column;  
        };
        this.getCurrentTokenPosition = function() {
            return {row: this.$row, column: this.getCurrentTokenColumn()};
        };
        this.getCurrentTokenRange = function() {
            var token = this.$rowTokens[this.$tokenIndex];
            var column = this.getCurrentTokenColumn();
            return new Range(this.$row, column, this.$row, column + token.value.length);
        };
        
    }).call(TokenIterator.prototype);

    exports.TokenIterator = TokenIterator;
    });

    ace.define("ace/mode/behaviour/cstyle",["require","exports","module","ace/lib/oop","ace/mode/behaviour","ace/token_iterator","ace/lib/lang"], function(require, exports, module) {

    var oop = require("../../lib/oop");
    var Behaviour = require("../behaviour").Behaviour;
    var TokenIterator = require("../../token_iterator").TokenIterator;
    var lang = require("../../lib/lang");

    var SAFE_INSERT_IN_TOKENS =
        ["text", "paren.rparen", "rparen", "paren", "punctuation.operator"];
    var SAFE_INSERT_BEFORE_TOKENS =
        ["text", "paren.rparen", "rparen", "paren", "punctuation.operator", "comment"];

    var context;
    var contextCache = {};
    var defaultQuotes = {'"' : '"', "'" : "'"};

    var initContext = function(editor) {
        var id = -1;
        if (editor.multiSelect) {
            id = editor.selection.index;
            if (contextCache.rangeCount != editor.multiSelect.rangeCount)
                contextCache = {rangeCount: editor.multiSelect.rangeCount};
        }
        if (contextCache[id])
            return context = contextCache[id];
        context = contextCache[id] = {
            autoInsertedBrackets: 0,
            autoInsertedRow: -1,
            autoInsertedLineEnd: "",
            maybeInsertedBrackets: 0,
            maybeInsertedRow: -1,
            maybeInsertedLineStart: "",
            maybeInsertedLineEnd: ""
        };
    };

    var getWrapped = function(selection, selected, opening, closing) {
        var rowDiff = selection.end.row - selection.start.row;
        return {
            text: opening + selected + closing,
            selection: [
                    0,
                    selection.start.column + 1,
                    rowDiff,
                    selection.end.column + (rowDiff ? 0 : 1)
                ]
        };
    };

    var CstyleBehaviour = function(options) {
        this.add("braces", "insertion", function(state, action, editor, session, text) {
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            if (text == '{') {
                initContext(editor);
                var selection = editor.getSelectionRange();
                var selected = session.doc.getTextRange(selection);
                if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
                    return getWrapped(selection, selected, '{', '}');
                } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                    if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode || options && options.braces) {
                        CstyleBehaviour.recordAutoInsert(editor, session, "}");
                        return {
                            text: '{}',
                            selection: [1, 1]
                        };
                    } else {
                        CstyleBehaviour.recordMaybeInsert(editor, session, "{");
                        return {
                            text: '{',
                            selection: [1, 1]
                        };
                    }
                }
            } else if (text == '}') {
                initContext(editor);
                var rightChar = line.substring(cursor.column, cursor.column + 1);
                if (rightChar == '}') {
                    var matching = session.$findOpeningBracket('}', {column: cursor.column + 1, row: cursor.row});
                    if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                        CstyleBehaviour.popAutoInsertedClosing();
                        return {
                            text: '',
                            selection: [1, 1]
                        };
                    }
                }
            } else if (text == "\n" || text == "\r\n") {
                initContext(editor);
                var closing = "";
                if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
                    closing = lang.stringRepeat("}", context.maybeInsertedBrackets);
                    CstyleBehaviour.clearMaybeInsertedClosing();
                }
                var rightChar = line.substring(cursor.column, cursor.column + 1);
                if (rightChar === '}') {
                    var openBracePos = session.findMatchingBracket({row: cursor.row, column: cursor.column+1}, '}');
                    if (!openBracePos)
                         return null;
                    var next_indent = this.$getIndent(session.getLine(openBracePos.row));
                } else if (closing) {
                    var next_indent = this.$getIndent(line);
                } else {
                    CstyleBehaviour.clearMaybeInsertedClosing();
                    return;
                }
                var indent = next_indent + session.getTabString();

                return {
                    text: '\n' + indent + '\n' + next_indent + closing,
                    selection: [1, indent.length, 1, indent.length]
                };
            } else {
                CstyleBehaviour.clearMaybeInsertedClosing();
            }
        });

        this.add("braces", "deletion", function(state, action, editor, session, range) {
            var selected = session.doc.getTextRange(range);
            if (!range.isMultiLine() && selected == '{') {
                initContext(editor);
                var line = session.doc.getLine(range.start.row);
                var rightChar = line.substring(range.end.column, range.end.column + 1);
                if (rightChar == '}') {
                    range.end.column++;
                    return range;
                } else {
                    context.maybeInsertedBrackets--;
                }
            }
        });

        this.add("parens", "insertion", function(state, action, editor, session, text) {
            if (text == '(') {
                initContext(editor);
                var selection = editor.getSelectionRange();
                var selected = session.doc.getTextRange(selection);
                if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                    return getWrapped(selection, selected, '(', ')');
                } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                    CstyleBehaviour.recordAutoInsert(editor, session, ")");
                    return {
                        text: '()',
                        selection: [1, 1]
                    };
                }
            } else if (text == ')') {
                initContext(editor);
                var cursor = editor.getCursorPosition();
                var line = session.doc.getLine(cursor.row);
                var rightChar = line.substring(cursor.column, cursor.column + 1);
                if (rightChar == ')') {
                    var matching = session.$findOpeningBracket(')', {column: cursor.column + 1, row: cursor.row});
                    if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                        CstyleBehaviour.popAutoInsertedClosing();
                        return {
                            text: '',
                            selection: [1, 1]
                        };
                    }
                }
            }
        });

        this.add("parens", "deletion", function(state, action, editor, session, range) {
            var selected = session.doc.getTextRange(range);
            if (!range.isMultiLine() && selected == '(') {
                initContext(editor);
                var line = session.doc.getLine(range.start.row);
                var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
                if (rightChar == ')') {
                    range.end.column++;
                    return range;
                }
            }
        });

        this.add("brackets", "insertion", function(state, action, editor, session, text) {
            if (text == '[') {
                initContext(editor);
                var selection = editor.getSelectionRange();
                var selected = session.doc.getTextRange(selection);
                if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                    return getWrapped(selection, selected, '[', ']');
                } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                    CstyleBehaviour.recordAutoInsert(editor, session, "]");
                    return {
                        text: '[]',
                        selection: [1, 1]
                    };
                }
            } else if (text == ']') {
                initContext(editor);
                var cursor = editor.getCursorPosition();
                var line = session.doc.getLine(cursor.row);
                var rightChar = line.substring(cursor.column, cursor.column + 1);
                if (rightChar == ']') {
                    var matching = session.$findOpeningBracket(']', {column: cursor.column + 1, row: cursor.row});
                    if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                        CstyleBehaviour.popAutoInsertedClosing();
                        return {
                            text: '',
                            selection: [1, 1]
                        };
                    }
                }
            }
        });

        this.add("brackets", "deletion", function(state, action, editor, session, range) {
            var selected = session.doc.getTextRange(range);
            if (!range.isMultiLine() && selected == '[') {
                initContext(editor);
                var line = session.doc.getLine(range.start.row);
                var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
                if (rightChar == ']') {
                    range.end.column++;
                    return range;
                }
            }
        });

        this.add("string_dquotes", "insertion", function(state, action, editor, session, text) {
            var quotes = session.$mode.$quotes || defaultQuotes;
            if (text.length == 1 && quotes[text]) {
                if (this.lineCommentStart && this.lineCommentStart.indexOf(text) != -1) 
                    return;
                initContext(editor);
                var quote = text;
                var selection = editor.getSelectionRange();
                var selected = session.doc.getTextRange(selection);
                if (selected !== "" && (selected.length != 1 || !quotes[selected]) && editor.getWrapBehavioursEnabled()) {
                    return getWrapped(selection, selected, quote, quote);
                } else if (!selected) {
                    var cursor = editor.getCursorPosition();
                    var line = session.doc.getLine(cursor.row);
                    var leftChar = line.substring(cursor.column-1, cursor.column);
                    var rightChar = line.substring(cursor.column, cursor.column + 1);
                    
                    var token = session.getTokenAt(cursor.row, cursor.column);
                    var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);
                    if (leftChar == "\\" && token && /escape/.test(token.type))
                        return null;
                    
                    var stringBefore = token && /string|escape/.test(token.type);
                    var stringAfter = !rightToken || /string|escape/.test(rightToken.type);
                    
                    var pair;
                    if (rightChar == quote) {
                        pair = stringBefore !== stringAfter;
                        if (pair && /string\.end/.test(rightToken.type))
                            pair = false;
                    } else {
                        if (stringBefore && !stringAfter)
                            return null; // wrap string with different quote
                        if (stringBefore && stringAfter)
                            return null; // do not pair quotes inside strings
                        var wordRe = session.$mode.tokenRe;
                        wordRe.lastIndex = 0;
                        var isWordBefore = wordRe.test(leftChar);
                        wordRe.lastIndex = 0;
                        var isWordAfter = wordRe.test(leftChar);
                        if (isWordBefore || isWordAfter)
                            return null; // before or after alphanumeric
                        if (rightChar && !/[\s;,.})\]\\]/.test(rightChar))
                            return null; // there is rightChar and it isn't closing
                        var charBefore = line[cursor.column - 2];
                        if (leftChar == quote &&  (charBefore == quote || wordRe.test(charBefore)))
                            return null;
                        pair = true;
                    }
                    return {
                        text: pair ? quote + quote : "",
                        selection: [1,1]
                    };
                }
            }
        });

        this.add("string_dquotes", "deletion", function(state, action, editor, session, range) {
            var quotes = session.$mode.$quotes || defaultQuotes;

            var selected = session.doc.getTextRange(range);
            if (!range.isMultiLine() && quotes.hasOwnProperty(selected)) {
                initContext(editor);
                var line = session.doc.getLine(range.start.row);
                var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
                if (rightChar == selected) {
                    range.end.column++;
                    return range;
                }
            }
        });

    };

        
    CstyleBehaviour.isSaneInsertion = function(editor, session) {
        var cursor = editor.getCursorPosition();
        var iterator = new TokenIterator(session, cursor.row, cursor.column);
        if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
            if (/[)}\]]/.test(editor.session.getLine(cursor.row)[cursor.column]))
                return true;
            var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
            if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS))
                return false;
        }
        iterator.stepForward();
        return iterator.getCurrentTokenRow() !== cursor.row ||
            this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
    };

    CstyleBehaviour.$matchTokenType = function(token, types) {
        return types.indexOf(token.type || token) > -1;
    };

    CstyleBehaviour.recordAutoInsert = function(editor, session, bracket) {
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (!this.isAutoInsertedClosing(cursor, line, context.autoInsertedLineEnd[0]))
            context.autoInsertedBrackets = 0;
        context.autoInsertedRow = cursor.row;
        context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
        context.autoInsertedBrackets++;
    };

    CstyleBehaviour.recordMaybeInsert = function(editor, session, bracket) {
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (!this.isMaybeInsertedClosing(cursor, line))
            context.maybeInsertedBrackets = 0;
        context.maybeInsertedRow = cursor.row;
        context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
        context.maybeInsertedLineEnd = line.substr(cursor.column);
        context.maybeInsertedBrackets++;
    };

    CstyleBehaviour.isAutoInsertedClosing = function(cursor, line, bracket) {
        return context.autoInsertedBrackets > 0 &&
            cursor.row === context.autoInsertedRow &&
            bracket === context.autoInsertedLineEnd[0] &&
            line.substr(cursor.column) === context.autoInsertedLineEnd;
    };

    CstyleBehaviour.isMaybeInsertedClosing = function(cursor, line) {
        return context.maybeInsertedBrackets > 0 &&
            cursor.row === context.maybeInsertedRow &&
            line.substr(cursor.column) === context.maybeInsertedLineEnd &&
            line.substr(0, cursor.column) == context.maybeInsertedLineStart;
    };

    CstyleBehaviour.popAutoInsertedClosing = function() {
        context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
        context.autoInsertedBrackets--;
    };

    CstyleBehaviour.clearMaybeInsertedClosing = function() {
        if (context) {
            context.maybeInsertedBrackets = 0;
            context.maybeInsertedRow = -1;
        }
    };



    oop.inherits(CstyleBehaviour, Behaviour);

    exports.CstyleBehaviour = CstyleBehaviour;
    });

    ace.define("ace/unicode",["require","exports","module"], function(require, exports, module) {
    var wordChars = [48,9,8,25,5,0,2,25,48,0,11,0,5,0,6,22,2,30,2,457,5,11,15,4,8,0,2,0,18,116,2,1,3,3,9,0,2,2,2,0,2,19,2,82,2,138,2,4,3,155,12,37,3,0,8,38,10,44,2,0,2,1,2,1,2,0,9,26,6,2,30,10,7,61,2,9,5,101,2,7,3,9,2,18,3,0,17,58,3,100,15,53,5,0,6,45,211,57,3,18,2,5,3,11,3,9,2,1,7,6,2,2,2,7,3,1,3,21,2,6,2,0,4,3,3,8,3,1,3,3,9,0,5,1,2,4,3,11,16,2,2,5,5,1,3,21,2,6,2,1,2,1,2,1,3,0,2,4,5,1,3,2,4,0,8,3,2,0,8,15,12,2,2,8,2,2,2,21,2,6,2,1,2,4,3,9,2,2,2,2,3,0,16,3,3,9,18,2,2,7,3,1,3,21,2,6,2,1,2,4,3,8,3,1,3,2,9,1,5,1,2,4,3,9,2,0,17,1,2,5,4,2,2,3,4,1,2,0,2,1,4,1,4,2,4,11,5,4,4,2,2,3,3,0,7,0,15,9,18,2,2,7,2,2,2,22,2,9,2,4,4,7,2,2,2,3,8,1,2,1,7,3,3,9,19,1,2,7,2,2,2,22,2,9,2,4,3,8,2,2,2,3,8,1,8,0,2,3,3,9,19,1,2,7,2,2,2,22,2,15,4,7,2,2,2,3,10,0,9,3,3,9,11,5,3,1,2,17,4,23,2,8,2,0,3,6,4,0,5,5,2,0,2,7,19,1,14,57,6,14,2,9,40,1,2,0,3,1,2,0,3,0,7,3,2,6,2,2,2,0,2,0,3,1,2,12,2,2,3,4,2,0,2,5,3,9,3,1,35,0,24,1,7,9,12,0,2,0,2,0,5,9,2,35,5,19,2,5,5,7,2,35,10,0,58,73,7,77,3,37,11,42,2,0,4,328,2,3,3,6,2,0,2,3,3,40,2,3,3,32,2,3,3,6,2,0,2,3,3,14,2,56,2,3,3,66,5,0,33,15,17,84,13,619,3,16,2,25,6,74,22,12,2,6,12,20,12,19,13,12,2,2,2,1,13,51,3,29,4,0,5,1,3,9,34,2,3,9,7,87,9,42,6,69,11,28,4,11,5,11,11,39,3,4,12,43,5,25,7,10,38,27,5,62,2,28,3,10,7,9,14,0,89,75,5,9,18,8,13,42,4,11,71,55,9,9,4,48,83,2,2,30,14,230,23,280,3,5,3,37,3,5,3,7,2,0,2,0,2,0,2,30,3,52,2,6,2,0,4,2,2,6,4,3,3,5,5,12,6,2,2,6,67,1,20,0,29,0,14,0,17,4,60,12,5,0,4,11,18,0,5,0,3,9,2,0,4,4,7,0,2,0,2,0,2,3,2,10,3,3,6,4,5,0,53,1,2684,46,2,46,2,132,7,6,15,37,11,53,10,0,17,22,10,6,2,6,2,6,2,6,2,6,2,6,2,6,2,6,2,31,48,0,470,1,36,5,2,4,6,1,5,85,3,1,3,2,2,89,2,3,6,40,4,93,18,23,57,15,513,6581,75,20939,53,1164,68,45,3,268,4,27,21,31,3,13,13,1,2,24,9,69,11,1,38,8,3,102,3,1,111,44,25,51,13,68,12,9,7,23,4,0,5,45,3,35,13,28,4,64,15,10,39,54,10,13,3,9,7,22,4,1,5,66,25,2,227,42,2,1,3,9,7,11171,13,22,5,48,8453,301,3,61,3,105,39,6,13,4,6,11,2,12,2,4,2,0,2,1,2,1,2,107,34,362,19,63,3,53,41,11,5,15,17,6,13,1,25,2,33,4,2,134,20,9,8,25,5,0,2,25,12,88,4,5,3,5,3,5,3,2];

    var code = 0;
    var str = [];
    for (var i = 0; i < wordChars.length; i += 2) {
        str.push(code += wordChars[i]);
        if (wordChars[i + 1])
            str.push(45, code += wordChars[i + 1]);
    }

    exports.wordChars = String.fromCharCode.apply(null, str);

    });

    ace.define("ace/mode/text",["require","exports","module","ace/config","ace/tokenizer","ace/mode/text_highlight_rules","ace/mode/behaviour/cstyle","ace/unicode","ace/lib/lang","ace/token_iterator","ace/range"], function(require, exports, module) {
    var config = require("../config");

    var Tokenizer = require("../tokenizer").Tokenizer;
    var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
    var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;
    var unicode = require("../unicode");
    var lang = require("../lib/lang");
    var TokenIterator = require("../token_iterator").TokenIterator;
    var Range = require("../range").Range;

    var Mode = function() {
        this.HighlightRules = TextHighlightRules;
    };

    (function() {
        this.$defaultBehaviour = new CstyleBehaviour();

        this.tokenRe = new RegExp("^[" + unicode.wordChars + "\\$_]+", "g");

        this.nonTokenRe = new RegExp("^(?:[^" + unicode.wordChars + "\\$_]|\\s])+", "g");

        this.getTokenizer = function() {
            if (!this.$tokenizer) {
                this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig);
                this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
            }
            return this.$tokenizer;
        };

        this.lineCommentStart = "";
        this.blockComment = "";

        this.toggleCommentLines = function(state, session, startRow, endRow) {
            var doc = session.doc;

            var ignoreBlankLines = true;
            var shouldRemove = true;
            var minIndent = Infinity;
            var tabSize = session.getTabSize();
            var insertAtTabStop = false;

            if (!this.lineCommentStart) {
                if (!this.blockComment)
                    return false;
                var lineCommentStart = this.blockComment.start;
                var lineCommentEnd = this.blockComment.end;
                var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
                var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");

                var comment = function(line, i) {
                    if (testRemove(line, i))
                        return;
                    if (!ignoreBlankLines || /\S/.test(line)) {
                        doc.insertInLine({row: i, column: line.length}, lineCommentEnd);
                        doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
                    }
                };

                var uncomment = function(line, i) {
                    var m;
                    if (m = line.match(regexpEnd))
                        doc.removeInLine(i, line.length - m[0].length, line.length);
                    if (m = line.match(regexpStart))
                        doc.removeInLine(i, m[1].length, m[0].length);
                };

                var testRemove = function(line, row) {
                    if (regexpStart.test(line))
                        return true;
                    var tokens = session.getTokens(row);
                    for (var i = 0; i < tokens.length; i++) {
                        if (tokens[i].type === "comment")
                            return true;
                    }
                };
            } else {
                if (Array.isArray(this.lineCommentStart)) {
                    var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
                    var lineCommentStart = this.lineCommentStart[0];
                } else {
                    var regexpStart = lang.escapeRegExp(this.lineCommentStart);
                    var lineCommentStart = this.lineCommentStart;
                }
                regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");
                
                insertAtTabStop = session.getUseSoftTabs();

                var uncomment = function(line, i) {
                    var m = line.match(regexpStart);
                    if (!m) return;
                    var start = m[1].length, end = m[0].length;
                    if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == " ")
                        end--;
                    doc.removeInLine(i, start, end);
                };
                var commentWithSpace = lineCommentStart + " ";
                var comment = function(line, i) {
                    if (!ignoreBlankLines || /\S/.test(line)) {
                        if (shouldInsertSpace(line, minIndent, minIndent))
                            doc.insertInLine({row: i, column: minIndent}, commentWithSpace);
                        else
                            doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
                    }
                };
                var testRemove = function(line, i) {
                    return regexpStart.test(line);
                };
                
                var shouldInsertSpace = function(line, before, after) {
                    var spaces = 0;
                    while (before-- && line.charAt(before) == " ")
                        spaces++;
                    if (spaces % tabSize != 0)
                        return false;
                    var spaces = 0;
                    while (line.charAt(after++) == " ")
                        spaces++;
                    if (tabSize > 2)
                        return spaces % tabSize != tabSize - 1;
                    else
                        return spaces % tabSize == 0;
                };
            }

            function iter(fun) {
                for (var i = startRow; i <= endRow; i++)
                    fun(doc.getLine(i), i);
            }


            var minEmptyLength = Infinity;
            iter(function(line, i) {
                var indent = line.search(/\S/);
                if (indent !== -1) {
                    if (indent < minIndent)
                        minIndent = indent;
                    if (shouldRemove && !testRemove(line, i))
                        shouldRemove = false;
                } else if (minEmptyLength > line.length) {
                    minEmptyLength = line.length;
                }
            });

            if (minIndent == Infinity) {
                minIndent = minEmptyLength;
                ignoreBlankLines = false;
                shouldRemove = false;
            }

            if (insertAtTabStop && minIndent % tabSize != 0)
                minIndent = Math.floor(minIndent / tabSize) * tabSize;

            iter(shouldRemove ? uncomment : comment);
        };

        this.toggleBlockComment = function(state, session, range, cursor) {
            var comment = this.blockComment;
            if (!comment)
                return;
            if (!comment.start && comment[0])
                comment = comment[0];

            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();

            var sel = session.selection;
            var initialRange = session.selection.toOrientedRange();
            var startRow, colDiff;

            if (token && /comment/.test(token.type)) {
                var startRange, endRange;
                while (token && /comment/.test(token.type)) {
                    var i = token.value.indexOf(comment.start);
                    if (i != -1) {
                        var row = iterator.getCurrentTokenRow();
                        var column = iterator.getCurrentTokenColumn() + i;
                        startRange = new Range(row, column, row, column + comment.start.length);
                        break;
                    }
                    token = iterator.stepBackward();
                }

                var iterator = new TokenIterator(session, cursor.row, cursor.column);
                var token = iterator.getCurrentToken();
                while (token && /comment/.test(token.type)) {
                    var i = token.value.indexOf(comment.end);
                    if (i != -1) {
                        var row = iterator.getCurrentTokenRow();
                        var column = iterator.getCurrentTokenColumn() + i;
                        endRange = new Range(row, column, row, column + comment.end.length);
                        break;
                    }
                    token = iterator.stepForward();
                }
                if (endRange)
                    session.remove(endRange);
                if (startRange) {
                    session.remove(startRange);
                    startRow = startRange.start.row;
                    colDiff = -comment.start.length;
                }
            } else {
                colDiff = comment.start.length;
                startRow = range.start.row;
                session.insert(range.end, comment.end);
                session.insert(range.start, comment.start);
            }
            if (initialRange.start.row == startRow)
                initialRange.start.column += colDiff;
            if (initialRange.end.row == startRow)
                initialRange.end.column += colDiff;
            session.selection.fromOrientedRange(initialRange);
        };

        this.getNextLineIndent = function(state, line, tab) {
            return this.$getIndent(line);
        };

        this.checkOutdent = function(state, line, input) {
            return false;
        };

        this.autoOutdent = function(state, doc, row) {
        };

        this.$getIndent = function(line) {
            return line.match(/^\s*/)[0];
        };

        this.createWorker = function(session) {
            return null;
        };

        this.createModeDelegates = function (mapping) {
            this.$embeds = [];
            this.$modes = {};
            for (var i in mapping) {
                if (mapping[i]) {
                    var Mode = mapping[i];
                    var id = Mode.prototype.$id;
                    var mode = config.$modes[id];
                    if (!mode)
                        config.$modes[id] = mode = new Mode();
                    if (!config.$modes[i])
                        config.$modes[i] = mode;
                    this.$embeds.push(i);
                    this.$modes[i] = mode;
                }
            }

            var delegations = ["toggleBlockComment", "toggleCommentLines", "getNextLineIndent", 
                "checkOutdent", "autoOutdent", "transformAction", "getCompletions"];

            for (var i = 0; i < delegations.length; i++) {
                (function(scope) {
                  var functionName = delegations[i];
                  var defaultHandler = scope[functionName];
                  scope[delegations[i]] = function() {
                      return this.$delegator(functionName, arguments, defaultHandler);
                  };
                }(this));
            }
        };

        this.$delegator = function(method, args, defaultHandler) {
            var state = args[0] || "start";
            if (typeof state != "string") {
                if (Array.isArray(state[2])) {
                    var language = state[2][state[2].length - 1];
                    var mode = this.$modes[language];
                    if (mode)
                        return mode[method].apply(mode, [state[1]].concat([].slice.call(args, 1)));
                }
                state = state[0] || "start";
            }
                
            for (var i = 0; i < this.$embeds.length; i++) {
                if (!this.$modes[this.$embeds[i]]) continue;

                var split = state.split(this.$embeds[i]);
                if (!split[0] && split[1]) {
                    args[0] = split[1];
                    var mode = this.$modes[this.$embeds[i]];
                    return mode[method].apply(mode, args);
                }
            }
            var ret = defaultHandler.apply(this, args);
            return defaultHandler ? ret : undefined;
        };

        this.transformAction = function(state, action, editor, session, param) {
            if (this.$behaviour) {
                var behaviours = this.$behaviour.getBehaviours();
                for (var key in behaviours) {
                    if (behaviours[key][action]) {
                        var ret = behaviours[key][action].apply(this, arguments);
                        if (ret) {
                            return ret;
                        }
                    }
                }
            }
        };
        
        this.getKeywords = function(append) {
            if (!this.completionKeywords) {
                var rules = this.$tokenizer.rules;
                var completionKeywords = [];
                for (var rule in rules) {
                    var ruleItr = rules[rule];
                    for (var r = 0, l = ruleItr.length; r < l; r++) {
                        if (typeof ruleItr[r].token === "string") {
                            if (/keyword|support|storage/.test(ruleItr[r].token))
                                completionKeywords.push(ruleItr[r].regex);
                        }
                        else if (typeof ruleItr[r].token === "object") {
                            for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {    
                                if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
                                    var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
                                    completionKeywords.push(rule.substr(1, rule.length - 2));
                                }
                            }
                        }
                    }
                }
                this.completionKeywords = completionKeywords;
            }
            if (!append)
                return this.$keywordList;
            return completionKeywords.concat(this.$keywordList || []);
        };
        
        this.$createKeywordList = function() {
            if (!this.$highlightRules)
                this.getTokenizer();
            return this.$keywordList = this.$highlightRules.$keywordList || [];
        };

        this.getCompletions = function(state, session, pos, prefix) {
            var keywords = this.$keywordList || this.$createKeywordList();
            return keywords.map(function(word) {
                return {
                    name: word,
                    value: word,
                    score: 0,
                    meta: "keyword"
                };
            });
        };

        this.$id = "ace/mode/text";
    }).call(Mode.prototype);

    exports.Mode = Mode;
    });

    ace.define("ace/apply_delta",["require","exports","module"], function(require, exports, module) {

    exports.applyDelta = function(docLines, delta, doNotValidate) {
        
        var row = delta.start.row;
        var startColumn = delta.start.column;
        var line = docLines[row] || "";
        switch (delta.action) {
            case "insert":
                var lines = delta.lines;
                if (lines.length === 1) {
                    docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
                } else {
                    var args = [row, 1].concat(delta.lines);
                    docLines.splice.apply(docLines, args);
                    docLines[row] = line.substring(0, startColumn) + docLines[row];
                    docLines[row + delta.lines.length - 1] += line.substring(startColumn);
                }
                break;
            case "remove":
                var endColumn = delta.end.column;
                var endRow = delta.end.row;
                if (row === endRow) {
                    docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
                } else {
                    docLines.splice(
                        row, endRow - row + 1,
                        line.substring(0, startColumn) + docLines[endRow].substring(endColumn)
                    );
                }
                break;
        }
    };
    });

    ace.define("ace/anchor",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(require, exports, module) {

    var oop = require("./lib/oop");
    var EventEmitter = require("./lib/event_emitter").EventEmitter;

    var Anchor = exports.Anchor = function(doc, row, column) {
        this.$onChange = this.onChange.bind(this);
        this.attach(doc);
        
        if (typeof column == "undefined")
            this.setPosition(row.row, row.column);
        else
            this.setPosition(row, column);
    };

    (function() {

        oop.implement(this, EventEmitter);
        this.getPosition = function() {
            return this.$clipPositionToDocument(this.row, this.column);
        };
        this.getDocument = function() {
            return this.document;
        };
        this.$insertRight = false;
        this.onChange = function(delta) {
            if (delta.start.row == delta.end.row && delta.start.row != this.row)
                return;

            if (delta.start.row > this.row)
                return;
                
            var point = $getTransformedPoint(delta, {row: this.row, column: this.column}, this.$insertRight);
            this.setPosition(point.row, point.column, true);
        };
        
        function $pointsInOrder(point1, point2, equalPointsInOrder) {
            var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
            return (point1.row < point2.row) || (point1.row == point2.row && bColIsAfter);
        }
                
        function $getTransformedPoint(delta, point, moveIfEqual) {
            var deltaIsInsert = delta.action == "insert";
            var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row    - delta.start.row);
            var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
            var deltaStart = delta.start;
            var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.
            if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
                return {
                    row: point.row,
                    column: point.column
                };
            }
            if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
                return {
                    row: point.row + deltaRowShift,
                    column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
                };
            }
            
            return {
                row: deltaStart.row,
                column: deltaStart.column
            };
        }
        this.setPosition = function(row, column, noClip) {
            var pos;
            if (noClip) {
                pos = {
                    row: row,
                    column: column
                };
            } else {
                pos = this.$clipPositionToDocument(row, column);
            }

            if (this.row == pos.row && this.column == pos.column)
                return;

            var old = {
                row: this.row,
                column: this.column
            };

            this.row = pos.row;
            this.column = pos.column;
            this._signal("change", {
                old: old,
                value: pos
            });
        };
        this.detach = function() {
            this.document.removeEventListener("change", this.$onChange);
        };
        this.attach = function(doc) {
            this.document = doc || this.document;
            this.document.on("change", this.$onChange);
        };
        this.$clipPositionToDocument = function(row, column) {
            var pos = {};

            if (row >= this.document.getLength()) {
                pos.row = Math.max(0, this.document.getLength() - 1);
                pos.column = this.document.getLine(pos.row).length;
            }
            else if (row < 0) {
                pos.row = 0;
                pos.column = 0;
            }
            else {
                pos.row = row;
                pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
            }

            if (column < 0)
                pos.column = 0;

            return pos;
        };

    }).call(Anchor.prototype);

    });

    ace.define("ace/document",["require","exports","module","ace/lib/oop","ace/apply_delta","ace/lib/event_emitter","ace/range","ace/anchor"], function(require, exports, module) {

    var oop = require("./lib/oop");
    var applyDelta = require("./apply_delta").applyDelta;
    var EventEmitter = require("./lib/event_emitter").EventEmitter;
    var Range = require("./range").Range;
    var Anchor = require("./anchor").Anchor;

    var Document = function(textOrLines) {
        this.$lines = [""];
        if (textOrLines.length === 0) {
            this.$lines = [""];
        } else if (Array.isArray(textOrLines)) {
            this.insertMergedLines({row: 0, column: 0}, textOrLines);
        } else {
            this.insert({row: 0, column:0}, textOrLines);
        }
    };

    (function() {

        oop.implement(this, EventEmitter);
        this.setValue = function(text) {
            var len = this.getLength() - 1;
            this.remove(new Range(0, 0, len, this.getLine(len).length));
            this.insert({row: 0, column: 0}, text);
        };
        this.getValue = function() {
            return this.getAllLines().join(this.getNewLineCharacter());
        };
        this.createAnchor = function(row, column) {
            return new Anchor(this, row, column);
        };
        if ("aaa".split(/a/).length === 0) {
            this.$split = function(text) {
                return text.replace(/\r\n|\r/g, "\n").split("\n");
            };
        } else {
            this.$split = function(text) {
                return text.split(/\r\n|\r|\n/);
            };
        }


        this.$detectNewLine = function(text) {
            var match = text.match(/^.*?(\r\n|\r|\n)/m);
            this.$autoNewLine = match ? match[1] : "\n";
            this._signal("changeNewLineMode");
        };
        this.getNewLineCharacter = function() {
            switch (this.$newLineMode) {
              case "windows":
                return "\r\n";
              case "unix":
                return "\n";
              default:
                return this.$autoNewLine || "\n";
            }
        };

        this.$autoNewLine = "";
        this.$newLineMode = "auto";
        this.setNewLineMode = function(newLineMode) {
            if (this.$newLineMode === newLineMode)
                return;

            this.$newLineMode = newLineMode;
            this._signal("changeNewLineMode");
        };
        this.getNewLineMode = function() {
            return this.$newLineMode;
        };
        this.isNewLine = function(text) {
            return (text == "\r\n" || text == "\r" || text == "\n");
        };
        this.getLine = function(row) {
            return this.$lines[row] || "";
        };
        this.getLines = function(firstRow, lastRow) {
            return this.$lines.slice(firstRow, lastRow + 1);
        };
        this.getAllLines = function() {
            return this.getLines(0, this.getLength());
        };
        this.getLength = function() {
            return this.$lines.length;
        };
        this.getTextRange = function(range) {
            return this.getLinesForRange(range).join(this.getNewLineCharacter());
        };
        this.getLinesForRange = function(range) {
            var lines;
            if (range.start.row === range.end.row) {
                lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
            } else {
                lines = this.getLines(range.start.row, range.end.row);
                lines[0] = (lines[0] || "").substring(range.start.column);
                var l = lines.length - 1;
                if (range.end.row - range.start.row == l)
                    lines[l] = lines[l].substring(0, range.end.column);
            }
            return lines;
        };
        this.insertLines = function(row, lines) {
            console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
            return this.insertFullLines(row, lines);
        };
        this.removeLines = function(firstRow, lastRow) {
            console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
            return this.removeFullLines(firstRow, lastRow);
        };
        this.insertNewLine = function(position) {
            console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.");
            return this.insertMergedLines(position, ["", ""]);
        };
        this.insert = function(position, text) {
            if (this.getLength() <= 1)
                this.$detectNewLine(text);
            
            return this.insertMergedLines(position, this.$split(text));
        };
        this.insertInLine = function(position, text) {
            var start = this.clippedPos(position.row, position.column);
            var end = this.pos(position.row, position.column + text.length);
            
            this.applyDelta({
                start: start,
                end: end,
                action: "insert",
                lines: [text]
            }, true);
            
            return this.clonePos(end);
        };
        
        this.clippedPos = function(row, column) {
            var length = this.getLength();
            if (row === undefined) {
                row = length;
            } else if (row < 0) {
                row = 0;
            } else if (row >= length) {
                row = length - 1;
                column = undefined;
            }
            var line = this.getLine(row);
            if (column == undefined)
                column = line.length;
            column = Math.min(Math.max(column, 0), line.length);
            return {row: row, column: column};
        };
        
        this.clonePos = function(pos) {
            return {row: pos.row, column: pos.column};
        };
        
        this.pos = function(row, column) {
            return {row: row, column: column};
        };
        
        this.$clipPosition = function(position) {
            var length = this.getLength();
            if (position.row >= length) {
                position.row = Math.max(0, length - 1);
                position.column = this.getLine(length - 1).length;
            } else {
                position.row = Math.max(0, position.row);
                position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
            }
            return position;
        };
        this.insertFullLines = function(row, lines) {
            row = Math.min(Math.max(row, 0), this.getLength());
            var column = 0;
            if (row < this.getLength()) {
                lines = lines.concat([""]);
                column = 0;
            } else {
                lines = [""].concat(lines);
                row--;
                column = this.$lines[row].length;
            }
            this.insertMergedLines({row: row, column: column}, lines);
        };    
        this.insertMergedLines = function(position, lines) {
            var start = this.clippedPos(position.row, position.column);
            var end = {
                row: start.row + lines.length - 1,
                column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
            };
            
            this.applyDelta({
                start: start,
                end: end,
                action: "insert",
                lines: lines
            });
            
            return this.clonePos(end);
        };
        this.remove = function(range) {
            var start = this.clippedPos(range.start.row, range.start.column);
            var end = this.clippedPos(range.end.row, range.end.column);
            this.applyDelta({
                start: start,
                end: end,
                action: "remove",
                lines: this.getLinesForRange({start: start, end: end})
            });
            return this.clonePos(start);
        };
        this.removeInLine = function(row, startColumn, endColumn) {
            var start = this.clippedPos(row, startColumn);
            var end = this.clippedPos(row, endColumn);
            
            this.applyDelta({
                start: start,
                end: end,
                action: "remove",
                lines: this.getLinesForRange({start: start, end: end})
            }, true);
            
            return this.clonePos(start);
        };
        this.removeFullLines = function(firstRow, lastRow) {
            firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
            lastRow  = Math.min(Math.max(0, lastRow ), this.getLength() - 1);
            var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
            var deleteLastNewLine  = lastRow  < this.getLength() - 1;
            var startRow = ( deleteFirstNewLine ? firstRow - 1                  : firstRow                    );
            var startCol = ( deleteFirstNewLine ? this.getLine(startRow).length : 0                           );
            var endRow   = ( deleteLastNewLine  ? lastRow + 1                   : lastRow                     );
            var endCol   = ( deleteLastNewLine  ? 0                             : this.getLine(endRow).length ); 
            var range = new Range(startRow, startCol, endRow, endCol);
            var deletedLines = this.$lines.slice(firstRow, lastRow + 1);
            
            this.applyDelta({
                start: range.start,
                end: range.end,
                action: "remove",
                lines: this.getLinesForRange(range)
            });
            return deletedLines;
        };
        this.removeNewLine = function(row) {
            if (row < this.getLength() - 1 && row >= 0) {
                this.applyDelta({
                    start: this.pos(row, this.getLine(row).length),
                    end: this.pos(row + 1, 0),
                    action: "remove",
                    lines: ["", ""]
                });
            }
        };
        this.replace = function(range, text) {
            if (!(range instanceof Range))
                range = Range.fromPoints(range.start, range.end);
            if (text.length === 0 && range.isEmpty())
                return range.start;
            if (text == this.getTextRange(range))
                return range.end;

            this.remove(range);
            var end;
            if (text) {
                end = this.insert(range.start, text);
            }
            else {
                end = range.start;
            }
            
            return end;
        };
        this.applyDeltas = function(deltas) {
            for (var i=0; i<deltas.length; i++) {
                this.applyDelta(deltas[i]);
            }
        };
        this.revertDeltas = function(deltas) {
            for (var i=deltas.length-1; i>=0; i--) {
                this.revertDelta(deltas[i]);
            }
        };
        this.applyDelta = function(delta, doNotValidate) {
            var isInsert = delta.action == "insert";
            if (isInsert ? delta.lines.length <= 1 && !delta.lines[0]
                : !Range.comparePoints(delta.start, delta.end)) {
                return;
            }
            
            if (isInsert && delta.lines.length > 20000) {
                this.$splitAndapplyLargeDelta(delta, 20000);
            }
            else {
                applyDelta(this.$lines, delta, doNotValidate);
                this._signal("change", delta);
            }
        };
        
        this.$splitAndapplyLargeDelta = function(delta, MAX) {
            var lines = delta.lines;
            var l = lines.length - MAX + 1;
            var row = delta.start.row; 
            var column = delta.start.column;
            for (var from = 0, to = 0; from < l; from = to) {
                to += MAX - 1;
                var chunk = lines.slice(from, to);
                chunk.push("");
                this.applyDelta({
                    start: this.pos(row + from, column),
                    end: this.pos(row + to, column = 0),
                    action: delta.action,
                    lines: chunk
                }, true);
            }
            delta.lines = lines.slice(from);
            delta.start.row = row + from;
            delta.start.column = column;
            this.applyDelta(delta, true);
        };
        this.revertDelta = function(delta) {
            this.applyDelta({
                start: this.clonePos(delta.start),
                end: this.clonePos(delta.end),
                action: (delta.action == "insert" ? "remove" : "insert"),
                lines: delta.lines.slice()
            });
        };
        this.indexToPosition = function(index, startRow) {
            var lines = this.$lines || this.getAllLines();
            var newlineLength = this.getNewLineCharacter().length;
            for (var i = startRow || 0, l = lines.length; i < l; i++) {
                index -= lines[i].length + newlineLength;
                if (index < 0)
                    return {row: i, column: index + lines[i].length + newlineLength};
            }
            return {row: l-1, column: index + lines[l-1].length + newlineLength};
        };
        this.positionToIndex = function(pos, startRow) {
            var lines = this.$lines || this.getAllLines();
            var newlineLength = this.getNewLineCharacter().length;
            var index = 0;
            var row = Math.min(pos.row, lines.length);
            for (var i = startRow || 0; i < row; ++i)
                index += lines[i].length + newlineLength;

            return index + pos.column;
        };

    }).call(Document.prototype);

    exports.Document = Document;
    });

    ace.define("ace/background_tokenizer",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(require, exports, module) {

    var oop = require("./lib/oop");
    var EventEmitter = require("./lib/event_emitter").EventEmitter;

    var BackgroundTokenizer = function(tokenizer, editor) {
        this.running = false;
        this.lines = [];
        this.states = [];
        this.currentLine = 0;
        this.tokenizer = tokenizer;

        var self = this;

        this.$worker = function() {
            if (!self.running) { return; }

            var workerStart = new Date();
            var currentLine = self.currentLine;
            var endLine = -1;
            var doc = self.doc;

            var startLine = currentLine;
            while (self.lines[currentLine])
                currentLine++;
            
            var len = doc.getLength();
            var processedLines = 0;
            self.running = false;
            while (currentLine < len) {
                self.$tokenizeRow(currentLine);
                endLine = currentLine;
                do {
                    currentLine++;
                } while (self.lines[currentLine]);
                processedLines ++;
                if ((processedLines % 5 === 0) && (new Date() - workerStart) > 20) {
                    self.running = setTimeout(self.$worker, 20);
                    break;
                }
            }
            self.currentLine = currentLine;
            
            if (endLine == -1)
                endLine = currentLine;
            
            if (startLine <= endLine)
                self.fireUpdateEvent(startLine, endLine);
        };
    };

    (function(){

        oop.implement(this, EventEmitter);
        this.setTokenizer = function(tokenizer) {
            this.tokenizer = tokenizer;
            this.lines = [];
            this.states = [];

            this.start(0);
        };
        this.setDocument = function(doc) {
            this.doc = doc;
            this.lines = [];
            this.states = [];

            this.stop();
        };
        this.fireUpdateEvent = function(firstRow, lastRow) {
            var data = {
                first: firstRow,
                last: lastRow
            };
            this._signal("update", {data: data});
        };
        this.start = function(startRow) {
            this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
            this.lines.splice(this.currentLine, this.lines.length);
            this.states.splice(this.currentLine, this.states.length);

            this.stop();
            this.running = setTimeout(this.$worker, 700);
        };
        
        this.scheduleStart = function() {
            if (!this.running)
                this.running = setTimeout(this.$worker, 700);
        };

        this.$updateOnChange = function(delta) {
            var startRow = delta.start.row;
            var len = delta.end.row - startRow;

            if (len === 0) {
                this.lines[startRow] = null;
            } else if (delta.action == "remove") {
                this.lines.splice(startRow, len + 1, null);
                this.states.splice(startRow, len + 1, null);
            } else {
                var args = Array(len + 1);
                args.unshift(startRow, 1);
                this.lines.splice.apply(this.lines, args);
                this.states.splice.apply(this.states, args);
            }

            this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());

            this.stop();
        };
        this.stop = function() {
            if (this.running)
                clearTimeout(this.running);
            this.running = false;
        };
        this.getTokens = function(row) {
            return this.lines[row] || this.$tokenizeRow(row);
        };
        this.getState = function(row) {
            if (this.currentLine == row)
                this.$tokenizeRow(row);
            return this.states[row] || "start";
        };

        this.$tokenizeRow = function(row) {
            var line = this.doc.getLine(row);
            var state = this.states[row - 1];

            var data = this.tokenizer.getLineTokens(line, state, row);

            if (this.states[row] + "" !== data.state + "") {
                this.states[row] = data.state;
                this.lines[row + 1] = null;
                if (this.currentLine > row + 1)
                    this.currentLine = row + 1;
            } else if (this.currentLine == row) {
                this.currentLine = row + 1;
            }

            return this.lines[row] = data.tokens;
        };

    }).call(BackgroundTokenizer.prototype);

    exports.BackgroundTokenizer = BackgroundTokenizer;
    });

    ace.define("ace/search_highlight",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/range"], function(require, exports, module) {

    var lang = require("./lib/lang");
    var oop = require("./lib/oop");
    var Range = require("./range").Range;

    var SearchHighlight = function(regExp, clazz, type) {
        this.setRegexp(regExp);
        this.clazz = clazz;
        this.type = type || "text";
    };

    (function() {
        this.MAX_RANGES = 500;
        
        this.setRegexp = function(regExp) {
            if (this.regExp+"" == regExp+"")
                return;
            this.regExp = regExp;
            this.cache = [];
        };

        this.update = function(html, markerLayer, session, config) {
            if (!this.regExp)
                return;
            var start = config.firstRow, end = config.lastRow;

            for (var i = start; i <= end; i++) {
                var ranges = this.cache[i];
                if (ranges == null) {
                    ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
                    if (ranges.length > this.MAX_RANGES)
                        ranges = ranges.slice(0, this.MAX_RANGES);
                    ranges = ranges.map(function(match) {
                        return new Range(i, match.offset, i, match.offset + match.length);
                    });
                    this.cache[i] = ranges.length ? ranges : "";
                }

                for (var j = ranges.length; j --; ) {
                    markerLayer.drawSingleLineMarker(
                        html, ranges[j].toScreenRange(session), this.clazz, config);
                }
            }
        };

    }).call(SearchHighlight.prototype);

    exports.SearchHighlight = SearchHighlight;
    });

    ace.define("ace/edit_session/fold_line",["require","exports","module","ace/range"], function(require, exports, module) {

    var Range = require("../range").Range;
    function FoldLine(foldData, folds) {
        this.foldData = foldData;
        if (Array.isArray(folds)) {
            this.folds = folds;
        } else {
            folds = this.folds = [ folds ];
        }

        var last = folds[folds.length - 1];
        this.range = new Range(folds[0].start.row, folds[0].start.column,
                               last.end.row, last.end.column);
        this.start = this.range.start;
        this.end   = this.range.end;

        this.folds.forEach(function(fold) {
            fold.setFoldLine(this);
        }, this);
    }

    (function() {
        this.shiftRow = function(shift) {
            this.start.row += shift;
            this.end.row += shift;
            this.folds.forEach(function(fold) {
                fold.start.row += shift;
                fold.end.row += shift;
            });
        };

        this.addFold = function(fold) {
            if (fold.sameRow) {
                if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
                    throw new Error("Can't add a fold to this FoldLine as it has no connection");
                }
                this.folds.push(fold);
                this.folds.sort(function(a, b) {
                    return -a.range.compareEnd(b.start.row, b.start.column);
                });
                if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
                    this.end.row = fold.end.row;
                    this.end.column =  fold.end.column;
                } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
                    this.start.row = fold.start.row;
                    this.start.column = fold.start.column;
                }
            } else if (fold.start.row == this.end.row) {
                this.folds.push(fold);
                this.end.row = fold.end.row;
                this.end.column = fold.end.column;
            } else if (fold.end.row == this.start.row) {
                this.folds.unshift(fold);
                this.start.row = fold.start.row;
                this.start.column = fold.start.column;
            } else {
                throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
            }
            fold.foldLine = this;
        };

        this.containsRow = function(row) {
            return row >= this.start.row && row <= this.end.row;
        };

        this.walk = function(callback, endRow, endColumn) {
            var lastEnd = 0,
                folds = this.folds,
                fold,
                cmp, stop, isNewRow = true;

            if (endRow == null) {
                endRow = this.end.row;
                endColumn = this.end.column;
            }

            for (var i = 0; i < folds.length; i++) {
                fold = folds[i];

                cmp = fold.range.compareStart(endRow, endColumn);
                if (cmp == -1) {
                    callback(null, endRow, endColumn, lastEnd, isNewRow);
                    return;
                }

                stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
                stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
                if (stop || cmp === 0) {
                    return;
                }
                isNewRow = !fold.sameRow;
                lastEnd = fold.end.column;
            }
            callback(null, endRow, endColumn, lastEnd, isNewRow);
        };

        this.getNextFoldTo = function(row, column) {
            var fold, cmp;
            for (var i = 0; i < this.folds.length; i++) {
                fold = this.folds[i];
                cmp = fold.range.compareEnd(row, column);
                if (cmp == -1) {
                    return {
                        fold: fold,
                        kind: "after"
                    };
                } else if (cmp === 0) {
                    return {
                        fold: fold,
                        kind: "inside"
                    };
                }
            }
            return null;
        };

        this.addRemoveChars = function(row, column, len) {
            var ret = this.getNextFoldTo(row, column),
                fold, folds;
            if (ret) {
                fold = ret.fold;
                if (ret.kind == "inside"
                    && fold.start.column != column
                    && fold.start.row != row)
                {
                    window.console && window.console.log(row, column, fold);
                } else if (fold.start.row == row) {
                    folds = this.folds;
                    var i = folds.indexOf(fold);
                    if (i === 0) {
                        this.start.column += len;
                    }
                    for (i; i < folds.length; i++) {
                        fold = folds[i];
                        fold.start.column += len;
                        if (!fold.sameRow) {
                            return;
                        }
                        fold.end.column += len;
                    }
                    this.end.column += len;
                }
            }
        };

        this.split = function(row, column) {
            var pos = this.getNextFoldTo(row, column);
            
            if (!pos || pos.kind == "inside")
                return null;
                
            var fold = pos.fold;
            var folds = this.folds;
            var foldData = this.foldData;
            
            var i = folds.indexOf(fold);
            var foldBefore = folds[i - 1];
            this.end.row = foldBefore.end.row;
            this.end.column = foldBefore.end.column;
            folds = folds.splice(i, folds.length - i);

            var newFoldLine = new FoldLine(foldData, folds);
            foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
            return newFoldLine;
        };

        this.merge = function(foldLineNext) {
            var folds = foldLineNext.folds;
            for (var i = 0; i < folds.length; i++) {
                this.addFold(folds[i]);
            }
            var foldData = this.foldData;
            foldData.splice(foldData.indexOf(foldLineNext), 1);
        };

        this.toString = function() {
            var ret = [this.range.toString() + ": [" ];

            this.folds.forEach(function(fold) {
                ret.push("  " + fold.toString());
            });
            ret.push("]");
            return ret.join("\n");
        };

        this.idxToPosition = function(idx) {
            var lastFoldEndColumn = 0;

            for (var i = 0; i < this.folds.length; i++) {
                var fold = this.folds[i];

                idx -= fold.start.column - lastFoldEndColumn;
                if (idx < 0) {
                    return {
                        row: fold.start.row,
                        column: fold.start.column + idx
                    };
                }

                idx -= fold.placeholder.length;
                if (idx < 0) {
                    return fold.start;
                }

                lastFoldEndColumn = fold.end.column;
            }

            return {
                row: this.end.row,
                column: this.end.column + idx
            };
        };
    }).call(FoldLine.prototype);

    exports.FoldLine = FoldLine;
    });

    ace.define("ace/range_list",["require","exports","module","ace/range"], function(require, exports, module) {
    var Range = require("./range").Range;
    var comparePoints = Range.comparePoints;

    var RangeList = function() {
        this.ranges = [];
        this.$bias = 1;
    };

    (function() {
        this.comparePoints = comparePoints;

        this.pointIndex = function(pos, excludeEdges, startIndex) {
            var list = this.ranges;

            for (var i = startIndex || 0; i < list.length; i++) {
                var range = list[i];
                var cmpEnd = comparePoints(pos, range.end);
                if (cmpEnd > 0)
                    continue;
                var cmpStart = comparePoints(pos, range.start);
                if (cmpEnd === 0)
                    return excludeEdges && cmpStart !== 0 ? -i-2 : i;
                if (cmpStart > 0 || (cmpStart === 0 && !excludeEdges))
                    return i;

                return -i-1;
            }
            return -i - 1;
        };

        this.add = function(range) {
            var excludeEdges = !range.isEmpty();
            var startIndex = this.pointIndex(range.start, excludeEdges);
            if (startIndex < 0)
                startIndex = -startIndex - 1;

            var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);

            if (endIndex < 0)
                endIndex = -endIndex - 1;
            else
                endIndex++;
            return this.ranges.splice(startIndex, endIndex - startIndex, range);
        };

        this.addList = function(list) {
            var removed = [];
            for (var i = list.length; i--; ) {
                removed.push.apply(removed, this.add(list[i]));
            }
            return removed;
        };

        this.substractPoint = function(pos) {
            var i = this.pointIndex(pos);

            if (i >= 0)
                return this.ranges.splice(i, 1);
        };
        this.merge = function() {
            var removed = [];
            var list = this.ranges;
            
            list = list.sort(function(a, b) {
                return comparePoints(a.start, b.start);
            });
            
            var next = list[0], range;
            for (var i = 1; i < list.length; i++) {
                range = next;
                next = list[i];
                var cmp = comparePoints(range.end, next.start);
                if (cmp < 0)
                    continue;

                if (cmp == 0 && !range.isEmpty() && !next.isEmpty())
                    continue;

                if (comparePoints(range.end, next.end) < 0) {
                    range.end.row = next.end.row;
                    range.end.column = next.end.column;
                }

                list.splice(i, 1);
                removed.push(next);
                next = range;
                i--;
            }
            
            this.ranges = list;

            return removed;
        };

        this.contains = function(row, column) {
            return this.pointIndex({row: row, column: column}) >= 0;
        };

        this.containsPoint = function(pos) {
            return this.pointIndex(pos) >= 0;
        };

        this.rangeAtPoint = function(pos) {
            var i = this.pointIndex(pos);
            if (i >= 0)
                return this.ranges[i];
        };


        this.clipRows = function(startRow, endRow) {
            var list = this.ranges;
            if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)
                return [];

            var startIndex = this.pointIndex({row: startRow, column: 0});
            if (startIndex < 0)
                startIndex = -startIndex - 1;
            var endIndex = this.pointIndex({row: endRow, column: 0}, startIndex);
            if (endIndex < 0)
                endIndex = -endIndex - 1;

            var clipped = [];
            for (var i = startIndex; i < endIndex; i++) {
                clipped.push(list[i]);
            }
            return clipped;
        };

        this.removeAll = function() {
            return this.ranges.splice(0, this.ranges.length);
        };

        this.attach = function(session) {
            if (this.session)
                this.detach();

            this.session = session;
            this.onChange = this.$onChange.bind(this);

            this.session.on('change', this.onChange);
        };

        this.detach = function() {
            if (!this.session)
                return;
            this.session.removeListener('change', this.onChange);
            this.session = null;
        };

        this.$onChange = function(delta) {
            var start = delta.start;
            var end = delta.end;
            var startRow = start.row;
            var endRow = end.row;
            var ranges = this.ranges;
            for (var i = 0, n = ranges.length; i < n; i++) {
                var r = ranges[i];
                if (r.end.row >= startRow)
                    break;
            }
            
            if (delta.action == "insert") {
                var lineDif = endRow - startRow;
                var colDiff = -start.column + end.column;
                for (; i < n; i++) {
                    var r = ranges[i];
                    if (r.start.row > startRow)
                        break;
        
                    if (r.start.row == startRow && r.start.column >= start.column) {
                        if (r.start.column == start.column && this.$bias <= 0) ; else {
                            r.start.column += colDiff;
                            r.start.row += lineDif;
                        }
                    }
                    if (r.end.row == startRow && r.end.column >= start.column) {
                        if (r.end.column == start.column && this.$bias < 0) {
                            continue;
                        }
                        if (r.end.column == start.column && colDiff > 0 && i < n - 1) {
                            if (r.end.column > r.start.column && r.end.column == ranges[i+1].start.column)
                                r.end.column -= colDiff;
                        }
                        r.end.column += colDiff;
                        r.end.row += lineDif;
                    }
                }
            } else {
                var lineDif = startRow - endRow;
                var colDiff = start.column - end.column;
                for (; i < n; i++) {
                    var r = ranges[i];
                    
                    if (r.start.row > endRow)
                        break;
                        
                    if (r.end.row < endRow
                        && (
                            startRow < r.end.row 
                            || startRow == r.end.row && start.column < r.end.column
                        )
                    ) {
                        r.end.row = startRow;
                        r.end.column = start.column;
                    }
                    else if (r.end.row == endRow) {
                        if (r.end.column <= end.column) {
                            if (lineDif || r.end.column > start.column) {
                                r.end.column = start.column;
                                r.end.row = start.row;
                            }
                        }
                        else {
                            r.end.column += colDiff;
                            r.end.row += lineDif;
                        }
                    }
                    else if (r.end.row > endRow) {
                        r.end.row += lineDif;
                    }
                    
                    if (r.start.row < endRow
                        && (
                            startRow < r.start.row 
                            || startRow == r.start.row && start.column < r.start.column
                        )
                    ) {
                        r.start.row = startRow;
                        r.start.column = start.column;
                    }
                    else if (r.start.row == endRow) {
                        if (r.start.column <= end.column) {
                            if (lineDif || r.start.column > start.column) {
                                r.start.column = start.column;
                                r.start.row = start.row;
                            }
                        }
                        else {
                            r.start.column += colDiff;
                            r.start.row += lineDif;
                        }
                    }
                    else if (r.start.row > endRow) {
                        r.start.row += lineDif;
                    }
                }
            }

            if (lineDif != 0 && i < n) {
                for (; i < n; i++) {
                    var r = ranges[i];
                    r.start.row += lineDif;
                    r.end.row += lineDif;
                }
            }
        };

    }).call(RangeList.prototype);

    exports.RangeList = RangeList;
    });

    ace.define("ace/edit_session/fold",["require","exports","module","ace/range_list","ace/lib/oop"], function(require, exports, module) {

    var RangeList = require("../range_list").RangeList;
    var oop = require("../lib/oop");
    var Fold = exports.Fold = function(range, placeholder) {
        this.foldLine = null;
        this.placeholder = placeholder;
        this.range = range;
        this.start = range.start;
        this.end = range.end;

        this.sameRow = range.start.row == range.end.row;
        this.subFolds = this.ranges = [];
    };

    oop.inherits(Fold, RangeList);

    (function() {

        this.toString = function() {
            return '"' + this.placeholder + '" ' + this.range.toString();
        };

        this.setFoldLine = function(foldLine) {
            this.foldLine = foldLine;
            this.subFolds.forEach(function(fold) {
                fold.setFoldLine(foldLine);
            });
        };

        this.clone = function() {
            var range = this.range.clone();
            var fold = new Fold(range, this.placeholder);
            this.subFolds.forEach(function(subFold) {
                fold.subFolds.push(subFold.clone());
            });
            fold.collapseChildren = this.collapseChildren;
            return fold;
        };

        this.addSubFold = function(fold) {
            if (this.range.isEqual(fold))
                return;
            consumeRange(fold, this.start);

            var row = fold.start.row, column = fold.start.column;
            for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {
                cmp = this.subFolds[i].range.compare(row, column);
                if (cmp != 1)
                    break;
            }
            var afterStart = this.subFolds[i];
            var firstConsumed = 0;

            if (cmp == 0) {
                if (afterStart.range.containsRange(fold))
                    return afterStart.addSubFold(fold);
                else
                    firstConsumed = 1;
            }
            var row = fold.range.end.row, column = fold.range.end.column;
            for (var j = i, cmp = -1; j < this.subFolds.length; j++) {
                cmp = this.subFolds[j].range.compare(row, column);
                if (cmp != 1)
                    break;
            }
            if (cmp == 0)  j++;
            var consumedFolds = this.subFolds.splice(i, j - i, fold);
            var last = cmp == 0 ? consumedFolds.length - 1 : consumedFolds.length;
            for (var k = firstConsumed; k < last; k++) {
                fold.addSubFold(consumedFolds[k]);
            }
            fold.setFoldLine(this.foldLine);

            return fold;
        };
        
        this.restoreRange = function(range) {
            return restoreRange(range, this.start);
        };

    }).call(Fold.prototype);

    function consumePoint(point, anchor) {
        point.row -= anchor.row;
        if (point.row == 0)
            point.column -= anchor.column;
    }
    function consumeRange(range, anchor) {
        consumePoint(range.start, anchor);
        consumePoint(range.end, anchor);
    }
    function restorePoint(point, anchor) {
        if (point.row == 0)
            point.column += anchor.column;
        point.row += anchor.row;
    }
    function restoreRange(range, anchor) {
        restorePoint(range.start, anchor);
        restorePoint(range.end, anchor);
    }

    });

    ace.define("ace/edit_session/folding",["require","exports","module","ace/range","ace/edit_session/fold_line","ace/edit_session/fold","ace/token_iterator"], function(require, exports, module) {

    var Range = require("../range").Range;
    var FoldLine = require("./fold_line").FoldLine;
    var Fold = require("./fold").Fold;
    var TokenIterator = require("../token_iterator").TokenIterator;

    function Folding() {
        this.getFoldAt = function(row, column, side) {
            var foldLine = this.getFoldLine(row);
            if (!foldLine)
                return null;

            var folds = foldLine.folds;
            for (var i = 0; i < folds.length; i++) {
                var range = folds[i].range;
                if (range.contains(row, column)) {
                    if (side == 1 && range.isEnd(row, column) && !range.isEmpty()) {
                        continue;
                    } else if (side == -1 && range.isStart(row, column) && !range.isEmpty()) {
                        continue;
                    }
                    return folds[i];
                }
            }
        };
        this.getFoldsInRange = function(range) {
            var start = range.start;
            var end = range.end;
            var foldLines = this.$foldData;
            var foundFolds = [];

            start.column += 1;
            end.column -= 1;

            for (var i = 0; i < foldLines.length; i++) {
                var cmp = foldLines[i].range.compareRange(range);
                if (cmp == 2) {
                    continue;
                }
                else if (cmp == -2) {
                    break;
                }

                var folds = foldLines[i].folds;
                for (var j = 0; j < folds.length; j++) {
                    var fold = folds[j];
                    cmp = fold.range.compareRange(range);
                    if (cmp == -2) {
                        break;
                    } else if (cmp == 2) {
                        continue;
                    } else
                    if (cmp == 42) {
                        break;
                    }
                    foundFolds.push(fold);
                }
            }
            start.column -= 1;
            end.column += 1;

            return foundFolds;
        };

        this.getFoldsInRangeList = function(ranges) {
            if (Array.isArray(ranges)) {
                var folds = [];
                ranges.forEach(function(range) {
                    folds = folds.concat(this.getFoldsInRange(range));
                }, this);
            } else {
                var folds = this.getFoldsInRange(ranges);
            }
            return folds;
        };
        this.getAllFolds = function() {
            var folds = [];
            var foldLines = this.$foldData;
            
            for (var i = 0; i < foldLines.length; i++)
                for (var j = 0; j < foldLines[i].folds.length; j++)
                    folds.push(foldLines[i].folds[j]);

            return folds;
        };
        this.getFoldStringAt = function(row, column, trim, foldLine) {
            foldLine = foldLine || this.getFoldLine(row);
            if (!foldLine)
                return null;

            var lastFold = {
                end: { column: 0 }
            };
            var str, fold;
            for (var i = 0; i < foldLine.folds.length; i++) {
                fold = foldLine.folds[i];
                var cmp = fold.range.compareEnd(row, column);
                if (cmp == -1) {
                    str = this
                        .getLine(fold.start.row)
                        .substring(lastFold.end.column, fold.start.column);
                    break;
                }
                else if (cmp === 0) {
                    return null;
                }
                lastFold = fold;
            }
            if (!str)
                str = this.getLine(fold.start.row).substring(lastFold.end.column);

            if (trim == -1)
                return str.substring(0, column - lastFold.end.column);
            else if (trim == 1)
                return str.substring(column - lastFold.end.column);
            else
                return str;
        };

        this.getFoldLine = function(docRow, startFoldLine) {
            var foldData = this.$foldData;
            var i = 0;
            if (startFoldLine)
                i = foldData.indexOf(startFoldLine);
            if (i == -1)
                i = 0;
            for (i; i < foldData.length; i++) {
                var foldLine = foldData[i];
                if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
                    return foldLine;
                } else if (foldLine.end.row > docRow) {
                    return null;
                }
            }
            return null;
        };
        this.getNextFoldLine = function(docRow, startFoldLine) {
            var foldData = this.$foldData;
            var i = 0;
            if (startFoldLine)
                i = foldData.indexOf(startFoldLine);
            if (i == -1)
                i = 0;
            for (i; i < foldData.length; i++) {
                var foldLine = foldData[i];
                if (foldLine.end.row >= docRow) {
                    return foldLine;
                }
            }
            return null;
        };

        this.getFoldedRowCount = function(first, last) {
            var foldData = this.$foldData, rowCount = last-first+1;
            for (var i = 0; i < foldData.length; i++) {
                var foldLine = foldData[i],
                    end = foldLine.end.row,
                    start = foldLine.start.row;
                if (end >= last) {
                    if (start < last) {
                        if (start >= first)
                            rowCount -= last-start;
                        else
                            rowCount = 0; // in one fold
                    }
                    break;
                } else if (end >= first){
                    if (start >= first) // fold inside range
                        rowCount -=  end-start;
                    else
                        rowCount -=  end-first+1;
                }
            }
            return rowCount;
        };

        this.$addFoldLine = function(foldLine) {
            this.$foldData.push(foldLine);
            this.$foldData.sort(function(a, b) {
                return a.start.row - b.start.row;
            });
            return foldLine;
        };
        this.addFold = function(placeholder, range) {
            var foldData = this.$foldData;
            var added = false;
            var fold;
            
            if (placeholder instanceof Fold)
                fold = placeholder;
            else {
                fold = new Fold(range, placeholder);
                fold.collapseChildren = range.collapseChildren;
            }
            this.$clipRangeToDocument(fold.range);

            var startRow = fold.start.row;
            var startColumn = fold.start.column;
            var endRow = fold.end.row;
            var endColumn = fold.end.column;

            var startFold = this.getFoldAt(startRow, startColumn, 1);
            var endFold = this.getFoldAt(endRow, endColumn, -1);
            if (startFold && endFold == startFold)
                return startFold.addSubFold(fold);

            if (startFold && !startFold.range.isStart(startRow, startColumn))
                this.removeFold(startFold);
            
            if (endFold && !endFold.range.isEnd(endRow, endColumn))
                this.removeFold(endFold);
            var folds = this.getFoldsInRange(fold.range);
            if (folds.length > 0) {
                this.removeFolds(folds);
                folds.forEach(function(subFold) {
                    fold.addSubFold(subFold);
                });
            }

            for (var i = 0; i < foldData.length; i++) {
                var foldLine = foldData[i];
                if (endRow == foldLine.start.row) {
                    foldLine.addFold(fold);
                    added = true;
                    break;
                } else if (startRow == foldLine.end.row) {
                    foldLine.addFold(fold);
                    added = true;
                    if (!fold.sameRow) {
                        var foldLineNext = foldData[i + 1];
                        if (foldLineNext && foldLineNext.start.row == endRow) {
                            foldLine.merge(foldLineNext);
                            break;
                        }
                    }
                    break;
                } else if (endRow <= foldLine.start.row) {
                    break;
                }
            }

            if (!added)
                foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));

            if (this.$useWrapMode)
                this.$updateWrapData(foldLine.start.row, foldLine.start.row);
            else
                this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
            this.$modified = true;
            this._signal("changeFold", { data: fold, action: "add" });

            return fold;
        };

        this.addFolds = function(folds) {
            folds.forEach(function(fold) {
                this.addFold(fold);
            }, this);
        };

        this.removeFold = function(fold) {
            var foldLine = fold.foldLine;
            var startRow = foldLine.start.row;
            var endRow = foldLine.end.row;

            var foldLines = this.$foldData;
            var folds = foldLine.folds;
            if (folds.length == 1) {
                foldLines.splice(foldLines.indexOf(foldLine), 1);
            } else
            if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
                folds.pop();
                foldLine.end.row = folds[folds.length - 1].end.row;
                foldLine.end.column = folds[folds.length - 1].end.column;
            } else
            if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
                folds.shift();
                foldLine.start.row = folds[0].start.row;
                foldLine.start.column = folds[0].start.column;
            } else
            if (fold.sameRow) {
                folds.splice(folds.indexOf(fold), 1);
            } else
            {
                var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
                folds = newFoldLine.folds;
                folds.shift();
                newFoldLine.start.row = folds[0].start.row;
                newFoldLine.start.column = folds[0].start.column;
            }

            if (!this.$updating) {
                if (this.$useWrapMode)
                    this.$updateWrapData(startRow, endRow);
                else
                    this.$updateRowLengthCache(startRow, endRow);
            }
            this.$modified = true;
            this._signal("changeFold", { data: fold, action: "remove" });
        };

        this.removeFolds = function(folds) {
            var cloneFolds = [];
            for (var i = 0; i < folds.length; i++) {
                cloneFolds.push(folds[i]);
            }

            cloneFolds.forEach(function(fold) {
                this.removeFold(fold);
            }, this);
            this.$modified = true;
        };

        this.expandFold = function(fold) {
            this.removeFold(fold);
            fold.subFolds.forEach(function(subFold) {
                fold.restoreRange(subFold);
                this.addFold(subFold);
            }, this);
            if (fold.collapseChildren > 0) {
                this.foldAll(fold.start.row+1, fold.end.row, fold.collapseChildren-1);
            }
            fold.subFolds = [];
        };

        this.expandFolds = function(folds) {
            folds.forEach(function(fold) {
                this.expandFold(fold);
            }, this);
        };

        this.unfold = function(location, expandInner) {
            var range, folds;
            if (location == null) {
                range = new Range(0, 0, this.getLength(), 0);
                expandInner = true;
            } else if (typeof location == "number")
                range = new Range(location, 0, location, this.getLine(location).length);
            else if ("row" in location)
                range = Range.fromPoints(location, location);
            else
                range = location;
            
            folds = this.getFoldsInRangeList(range);
            if (expandInner) {
                this.removeFolds(folds);
            } else {
                var subFolds = folds;
                while (subFolds.length) {
                    this.expandFolds(subFolds);
                    subFolds = this.getFoldsInRangeList(range);
                }
            }
            if (folds.length)
                return folds;
        };
        this.isRowFolded = function(docRow, startFoldRow) {
            return !!this.getFoldLine(docRow, startFoldRow);
        };

        this.getRowFoldEnd = function(docRow, startFoldRow) {
            var foldLine = this.getFoldLine(docRow, startFoldRow);
            return foldLine ? foldLine.end.row : docRow;
        };

        this.getRowFoldStart = function(docRow, startFoldRow) {
            var foldLine = this.getFoldLine(docRow, startFoldRow);
            return foldLine ? foldLine.start.row : docRow;
        };

        this.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {
            if (startRow == null)
                startRow = foldLine.start.row;
            if (startColumn == null)
                startColumn = 0;
            if (endRow == null)
                endRow = foldLine.end.row;
            if (endColumn == null)
                endColumn = this.getLine(endRow).length;
            var doc = this.doc;
            var textLine = "";

            foldLine.walk(function(placeholder, row, column, lastColumn) {
                if (row < startRow)
                    return;
                if (row == startRow) {
                    if (column < startColumn)
                        return;
                    lastColumn = Math.max(startColumn, lastColumn);
                }

                if (placeholder != null) {
                    textLine += placeholder;
                } else {
                    textLine += doc.getLine(row).substring(lastColumn, column);
                }
            }, endRow, endColumn);
            return textLine;
        };

        this.getDisplayLine = function(row, endColumn, startRow, startColumn) {
            var foldLine = this.getFoldLine(row);

            if (!foldLine) {
                var line;
                line = this.doc.getLine(row);
                return line.substring(startColumn || 0, endColumn || line.length);
            } else {
                return this.getFoldDisplayLine(
                    foldLine, row, endColumn, startRow, startColumn);
            }
        };

        this.$cloneFoldData = function() {
            var fd = [];
            fd = this.$foldData.map(function(foldLine) {
                var folds = foldLine.folds.map(function(fold) {
                    return fold.clone();
                });
                return new FoldLine(fd, folds);
            });

            return fd;
        };

        this.toggleFold = function(tryToUnfold) {
            var selection = this.selection;
            var range = selection.getRange();
            var fold;
            var bracketPos;

            if (range.isEmpty()) {
                var cursor = range.start;
                fold = this.getFoldAt(cursor.row, cursor.column);

                if (fold) {
                    this.expandFold(fold);
                    return;
                } else if (bracketPos = this.findMatchingBracket(cursor)) {
                    if (range.comparePoint(bracketPos) == 1) {
                        range.end = bracketPos;
                    } else {
                        range.start = bracketPos;
                        range.start.column++;
                        range.end.column--;
                    }
                } else if (bracketPos = this.findMatchingBracket({row: cursor.row, column: cursor.column + 1})) {
                    if (range.comparePoint(bracketPos) == 1)
                        range.end = bracketPos;
                    else
                        range.start = bracketPos;

                    range.start.column++;
                } else {
                    range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
                }
            } else {
                var folds = this.getFoldsInRange(range);
                if (tryToUnfold && folds.length) {
                    this.expandFolds(folds);
                    return;
                } else if (folds.length == 1 ) {
                    fold = folds[0];
                }
            }

            if (!fold)
                fold = this.getFoldAt(range.start.row, range.start.column);

            if (fold && fold.range.toString() == range.toString()) {
                this.expandFold(fold);
                return;
            }

            var placeholder = "...";
            if (!range.isMultiLine()) {
                placeholder = this.getTextRange(range);
                if (placeholder.length < 4)
                    return;
                placeholder = placeholder.trim().substring(0, 2) + "..";
            }

            this.addFold(placeholder, range);
        };

        this.getCommentFoldRange = function(row, column, dir) {
            var iterator = new TokenIterator(this, row, column);
            var token = iterator.getCurrentToken();
            var type = token.type;
            if (token && /^comment|string/.test(type)) {
                type = type.match(/comment|string/)[0];
                if (type == "comment")
                    type += "|doc-start";
                var re = new RegExp(type);
                var range = new Range();
                if (dir != 1) {
                    do {
                        token = iterator.stepBackward();
                    } while (token && re.test(token.type));
                    iterator.stepForward();
                }
                
                range.start.row = iterator.getCurrentTokenRow();
                range.start.column = iterator.getCurrentTokenColumn() + 2;

                iterator = new TokenIterator(this, row, column);
                
                if (dir != -1) {
                    var lastRow = -1;
                    do {
                        token = iterator.stepForward();
                        if (lastRow == -1) {
                            var state = this.getState(iterator.$row);
                            if (!re.test(state))
                                lastRow = iterator.$row;
                        } else if (iterator.$row > lastRow) {
                            break;
                        }
                    } while (token && re.test(token.type));
                    token = iterator.stepBackward();
                } else
                    token = iterator.getCurrentToken();

                range.end.row = iterator.getCurrentTokenRow();
                range.end.column = iterator.getCurrentTokenColumn() + token.value.length - 2;
                return range;
            }
        };

        this.foldAll = function(startRow, endRow, depth) {
            if (depth == undefined)
                depth = 100000; // JSON.stringify doesn't hanle Infinity
            var foldWidgets = this.foldWidgets;
            if (!foldWidgets)
                return; // mode doesn't support folding
            endRow = endRow || this.getLength();
            startRow = startRow || 0;
            for (var row = startRow; row < endRow; row++) {
                if (foldWidgets[row] == null)
                    foldWidgets[row] = this.getFoldWidget(row);
                if (foldWidgets[row] != "start")
                    continue;

                var range = this.getFoldWidgetRange(row);
                if (range && range.isMultiLine()
                    && range.end.row <= endRow
                    && range.start.row >= startRow
                ) {
                    row = range.end.row;
                    try {
                        var fold = this.addFold("...", range);
                        if (fold)
                            fold.collapseChildren = depth;
                    } catch(e) {}
                }
            }
        };
        this.$foldStyles = {
            "manual": 1,
            "markbegin": 1,
            "markbeginend": 1
        };
        this.$foldStyle = "markbegin";
        this.setFoldStyle = function(style) {
            if (!this.$foldStyles[style])
                throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
            
            if (this.$foldStyle == style)
                return;

            this.$foldStyle = style;
            
            if (style == "manual")
                this.unfold();
            var mode = this.$foldMode;
            this.$setFolding(null);
            this.$setFolding(mode);
        };

        this.$setFolding = function(foldMode) {
            if (this.$foldMode == foldMode)
                return;
                
            this.$foldMode = foldMode;
            
            this.off('change', this.$updateFoldWidgets);
            this.off('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
            this._signal("changeAnnotation");
            
            if (!foldMode || this.$foldStyle == "manual") {
                this.foldWidgets = null;
                return;
            }
            
            this.foldWidgets = [];
            this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
            this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
            
            this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
            this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
            this.on('change', this.$updateFoldWidgets);
            this.on('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
        };

        this.getParentFoldRangeData = function (row, ignoreCurrent) {
            var fw = this.foldWidgets;
            if (!fw || (ignoreCurrent && fw[row]))
                return {};

            var i = row - 1, firstRange;
            while (i >= 0) {
                var c = fw[i];
                if (c == null)
                    c = fw[i] = this.getFoldWidget(i);

                if (c == "start") {
                    var range = this.getFoldWidgetRange(i);
                    if (!firstRange)
                        firstRange = range;
                    if (range && range.end.row >= row)
                        break;
                }
                i--;
            }

            return {
                range: i !== -1 && range,
                firstRange: firstRange
            };
        };

        this.onFoldWidgetClick = function(row, e) {
            e = e.domEvent;
            var options = {
                children: e.shiftKey,
                all: e.ctrlKey || e.metaKey,
                siblings: e.altKey
            };
            
            var range = this.$toggleFoldWidget(row, options);
            if (!range) {
                var el = (e.target || e.srcElement);
                if (el && /ace_fold-widget/.test(el.className))
                    el.className += " ace_invalid";
            }
        };
        
        this.$toggleFoldWidget = function(row, options) {
            if (!this.getFoldWidget)
                return;
            var type = this.getFoldWidget(row);
            var line = this.getLine(row);

            var dir = type === "end" ? -1 : 1;
            var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);

            if (fold) {
                if (options.children || options.all)
                    this.removeFold(fold);
                else
                    this.expandFold(fold);
                return fold;
            }

            var range = this.getFoldWidgetRange(row, true);
            if (range && !range.isMultiLine()) {
                fold = this.getFoldAt(range.start.row, range.start.column, 1);
                if (fold && range.isEqual(fold.range)) {
                    this.removeFold(fold);
                    return fold;
                }
            }
            
            if (options.siblings) {
                var data = this.getParentFoldRangeData(row);
                if (data.range) {
                    var startRow = data.range.start.row + 1;
                    var endRow = data.range.end.row;
                }
                this.foldAll(startRow, endRow, options.all ? 10000 : 0);
            } else if (options.children) {
                endRow = range ? range.end.row : this.getLength();
                this.foldAll(row + 1, endRow, options.all ? 10000 : 0);
            } else if (range) {
                if (options.all) 
                    range.collapseChildren = 10000;
                this.addFold("...", range);
            }
            
            return range;
        };
        
        
        
        this.toggleFoldWidget = function(toggleParent) {
            var row = this.selection.getCursor().row;
            row = this.getRowFoldStart(row);
            var range = this.$toggleFoldWidget(row, {});
            
            if (range)
                return;
            var data = this.getParentFoldRangeData(row, true);
            range = data.range || data.firstRange;
            
            if (range) {
                row = range.start.row;
                var fold = this.getFoldAt(row, this.getLine(row).length, 1);

                if (fold) {
                    this.removeFold(fold);
                } else {
                    this.addFold("...", range);
                }
            }
        };

        this.updateFoldWidgets = function(delta) {
            var firstRow = delta.start.row;
            var len = delta.end.row - firstRow;

            if (len === 0) {
                this.foldWidgets[firstRow] = null;
            } else if (delta.action == 'remove') {
                this.foldWidgets.splice(firstRow, len + 1, null);
            } else {
                var args = Array(len + 1);
                args.unshift(firstRow, 1);
                this.foldWidgets.splice.apply(this.foldWidgets, args);
            }
        };
        this.tokenizerUpdateFoldWidgets = function(e) {
            var rows = e.data;
            if (rows.first != rows.last) {
                if (this.foldWidgets.length > rows.first)
                    this.foldWidgets.splice(rows.first, this.foldWidgets.length);
            }
        };
    }

    exports.Folding = Folding;

    });

    ace.define("ace/edit_session/bracket_match",["require","exports","module","ace/token_iterator","ace/range"], function(require, exports, module) {

    var TokenIterator = require("../token_iterator").TokenIterator;
    var Range = require("../range").Range;


    function BracketMatch() {

        this.findMatchingBracket = function(position, chr) {
            if (position.column == 0) return null;

            var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column-1);
            if (charBeforeCursor == "") return null;

            var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
            if (!match)
                return null;

            if (match[1])
                return this.$findClosingBracket(match[1], position);
            else
                return this.$findOpeningBracket(match[2], position);
        };
        
        this.getBracketRange = function(pos) {
            var line = this.getLine(pos.row);
            var before = true, range;

            var chr = line.charAt(pos.column - 1);
            var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
            if (!match) {
                chr = line.charAt(pos.column);
                pos = {row: pos.row, column: pos.column + 1};
                match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
                before = false;
            }
            if (!match)
                return null;

            if (match[1]) {
                var bracketPos = this.$findClosingBracket(match[1], pos);
                if (!bracketPos)
                    return null;
                range = Range.fromPoints(pos, bracketPos);
                if (!before) {
                    range.end.column++;
                    range.start.column--;
                }
                range.cursor = range.end;
            } else {
                var bracketPos = this.$findOpeningBracket(match[2], pos);
                if (!bracketPos)
                    return null;
                range = Range.fromPoints(bracketPos, pos);
                if (!before) {
                    range.start.column++;
                    range.end.column--;
                }
                range.cursor = range.start;
            }
            
            return range;
        };
        this.getMatchingBracketRanges = function(pos) {
            var line = this.getLine(pos.row);

            var chr = line.charAt(pos.column - 1);
            var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
            if (!match) {
                chr = line.charAt(pos.column);
                pos = {row: pos.row, column: pos.column + 1};
                match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
            }

            if (!match)
                return null;

            var startRange = new Range(pos.row, pos.column - 1, pos.row, pos.column);
            var bracketPos = match[1] ? this.$findClosingBracket(match[1], pos)
                : this.$findOpeningBracket(match[2], pos);
            if (!bracketPos)
                return [startRange];
            var endRange = new Range(bracketPos.row, bracketPos.column, bracketPos.row, bracketPos.column + 1);

            return [startRange, endRange];
        };

        this.$brackets = {
            ")": "(",
            "(": ")",
            "]": "[",
            "[": "]",
            "{": "}",
            "}": "{",
            "<": ">",
            ">": "<"
        };

        this.$findOpeningBracket = function(bracket, position, typeRe) {
            var openBracket = this.$brackets[bracket];
            var depth = 1;

            var iterator = new TokenIterator(this, position.row, position.column);
            var token = iterator.getCurrentToken();
            if (!token)
                token = iterator.stepForward();
            if (!token)
                return;
            
             if (!typeRe){
                typeRe = new RegExp(
                    "(\\.?" +
                    token.type.replace(".", "\\.").replace("rparen", ".paren")
                        .replace(/\b(?:end)\b/, "(?:start|begin|end)")
                    + ")+"
                );
            }
            var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
            var value = token.value;
            
            while (true) {
            
                while (valueIndex >= 0) {
                    var chr = value.charAt(valueIndex);
                    if (chr == openBracket) {
                        depth -= 1;
                        if (depth == 0) {
                            return {row: iterator.getCurrentTokenRow(),
                                column: valueIndex + iterator.getCurrentTokenColumn()};
                        }
                    }
                    else if (chr == bracket) {
                        depth += 1;
                    }
                    valueIndex -= 1;
                }
                do {
                    token = iterator.stepBackward();
                } while (token && !typeRe.test(token.type));

                if (token == null)
                    break;
                    
                value = token.value;
                valueIndex = value.length - 1;
            }
            
            return null;
        };

        this.$findClosingBracket = function(bracket, position, typeRe) {
            var closingBracket = this.$brackets[bracket];
            var depth = 1;

            var iterator = new TokenIterator(this, position.row, position.column);
            var token = iterator.getCurrentToken();
            if (!token)
                token = iterator.stepForward();
            if (!token)
                return;

            if (!typeRe){
                typeRe = new RegExp(
                    "(\\.?" +
                    token.type.replace(".", "\\.").replace("lparen", ".paren")
                        .replace(/\b(?:start|begin)\b/, "(?:start|begin|end)")
                    + ")+"
                );
            }
            var valueIndex = position.column - iterator.getCurrentTokenColumn();

            while (true) {

                var value = token.value;
                var valueLength = value.length;
                while (valueIndex < valueLength) {
                    var chr = value.charAt(valueIndex);
                    if (chr == closingBracket) {
                        depth -= 1;
                        if (depth == 0) {
                            return {row: iterator.getCurrentTokenRow(),
                                column: valueIndex + iterator.getCurrentTokenColumn()};
                        }
                    }
                    else if (chr == bracket) {
                        depth += 1;
                    }
                    valueIndex += 1;
                }
                do {
                    token = iterator.stepForward();
                } while (token && !typeRe.test(token.type));

                if (token == null)
                    break;

                valueIndex = 0;
            }
            
            return null;
        };
    }
    exports.BracketMatch = BracketMatch;

    });

    ace.define("ace/edit_session",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/bidihandler","ace/config","ace/lib/event_emitter","ace/selection","ace/mode/text","ace/range","ace/document","ace/background_tokenizer","ace/search_highlight","ace/edit_session/folding","ace/edit_session/bracket_match"], function(require, exports, module) {

    var oop = require("./lib/oop");
    var lang = require("./lib/lang");
    var BidiHandler = require("./bidihandler").BidiHandler;
    var config = require("./config");
    var EventEmitter = require("./lib/event_emitter").EventEmitter;
    var Selection = require("./selection").Selection;
    var TextMode = require("./mode/text").Mode;
    var Range = require("./range").Range;
    var Document = require("./document").Document;
    var BackgroundTokenizer = require("./background_tokenizer").BackgroundTokenizer;
    var SearchHighlight = require("./search_highlight").SearchHighlight;

    var EditSession = function(text, mode) {
        this.$breakpoints = [];
        this.$decorations = [];
        this.$frontMarkers = {};
        this.$backMarkers = {};
        this.$markerId = 1;
        this.$undoSelect = true;

        this.$foldData = [];
        this.id = "session" + (++EditSession.$uid);
        this.$foldData.toString = function() {
            return this.join("\n");
        };
        this.on("changeFold", this.onChangeFold.bind(this));
        this.$onChange = this.onChange.bind(this);

        if (typeof text != "object" || !text.getLine)
            text = new Document(text);

        this.setDocument(text);
        this.selection = new Selection(this);
        this.$bidiHandler = new BidiHandler(this);

        config.resetOptions(this);
        this.setMode(mode);
        config._signal("session", this);
    };


    EditSession.$uid = 0;

    (function() {

        oop.implement(this, EventEmitter);
        this.setDocument = function(doc) {
            if (this.doc)
                this.doc.removeListener("change", this.$onChange);

            this.doc = doc;
            doc.on("change", this.$onChange);

            if (this.bgTokenizer)
                this.bgTokenizer.setDocument(this.getDocument());

            this.resetCaches();
        };
        this.getDocument = function() {
            return this.doc;
        };
        this.$resetRowCache = function(docRow) {
            if (!docRow) {
                this.$docRowCache = [];
                this.$screenRowCache = [];
                return;
            }
            var l = this.$docRowCache.length;
            var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
            if (l > i) {
                this.$docRowCache.splice(i, l);
                this.$screenRowCache.splice(i, l);
            }
        };

        this.$getRowCacheIndex = function(cacheArray, val) {
            var low = 0;
            var hi = cacheArray.length - 1;

            while (low <= hi) {
                var mid = (low + hi) >> 1;
                var c = cacheArray[mid];

                if (val > c)
                    low = mid + 1;
                else if (val < c)
                    hi = mid - 1;
                else
                    return mid;
            }

            return low -1;
        };

        this.resetCaches = function() {
            this.$modified = true;
            this.$wrapData = [];
            this.$rowLengthCache = [];
            this.$resetRowCache(0);
            if (this.bgTokenizer)
                this.bgTokenizer.start(0);
        };

        this.onChangeFold = function(e) {
            var fold = e.data;
            this.$resetRowCache(fold.start.row);
        };

        this.onChange = function(delta) {
            this.$modified = true;
            this.$bidiHandler.onChange(delta);
            this.$resetRowCache(delta.start.row);

            var removedFolds = this.$updateInternalDataOnChange(delta);
            if (!this.$fromUndo && this.$undoManager) {
                if (removedFolds && removedFolds.length) {
                    this.$undoManager.add({
                        action: "removeFolds",
                        folds:  removedFolds
                    }, this.mergeUndoDeltas);
                    this.mergeUndoDeltas = true;
                }
                this.$undoManager.add(delta, this.mergeUndoDeltas);
                this.mergeUndoDeltas = true;
                
                this.$informUndoManager.schedule();
            }

            this.bgTokenizer && this.bgTokenizer.$updateOnChange(delta);
            this._signal("change", delta);
        };
        this.setValue = function(text) {
            this.doc.setValue(text);
            this.selection.moveTo(0, 0);

            this.$resetRowCache(0);
            this.setUndoManager(this.$undoManager);
            this.getUndoManager().reset();
        };
        this.getValue =
        this.toString = function() {
            return this.doc.getValue();
        };
        this.getSelection = function() {
            return this.selection;
        };
        this.getState = function(row) {
            return this.bgTokenizer.getState(row);
        };
        this.getTokens = function(row) {
            return this.bgTokenizer.getTokens(row);
        };
        this.getTokenAt = function(row, column) {
            var tokens = this.bgTokenizer.getTokens(row);
            var token, c = 0;
            if (column == null) {
                var i = tokens.length - 1;
                c = this.getLine(row).length;
            } else {
                for (var i = 0; i < tokens.length; i++) {
                    c += tokens[i].value.length;
                    if (c >= column)
                        break;
                }
            }
            token = tokens[i];
            if (!token)
                return null;
            token.index = i;
            token.start = c - token.value.length;
            return token;
        };
        this.setUndoManager = function(undoManager) {
            this.$undoManager = undoManager;
            
            if (this.$informUndoManager)
                this.$informUndoManager.cancel();
            
            if (undoManager) {
                var self = this;
                undoManager.addSession(this);
                this.$syncInformUndoManager = function() {
                    self.$informUndoManager.cancel();
                    self.mergeUndoDeltas = false;
                };
                this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
            } else {
                this.$syncInformUndoManager = function() {};
            }
        };
        this.markUndoGroup = function() {
            if (this.$syncInformUndoManager)
                this.$syncInformUndoManager();
        };
        
        this.$defaultUndoManager = {
            undo: function() {},
            redo: function() {},
            hasUndo: function() {},
            hasRedo: function() {},
            reset: function() {},
            add: function() {},
            addSelection: function() {},
            startNewGroup: function() {},
            addSession: function() {}
        };
        this.getUndoManager = function() {
            return this.$undoManager || this.$defaultUndoManager;
        };
        this.getTabString = function() {
            if (this.getUseSoftTabs()) {
                return lang.stringRepeat(" ", this.getTabSize());
            } else {
                return "\t";
            }
        };
        this.setUseSoftTabs = function(val) {
            this.setOption("useSoftTabs", val);
        };
        this.getUseSoftTabs = function() {
            return this.$useSoftTabs && !this.$mode.$indentWithTabs;
        };
        this.setTabSize = function(tabSize) {
            this.setOption("tabSize", tabSize);
        };
        this.getTabSize = function() {
            return this.$tabSize;
        };
        this.isTabStop = function(position) {
            return this.$useSoftTabs && (position.column % this.$tabSize === 0);
        };
        this.setNavigateWithinSoftTabs = function (navigateWithinSoftTabs) {
            this.setOption("navigateWithinSoftTabs", navigateWithinSoftTabs);
        };
        this.getNavigateWithinSoftTabs = function() {
            return this.$navigateWithinSoftTabs;
        };

        this.$overwrite = false;
        this.setOverwrite = function(overwrite) {
            this.setOption("overwrite", overwrite);
        };
        this.getOverwrite = function() {
            return this.$overwrite;
        };
        this.toggleOverwrite = function() {
            this.setOverwrite(!this.$overwrite);
        };
        this.addGutterDecoration = function(row, className) {
            if (!this.$decorations[row])
                this.$decorations[row] = "";
            this.$decorations[row] += " " + className;
            this._signal("changeBreakpoint", {});
        };
        this.removeGutterDecoration = function(row, className) {
            this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
            this._signal("changeBreakpoint", {});
        };
        this.getBreakpoints = function() {
            return this.$breakpoints;
        };
        this.setBreakpoints = function(rows) {
            this.$breakpoints = [];
            for (var i=0; i<rows.length; i++) {
                this.$breakpoints[rows[i]] = "ace_breakpoint";
            }
            this._signal("changeBreakpoint", {});
        };
        this.clearBreakpoints = function() {
            this.$breakpoints = [];
            this._signal("changeBreakpoint", {});
        };
        this.setBreakpoint = function(row, className) {
            if (className === undefined)
                className = "ace_breakpoint";
            if (className)
                this.$breakpoints[row] = className;
            else
                delete this.$breakpoints[row];
            this._signal("changeBreakpoint", {});
        };
        this.clearBreakpoint = function(row) {
            delete this.$breakpoints[row];
            this._signal("changeBreakpoint", {});
        };
        this.addMarker = function(range, clazz, type, inFront) {
            var id = this.$markerId++;

            var marker = {
                range : range,
                type : type || "line",
                renderer: typeof type == "function" ? type : null,
                clazz : clazz,
                inFront: !!inFront,
                id: id
            };

            if (inFront) {
                this.$frontMarkers[id] = marker;
                this._signal("changeFrontMarker");
            } else {
                this.$backMarkers[id] = marker;
                this._signal("changeBackMarker");
            }

            return id;
        };
        this.addDynamicMarker = function(marker, inFront) {
            if (!marker.update)
                return;
            var id = this.$markerId++;
            marker.id = id;
            marker.inFront = !!inFront;

            if (inFront) {
                this.$frontMarkers[id] = marker;
                this._signal("changeFrontMarker");
            } else {
                this.$backMarkers[id] = marker;
                this._signal("changeBackMarker");
            }

            return marker;
        };
        this.removeMarker = function(markerId) {
            var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
            if (!marker)
                return;

            var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
            delete (markers[markerId]);
            this._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
        };
        this.getMarkers = function(inFront) {
            return inFront ? this.$frontMarkers : this.$backMarkers;
        };

        this.highlight = function(re) {
            if (!this.$searchHighlight) {
                var highlight = new SearchHighlight(null, "ace_selected-word", "text");
                this.$searchHighlight = this.addDynamicMarker(highlight);
            }
            this.$searchHighlight.setRegexp(re);
        };
        this.highlightLines = function(startRow, endRow, clazz, inFront) {
            if (typeof endRow != "number") {
                clazz = endRow;
                endRow = startRow;
            }
            if (!clazz)
                clazz = "ace_step";

            var range = new Range(startRow, 0, endRow, Infinity);
            range.id = this.addMarker(range, clazz, "fullLine", inFront);
            return range;
        };
        this.setAnnotations = function(annotations) {
            this.$annotations = annotations;
            this._signal("changeAnnotation", {});
        };
        this.getAnnotations = function() {
            return this.$annotations || [];
        };
        this.clearAnnotations = function() {
            this.setAnnotations([]);
        };
        this.$detectNewLine = function(text) {
            var match = text.match(/^.*?(\r?\n)/m);
            if (match) {
                this.$autoNewLine = match[1];
            } else {
                this.$autoNewLine = "\n";
            }
        };
        this.getWordRange = function(row, column) {
            var line = this.getLine(row);

            var inToken = false;
            if (column > 0)
                inToken = !!line.charAt(column - 1).match(this.tokenRe);

            if (!inToken)
                inToken = !!line.charAt(column).match(this.tokenRe);

            if (inToken)
                var re = this.tokenRe;
            else if (/^\s+$/.test(line.slice(column-1, column+1)))
                var re = /\s/;
            else
                var re = this.nonTokenRe;

            var start = column;
            if (start > 0) {
                do {
                    start--;
                }
                while (start >= 0 && line.charAt(start).match(re));
                start++;
            }

            var end = column;
            while (end < line.length && line.charAt(end).match(re)) {
                end++;
            }

            return new Range(row, start, row, end);
        };
        this.getAWordRange = function(row, column) {
            var wordRange = this.getWordRange(row, column);
            var line = this.getLine(wordRange.end.row);

            while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
                wordRange.end.column += 1;
            }
            return wordRange;
        };
        this.setNewLineMode = function(newLineMode) {
            this.doc.setNewLineMode(newLineMode);
        };
        this.getNewLineMode = function() {
            return this.doc.getNewLineMode();
        };
        this.setUseWorker = function(useWorker) { this.setOption("useWorker", useWorker); };
        this.getUseWorker = function() { return this.$useWorker; };
        this.onReloadTokenizer = function(e) {
            var rows = e.data;
            this.bgTokenizer.start(rows.first);
            this._signal("tokenizerUpdate", e);
        };

        this.$modes = config.$modes;
        this.$mode = null;
        this.$modeId = null;
        this.setMode = function(mode, cb) {
            if (mode && typeof mode === "object") {
                if (mode.getTokenizer)
                    return this.$onChangeMode(mode);
                var options = mode;
                var path = options.path;
            } else {
                path = mode || "ace/mode/text";
            }
            if (!this.$modes["ace/mode/text"])
                this.$modes["ace/mode/text"] = new TextMode();

            if (this.$modes[path] && !options) {
                this.$onChangeMode(this.$modes[path]);
                cb && cb();
                return;
            }
            this.$modeId = path;
            config.loadModule(["mode", path], function(m) {
                if (this.$modeId !== path)
                    return cb && cb();
                if (this.$modes[path] && !options) {
                    this.$onChangeMode(this.$modes[path]);
                } else if (m && m.Mode) {
                    m = new m.Mode(options);
                    if (!options) {
                        this.$modes[path] = m;
                        m.$id = path;
                    }
                    this.$onChangeMode(m);
                }
                cb && cb();
            }.bind(this));
            if (!this.$mode)
                this.$onChangeMode(this.$modes["ace/mode/text"], true);
        };

        this.$onChangeMode = function(mode, $isPlaceholder) {
            if (!$isPlaceholder)
                this.$modeId = mode.$id;
            if (this.$mode === mode) 
                return;

            this.$mode = mode;

            this.$stopWorker();

            if (this.$useWorker)
                this.$startWorker();

            var tokenizer = mode.getTokenizer();

            if(tokenizer.addEventListener !== undefined) {
                var onReloadTokenizer = this.onReloadTokenizer.bind(this);
                tokenizer.addEventListener("update", onReloadTokenizer);
            }

            if (!this.bgTokenizer) {
                this.bgTokenizer = new BackgroundTokenizer(tokenizer);
                var _self = this;
                this.bgTokenizer.addEventListener("update", function(e) {
                    _self._signal("tokenizerUpdate", e);
                });
            } else {
                this.bgTokenizer.setTokenizer(tokenizer);
            }

            this.bgTokenizer.setDocument(this.getDocument());

            this.tokenRe = mode.tokenRe;
            this.nonTokenRe = mode.nonTokenRe;

            
            if (!$isPlaceholder) {
                if (mode.attachToSession)
                    mode.attachToSession(this);
                this.$options.wrapMethod.set.call(this, this.$wrapMethod);
                this.$setFolding(mode.foldingRules);
                this.bgTokenizer.start(0);
                this._emit("changeMode");
            }
        };

        this.$stopWorker = function() {
            if (this.$worker) {
                this.$worker.terminate();
                this.$worker = null;
            }
        };

        this.$startWorker = function() {
            try {
                this.$worker = this.$mode.createWorker(this);
            } catch (e) {
                config.warn("Could not load worker", e);
                this.$worker = null;
            }
        };
        this.getMode = function() {
            return this.$mode;
        };

        this.$scrollTop = 0;
        this.setScrollTop = function(scrollTop) {
            if (this.$scrollTop === scrollTop || isNaN(scrollTop))
                return;

            this.$scrollTop = scrollTop;
            this._signal("changeScrollTop", scrollTop);
        };
        this.getScrollTop = function() {
            return this.$scrollTop;
        };

        this.$scrollLeft = 0;
        this.setScrollLeft = function(scrollLeft) {
            if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
                return;

            this.$scrollLeft = scrollLeft;
            this._signal("changeScrollLeft", scrollLeft);
        };
        this.getScrollLeft = function() {
            return this.$scrollLeft;
        };
        this.getScreenWidth = function() {
            this.$computeWidth();
            if (this.lineWidgets) 
                return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
            return this.screenWidth;
        };
        
        this.getLineWidgetMaxWidth = function() {
            if (this.lineWidgetsWidth != null) return this.lineWidgetsWidth;
            var width = 0;
            this.lineWidgets.forEach(function(w) {
                if (w && w.screenWidth > width)
                    width = w.screenWidth;
            });
            return this.lineWidgetWidth = width;
        };

        this.$computeWidth = function(force) {
            if (this.$modified || force) {
                this.$modified = false;

                if (this.$useWrapMode)
                    return this.screenWidth = this.$wrapLimit;

                var lines = this.doc.getAllLines();
                var cache = this.$rowLengthCache;
                var longestScreenLine = 0;
                var foldIndex = 0;
                var foldLine = this.$foldData[foldIndex];
                var foldStart = foldLine ? foldLine.start.row : Infinity;
                var len = lines.length;

                for (var i = 0; i < len; i++) {
                    if (i > foldStart) {
                        i = foldLine.end.row + 1;
                        if (i >= len)
                            break;
                        foldLine = this.$foldData[foldIndex++];
                        foldStart = foldLine ? foldLine.start.row : Infinity;
                    }

                    if (cache[i] == null)
                        cache[i] = this.$getStringScreenWidth(lines[i])[0];

                    if (cache[i] > longestScreenLine)
                        longestScreenLine = cache[i];
                }
                this.screenWidth = longestScreenLine;
            }
        };
        this.getLine = function(row) {
            return this.doc.getLine(row);
        };
        this.getLines = function(firstRow, lastRow) {
            return this.doc.getLines(firstRow, lastRow);
        };
        this.getLength = function() {
            return this.doc.getLength();
        };
        this.getTextRange = function(range) {
            return this.doc.getTextRange(range || this.selection.getRange());
        };
        this.insert = function(position, text) {
            return this.doc.insert(position, text);
        };
        this.remove = function(range) {
            return this.doc.remove(range);
        };
        this.removeFullLines = function(firstRow, lastRow){
            return this.doc.removeFullLines(firstRow, lastRow);
        };
        this.undoChanges = function(deltas, dontSelect) {
            if (!deltas.length)
                return;

            this.$fromUndo = true;
            for (var i = deltas.length - 1; i != -1; i--) {
                var delta = deltas[i];
                if (delta.action == "insert" || delta.action == "remove") {
                    this.doc.revertDelta(delta);
                } else if (delta.folds) {
                    this.addFolds(delta.folds);
                }
            }
            if (!dontSelect && this.$undoSelect) {
                if (deltas.selectionBefore)
                    this.selection.fromJSON(deltas.selectionBefore);
                else
                    this.selection.setRange(this.$getUndoSelection(deltas, true));
            }
            this.$fromUndo = false;
        };
        this.redoChanges = function(deltas, dontSelect) {
            if (!deltas.length)
                return;

            this.$fromUndo = true;
            for (var i = 0; i < deltas.length; i++) {
                var delta = deltas[i];
                if (delta.action == "insert" || delta.action == "remove") {
                    this.doc.applyDelta(delta);
                }
            }

            if (!dontSelect && this.$undoSelect) {
                if (deltas.selectionAfter)
                    this.selection.fromJSON(deltas.selectionAfter);
                else
                    this.selection.setRange(this.$getUndoSelection(deltas, false));
            }
            this.$fromUndo = false;
        };
        this.setUndoSelect = function(enable) {
            this.$undoSelect = enable;
        };

        this.$getUndoSelection = function(deltas, isUndo) {
            function isInsert(delta) {
                return isUndo ? delta.action !== "insert" : delta.action === "insert";
            }

            var range, point;

            for (var i = 0; i < deltas.length; i++) {
                var delta = deltas[i];
                if (!delta.start) continue; // skip folds
                if (!range) {
                    if (isInsert(delta)) {
                        range = Range.fromPoints(delta.start, delta.end);
                    } else {
                        range = Range.fromPoints(delta.start, delta.start);
                    }
                    continue;
                }
                
                if (isInsert(delta)) {
                    point = delta.start;
                    if (range.compare(point.row, point.column) == -1) {
                        range.setStart(point);
                    }
                    point = delta.end;
                    if (range.compare(point.row, point.column) == 1) {
                        range.setEnd(point);
                    }
                } else {
                    point = delta.start;
                    if (range.compare(point.row, point.column) == -1) {
                        range = Range.fromPoints(delta.start, delta.start);
                    }
                }
            }
            return range;
        };
        this.replace = function(range, text) {
            return this.doc.replace(range, text);
        };
        this.moveText = function(fromRange, toPosition, copy) {
            var text = this.getTextRange(fromRange);
            var folds = this.getFoldsInRange(fromRange);

            var toRange = Range.fromPoints(toPosition, toPosition);
            if (!copy) {
                this.remove(fromRange);
                var rowDiff = fromRange.start.row - fromRange.end.row;
                var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
                if (collDiff) {
                    if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)
                        toRange.start.column += collDiff;
                    if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)
                        toRange.end.column += collDiff;
                }
                if (rowDiff && toRange.start.row >= fromRange.end.row) {
                    toRange.start.row += rowDiff;
                    toRange.end.row += rowDiff;
                }
            }

            toRange.end = this.insert(toRange.start, text);
            if (folds.length) {
                var oldStart = fromRange.start;
                var newStart = toRange.start;
                var rowDiff = newStart.row - oldStart.row;
                var collDiff = newStart.column - oldStart.column;
                this.addFolds(folds.map(function(x) {
                    x = x.clone();
                    if (x.start.row == oldStart.row)
                        x.start.column += collDiff;
                    if (x.end.row == oldStart.row)
                        x.end.column += collDiff;
                    x.start.row += rowDiff;
                    x.end.row += rowDiff;
                    return x;
                }));
            }

            return toRange;
        };
        this.indentRows = function(startRow, endRow, indentString) {
            indentString = indentString.replace(/\t/g, this.getTabString());
            for (var row=startRow; row<=endRow; row++)
                this.doc.insertInLine({row: row, column: 0}, indentString);
        };
        this.outdentRows = function (range) {
            var rowRange = range.collapseRows();
            var deleteRange = new Range(0, 0, 0, 0);
            var size = this.getTabSize();

            for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
                var line = this.getLine(i);

                deleteRange.start.row = i;
                deleteRange.end.row = i;
                for (var j = 0; j < size; ++j)
                    if (line.charAt(j) != ' ')
                        break;
                if (j < size && line.charAt(j) == '\t') {
                    deleteRange.start.column = j;
                    deleteRange.end.column = j + 1;
                } else {
                    deleteRange.start.column = 0;
                    deleteRange.end.column = j;
                }
                this.remove(deleteRange);
            }
        };

        this.$moveLines = function(firstRow, lastRow, dir) {
            firstRow = this.getRowFoldStart(firstRow);
            lastRow = this.getRowFoldEnd(lastRow);
            if (dir < 0) {
                var row = this.getRowFoldStart(firstRow + dir);
                if (row < 0) return 0;
                var diff = row-firstRow;
            } else if (dir > 0) {
                var row = this.getRowFoldEnd(lastRow + dir);
                if (row > this.doc.getLength()-1) return 0;
                var diff = row-lastRow;
            } else {
                firstRow = this.$clipRowToDocument(firstRow);
                lastRow = this.$clipRowToDocument(lastRow);
                var diff = lastRow - firstRow + 1;
            }

            var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
            var folds = this.getFoldsInRange(range).map(function(x){
                x = x.clone();
                x.start.row += diff;
                x.end.row += diff;
                return x;
            });
            
            var lines = dir == 0
                ? this.doc.getLines(firstRow, lastRow)
                : this.doc.removeFullLines(firstRow, lastRow);
            this.doc.insertFullLines(firstRow+diff, lines);
            folds.length && this.addFolds(folds);
            return diff;
        };
        this.moveLinesUp = function(firstRow, lastRow) {
            return this.$moveLines(firstRow, lastRow, -1);
        };
        this.moveLinesDown = function(firstRow, lastRow) {
            return this.$moveLines(firstRow, lastRow, 1);
        };
        this.duplicateLines = function(firstRow, lastRow) {
            return this.$moveLines(firstRow, lastRow, 0);
        };


        this.$clipRowToDocument = function(row) {
            return Math.max(0, Math.min(row, this.doc.getLength()-1));
        };

        this.$clipColumnToRow = function(row, column) {
            if (column < 0)
                return 0;
            return Math.min(this.doc.getLine(row).length, column);
        };


        this.$clipPositionToDocument = function(row, column) {
            column = Math.max(0, column);

            if (row < 0) {
                row = 0;
                column = 0;
            } else {
                var len = this.doc.getLength();
                if (row >= len) {
                    row = len - 1;
                    column = this.doc.getLine(len-1).length;
                } else {
                    column = Math.min(this.doc.getLine(row).length, column);
                }
            }

            return {
                row: row,
                column: column
            };
        };

        this.$clipRangeToDocument = function(range) {
            if (range.start.row < 0) {
                range.start.row = 0;
                range.start.column = 0;
            } else {
                range.start.column = this.$clipColumnToRow(
                    range.start.row,
                    range.start.column
                );
            }

            var len = this.doc.getLength() - 1;
            if (range.end.row > len) {
                range.end.row = len;
                range.end.column = this.doc.getLine(len).length;
            } else {
                range.end.column = this.$clipColumnToRow(
                    range.end.row,
                    range.end.column
                );
            }
            return range;
        };
        this.$wrapLimit = 80;
        this.$useWrapMode = false;
        this.$wrapLimitRange = {
            min : null,
            max : null
        };
        this.setUseWrapMode = function(useWrapMode) {
            if (useWrapMode != this.$useWrapMode) {
                this.$useWrapMode = useWrapMode;
                this.$modified = true;
                this.$resetRowCache(0);
                if (useWrapMode) {
                    var len = this.getLength();
                    this.$wrapData = Array(len);
                    this.$updateWrapData(0, len - 1);
                }

                this._signal("changeWrapMode");
            }
        };
        this.getUseWrapMode = function() {
            return this.$useWrapMode;
        };
        this.setWrapLimitRange = function(min, max) {
            if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
                this.$wrapLimitRange = { min: min, max: max };
                this.$modified = true;
                this.$bidiHandler.markAsDirty();
                if (this.$useWrapMode)
                    this._signal("changeWrapMode");
            }
        };
        this.adjustWrapLimit = function(desiredLimit, $printMargin) {
            var limits = this.$wrapLimitRange;
            if (limits.max < 0)
                limits = {min: $printMargin, max: $printMargin};
            var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
            if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
                this.$wrapLimit = wrapLimit;
                this.$modified = true;
                if (this.$useWrapMode) {
                    this.$updateWrapData(0, this.getLength() - 1);
                    this.$resetRowCache(0);
                    this._signal("changeWrapLimit");
                }
                return true;
            }
            return false;
        };

        this.$constrainWrapLimit = function(wrapLimit, min, max) {
            if (min)
                wrapLimit = Math.max(min, wrapLimit);

            if (max)
                wrapLimit = Math.min(max, wrapLimit);

            return wrapLimit;
        };
        this.getWrapLimit = function() {
            return this.$wrapLimit;
        };
        this.setWrapLimit = function (limit) {
            this.setWrapLimitRange(limit, limit);
        };
        this.getWrapLimitRange = function() {
            return {
                min : this.$wrapLimitRange.min,
                max : this.$wrapLimitRange.max
            };
        };

        this.$updateInternalDataOnChange = function(delta) {
            var useWrapMode = this.$useWrapMode;
            var action = delta.action;
            var start = delta.start;
            var end = delta.end;
            var firstRow = start.row;
            var lastRow = end.row;
            var len = lastRow - firstRow;
            var removedFolds = null;
            
            this.$updating = true;
            if (len != 0) {
                if (action === "remove") {
                    this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);

                    var foldLines = this.$foldData;
                    removedFolds = this.getFoldsInRange(delta);
                    this.removeFolds(removedFolds);

                    var foldLine = this.getFoldLine(end.row);
                    var idx = 0;
                    if (foldLine) {
                        foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
                        foldLine.shiftRow(-len);

                        var foldLineBefore = this.getFoldLine(firstRow);
                        if (foldLineBefore && foldLineBefore !== foldLine) {
                            foldLineBefore.merge(foldLine);
                            foldLine = foldLineBefore;
                        }
                        idx = foldLines.indexOf(foldLine) + 1;
                    }

                    for (idx; idx < foldLines.length; idx++) {
                        var foldLine = foldLines[idx];
                        if (foldLine.start.row >= end.row) {
                            foldLine.shiftRow(-len);
                        }
                    }

                    lastRow = firstRow;
                } else {
                    var args = Array(len);
                    args.unshift(firstRow, 0);
                    var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;
                    arr.splice.apply(arr, args);
                    var foldLines = this.$foldData;
                    var foldLine = this.getFoldLine(firstRow);
                    var idx = 0;
                    if (foldLine) {
                        var cmp = foldLine.range.compareInside(start.row, start.column);
                        if (cmp == 0) {
                            foldLine = foldLine.split(start.row, start.column);
                            if (foldLine) {
                                foldLine.shiftRow(len);
                                foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
                            }
                        } else
                        if (cmp == -1) {
                            foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
                            foldLine.shiftRow(len);
                        }
                        idx = foldLines.indexOf(foldLine) + 1;
                    }

                    for (idx; idx < foldLines.length; idx++) {
                        var foldLine = foldLines[idx];
                        if (foldLine.start.row >= firstRow) {
                            foldLine.shiftRow(len);
                        }
                    }
                }
            } else {
                len = Math.abs(delta.start.column - delta.end.column);
                if (action === "remove") {
                    removedFolds = this.getFoldsInRange(delta);
                    this.removeFolds(removedFolds);

                    len = -len;
                }
                var foldLine = this.getFoldLine(firstRow);
                if (foldLine) {
                    foldLine.addRemoveChars(firstRow, start.column, len);
                }
            }

            if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
                console.error("doc.getLength() and $wrapData.length have to be the same!");
            }
            this.$updating = false;

            if (useWrapMode)
                this.$updateWrapData(firstRow, lastRow);
            else
                this.$updateRowLengthCache(firstRow, lastRow);

            return removedFolds;
        };

        this.$updateRowLengthCache = function(firstRow, lastRow, b) {
            this.$rowLengthCache[firstRow] = null;
            this.$rowLengthCache[lastRow] = null;
        };

        this.$updateWrapData = function(firstRow, lastRow) {
            var lines = this.doc.getAllLines();
            var tabSize = this.getTabSize();
            var wrapData = this.$wrapData;
            var wrapLimit = this.$wrapLimit;
            var tokens;
            var foldLine;

            var row = firstRow;
            lastRow = Math.min(lastRow, lines.length - 1);
            while (row <= lastRow) {
                foldLine = this.getFoldLine(row, foldLine);
                if (!foldLine) {
                    tokens = this.$getDisplayTokens(lines[row]);
                    wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                    row ++;
                } else {
                    tokens = [];
                    foldLine.walk(function(placeholder, row, column, lastColumn) {
                            var walkTokens;
                            if (placeholder != null) {
                                walkTokens = this.$getDisplayTokens(
                                                placeholder, tokens.length);
                                walkTokens[0] = PLACEHOLDER_START;
                                for (var i = 1; i < walkTokens.length; i++) {
                                    walkTokens[i] = PLACEHOLDER_BODY;
                                }
                            } else {
                                walkTokens = this.$getDisplayTokens(
                                    lines[row].substring(lastColumn, column),
                                    tokens.length);
                            }
                            tokens = tokens.concat(walkTokens);
                        }.bind(this),
                        foldLine.end.row,
                        lines[foldLine.end.row].length + 1
                    );

                    wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                    row = foldLine.end.row + 1;
                }
            }
        };
        var CHAR = 1,
            CHAR_EXT = 2,
            PLACEHOLDER_START = 3,
            PLACEHOLDER_BODY =  4,
            PUNCTUATION = 9,
            SPACE = 10,
            TAB = 11,
            TAB_SPACE = 12;


        this.$computeWrapSplits = function(tokens, wrapLimit, tabSize) {
            if (tokens.length == 0) {
                return [];
            }

            var splits = [];
            var displayLength = tokens.length;
            var lastSplit = 0, lastDocSplit = 0;

            var isCode = this.$wrapAsCode;

            var indentedSoftWrap = this.$indentedSoftWrap;
            var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8)
                || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);

            function getWrapIndent() {
                var indentation = 0;
                if (maxIndent === 0)
                    return indentation;
                if (indentedSoftWrap) {
                    for (var i = 0; i < tokens.length; i++) {
                        var token = tokens[i];
                        if (token == SPACE)
                            indentation += 1;
                        else if (token == TAB)
                            indentation += tabSize;
                        else if (token == TAB_SPACE)
                            continue;
                        else
                            break;
                    }
                }
                if (isCode && indentedSoftWrap !== false)
                    indentation += tabSize;
                return Math.min(indentation, maxIndent);
            }
            function addSplit(screenPos) {
                var len = screenPos - lastSplit;
                for (var i = lastSplit; i < screenPos; i++) {
                    var ch = tokens[i];
                    if (ch === 12 || ch === 2) len -= 1;
                }

                if (!splits.length) {
                    indent = getWrapIndent();
                    splits.indent = indent;
                }
                lastDocSplit += len;
                splits.push(lastDocSplit);
                lastSplit = screenPos;
            }
            var indent = 0;
            while (displayLength - lastSplit > wrapLimit - indent) {
                var split = lastSplit + wrapLimit - indent;
                if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {
                    addSplit(split);
                    continue;
                }
                if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
                    for (split; split != lastSplit - 1; split--) {
                        if (tokens[split] == PLACEHOLDER_START) {
                            break;
                        }
                    }
                    if (split > lastSplit) {
                        addSplit(split);
                        continue;
                    }
                    split = lastSplit + wrapLimit;
                    for (split; split < tokens.length; split++) {
                        if (tokens[split] != PLACEHOLDER_BODY) {
                            break;
                        }
                    }
                    if (split == tokens.length) {
                        break;  // Breaks the while-loop.
                    }
                    addSplit(split);
                    continue;
                }
                var minSplit = Math.max(split - (wrapLimit -(wrapLimit>>2)), lastSplit - 1);
                while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                    split --;
                }
                if (isCode) {
                    while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                        split --;
                    }
                    while (split > minSplit && tokens[split] == PUNCTUATION) {
                        split --;
                    }
                } else {
                    while (split > minSplit && tokens[split] < SPACE) {
                        split --;
                    }
                }
                if (split > minSplit) {
                    addSplit(++split);
                    continue;
                }
                split = lastSplit + wrapLimit;
                if (tokens[split] == CHAR_EXT)
                    split--;
                addSplit(split - indent);
            }
            return splits;
        };
        this.$getDisplayTokens = function(str, offset) {
            var arr = [];
            var tabSize;
            offset = offset || 0;

            for (var i = 0; i < str.length; i++) {
                var c = str.charCodeAt(i);
                if (c == 9) {
                    tabSize = this.getScreenTabSize(arr.length + offset);
                    arr.push(TAB);
                    for (var n = 1; n < tabSize; n++) {
                        arr.push(TAB_SPACE);
                    }
                }
                else if (c == 32) {
                    arr.push(SPACE);
                } else if((c > 39 && c < 48) || (c > 57 && c < 64)) {
                    arr.push(PUNCTUATION);
                }
                else if (c >= 0x1100 && isFullWidth(c)) {
                    arr.push(CHAR, CHAR_EXT);
                } else {
                    arr.push(CHAR);
                }
            }
            return arr;
        };
        this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
            if (maxScreenColumn == 0)
                return [0, 0];
            if (maxScreenColumn == null)
                maxScreenColumn = Infinity;
            screenColumn = screenColumn || 0;

            var c, column;
            for (column = 0; column < str.length; column++) {
                c = str.charCodeAt(column);
                if (c == 9) {
                    screenColumn += this.getScreenTabSize(screenColumn);
                }
                else if (c >= 0x1100 && isFullWidth(c)) {
                    screenColumn += 2;
                } else {
                    screenColumn += 1;
                }
                if (screenColumn > maxScreenColumn) {
                    break;
                }
            }

            return [screenColumn, column];
        };

        this.lineWidgets = null;
        this.getRowLength = function(row) {
            var h = 1;
            if (this.lineWidgets)
                h += this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
            
            if (!this.$useWrapMode || !this.$wrapData[row])
                return h;
            else
                return this.$wrapData[row].length + h;
        };
        this.getRowLineCount = function(row) {
            if (!this.$useWrapMode || !this.$wrapData[row]) {
                return 1;
            } else {
                return this.$wrapData[row].length + 1;
            }
        };

        this.getRowWrapIndent = function(screenRow) {
            if (this.$useWrapMode) {
                var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
                var splits = this.$wrapData[pos.row];
                return splits.length && splits[0] < pos.column ? splits.indent : 0;
            } else {
                return 0;
            }
        };
        this.getScreenLastRowColumn = function(screenRow) {
            var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
            return this.documentToScreenColumn(pos.row, pos.column);
        };
        this.getDocumentLastRowColumn = function(docRow, docColumn) {
            var screenRow = this.documentToScreenRow(docRow, docColumn);
            return this.getScreenLastRowColumn(screenRow);
        };
        this.getDocumentLastRowColumnPosition = function(docRow, docColumn) {
            var screenRow = this.documentToScreenRow(docRow, docColumn);
            return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
        };
        this.getRowSplitData = function(row) {
            if (!this.$useWrapMode) {
                return undefined;
            } else {
                return this.$wrapData[row];
            }
        };
        this.getScreenTabSize = function(screenColumn) {
            return this.$tabSize - (screenColumn % this.$tabSize | 0);
        };


        this.screenToDocumentRow = function(screenRow, screenColumn) {
            return this.screenToDocumentPosition(screenRow, screenColumn).row;
        };


        this.screenToDocumentColumn = function(screenRow, screenColumn) {
            return this.screenToDocumentPosition(screenRow, screenColumn).column;
        };
        this.screenToDocumentPosition = function(screenRow, screenColumn, offsetX) {
            if (screenRow < 0)
                return {row: 0, column: 0};

            var line;
            var docRow = 0;
            var docColumn = 0;
            var column;
            var row = 0;
            var rowLength = 0;

            var rowCache = this.$screenRowCache;
            var i = this.$getRowCacheIndex(rowCache, screenRow);
            var l = rowCache.length;
            if (l && i >= 0) {
                var row = rowCache[i];
                var docRow = this.$docRowCache[i];
                var doCache = screenRow > rowCache[l - 1];
            } else {
                var doCache = !l;
            }

            var maxRow = this.getLength() - 1;
            var foldLine = this.getNextFoldLine(docRow);
            var foldStart = foldLine ? foldLine.start.row : Infinity;

            while (row <= screenRow) {
                rowLength = this.getRowLength(docRow);
                if (row + rowLength > screenRow || docRow >= maxRow) {
                    break;
                } else {
                    row += rowLength;
                    docRow++;
                    if (docRow > foldStart) {
                        docRow = foldLine.end.row+1;
                        foldLine = this.getNextFoldLine(docRow, foldLine);
                        foldStart = foldLine ? foldLine.start.row : Infinity;
                    }
                }

                if (doCache) {
                    this.$docRowCache.push(docRow);
                    this.$screenRowCache.push(row);
                }
            }

            if (foldLine && foldLine.start.row <= docRow) {
                line = this.getFoldDisplayLine(foldLine);
                docRow = foldLine.start.row;
            } else if (row + rowLength <= screenRow || docRow > maxRow) {
                return {
                    row: maxRow,
                    column: this.getLine(maxRow).length
                };
            } else {
                line = this.getLine(docRow);
                foldLine = null;
            }
            var wrapIndent = 0, splitIndex = Math.floor(screenRow - row);
            if (this.$useWrapMode) {
                var splits = this.$wrapData[docRow];
                if (splits) {
                    column = splits[splitIndex];
                    if(splitIndex > 0 && splits.length) {
                        wrapIndent = splits.indent;
                        docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
                        line = line.substring(docColumn);
                    }
                }
            }

            if (offsetX !== undefined && this.$bidiHandler.isBidiRow(row + splitIndex, docRow, splitIndex))
                screenColumn = this.$bidiHandler.offsetToCol(offsetX);

            docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];
            if (this.$useWrapMode && docColumn >= column)
                docColumn = column - 1;

            if (foldLine)
                return foldLine.idxToPosition(docColumn);

            return {row: docRow, column: docColumn};
        };
        this.documentToScreenPosition = function(docRow, docColumn) {
            if (typeof docColumn === "undefined")
                var pos = this.$clipPositionToDocument(docRow.row, docRow.column);
            else
                pos = this.$clipPositionToDocument(docRow, docColumn);

            docRow = pos.row;
            docColumn = pos.column;

            var screenRow = 0;
            var foldStartRow = null;
            var fold = null;
            fold = this.getFoldAt(docRow, docColumn, 1);
            if (fold) {
                docRow = fold.start.row;
                docColumn = fold.start.column;
            }

            var rowEnd, row = 0;


            var rowCache = this.$docRowCache;
            var i = this.$getRowCacheIndex(rowCache, docRow);
            var l = rowCache.length;
            if (l && i >= 0) {
                var row = rowCache[i];
                var screenRow = this.$screenRowCache[i];
                var doCache = docRow > rowCache[l - 1];
            } else {
                var doCache = !l;
            }

            var foldLine = this.getNextFoldLine(row);
            var foldStart = foldLine ?foldLine.start.row :Infinity;

            while (row < docRow) {
                if (row >= foldStart) {
                    rowEnd = foldLine.end.row + 1;
                    if (rowEnd > docRow)
                        break;
                    foldLine = this.getNextFoldLine(rowEnd, foldLine);
                    foldStart = foldLine ?foldLine.start.row :Infinity;
                }
                else {
                    rowEnd = row + 1;
                }

                screenRow += this.getRowLength(row);
                row = rowEnd;

                if (doCache) {
                    this.$docRowCache.push(row);
                    this.$screenRowCache.push(screenRow);
                }
            }
            var textLine = "";
            if (foldLine && row >= foldStart) {
                textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
                foldStartRow = foldLine.start.row;
            } else {
                textLine = this.getLine(docRow).substring(0, docColumn);
                foldStartRow = docRow;
            }
            var wrapIndent = 0;
            if (this.$useWrapMode) {
                var wrapRow = this.$wrapData[foldStartRow];
                if (wrapRow) {
                    var screenRowOffset = 0;
                    while (textLine.length >= wrapRow[screenRowOffset]) {
                        screenRow ++;
                        screenRowOffset++;
                    }
                    textLine = textLine.substring(
                        wrapRow[screenRowOffset - 1] || 0, textLine.length
                    );
                    wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;
                }
            }
            
            if (this.lineWidgets && this.lineWidgets[row] && this.lineWidgets[row].rowsAbove)
                screenRow += this.lineWidgets[row].rowsAbove;

            return {
                row: screenRow,
                column: wrapIndent + this.$getStringScreenWidth(textLine)[0]
            };
        };
        this.documentToScreenColumn = function(row, docColumn) {
            return this.documentToScreenPosition(row, docColumn).column;
        };
        this.documentToScreenRow = function(docRow, docColumn) {
            return this.documentToScreenPosition(docRow, docColumn).row;
        };
        this.getScreenLength = function() {
            var screenRows = 0;
            var fold = null;
            if (!this.$useWrapMode) {
                screenRows = this.getLength();
                var foldData = this.$foldData;
                for (var i = 0; i < foldData.length; i++) {
                    fold = foldData[i];
                    screenRows -= fold.end.row - fold.start.row;
                }
            } else {
                var lastRow = this.$wrapData.length;
                var row = 0, i = 0;
                var fold = this.$foldData[i++];
                var foldStart = fold ? fold.start.row :Infinity;

                while (row < lastRow) {
                    var splits = this.$wrapData[row];
                    screenRows += splits ? splits.length + 1 : 1;
                    row ++;
                    if (row > foldStart) {
                        row = fold.end.row+1;
                        fold = this.$foldData[i++];
                        foldStart = fold ?fold.start.row :Infinity;
                    }
                }
            }
            if (this.lineWidgets)
                screenRows += this.$getWidgetScreenLength();

            return screenRows;
        };
        this.$setFontMetrics = function(fm) {
            if (!this.$enableVarChar) return;
            this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
                if (maxScreenColumn === 0)
                    return [0, 0];
                if (!maxScreenColumn)
                    maxScreenColumn = Infinity;
                screenColumn = screenColumn || 0;
                
                var c, column;
                for (column = 0; column < str.length; column++) {
                    c = str.charAt(column);
                    if (c === "\t") {
                        screenColumn += this.getScreenTabSize(screenColumn);
                    } else {
                        screenColumn += fm.getCharacterWidth(c);
                    }
                    if (screenColumn > maxScreenColumn) {
                        break;
                    }
                }
                
                return [screenColumn, column];
            };
        };
        
        this.destroy = function() {
            if (this.bgTokenizer) {
                this.bgTokenizer.setDocument(null);
                this.bgTokenizer = null;
            }
            this.$stopWorker();
        };

        this.isFullWidth = isFullWidth;
        function isFullWidth(c) {
            if (c < 0x1100)
                return false;
            return c >= 0x1100 && c <= 0x115F ||
                   c >= 0x11A3 && c <= 0x11A7 ||
                   c >= 0x11FA && c <= 0x11FF ||
                   c >= 0x2329 && c <= 0x232A ||
                   c >= 0x2E80 && c <= 0x2E99 ||
                   c >= 0x2E9B && c <= 0x2EF3 ||
                   c >= 0x2F00 && c <= 0x2FD5 ||
                   c >= 0x2FF0 && c <= 0x2FFB ||
                   c >= 0x3000 && c <= 0x303E ||
                   c >= 0x3041 && c <= 0x3096 ||
                   c >= 0x3099 && c <= 0x30FF ||
                   c >= 0x3105 && c <= 0x312D ||
                   c >= 0x3131 && c <= 0x318E ||
                   c >= 0x3190 && c <= 0x31BA ||
                   c >= 0x31C0 && c <= 0x31E3 ||
                   c >= 0x31F0 && c <= 0x321E ||
                   c >= 0x3220 && c <= 0x3247 ||
                   c >= 0x3250 && c <= 0x32FE ||
                   c >= 0x3300 && c <= 0x4DBF ||
                   c >= 0x4E00 && c <= 0xA48C ||
                   c >= 0xA490 && c <= 0xA4C6 ||
                   c >= 0xA960 && c <= 0xA97C ||
                   c >= 0xAC00 && c <= 0xD7A3 ||
                   c >= 0xD7B0 && c <= 0xD7C6 ||
                   c >= 0xD7CB && c <= 0xD7FB ||
                   c >= 0xF900 && c <= 0xFAFF ||
                   c >= 0xFE10 && c <= 0xFE19 ||
                   c >= 0xFE30 && c <= 0xFE52 ||
                   c >= 0xFE54 && c <= 0xFE66 ||
                   c >= 0xFE68 && c <= 0xFE6B ||
                   c >= 0xFF01 && c <= 0xFF60 ||
                   c >= 0xFFE0 && c <= 0xFFE6;
        }

    }).call(EditSession.prototype);

    require("./edit_session/folding").Folding.call(EditSession.prototype);
    require("./edit_session/bracket_match").BracketMatch.call(EditSession.prototype);


    config.defineOptions(EditSession.prototype, "session", {
        wrap: {
            set: function(value) {
                if (!value || value == "off")
                    value = false;
                else if (value == "free")
                    value = true;
                else if (value == "printMargin")
                    value = -1;
                else if (typeof value == "string")
                    value = parseInt(value, 10) || false;

                if (this.$wrap == value)
                    return;
                this.$wrap = value;
                if (!value) {
                    this.setUseWrapMode(false);
                } else {
                    var col = typeof value == "number" ? value : null;
                    this.setWrapLimitRange(col, col);
                    this.setUseWrapMode(true);
                }
            },
            get: function() {
                if (this.getUseWrapMode()) {
                    if (this.$wrap == -1)
                        return "printMargin";
                    if (!this.getWrapLimitRange().min)
                        return "free";
                    return this.$wrap;
                }
                return "off";
            },
            handlesSet: true
        },    
        wrapMethod: {
            set: function(val) {
                val = val == "auto"
                    ? this.$mode.type != "text"
                    : val != "text";
                if (val != this.$wrapAsCode) {
                    this.$wrapAsCode = val;
                    if (this.$useWrapMode) {
                        this.$useWrapMode = false;
                        this.setUseWrapMode(true);
                    }
                }
            },
            initialValue: "auto"
        },
        indentedSoftWrap: {
            set: function() {
                if (this.$useWrapMode) {
                    this.$useWrapMode = false;
                    this.setUseWrapMode(true);
                }
            },
            initialValue: true 
        },
        firstLineNumber: {
            set: function() {this._signal("changeBreakpoint");},
            initialValue: 1
        },
        useWorker: {
            set: function(useWorker) {
                this.$useWorker = useWorker;

                this.$stopWorker();
                if (useWorker)
                    this.$startWorker();
            },
            initialValue: true
        },
        useSoftTabs: {initialValue: true},
        tabSize: {
            set: function(tabSize) {
                tabSize = parseInt(tabSize);
                if (tabSize > 0 && this.$tabSize !== tabSize) {
                    this.$modified = true;
                    this.$rowLengthCache = [];
                    this.$tabSize = tabSize;
                    this._signal("changeTabSize");
                }
            },
            initialValue: 4,
            handlesSet: true
        },
        navigateWithinSoftTabs: {initialValue: false},
        foldStyle: {
            set: function(val) {this.setFoldStyle(val);},
            handlesSet: true
        },
        overwrite: {
            set: function(val) {this._signal("changeOverwrite");},
            initialValue: false
        },
        newLineMode: {
            set: function(val) {this.doc.setNewLineMode(val);},
            get: function() {return this.doc.getNewLineMode();},
            handlesSet: true
        },
        mode: {
            set: function(val) { this.setMode(val); },
            get: function() { return this.$modeId; },
            handlesSet: true
        }
    });

    exports.EditSession = EditSession;
    });

    ace.define("ace/search",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/range"], function(require, exports, module) {

    var lang = require("./lib/lang");
    var oop = require("./lib/oop");
    var Range = require("./range").Range;

    var Search = function() {
        this.$options = {};
    };

    (function() {
        this.set = function(options) {
            oop.mixin(this.$options, options);
            return this;
        };
        this.getOptions = function() {
            return lang.copyObject(this.$options);
        };
        this.setOptions = function(options) {
            this.$options = options;
        };
        this.find = function(session) {
            var options = this.$options;
            var iterator = this.$matchIterator(session, options);
            if (!iterator)
                return false;

            var firstRange = null;
            iterator.forEach(function(sr, sc, er, ec) {
                firstRange = new Range(sr, sc, er, ec);
                if (sc == ec && options.start && options.start.start
                    && options.skipCurrent != false && firstRange.isEqual(options.start)
                ) {
                    firstRange = null;
                    return false;
                }
                
                return true;
            });

            return firstRange;
        };
        this.findAll = function(session) {
            var options = this.$options;
            if (!options.needle)
                return [];
            this.$assembleRegExp(options);

            var range = options.range;
            var lines = range
                ? session.getLines(range.start.row, range.end.row)
                : session.doc.getAllLines();

            var ranges = [];
            var re = options.re;
            if (options.$isMultiLine) {
                var len = re.length;
                var maxRow = lines.length - len;
                var prevRange;
                outer: for (var row = re.offset || 0; row <= maxRow; row++) {
                    for (var j = 0; j < len; j++)
                        if (lines[row + j].search(re[j]) == -1)
                            continue outer;
                    
                    var startLine = lines[row];
                    var line = lines[row + len - 1];
                    var startIndex = startLine.length - startLine.match(re[0])[0].length;
                    var endIndex = line.match(re[len - 1])[0].length;
                    
                    if (prevRange && prevRange.end.row === row &&
                        prevRange.end.column > startIndex
                    ) {
                        continue;
                    }
                    ranges.push(prevRange = new Range(
                        row, startIndex, row + len - 1, endIndex
                    ));
                    if (len > 2)
                        row = row + len - 2;
                }
            } else {
                for (var i = 0; i < lines.length; i++) {
                    var matches = lang.getMatchOffsets(lines[i], re);
                    for (var j = 0; j < matches.length; j++) {
                        var match = matches[j];
                        ranges.push(new Range(i, match.offset, i, match.offset + match.length));
                    }
                }
            }

            if (range) {
                var startColumn = range.start.column;
                var endColumn = range.start.column;
                var i = 0, j = ranges.length - 1;
                while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == range.start.row)
                    i++;

                while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == range.end.row)
                    j--;
                
                ranges = ranges.slice(i, j + 1);
                for (i = 0, j = ranges.length; i < j; i++) {
                    ranges[i].start.row += range.start.row;
                    ranges[i].end.row += range.start.row;
                }
            }

            return ranges;
        };
        this.replace = function(input, replacement) {
            var options = this.$options;

            var re = this.$assembleRegExp(options);
            if (options.$isMultiLine)
                return replacement;

            if (!re)
                return;

            var match = re.exec(input);
            if (!match || match[0].length != input.length)
                return null;
            
            replacement = input.replace(re, replacement);
            if (options.preserveCase) {
                replacement = replacement.split("");
                for (var i = Math.min(input.length, input.length); i--; ) {
                    var ch = input[i];
                    if (ch && ch.toLowerCase() != ch)
                        replacement[i] = replacement[i].toUpperCase();
                    else
                        replacement[i] = replacement[i].toLowerCase();
                }
                replacement = replacement.join("");
            }
            
            return replacement;
        };

        this.$assembleRegExp = function(options, $disableFakeMultiline) {
            if (options.needle instanceof RegExp)
                return options.re = options.needle;

            var needle = options.needle;

            if (!options.needle)
                return options.re = false;

            if (!options.regExp)
                needle = lang.escapeRegExp(needle);

            if (options.wholeWord)
                needle = addWordBoundary(needle, options);

            var modifier = options.caseSensitive ? "gm" : "gmi";

            options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
            if (options.$isMultiLine)
                return options.re = this.$assembleMultilineRegExp(needle, modifier);

            try {
                var re = new RegExp(needle, modifier);
            } catch(e) {
                re = false;
            }
            return options.re = re;
        };

        this.$assembleMultilineRegExp = function(needle, modifier) {
            var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
            var re = [];
            for (var i = 0; i < parts.length; i++) try {
                re.push(new RegExp(parts[i], modifier));
            } catch(e) {
                return false;
            }
            return re;
        };

        this.$matchIterator = function(session, options) {
            var re = this.$assembleRegExp(options);
            if (!re)
                return false;
            var backwards = options.backwards == true;
            var skipCurrent = options.skipCurrent != false;

            var range = options.range;
            var start = options.start;
            if (!start)
                start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();
             
            if (start.start)
                start = start[skipCurrent != backwards ? "end" : "start"];

            var firstRow = range ? range.start.row : 0;
            var lastRow = range ? range.end.row : session.getLength() - 1;
            
            if (backwards) {
                var forEach = function(callback) {
                    var row = start.row;
                    if (forEachInLine(row, start.column, callback))
                        return;
                    for (row--; row >= firstRow; row--)
                        if (forEachInLine(row, Number.MAX_VALUE, callback))
                            return;
                    if (options.wrap == false)
                        return;
                    for (row = lastRow, firstRow = start.row; row >= firstRow; row--)
                        if (forEachInLine(row, Number.MAX_VALUE, callback))
                            return;
                };
            }
            else {
                var forEach = function(callback) {
                    var row = start.row;
                    if (forEachInLine(row, start.column, callback))
                        return;
                    for (row = row + 1; row <= lastRow; row++)
                        if (forEachInLine(row, 0, callback))
                            return;
                    if (options.wrap == false)
                        return;
                    for (row = firstRow, lastRow = start.row; row <= lastRow; row++)
                        if (forEachInLine(row, 0, callback))
                            return;
                };
            }
            
            if (options.$isMultiLine) {
                var len = re.length;
                var forEachInLine = function(row, offset, callback) {
                    var startRow = backwards ? row - len + 1 : row;
                    if (startRow < 0) return;
                    var line = session.getLine(startRow);
                    var startIndex = line.search(re[0]);
                    if (!backwards && startIndex < offset || startIndex === -1) return;
                    for (var i = 1; i < len; i++) {
                        line = session.getLine(startRow + i);
                        if (line.search(re[i]) == -1)
                            return;
                    }
                    var endIndex = line.match(re[len - 1])[0].length;
                    if (backwards && endIndex > offset) return;
                    if (callback(startRow, startIndex, startRow + len - 1, endIndex))
                        return true;
                };
            }
            else if (backwards) {
                var forEachInLine = function(row, endIndex, callback) {
                    var line = session.getLine(row);
                    var matches = [];
                    var m, last = 0;
                    re.lastIndex = 0;
                    while((m = re.exec(line))) {
                        var length = m[0].length;
                        last = m.index;
                        if (!length) {
                            if (last >= line.length) break;
                            re.lastIndex = last += 1;
                        }
                        if (m.index + length > endIndex)
                            break;
                        matches.push(m.index, length);
                    }
                    for (var i = matches.length - 1; i >= 0; i -= 2) {
                        var column = matches[i - 1];
                        var length = matches[i];
                        if (callback(row, column, row, column + length))
                            return true;
                    }
                };
            }
            else {
                var forEachInLine = function(row, startIndex, callback) {
                    var line = session.getLine(row);
                    var last;
                    var m;
                    re.lastIndex = startIndex;
                    while((m = re.exec(line))) {
                        var length = m[0].length;
                        last = m.index;
                        if (callback(row, last, row,last + length))
                            return true;
                        if (!length) {
                            re.lastIndex = last += 1;
                            if (last >= line.length) return false;
                        }
                    }
                };
            }
            return {forEach: forEach};
        };

    }).call(Search.prototype);

    function addWordBoundary(needle, options) {
        function wordBoundary(c) {
            if (/\w/.test(c) || options.regExp) return "\\b";
            return "";
        }
        return wordBoundary(needle[0]) + needle
            + wordBoundary(needle[needle.length - 1]);
    }

    exports.Search = Search;
    });

    ace.define("ace/keyboard/hash_handler",["require","exports","module","ace/lib/keys","ace/lib/useragent"], function(require, exports, module) {

    var keyUtil = require("../lib/keys");
    var useragent = require("../lib/useragent");
    var KEY_MODS = keyUtil.KEY_MODS;

    function HashHandler(config, platform) {
        this.platform = platform || (useragent.isMac ? "mac" : "win");
        this.commands = {};
        this.commandKeyBinding = {};
        this.addCommands(config);
        this.$singleCommand = true;
    }

    function MultiHashHandler(config, platform) {
        HashHandler.call(this, config, platform);
        this.$singleCommand = false;
    }

    MultiHashHandler.prototype = HashHandler.prototype;

    (function() {
        

        this.addCommand = function(command) {
            if (this.commands[command.name])
                this.removeCommand(command);

            this.commands[command.name] = command;

            if (command.bindKey)
                this._buildKeyHash(command);
        };

        this.removeCommand = function(command, keepCommand) {
            var name = command && (typeof command === 'string' ? command : command.name);
            command = this.commands[name];
            if (!keepCommand)
                delete this.commands[name];
            var ckb = this.commandKeyBinding;
            for (var keyId in ckb) {
                var cmdGroup = ckb[keyId];
                if (cmdGroup == command) {
                    delete ckb[keyId];
                } else if (Array.isArray(cmdGroup)) {
                    var i = cmdGroup.indexOf(command);
                    if (i != -1) {
                        cmdGroup.splice(i, 1);
                        if (cmdGroup.length == 1)
                            ckb[keyId] = cmdGroup[0];
                    }
                }
            }
        };

        this.bindKey = function(key, command, position) {
            if (typeof key == "object" && key) {
                if (position == undefined)
                    position = key.position;
                key = key[this.platform];
            }
            if (!key)
                return;
            if (typeof command == "function")
                return this.addCommand({exec: command, bindKey: key, name: command.name || key});
            
            key.split("|").forEach(function(keyPart) {
                var chain = "";
                if (keyPart.indexOf(" ") != -1) {
                    var parts = keyPart.split(/\s+/);
                    keyPart = parts.pop();
                    parts.forEach(function(keyPart) {
                        var binding = this.parseKeys(keyPart);
                        var id = KEY_MODS[binding.hashId] + binding.key;
                        chain += (chain ? " " : "") + id;
                        this._addCommandToBinding(chain, "chainKeys");
                    }, this);
                    chain += " ";
                }
                var binding = this.parseKeys(keyPart);
                var id = KEY_MODS[binding.hashId] + binding.key;
                this._addCommandToBinding(chain + id, command, position);
            }, this);
        };
        
        function getPosition(command) {
            return typeof command == "object" && command.bindKey
                && command.bindKey.position 
                || (command.isDefault ? -100 : 0);
        }
        this._addCommandToBinding = function(keyId, command, position) {
            var ckb = this.commandKeyBinding, i;
            if (!command) {
                delete ckb[keyId];
            } else if (!ckb[keyId] || this.$singleCommand) {
                ckb[keyId] = command;
            } else {
                if (!Array.isArray(ckb[keyId])) {
                    ckb[keyId] = [ckb[keyId]];
                } else if ((i = ckb[keyId].indexOf(command)) != -1) {
                    ckb[keyId].splice(i, 1);
                }
                
                if (typeof position != "number") {
                    position = getPosition(command);
                }

                var commands = ckb[keyId];
                for (i = 0; i < commands.length; i++) {
                    var other = commands[i];
                    var otherPos = getPosition(other);
                    if (otherPos > position)
                        break;
                }
                commands.splice(i, 0, command);
            }
        };

        this.addCommands = function(commands) {
            commands && Object.keys(commands).forEach(function(name) {
                var command = commands[name];
                if (!command)
                    return;
                
                if (typeof command === "string")
                    return this.bindKey(command, name);

                if (typeof command === "function")
                    command = { exec: command };

                if (typeof command !== "object")
                    return;

                if (!command.name)
                    command.name = name;

                this.addCommand(command);
            }, this);
        };

        this.removeCommands = function(commands) {
            Object.keys(commands).forEach(function(name) {
                this.removeCommand(commands[name]);
            }, this);
        };

        this.bindKeys = function(keyList) {
            Object.keys(keyList).forEach(function(key) {
                this.bindKey(key, keyList[key]);
            }, this);
        };

        this._buildKeyHash = function(command) {
            this.bindKey(command.bindKey, command);
        };
        this.parseKeys = function(keys) {
            var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(x){return x;});
            var key = parts.pop();

            var keyCode = keyUtil[key];
            if (keyUtil.FUNCTION_KEYS[keyCode])
                key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
            else if (!parts.length)
                return {key: key, hashId: -1};
            else if (parts.length == 1 && parts[0] == "shift")
                return {key: key.toUpperCase(), hashId: -1};

            var hashId = 0;
            for (var i = parts.length; i--;) {
                var modifier = keyUtil.KEY_MODS[parts[i]];
                if (modifier == null) {
                    if (typeof console != "undefined")
                        console.error("invalid modifier " + parts[i] + " in " + keys);
                    return false;
                }
                hashId |= modifier;
            }
            return {key: key, hashId: hashId};
        };

        this.findKeyCommand = function findKeyCommand(hashId, keyString) {
            var key = KEY_MODS[hashId] + keyString;
            return this.commandKeyBinding[key];
        };

        this.handleKeyboard = function(data, hashId, keyString, keyCode) {
            if (keyCode < 0) return;
            var key = KEY_MODS[hashId] + keyString;
            var command = this.commandKeyBinding[key];
            if (data.$keyChain) {
                data.$keyChain += " " + key;
                command = this.commandKeyBinding[data.$keyChain] || command;
            }
            
            if (command) {
                if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
                    data.$keyChain = data.$keyChain || key;
                    return {command: "null"};
                }
            }
            
            if (data.$keyChain) {
                if ((!hashId || hashId == 4) && keyString.length == 1)
                    data.$keyChain = data.$keyChain.slice(0, -key.length - 1); // wait for input
                else if (hashId == -1 || keyCode > 0)
                    data.$keyChain = ""; // reset keyChain
            }
            return {command: command};
        };
        
        this.getStatusText = function(editor, data) {
            return data.$keyChain || "";
        };

    }).call(HashHandler.prototype);

    exports.HashHandler = HashHandler;
    exports.MultiHashHandler = MultiHashHandler;
    });

    ace.define("ace/commands/command_manager",["require","exports","module","ace/lib/oop","ace/keyboard/hash_handler","ace/lib/event_emitter"], function(require, exports, module) {

    var oop = require("../lib/oop");
    var MultiHashHandler = require("../keyboard/hash_handler").MultiHashHandler;
    var EventEmitter = require("../lib/event_emitter").EventEmitter;

    var CommandManager = function(platform, commands) {
        MultiHashHandler.call(this, commands, platform);
        this.byName = this.commands;
        this.setDefaultHandler("exec", function(e) {
            return e.command.exec(e.editor, e.args || {});
        });
    };

    oop.inherits(CommandManager, MultiHashHandler);

    (function() {

        oop.implement(this, EventEmitter);

        this.exec = function(command, editor, args) {
            if (Array.isArray(command)) {
                for (var i = command.length; i--; ) {
                    if (this.exec(command[i], editor, args)) return true;
                }
                return false;
            }

            if (typeof command === "string")
                command = this.commands[command];

            if (!command)
                return false;

            if (editor && editor.$readOnly && !command.readOnly)
                return false;

            if (this.$checkCommandState != false && command.isAvailable && !command.isAvailable(editor))
                return false;

            var e = {editor: editor, command: command, args: args};
            e.returnValue = this._emit("exec", e);
            this._signal("afterExec", e);

            return e.returnValue === false ? false : true;
        };

        this.toggleRecording = function(editor) {
            if (this.$inReplay)
                return;

            editor && editor._emit("changeStatus");
            if (this.recording) {
                this.macro.pop();
                this.removeEventListener("exec", this.$addCommandToMacro);

                if (!this.macro.length)
                    this.macro = this.oldMacro;

                return this.recording = false;
            }
            if (!this.$addCommandToMacro) {
                this.$addCommandToMacro = function(e) {
                    this.macro.push([e.command, e.args]);
                }.bind(this);
            }

            this.oldMacro = this.macro;
            this.macro = [];
            this.on("exec", this.$addCommandToMacro);
            return this.recording = true;
        };

        this.replay = function(editor) {
            if (this.$inReplay || !this.macro)
                return;

            if (this.recording)
                return this.toggleRecording(editor);

            try {
                this.$inReplay = true;
                this.macro.forEach(function(x) {
                    if (typeof x == "string")
                        this.exec(x, editor);
                    else
                        this.exec(x[0], editor, x[1]);
                }, this);
            } finally {
                this.$inReplay = false;
            }
        };

        this.trimMacro = function(m) {
            return m.map(function(x){
                if (typeof x[0] != "string")
                    x[0] = x[0].name;
                if (!x[1])
                    x = x[0];
                return x;
            });
        };

    }).call(CommandManager.prototype);

    exports.CommandManager = CommandManager;

    });

    ace.define("ace/commands/default_commands",["require","exports","module","ace/lib/lang","ace/config","ace/range"], function(require, exports, module) {

    var lang = require("../lib/lang");
    var config = require("../config");
    var Range = require("../range").Range;

    function bindKey(win, mac) {
        return {win: win, mac: mac};
    }
    exports.commands = [{
        name: "showSettingsMenu",
        bindKey: bindKey("Ctrl-,", "Command-,"),
        exec: function(editor) {
            config.loadModule("ace/ext/settings_menu", function(module) {
                module.init(editor);
                editor.showSettingsMenu();
            });
        },
        readOnly: true
    }, {
        name: "goToNextError",
        bindKey: bindKey("Alt-E", "F4"),
        exec: function(editor) {
            config.loadModule("./ext/error_marker", function(module) {
                module.showErrorMarker(editor, 1);
            });
        },
        scrollIntoView: "animate",
        readOnly: true
    }, {
        name: "goToPreviousError",
        bindKey: bindKey("Alt-Shift-E", "Shift-F4"),
        exec: function(editor) {
            config.loadModule("./ext/error_marker", function(module) {
                module.showErrorMarker(editor, -1);
            });
        },
        scrollIntoView: "animate",
        readOnly: true
    }, {
        name: "selectall",
        description: "Select all",
        bindKey: bindKey("Ctrl-A", "Command-A"),
        exec: function(editor) { editor.selectAll(); },
        readOnly: true
    }, {
        name: "centerselection",
        description: "Center selection",
        bindKey: bindKey(null, "Ctrl-L"),
        exec: function(editor) { editor.centerSelection(); },
        readOnly: true
    }, {
        name: "gotoline",
        description: "Go to line...",
        bindKey: bindKey("Ctrl-L", "Command-L"),
        exec: function(editor, line) {
            if (typeof line === "number" && !isNaN(line))
                editor.gotoLine(line);
            editor.prompt({ $type: "gotoLine" });
        },
        readOnly: true
    }, {
        name: "fold",
        bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
        exec: function(editor) { editor.session.toggleFold(false); },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
    }, {
        name: "unfold",
        bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
        exec: function(editor) { editor.session.toggleFold(true); },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
    }, {
        name: "toggleFoldWidget",
        bindKey: bindKey("F2", "F2"),
        exec: function(editor) { editor.session.toggleFoldWidget(); },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
    }, {
        name: "toggleParentFoldWidget",
        bindKey: bindKey("Alt-F2", "Alt-F2"),
        exec: function(editor) { editor.session.toggleFoldWidget(true); },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
    }, {
        name: "foldall",
        description: "Fold all",
        bindKey: bindKey(null, "Ctrl-Command-Option-0"),
        exec: function(editor) { editor.session.foldAll(); },
        scrollIntoView: "center",
        readOnly: true
    }, {
        name: "foldOther",
        description: "Fold other",
        bindKey: bindKey("Alt-0", "Command-Option-0"),
        exec: function(editor) { 
            editor.session.foldAll();
            editor.session.unfold(editor.selection.getAllRanges());
        },
        scrollIntoView: "center",
        readOnly: true
    }, {
        name: "unfoldall",
        description: "Unfold all",
        bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
        exec: function(editor) { editor.session.unfold(); },
        scrollIntoView: "center",
        readOnly: true
    }, {
        name: "findnext",
        description: "Find next",
        bindKey: bindKey("Ctrl-K", "Command-G"),
        exec: function(editor) { editor.findNext(); },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
    }, {
        name: "findprevious",
        description: "Find previous",
        bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
        exec: function(editor) { editor.findPrevious(); },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
    }, {
        name: "selectOrFindNext",
        description: "Select or find next",
        bindKey: bindKey("Alt-K", "Ctrl-G"),
        exec: function(editor) {
            if (editor.selection.isEmpty())
                editor.selection.selectWord();
            else
                editor.findNext(); 
        },
        readOnly: true
    }, {
        name: "selectOrFindPrevious",
        description: "Select or find previous",
        bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
        exec: function(editor) { 
            if (editor.selection.isEmpty())
                editor.selection.selectWord();
            else
                editor.findPrevious();
        },
        readOnly: true
    }, {
        name: "find",
        description: "Find",
        bindKey: bindKey("Ctrl-F", "Command-F"),
        exec: function(editor) {
            config.loadModule("ace/ext/searchbox", function(e) {e.Search(editor);});
        },
        readOnly: true
    }, {
        name: "overwrite",
        description: "Overwrite",
        bindKey: "Insert",
        exec: function(editor) { editor.toggleOverwrite(); },
        readOnly: true
    }, {
        name: "selecttostart",
        description: "Select to start",
        bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Home|Command-Shift-Up"),
        exec: function(editor) { editor.getSelection().selectFileStart(); },
        multiSelectAction: "forEach",
        readOnly: true,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
    }, {
        name: "gotostart",
        description: "Go to start",
        bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
        exec: function(editor) { editor.navigateFileStart(); },
        multiSelectAction: "forEach",
        readOnly: true,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
    }, {
        name: "selectup",
        description: "Select up",
        bindKey: bindKey("Shift-Up", "Shift-Up|Ctrl-Shift-P"),
        exec: function(editor) { editor.getSelection().selectUp(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "golineup",
        description: "Go line up",
        bindKey: bindKey("Up", "Up|Ctrl-P"),
        exec: function(editor, args) { editor.navigateUp(args.times); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selecttoend",
        description: "Select to end",
        bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-End|Command-Shift-Down"),
        exec: function(editor) { editor.getSelection().selectFileEnd(); },
        multiSelectAction: "forEach",
        readOnly: true,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
    }, {
        name: "gotoend",
        description: "Go to end",
        bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
        exec: function(editor) { editor.navigateFileEnd(); },
        multiSelectAction: "forEach",
        readOnly: true,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
    }, {
        name: "selectdown",
        description: "Select down",
        bindKey: bindKey("Shift-Down", "Shift-Down|Ctrl-Shift-N"),
        exec: function(editor) { editor.getSelection().selectDown(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "golinedown",
        description: "Go line down",
        bindKey: bindKey("Down", "Down|Ctrl-N"),
        exec: function(editor, args) { editor.navigateDown(args.times); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selectwordleft",
        description: "Select word left",
        bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
        exec: function(editor) { editor.getSelection().selectWordLeft(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "gotowordleft",
        description: "Go to word left",
        bindKey: bindKey("Ctrl-Left", "Option-Left"),
        exec: function(editor) { editor.navigateWordLeft(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selecttolinestart",
        description: "Select to line start",
        bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left|Ctrl-Shift-A"),
        exec: function(editor) { editor.getSelection().selectLineStart(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "gotolinestart",
        description: "Go to line start",
        bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
        exec: function(editor) { editor.navigateLineStart(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selectleft",
        description: "Select left",
        bindKey: bindKey("Shift-Left", "Shift-Left|Ctrl-Shift-B"),
        exec: function(editor) { editor.getSelection().selectLeft(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "gotoleft",
        description: "Go to left",
        bindKey: bindKey("Left", "Left|Ctrl-B"),
        exec: function(editor, args) { editor.navigateLeft(args.times); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selectwordright",
        description: "Select word right",
        bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
        exec: function(editor) { editor.getSelection().selectWordRight(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "gotowordright",
        description: "Go to word right",
        bindKey: bindKey("Ctrl-Right", "Option-Right"),
        exec: function(editor) { editor.navigateWordRight(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selecttolineend",
        description: "Select to line end",
        bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right|Shift-End|Ctrl-Shift-E"),
        exec: function(editor) { editor.getSelection().selectLineEnd(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "gotolineend",
        description: "Go to line end",
        bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
        exec: function(editor) { editor.navigateLineEnd(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selectright",
        description: "Select right",
        bindKey: bindKey("Shift-Right", "Shift-Right"),
        exec: function(editor) { editor.getSelection().selectRight(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "gotoright",
        description: "Go to right",
        bindKey: bindKey("Right", "Right|Ctrl-F"),
        exec: function(editor, args) { editor.navigateRight(args.times); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selectpagedown",
        description: "Select page down",
        bindKey: "Shift-PageDown",
        exec: function(editor) { editor.selectPageDown(); },
        readOnly: true
    }, {
        name: "pagedown",
        description: "Page down",
        bindKey: bindKey(null, "Option-PageDown"),
        exec: function(editor) { editor.scrollPageDown(); },
        readOnly: true
    }, {
        name: "gotopagedown",
        description: "Go to page down",
        bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
        exec: function(editor) { editor.gotoPageDown(); },
        readOnly: true
    }, {
        name: "selectpageup",
        description: "Select page up",
        bindKey: "Shift-PageUp",
        exec: function(editor) { editor.selectPageUp(); },
        readOnly: true
    }, {
        name: "pageup",
        description: "Page up",
        bindKey: bindKey(null, "Option-PageUp"),
        exec: function(editor) { editor.scrollPageUp(); },
        readOnly: true
    }, {
        name: "gotopageup",
        description: "Go to page up",
        bindKey: "PageUp",
        exec: function(editor) { editor.gotoPageUp(); },
        readOnly: true
    }, {
        name: "scrollup",
        description: "Scroll up",
        bindKey: bindKey("Ctrl-Up", null),
        exec: function(e) { e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight); },
        readOnly: true
    }, {
        name: "scrolldown",
        description: "Scroll down",
        bindKey: bindKey("Ctrl-Down", null),
        exec: function(e) { e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight); },
        readOnly: true
    }, {
        name: "selectlinestart",
        description: "Select line start",
        bindKey: "Shift-Home",
        exec: function(editor) { editor.getSelection().selectLineStart(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selectlineend",
        description: "Select line end",
        bindKey: "Shift-End",
        exec: function(editor) { editor.getSelection().selectLineEnd(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "togglerecording",
        description: "Toggle recording",
        bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
        exec: function(editor) { editor.commands.toggleRecording(editor); },
        readOnly: true
    }, {
        name: "replaymacro",
        description: "Replay macro",
        bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
        exec: function(editor) { editor.commands.replay(editor); },
        readOnly: true
    }, {
        name: "jumptomatching",
        description: "Jump to matching",
        bindKey: bindKey("Ctrl-\\|Ctrl-P", "Command-\\"),
        exec: function(editor) { editor.jumpToMatching(); },
        multiSelectAction: "forEach",
        scrollIntoView: "animate",
        readOnly: true
    }, {
        name: "selecttomatching",
        description: "Select to matching",
        bindKey: bindKey("Ctrl-Shift-\\|Ctrl-Shift-P", "Command-Shift-\\"),
        exec: function(editor) { editor.jumpToMatching(true); },
        multiSelectAction: "forEach",
        scrollIntoView: "animate",
        readOnly: true
    }, {
        name: "expandToMatching",
        description: "Expand to matching",
        bindKey: bindKey("Ctrl-Shift-M", "Ctrl-Shift-M"),
        exec: function(editor) { editor.jumpToMatching(true, true); },
        multiSelectAction: "forEach",
        scrollIntoView: "animate",
        readOnly: true
    }, {
        name: "passKeysToBrowser",
        description: "Pass keys to browser",
        bindKey: bindKey(null, null),
        exec: function() {},
        passEvent: true,
        readOnly: true
    }, {
        name: "copy",
        description: "Copy",
        exec: function(editor) {
        },
        readOnly: true
    },
    {
        name: "cut",
        description: "Cut",
        exec: function(editor) {
            var cutLine = editor.$copyWithEmptySelection && editor.selection.isEmpty();
            var range = cutLine ? editor.selection.getLineRange() : editor.selection.getRange();
            editor._emit("cut", range);

            if (!range.isEmpty())
                editor.session.remove(range);
            editor.clearSelection();
        },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
    }, {
        name: "paste",
        description: "Paste",
        exec: function(editor, args) {
            editor.$handlePaste(args);
        },
        scrollIntoView: "cursor"
    }, {
        name: "removeline",
        description: "Remove line",
        bindKey: bindKey("Ctrl-D", "Command-D"),
        exec: function(editor) { editor.removeLines(); },
        scrollIntoView: "cursor",
        multiSelectAction: "forEachLine"
    }, {
        name: "duplicateSelection",
        description: "Duplicate selection",
        bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
        exec: function(editor) { editor.duplicateSelection(); },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
    }, {
        name: "sortlines",
        description: "Sort lines",
        bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
        exec: function(editor) { editor.sortLines(); },
        scrollIntoView: "selection",
        multiSelectAction: "forEachLine"
    }, {
        name: "togglecomment",
        description: "Toggle comment",
        bindKey: bindKey("Ctrl-/", "Command-/"),
        exec: function(editor) { editor.toggleCommentLines(); },
        multiSelectAction: "forEachLine",
        scrollIntoView: "selectionPart"
    }, {
        name: "toggleBlockComment",
        description: "Toggle block comment",
        bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
        exec: function(editor) { editor.toggleBlockComment(); },
        multiSelectAction: "forEach",
        scrollIntoView: "selectionPart"
    }, {
        name: "modifyNumberUp",
        description: "Modify number up",
        bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
        exec: function(editor) { editor.modifyNumber(1); },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
    }, {
        name: "modifyNumberDown",
        description: "Modify number down",
        bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
        exec: function(editor) { editor.modifyNumber(-1); },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
    }, {
        name: "replace",
        description: "Replace",
        bindKey: bindKey("Ctrl-H", "Command-Option-F"),
        exec: function(editor) {
            config.loadModule("ace/ext/searchbox", function(e) {e.Search(editor, true);});
        }
    }, {
        name: "undo",
        description: "Undo",
        bindKey: bindKey("Ctrl-Z", "Command-Z"),
        exec: function(editor) { editor.undo(); }
    }, {
        name: "redo",
        description: "Redo",
        bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
        exec: function(editor) { editor.redo(); }
    }, {
        name: "copylinesup",
        description: "Copy lines up",
        bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
        exec: function(editor) { editor.copyLinesUp(); },
        scrollIntoView: "cursor"
    }, {
        name: "movelinesup",
        description: "Move lines up",
        bindKey: bindKey("Alt-Up", "Option-Up"),
        exec: function(editor) { editor.moveLinesUp(); },
        scrollIntoView: "cursor"
    }, {
        name: "copylinesdown",
        description: "Copy lines down",
        bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
        exec: function(editor) { editor.copyLinesDown(); },
        scrollIntoView: "cursor"
    }, {
        name: "movelinesdown",
        description: "Move lines down",
        bindKey: bindKey("Alt-Down", "Option-Down"),
        exec: function(editor) { editor.moveLinesDown(); },
        scrollIntoView: "cursor"
    }, {
        name: "del",
        description: "Delete",
        bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
        exec: function(editor) { editor.remove("right"); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "backspace",
        description: "Backspace",
        bindKey: bindKey(
            "Shift-Backspace|Backspace",
            "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"
        ),
        exec: function(editor) { editor.remove("left"); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "cut_or_delete",
        description: "Cut or delete",
        bindKey: bindKey("Shift-Delete", null),
        exec: function(editor) { 
            if (editor.selection.isEmpty()) {
                editor.remove("left");
            } else {
                return false;
            }
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "removetolinestart",
        description: "Remove to line start",
        bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
        exec: function(editor) { editor.removeToLineStart(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "removetolineend",
        description: "Remove to line end",
        bindKey: bindKey("Alt-Delete", "Ctrl-K|Command-Delete"),
        exec: function(editor) { editor.removeToLineEnd(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "removetolinestarthard",
        description: "Remove to line start hard",
        bindKey: bindKey("Ctrl-Shift-Backspace", null),
        exec: function(editor) {
            var range = editor.selection.getRange();
            range.start.column = 0;
            editor.session.remove(range);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "removetolineendhard",
        description: "Remove to line end hard",
        bindKey: bindKey("Ctrl-Shift-Delete", null),
        exec: function(editor) {
            var range = editor.selection.getRange();
            range.end.column = Number.MAX_VALUE;
            editor.session.remove(range);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "removewordleft",
        description: "Remove word left",
        bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
        exec: function(editor) { editor.removeWordLeft(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "removewordright",
        description: "Remove word right",
        bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
        exec: function(editor) { editor.removeWordRight(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "outdent",
        description: "Outdent",
        bindKey: bindKey("Shift-Tab", "Shift-Tab"),
        exec: function(editor) { editor.blockOutdent(); },
        multiSelectAction: "forEach",
        scrollIntoView: "selectionPart"
    }, {
        name: "indent",
        description: "Indent",
        bindKey: bindKey("Tab", "Tab"),
        exec: function(editor) { editor.indent(); },
        multiSelectAction: "forEach",
        scrollIntoView: "selectionPart"
    }, {
        name: "blockoutdent",
        description: "Block outdent",
        bindKey: bindKey("Ctrl-[", "Ctrl-["),
        exec: function(editor) { editor.blockOutdent(); },
        multiSelectAction: "forEachLine",
        scrollIntoView: "selectionPart"
    }, {
        name: "blockindent",
        description: "Block indent",
        bindKey: bindKey("Ctrl-]", "Ctrl-]"),
        exec: function(editor) { editor.blockIndent(); },
        multiSelectAction: "forEachLine",
        scrollIntoView: "selectionPart"
    }, {
        name: "insertstring",
        description: "Insert string",
        exec: function(editor, str) { editor.insert(str); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "inserttext",
        description: "Insert text",
        exec: function(editor, args) {
            editor.insert(lang.stringRepeat(args.text  || "", args.times || 1));
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "splitline",
        description: "Split line",
        bindKey: bindKey(null, "Ctrl-O"),
        exec: function(editor) { editor.splitLine(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "transposeletters",
        description: "Transpose letters",
        bindKey: bindKey("Alt-Shift-X", "Ctrl-T"),
        exec: function(editor) { editor.transposeLetters(); },
        multiSelectAction: function(editor) {editor.transposeSelections(1); },
        scrollIntoView: "cursor"
    }, {
        name: "touppercase",
        description: "To uppercase",
        bindKey: bindKey("Ctrl-U", "Ctrl-U"),
        exec: function(editor) { editor.toUpperCase(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "tolowercase",
        description: "To lowercase",
        bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
        exec: function(editor) { editor.toLowerCase(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "expandtoline",
        description: "Expand to line",
        bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
        exec: function(editor) {
            var range = editor.selection.getRange();

            range.start.column = range.end.column = 0;
            range.end.row++;
            editor.selection.setRange(range, false);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "joinlines",
        description: "Join lines",
        bindKey: bindKey(null, null),
        exec: function(editor) {
            var isBackwards = editor.selection.isBackwards();
            var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
            var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
            var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
            var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
            var selectedCount = selectedText.replace(/\n\s*/, " ").length;
            var insertLine = editor.session.doc.getLine(selectionStart.row);

            for (var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++) {
                var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));
                if (curLine.length !== 0) {
                    curLine = " " + curLine;
                }
                insertLine += curLine;
            }

            if (selectionEnd.row + 1 < (editor.session.doc.getLength() - 1)) {
                insertLine += editor.session.doc.getNewLineCharacter();
            }

            editor.clearSelection();
            editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);

            if (selectedCount > 0) {
                editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
                editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
            } else {
                firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? (firstLineEndCol + 1) : firstLineEndCol;
                editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
            }
        },
        multiSelectAction: "forEach",
        readOnly: true
    }, {
        name: "invertSelection",
        description: "Invert selection",
        bindKey: bindKey(null, null),
        exec: function(editor) {
            var endRow = editor.session.doc.getLength() - 1;
            var endCol = editor.session.doc.getLine(endRow).length;
            var ranges = editor.selection.rangeList.ranges;
            var newRanges = [];
            if (ranges.length < 1) {
                ranges = [editor.selection.getRange()];
            }

            for (var i = 0; i < ranges.length; i++) {
                if (i == (ranges.length - 1)) {
                    if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) {
                        newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));
                    }
                }

                if (i === 0) {
                    if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) {
                        newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));
                    }
                } else {
                    newRanges.push(new Range(ranges[i-1].end.row, ranges[i-1].end.column, ranges[i].start.row, ranges[i].start.column));
                }
            }

            editor.exitMultiSelectMode();
            editor.clearSelection();

            for(var i = 0; i < newRanges.length; i++) {
                editor.selection.addRange(newRanges[i], false);
            }
        },
        readOnly: true,
        scrollIntoView: "none"
    }, {
        name: "addLineAfter",
        exec: function(editor) {
            editor.selection.clearSelection();
            editor.navigateLineEnd();
            editor.insert("\n");
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "addLineBefore",
        exec: function(editor) {
            editor.selection.clearSelection();
            var cursor = editor.getCursorPosition();
            editor.selection.moveTo(cursor.row - 1, Number.MAX_VALUE);
            editor.insert("\n");
            if (cursor.row === 0) editor.navigateUp();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "openCommandPallete",
        description: "Open command pallete",
        bindKey: bindKey("F1", "F1"),
        exec: function(editor) {
            editor.prompt({ $type: "commands" });
        },
        readOnly: true
    }, {
        name: "modeSelect",
        description: "Change language mode...",
        bindKey: bindKey(null, null),
        exec: function(editor) {
            editor.prompt({ $type: "modes" });
        },
        readOnly: true
    }];

    });

    ace.define("ace/editor",["require","exports","module","ace/lib/fixoldbrowsers","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/useragent","ace/keyboard/textinput","ace/mouse/mouse_handler","ace/mouse/fold_handler","ace/keyboard/keybinding","ace/edit_session","ace/search","ace/range","ace/lib/event_emitter","ace/commands/command_manager","ace/commands/default_commands","ace/config","ace/token_iterator","ace/clipboard"], function(require, exports, module) {

    require("./lib/fixoldbrowsers");

    var oop = require("./lib/oop");
    var dom = require("./lib/dom");
    var lang = require("./lib/lang");
    var useragent = require("./lib/useragent");
    var TextInput = require("./keyboard/textinput").TextInput;
    var MouseHandler = require("./mouse/mouse_handler").MouseHandler;
    var FoldHandler = require("./mouse/fold_handler").FoldHandler;
    var KeyBinding = require("./keyboard/keybinding").KeyBinding;
    var EditSession = require("./edit_session").EditSession;
    var Search = require("./search").Search;
    var Range = require("./range").Range;
    var EventEmitter = require("./lib/event_emitter").EventEmitter;
    var CommandManager = require("./commands/command_manager").CommandManager;
    var defaultCommands = require("./commands/default_commands").commands;
    var config = require("./config");
    var TokenIterator = require("./token_iterator").TokenIterator;

    var clipboard = require("./clipboard");
    var Editor = function(renderer, session, options) {
        var container = renderer.getContainerElement();
        this.container = container;
        this.renderer = renderer;
        this.id = "editor" + (++Editor.$uid);

        this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
        if (typeof document == "object") {
            this.textInput = new TextInput(renderer.getTextAreaContainer(), this);
            this.renderer.textarea = this.textInput.getElement();
            this.$mouseHandler = new MouseHandler(this);
            new FoldHandler(this);
        }

        this.keyBinding = new KeyBinding(this);

        this.$search = new Search().set({
            wrap: true
        });

        this.$historyTracker = this.$historyTracker.bind(this);
        this.commands.on("exec", this.$historyTracker);

        this.$initOperationListeners();
        
        this._$emitInputEvent = lang.delayedCall(function() {
            this._signal("input", {});
            if (this.session && this.session.bgTokenizer)
                this.session.bgTokenizer.scheduleStart();
        }.bind(this));
        
        this.on("change", function(_, _self) {
            _self._$emitInputEvent.schedule(31);
        });

        this.setSession(session || options && options.session || new EditSession(""));
        config.resetOptions(this);
        if (options)
            this.setOptions(options);
        config._signal("editor", this);
    };

    Editor.$uid = 0;

    (function(){

        oop.implement(this, EventEmitter);

        this.$initOperationListeners = function() {
            this.commands.on("exec", this.startOperation.bind(this), true);
            this.commands.on("afterExec", this.endOperation.bind(this), true);

            this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this, true));
            this.on("change", function() {
                if (!this.curOp) {
                    this.startOperation();
                    this.curOp.selectionBefore = this.$lastSel;
                }
                this.curOp.docChanged = true;
            }.bind(this), true);
            
            this.on("changeSelection", function() {
                if (!this.curOp) {
                    this.startOperation();
                    this.curOp.selectionBefore = this.$lastSel;
                }
                this.curOp.selectionChanged = true;
            }.bind(this), true);
        };

        this.curOp = null;
        this.prevOp = {};
        this.startOperation = function(commandEvent) {
            if (this.curOp) {
                if (!commandEvent || this.curOp.command)
                    return;
                this.prevOp = this.curOp;
            }
            if (!commandEvent) {
                this.previousCommand = null;
                commandEvent = {};
            }

            this.$opResetTimer.schedule();
            this.curOp = this.session.curOp = {
                command: commandEvent.command || {},
                args: commandEvent.args,
                scrollTop: this.renderer.scrollTop
            };
            this.curOp.selectionBefore = this.selection.toJSON();
        };

        this.endOperation = function(e) {
            if (this.curOp) {
                if (e && e.returnValue === false)
                    return (this.curOp = null);
                if (e == true && this.curOp.command && this.curOp.command.name == "mouse")
                    return;
                this._signal("beforeEndOperation");
                if (!this.curOp) return;
                var command = this.curOp.command;
                var scrollIntoView = command && command.scrollIntoView;
                if (scrollIntoView) {
                    switch (scrollIntoView) {
                        case "center-animate":
                            scrollIntoView = "animate";
                        case "center":
                            this.renderer.scrollCursorIntoView(null, 0.5);
                            break;
                        case "animate":
                        case "cursor":
                            this.renderer.scrollCursorIntoView();
                            break;
                        case "selectionPart":
                            var range = this.selection.getRange();
                            var config = this.renderer.layerConfig;
                            if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {
                                this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                            }
                            break;
                    }
                    if (scrollIntoView == "animate")
                        this.renderer.animateScrolling(this.curOp.scrollTop);
                }
                var sel = this.selection.toJSON();
                this.curOp.selectionAfter = sel;
                this.$lastSel = this.selection.toJSON();
                this.session.getUndoManager().addSelection(sel);
                this.prevOp = this.curOp;
                this.curOp = null;
            }
        };
        this.$mergeableCommands = ["backspace", "del", "insertstring"];
        this.$historyTracker = function(e) {
            if (!this.$mergeUndoDeltas)
                return;

            var prev = this.prevOp;
            var mergeableCommands = this.$mergeableCommands;
            var shouldMerge = prev.command && (e.command.name == prev.command.name);
            if (e.command.name == "insertstring") {
                var text = e.args;
                if (this.mergeNextCommand === undefined)
                    this.mergeNextCommand = true;

                shouldMerge = shouldMerge
                    && this.mergeNextCommand // previous command allows to coalesce with
                    && (!/\s/.test(text) || /\s/.test(prev.args)); // previous insertion was of same type

                this.mergeNextCommand = true;
            } else {
                shouldMerge = shouldMerge
                    && mergeableCommands.indexOf(e.command.name) !== -1; // the command is mergeable
            }

            if (
                this.$mergeUndoDeltas != "always"
                && Date.now() - this.sequenceStartTime > 2000
            ) {
                shouldMerge = false; // the sequence is too long
            }

            if (shouldMerge)
                this.session.mergeUndoDeltas = true;
            else if (mergeableCommands.indexOf(e.command.name) !== -1)
                this.sequenceStartTime = Date.now();
        };
        this.setKeyboardHandler = function(keyboardHandler, cb) {
            if (keyboardHandler && typeof keyboardHandler === "string" && keyboardHandler != "ace") {
                this.$keybindingId = keyboardHandler;
                var _self = this;
                config.loadModule(["keybinding", keyboardHandler], function(module) {
                    if (_self.$keybindingId == keyboardHandler)
                        _self.keyBinding.setKeyboardHandler(module && module.handler);
                    cb && cb();
                });
            } else {
                this.$keybindingId = null;
                this.keyBinding.setKeyboardHandler(keyboardHandler);
                cb && cb();
            }
        };
        this.getKeyboardHandler = function() {
            return this.keyBinding.getKeyboardHandler();
        };
        this.setSession = function(session) {
            if (this.session == session)
                return;
            if (this.curOp) this.endOperation();
            this.curOp = {};

            var oldSession = this.session;
            if (oldSession) {
                this.session.off("change", this.$onDocumentChange);
                this.session.off("changeMode", this.$onChangeMode);
                this.session.off("tokenizerUpdate", this.$onTokenizerUpdate);
                this.session.off("changeTabSize", this.$onChangeTabSize);
                this.session.off("changeWrapLimit", this.$onChangeWrapLimit);
                this.session.off("changeWrapMode", this.$onChangeWrapMode);
                this.session.off("changeFold", this.$onChangeFold);
                this.session.off("changeFrontMarker", this.$onChangeFrontMarker);
                this.session.off("changeBackMarker", this.$onChangeBackMarker);
                this.session.off("changeBreakpoint", this.$onChangeBreakpoint);
                this.session.off("changeAnnotation", this.$onChangeAnnotation);
                this.session.off("changeOverwrite", this.$onCursorChange);
                this.session.off("changeScrollTop", this.$onScrollTopChange);
                this.session.off("changeScrollLeft", this.$onScrollLeftChange);

                var selection = this.session.getSelection();
                selection.off("changeCursor", this.$onCursorChange);
                selection.off("changeSelection", this.$onSelectionChange);
            }

            this.session = session;
            if (session) {
                this.$onDocumentChange = this.onDocumentChange.bind(this);
                session.on("change", this.$onDocumentChange);
                this.renderer.setSession(session);
        
                this.$onChangeMode = this.onChangeMode.bind(this);
                session.on("changeMode", this.$onChangeMode);
        
                this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
                session.on("tokenizerUpdate", this.$onTokenizerUpdate);
        
                this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
                session.on("changeTabSize", this.$onChangeTabSize);
        
                this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
                session.on("changeWrapLimit", this.$onChangeWrapLimit);
        
                this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
                session.on("changeWrapMode", this.$onChangeWrapMode);
        
                this.$onChangeFold = this.onChangeFold.bind(this);
                session.on("changeFold", this.$onChangeFold);
        
                this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
                this.session.on("changeFrontMarker", this.$onChangeFrontMarker);
        
                this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
                this.session.on("changeBackMarker", this.$onChangeBackMarker);
        
                this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
                this.session.on("changeBreakpoint", this.$onChangeBreakpoint);
        
                this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
                this.session.on("changeAnnotation", this.$onChangeAnnotation);
        
                this.$onCursorChange = this.onCursorChange.bind(this);
                this.session.on("changeOverwrite", this.$onCursorChange);
        
                this.$onScrollTopChange = this.onScrollTopChange.bind(this);
                this.session.on("changeScrollTop", this.$onScrollTopChange);
        
                this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
                this.session.on("changeScrollLeft", this.$onScrollLeftChange);
        
                this.selection = session.getSelection();
                this.selection.on("changeCursor", this.$onCursorChange);
        
                this.$onSelectionChange = this.onSelectionChange.bind(this);
                this.selection.on("changeSelection", this.$onSelectionChange);
        
                this.onChangeMode();
        
                this.onCursorChange();
        
                this.onScrollTopChange();
                this.onScrollLeftChange();
                this.onSelectionChange();
                this.onChangeFrontMarker();
                this.onChangeBackMarker();
                this.onChangeBreakpoint();
                this.onChangeAnnotation();
                this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
                this.renderer.updateFull();
            } else {
                this.selection = null;
                this.renderer.setSession(session);
            }

            this._signal("changeSession", {
                session: session,
                oldSession: oldSession
            });
            
            this.curOp = null;
            
            oldSession && oldSession._signal("changeEditor", {oldEditor: this});
            session && session._signal("changeEditor", {editor: this});
            
            if (session && session.bgTokenizer)
                session.bgTokenizer.scheduleStart();
        };
        this.getSession = function() {
            return this.session;
        };
        this.setValue = function(val, cursorPos) {
            this.session.doc.setValue(val);

            if (!cursorPos)
                this.selectAll();
            else if (cursorPos == 1)
                this.navigateFileEnd();
            else if (cursorPos == -1)
                this.navigateFileStart();

            return val;
        };
        this.getValue = function() {
            return this.session.getValue();
        };
        this.getSelection = function() {
            return this.selection;
        };
        this.resize = function(force) {
            this.renderer.onResize(force);
        };
        this.setTheme = function(theme, cb) {
            this.renderer.setTheme(theme, cb);
        };
        this.getTheme = function() {
            return this.renderer.getTheme();
        };
        this.setStyle = function(style) {
            this.renderer.setStyle(style);
        };
        this.unsetStyle = function(style) {
            this.renderer.unsetStyle(style);
        };
        this.getFontSize = function () {
            return this.getOption("fontSize") ||
               dom.computedStyle(this.container).fontSize;
        };
        this.setFontSize = function(size) {
            this.setOption("fontSize", size);
        };

        this.$highlightBrackets = function() {
            if (this.$highlightPending) {
                return;
            }
            var self = this;
            this.$highlightPending = true;
            setTimeout(function () {
                self.$highlightPending = false;
                var session = self.session;
                if (!session || !session.bgTokenizer) return;
                if (session.$bracketHighlight) {
                    session.$bracketHighlight.markerIds.forEach(function(id) {
                        session.removeMarker(id);
                    });
                    session.$bracketHighlight = null;
                }
                var ranges = session.getMatchingBracketRanges(self.getCursorPosition());
                if (!ranges && session.$mode.getMatching) 
                    ranges = session.$mode.getMatching(self.session);
                if (!ranges)
                    return;

                var markerType = "ace_bracket";
                if (!Array.isArray(ranges)) {
                    ranges = [ranges];
                } else if (ranges.length == 1) {
                    markerType = "ace_error_bracket";
                }
                if (ranges.length == 2) {
                    if (Range.comparePoints(ranges[0].end, ranges[1].start) == 0)
                        ranges = [Range.fromPoints(ranges[0].start, ranges[1].end)];
                    else if (Range.comparePoints(ranges[0].start, ranges[1].end) == 0)
                        ranges = [Range.fromPoints(ranges[1].start, ranges[0].end)];
                }

                session.$bracketHighlight = {
                    ranges: ranges,
                    markerIds: ranges.map(function(range) {
                        return session.addMarker(range, markerType, "text");
                    })
                };
            }, 50);
        };
        this.$highlightTags = function() {
            if (this.$highlightTagPending)
                return;
            var self = this;
            this.$highlightTagPending = true;
            setTimeout(function() {
                self.$highlightTagPending = false;
                
                var session = self.session;
                if (!session || !session.bgTokenizer) return;
                
                var pos = self.getCursorPosition();
                var iterator = new TokenIterator(self.session, pos.row, pos.column);
                var token = iterator.getCurrentToken();
                
                if (!token || !/\b(?:tag-open|tag-name)/.test(token.type)) {
                    session.removeMarker(session.$tagHighlight);
                    session.$tagHighlight = null;
                    return;
                }
                
                if (token.type.indexOf("tag-open") != -1) {
                    token = iterator.stepForward();
                    if (!token)
                        return;
                }
                
                var tag = token.value;
                var depth = 0;
                var prevToken = iterator.stepBackward();
                
                if (prevToken.value == '<'){
                    do {
                        prevToken = token;
                        token = iterator.stepForward();
                        
                        if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
                            if (prevToken.value === '<'){
                                depth++;
                            } else if (prevToken.value === '</'){
                                depth--;
                            }
                        }
                        
                    } while (token && depth >= 0);
                } else {
                    do {
                        token = prevToken;
                        prevToken = iterator.stepBackward();
                        
                        if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
                            if (prevToken.value === '<') {
                                depth++;
                            } else if (prevToken.value === '</') {
                                depth--;
                            }
                        }
                    } while (prevToken && depth <= 0);
                    iterator.stepForward();
                }
                
                if (!token) {
                    session.removeMarker(session.$tagHighlight);
                    session.$tagHighlight = null;
                    return;
                }
                
                var row = iterator.getCurrentTokenRow();
                var column = iterator.getCurrentTokenColumn();
                var range = new Range(row, column, row, column+token.value.length);
                var sbm = session.$backMarkers[session.$tagHighlight];
                if (session.$tagHighlight && sbm != undefined && range.compareRange(sbm.range) !== 0) {
                    session.removeMarker(session.$tagHighlight);
                    session.$tagHighlight = null;
                }
                
                if (!session.$tagHighlight)
                    session.$tagHighlight = session.addMarker(range, "ace_bracket", "text");
            }, 50);
        };
        this.focus = function() {
            var _self = this;
            setTimeout(function() {
                if (!_self.isFocused())
                    _self.textInput.focus();
            });
            this.textInput.focus();
        };
        this.isFocused = function() {
            return this.textInput.isFocused();
        };
        this.blur = function() {
            this.textInput.blur();
        };
        this.onFocus = function(e) {
            if (this.$isFocused)
                return;
            this.$isFocused = true;
            this.renderer.showCursor();
            this.renderer.visualizeFocus();
            this._emit("focus", e);
        };
        this.onBlur = function(e) {
            if (!this.$isFocused)
                return;
            this.$isFocused = false;
            this.renderer.hideCursor();
            this.renderer.visualizeBlur();
            this._emit("blur", e);
        };

        this.$cursorChange = function() {
            this.renderer.updateCursor();
        };
        this.onDocumentChange = function(delta) {
            var wrap = this.session.$useWrapMode;
            var lastRow = (delta.start.row == delta.end.row ? delta.end.row : Infinity);
            this.renderer.updateLines(delta.start.row, lastRow, wrap);

            this._signal("change", delta);
            this.$cursorChange();
            this.$updateHighlightActiveLine();
        };

        this.onTokenizerUpdate = function(e) {
            var rows = e.data;
            this.renderer.updateLines(rows.first, rows.last);
        };


        this.onScrollTopChange = function() {
            this.renderer.scrollToY(this.session.getScrollTop());
        };

        this.onScrollLeftChange = function() {
            this.renderer.scrollToX(this.session.getScrollLeft());
        };
        this.onCursorChange = function() {
            this.$cursorChange();

            this.$highlightBrackets();
            this.$highlightTags();
            this.$updateHighlightActiveLine();
            this._signal("changeSelection");
        };

        this.$updateHighlightActiveLine = function() {
            var session = this.getSession();

            var highlight;
            if (this.$highlightActiveLine) {
                if (this.$selectionStyle != "line" || !this.selection.isMultiLine())
                    highlight = this.getCursorPosition();
                if (this.renderer.theme && this.renderer.theme.$selectionColorConflict && !this.selection.isEmpty())
                    highlight = false;
                if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))
                    highlight = false;
            }

            if (session.$highlightLineMarker && !highlight) {
                session.removeMarker(session.$highlightLineMarker.id);
                session.$highlightLineMarker = null;
            } else if (!session.$highlightLineMarker && highlight) {
                var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
                range.id = session.addMarker(range, "ace_active-line", "screenLine");
                session.$highlightLineMarker = range;
            } else if (highlight) {
                session.$highlightLineMarker.start.row = highlight.row;
                session.$highlightLineMarker.end.row = highlight.row;
                session.$highlightLineMarker.start.column = highlight.column;
                session._signal("changeBackMarker");
            }
        };

        this.onSelectionChange = function(e) {
            var session = this.session;

            if (session.$selectionMarker) {
                session.removeMarker(session.$selectionMarker);
            }
            session.$selectionMarker = null;

            if (!this.selection.isEmpty()) {
                var range = this.selection.getRange();
                var style = this.getSelectionStyle();
                session.$selectionMarker = session.addMarker(range, "ace_selection", style);
            } else {
                this.$updateHighlightActiveLine();
            }

            var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
            this.session.highlight(re);

            this._signal("changeSelection");
        };

        this.$getSelectionHighLightRegexp = function() {
            var session = this.session;

            var selection = this.getSelectionRange();
            if (selection.isEmpty() || selection.isMultiLine())
                return;

            var startColumn = selection.start.column;
            var endColumn = selection.end.column;
            var line = session.getLine(selection.start.row);
            
            var needle = line.substring(startColumn, endColumn);
            if (needle.length > 5000 || !/[\w\d]/.test(needle))
                return;

            var re = this.$search.$assembleRegExp({
                wholeWord: true,
                caseSensitive: true,
                needle: needle
            });
            
            var wordWithBoundary = line.substring(startColumn - 1, endColumn + 1);
            if (!re.test(wordWithBoundary))
                return;
            
            return re;
        };


        this.onChangeFrontMarker = function() {
            this.renderer.updateFrontMarkers();
        };

        this.onChangeBackMarker = function() {
            this.renderer.updateBackMarkers();
        };


        this.onChangeBreakpoint = function() {
            this.renderer.updateBreakpoints();
        };

        this.onChangeAnnotation = function() {
            this.renderer.setAnnotations(this.session.getAnnotations());
        };


        this.onChangeMode = function(e) {
            this.renderer.updateText();
            this._emit("changeMode", e);
        };


        this.onChangeWrapLimit = function() {
            this.renderer.updateFull();
        };

        this.onChangeWrapMode = function() {
            this.renderer.onResize(true);
        };


        this.onChangeFold = function() {
            this.$updateHighlightActiveLine();
            this.renderer.updateFull();
        };
        this.getSelectedText = function() {
            return this.session.getTextRange(this.getSelectionRange());
        };
        this.getCopyText = function() {
            var text = this.getSelectedText();
            var nl = this.session.doc.getNewLineCharacter();
            var copyLine= false;
            if (!text && this.$copyWithEmptySelection) {
                copyLine = true;
                var ranges = this.selection.getAllRanges();
                for (var i = 0; i < ranges.length; i++) {
                    var range = ranges[i];
                    if (i && ranges[i - 1].start.row == range.start.row)
                        continue;
                    text += this.session.getLine(range.start.row) + nl;
                }
            }
            var e = {text: text};
            this._signal("copy", e);
            clipboard.lineMode = copyLine ? e.text : "";
            return e.text;
        };
        this.onCopy = function() {
            this.commands.exec("copy", this);
        };
        this.onCut = function() {
            this.commands.exec("cut", this);
        };
        this.onPaste = function(text, event) {
            var e = {text: text, event: event};
            this.commands.exec("paste", this, e);
        };
        
        this.$handlePaste = function(e) {
            if (typeof e == "string") 
                e = {text: e};
            this._signal("paste", e);
            var text = e.text;

            var lineMode = text == clipboard.lineMode;
            var session = this.session;
            if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
                if (lineMode)
                    session.insert({ row: this.selection.lead.row, column: 0 }, text);
                else
                    this.insert(text);
            } else if (lineMode) {
                this.selection.rangeList.ranges.forEach(function(range) {
                    session.insert({ row: range.start.row, column: 0 }, text);
                });
            } else {
                var lines = text.split(/\r\n|\r|\n/);
                var ranges = this.selection.rangeList.ranges;
        
                var isFullLine = lines.length == 2 && (!lines[0] || !lines[1]);
                if (lines.length != ranges.length || isFullLine)
                    return this.commands.exec("insertstring", this, text);
        
                for (var i = ranges.length; i--;) {
                    var range = ranges[i];
                    if (!range.isEmpty())
                        session.remove(range);
        
                    session.insert(range.start, lines[i]);
                }
            }
        };

        this.execCommand = function(command, args) {
            return this.commands.exec(command, this, args);
        };
        this.insert = function(text, pasted) {
            var session = this.session;
            var mode = session.getMode();
            var cursor = this.getCursorPosition();

            if (this.getBehavioursEnabled() && !pasted) {
                var transform = mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);
                if (transform) {
                    if (text !== transform.text) {
                        if (!this.inVirtualSelectionMode) {
                            this.session.mergeUndoDeltas = false;
                            this.mergeNextCommand = false;
                        }
                    }
                    text = transform.text;

                }
            }
            
            if (text == "\t")
                text = this.session.getTabString();
            if (!this.selection.isEmpty()) {
                var range = this.getSelectionRange();
                cursor = this.session.remove(range);
                this.clearSelection();
            }
            else if (this.session.getOverwrite() && text.indexOf("\n") == -1) {
                var range = new Range.fromPoints(cursor, cursor);
                range.end.column += text.length;
                this.session.remove(range);
            }

            if (text == "\n" || text == "\r\n") {
                var line = session.getLine(cursor.row);
                if (cursor.column > line.search(/\S|$/)) {
                    var d = line.substr(cursor.column).search(/\S|$/);
                    session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
                }
            }
            this.clearSelection();

            var start = cursor.column;
            var lineState = session.getState(cursor.row);
            var line = session.getLine(cursor.row);
            var shouldOutdent = mode.checkOutdent(lineState, line, text);
            session.insert(cursor, text);

            if (transform && transform.selection) {
                if (transform.selection.length == 2) { // Transform relative to the current column
                    this.selection.setSelectionRange(
                        new Range(cursor.row, start + transform.selection[0],
                                  cursor.row, start + transform.selection[1]));
                } else { // Transform relative to the current row.
                    this.selection.setSelectionRange(
                        new Range(cursor.row + transform.selection[0],
                                  transform.selection[1],
                                  cursor.row + transform.selection[2],
                                  transform.selection[3]));
                }
            }

            if (session.getDocument().isNewLine(text)) {
                var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());

                session.insert({row: cursor.row+1, column: 0}, lineIndent);
            }
            if (shouldOutdent)
                mode.autoOutdent(lineState, session, cursor.row);
        };

        this.onTextInput = function(text, composition) {
            if (!composition)
                return this.keyBinding.onTextInput(text);
            
            this.startOperation({command: { name: "insertstring" }});
            var applyComposition = this.applyComposition.bind(this, text, composition);
            if (this.selection.rangeCount)
                this.forEachSelection(applyComposition);
            else
                applyComposition();
            this.endOperation();
        };
        
        this.applyComposition = function(text, composition) {
            if (composition.extendLeft || composition.extendRight) {
                var r = this.selection.getRange();
                r.start.column -= composition.extendLeft;
                r.end.column += composition.extendRight;
                this.selection.setRange(r);
                if (!text && !r.isEmpty())
                    this.remove();
            }
            if (text || !this.selection.isEmpty())
                this.insert(text, true);
            if (composition.restoreStart || composition.restoreEnd) {
                var r = this.selection.getRange();
                r.start.column -= composition.restoreStart;
                r.end.column -= composition.restoreEnd;
                this.selection.setRange(r);
            }
        };

        this.onCommandKey = function(e, hashId, keyCode) {
            return this.keyBinding.onCommandKey(e, hashId, keyCode);
        };
        this.setOverwrite = function(overwrite) {
            this.session.setOverwrite(overwrite);
        };
        this.getOverwrite = function() {
            return this.session.getOverwrite();
        };
        this.toggleOverwrite = function() {
            this.session.toggleOverwrite();
        };
        this.setScrollSpeed = function(speed) {
            this.setOption("scrollSpeed", speed);
        };
        this.getScrollSpeed = function() {
            return this.getOption("scrollSpeed");
        };
        this.setDragDelay = function(dragDelay) {
            this.setOption("dragDelay", dragDelay);
        };
        this.getDragDelay = function() {
            return this.getOption("dragDelay");
        };
        this.setSelectionStyle = function(val) {
            this.setOption("selectionStyle", val);
        };
        this.getSelectionStyle = function() {
            return this.getOption("selectionStyle");
        };
        this.setHighlightActiveLine = function(shouldHighlight) {
            this.setOption("highlightActiveLine", shouldHighlight);
        };
        this.getHighlightActiveLine = function() {
            return this.getOption("highlightActiveLine");
        };
        this.setHighlightGutterLine = function(shouldHighlight) {
            this.setOption("highlightGutterLine", shouldHighlight);
        };

        this.getHighlightGutterLine = function() {
            return this.getOption("highlightGutterLine");
        };
        this.setHighlightSelectedWord = function(shouldHighlight) {
            this.setOption("highlightSelectedWord", shouldHighlight);
        };
        this.getHighlightSelectedWord = function() {
            return this.$highlightSelectedWord;
        };

        this.setAnimatedScroll = function(shouldAnimate){
            this.renderer.setAnimatedScroll(shouldAnimate);
        };

        this.getAnimatedScroll = function(){
            return this.renderer.getAnimatedScroll();
        };
        this.setShowInvisibles = function(showInvisibles) {
            this.renderer.setShowInvisibles(showInvisibles);
        };
        this.getShowInvisibles = function() {
            return this.renderer.getShowInvisibles();
        };

        this.setDisplayIndentGuides = function(display) {
            this.renderer.setDisplayIndentGuides(display);
        };

        this.getDisplayIndentGuides = function() {
            return this.renderer.getDisplayIndentGuides();
        };
        this.setShowPrintMargin = function(showPrintMargin) {
            this.renderer.setShowPrintMargin(showPrintMargin);
        };
        this.getShowPrintMargin = function() {
            return this.renderer.getShowPrintMargin();
        };
        this.setPrintMarginColumn = function(showPrintMargin) {
            this.renderer.setPrintMarginColumn(showPrintMargin);
        };
        this.getPrintMarginColumn = function() {
            return this.renderer.getPrintMarginColumn();
        };
        this.setReadOnly = function(readOnly) {
            this.setOption("readOnly", readOnly);
        };
        this.getReadOnly = function() {
            return this.getOption("readOnly");
        };
        this.setBehavioursEnabled = function (enabled) {
            this.setOption("behavioursEnabled", enabled);
        };
        this.getBehavioursEnabled = function () {
            return this.getOption("behavioursEnabled");
        };
        this.setWrapBehavioursEnabled = function (enabled) {
            this.setOption("wrapBehavioursEnabled", enabled);
        };
        this.getWrapBehavioursEnabled = function () {
            return this.getOption("wrapBehavioursEnabled");
        };
        this.setShowFoldWidgets = function(show) {
            this.setOption("showFoldWidgets", show);

        };
        this.getShowFoldWidgets = function() {
            return this.getOption("showFoldWidgets");
        };

        this.setFadeFoldWidgets = function(fade) {
            this.setOption("fadeFoldWidgets", fade);
        };

        this.getFadeFoldWidgets = function() {
            return this.getOption("fadeFoldWidgets");
        };
        this.remove = function(dir) {
            if (this.selection.isEmpty()){
                if (dir == "left")
                    this.selection.selectLeft();
                else
                    this.selection.selectRight();
            }

            var range = this.getSelectionRange();
            if (this.getBehavioursEnabled()) {
                var session = this.session;
                var state = session.getState(range.start.row);
                var new_range = session.getMode().transformAction(state, 'deletion', this, session, range);

                if (range.end.column === 0) {
                    var text = session.getTextRange(range);
                    if (text[text.length - 1] == "\n") {
                        var line = session.getLine(range.end.row);
                        if (/^\s+$/.test(line)) {
                            range.end.column = line.length;
                        }
                    }
                }
                if (new_range)
                    range = new_range;
            }

            this.session.remove(range);
            this.clearSelection();
        };
        this.removeWordRight = function() {
            if (this.selection.isEmpty())
                this.selection.selectWordRight();

            this.session.remove(this.getSelectionRange());
            this.clearSelection();
        };
        this.removeWordLeft = function() {
            if (this.selection.isEmpty())
                this.selection.selectWordLeft();

            this.session.remove(this.getSelectionRange());
            this.clearSelection();
        };
        this.removeToLineStart = function() {
            if (this.selection.isEmpty())
                this.selection.selectLineStart();
            if (this.selection.isEmpty())
                this.selection.selectLeft();
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
        };
        this.removeToLineEnd = function() {
            if (this.selection.isEmpty())
                this.selection.selectLineEnd();

            var range = this.getSelectionRange();
            if (range.start.column == range.end.column && range.start.row == range.end.row) {
                range.end.column = 0;
                range.end.row++;
            }

            this.session.remove(range);
            this.clearSelection();
        };
        this.splitLine = function() {
            if (!this.selection.isEmpty()) {
                this.session.remove(this.getSelectionRange());
                this.clearSelection();
            }

            var cursor = this.getCursorPosition();
            this.insert("\n");
            this.moveCursorToPosition(cursor);
        };
        this.transposeLetters = function() {
            if (!this.selection.isEmpty()) {
                return;
            }

            var cursor = this.getCursorPosition();
            var column = cursor.column;
            if (column === 0)
                return;

            var line = this.session.getLine(cursor.row);
            var swap, range;
            if (column < line.length) {
                swap = line.charAt(column) + line.charAt(column-1);
                range = new Range(cursor.row, column-1, cursor.row, column+1);
            }
            else {
                swap = line.charAt(column-1) + line.charAt(column-2);
                range = new Range(cursor.row, column-2, cursor.row, column);
            }
            this.session.replace(range, swap);
            this.session.selection.moveToPosition(range.end);
        };
        this.toLowerCase = function() {
            var originalRange = this.getSelectionRange();
            if (this.selection.isEmpty()) {
                this.selection.selectWord();
            }

            var range = this.getSelectionRange();
            var text = this.session.getTextRange(range);
            this.session.replace(range, text.toLowerCase());
            this.selection.setSelectionRange(originalRange);
        };
        this.toUpperCase = function() {
            var originalRange = this.getSelectionRange();
            if (this.selection.isEmpty()) {
                this.selection.selectWord();
            }

            var range = this.getSelectionRange();
            var text = this.session.getTextRange(range);
            this.session.replace(range, text.toUpperCase());
            this.selection.setSelectionRange(originalRange);
        };
        this.indent = function() {
            var session = this.session;
            var range = this.getSelectionRange();

            if (range.start.row < range.end.row) {
                var rows = this.$getSelectedRows();
                session.indentRows(rows.first, rows.last, "\t");
                return;
            } else if (range.start.column < range.end.column) {
                var text = session.getTextRange(range);
                if (!/^\s+$/.test(text)) {
                    var rows = this.$getSelectedRows();
                    session.indentRows(rows.first, rows.last, "\t");
                    return;
                }
            }
            
            var line = session.getLine(range.start.row);
            var position = range.start;
            var size = session.getTabSize();
            var column = session.documentToScreenColumn(position.row, position.column);

            if (this.session.getUseSoftTabs()) {
                var count = (size - column % size);
                var indentString = lang.stringRepeat(" ", count);
            } else {
                var count = column % size;
                while (line[range.start.column - 1] == " " && count) {
                    range.start.column--;
                    count--;
                }
                this.selection.setSelectionRange(range);
                indentString = "\t";
            }
            return this.insert(indentString);
        };
        this.blockIndent = function() {
            var rows = this.$getSelectedRows();
            this.session.indentRows(rows.first, rows.last, "\t");
        };
        this.blockOutdent = function() {
            var selection = this.session.getSelection();
            this.session.outdentRows(selection.getRange());
        };
        this.sortLines = function() {
            var rows = this.$getSelectedRows();
            var session = this.session;

            var lines = [];
            for (var i = rows.first; i <= rows.last; i++)
                lines.push(session.getLine(i));

            lines.sort(function(a, b) {
                if (a.toLowerCase() < b.toLowerCase()) return -1;
                if (a.toLowerCase() > b.toLowerCase()) return 1;
                return 0;
            });

            var deleteRange = new Range(0, 0, 0, 0);
            for (var i = rows.first; i <= rows.last; i++) {
                var line = session.getLine(i);
                deleteRange.start.row = i;
                deleteRange.end.row = i;
                deleteRange.end.column = line.length;
                session.replace(deleteRange, lines[i-rows.first]);
            }
        };
        this.toggleCommentLines = function() {
            var state = this.session.getState(this.getCursorPosition().row);
            var rows = this.$getSelectedRows();
            this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
        };

        this.toggleBlockComment = function() {
            var cursor = this.getCursorPosition();
            var state = this.session.getState(cursor.row);
            var range = this.getSelectionRange();
            this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
        };
        this.getNumberAt = function(row, column) {
            var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
            _numberRx.lastIndex = 0;

            var s = this.session.getLine(row);
            while (_numberRx.lastIndex < column) {
                var m = _numberRx.exec(s);
                if(m.index <= column && m.index+m[0].length >= column){
                    var number = {
                        value: m[0],
                        start: m.index,
                        end: m.index+m[0].length
                    };
                    return number;
                }
            }
            return null;
        };
        this.modifyNumber = function(amount) {
            var row = this.selection.getCursor().row;
            var column = this.selection.getCursor().column;
            var charRange = new Range(row, column-1, row, column);

            var c = this.session.getTextRange(charRange);
            if (!isNaN(parseFloat(c)) && isFinite(c)) {
                var nr = this.getNumberAt(row, column);
                if (nr) {
                    var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
                    var decimals = nr.start + nr.value.length - fp;

                    var t = parseFloat(nr.value);
                    t *= Math.pow(10, decimals);


                    if(fp !== nr.end && column < fp){
                        amount *= Math.pow(10, nr.end - column - 1);
                    } else {
                        amount *= Math.pow(10, nr.end - column);
                    }

                    t += amount;
                    t /= Math.pow(10, decimals);
                    var nnr = t.toFixed(decimals);
                    var replaceRange = new Range(row, nr.start, row, nr.end);
                    this.session.replace(replaceRange, nnr);
                    this.moveCursorTo(row, Math.max(nr.start +1, column + nnr.length - nr.value.length));

                }
            } else {
                this.toggleWord();
            }
        };

        this.$toggleWordPairs = [
            ["first", "last"],
            ["true", "false"],
            ["yes", "no"],
            ["width", "height"],
            ["top", "bottom"],
            ["right", "left"],
            ["on", "off"],
            ["x", "y"],
            ["get", "set"],
            ["max", "min"],
            ["horizontal", "vertical"],
            ["show", "hide"],
            ["add", "remove"],
            ["up", "down"],
            ["before", "after"],
            ["even", "odd"],
            ["in", "out"],
            ["inside", "outside"],
            ["next", "previous"],
            ["increase", "decrease"],
            ["attach", "detach"],
            ["&&", "||"],
            ["==", "!="]
        ];

        this.toggleWord = function () {
            var row = this.selection.getCursor().row;
            var column = this.selection.getCursor().column;
            this.selection.selectWord();
            var currentState = this.getSelectedText();
            var currWordStart = this.selection.getWordRange().start.column;
            var wordParts = currentState.replace(/([a-z]+|[A-Z]+)(?=[A-Z_]|$)/g, '$1 ').split(/\s/);
            var delta = column - currWordStart - 1;
            if (delta < 0) delta = 0;
            var curLength = 0, itLength = 0;
            var that = this;
            if (currentState.match(/[A-Za-z0-9_]+/)) {
                wordParts.forEach(function (item, i) {
                    itLength = curLength + item.length;
                    if (delta >= curLength && delta <= itLength) {
                        currentState = item;
                        that.selection.clearSelection();
                        that.moveCursorTo(row, curLength + currWordStart);
                        that.selection.selectTo(row, itLength + currWordStart);
                    }
                    curLength = itLength;
                });
            }

            var wordPairs = this.$toggleWordPairs;
            var reg;
            for (var i = 0; i < wordPairs.length; i++) {
                var item = wordPairs[i];
                for (var j = 0; j <= 1; j++) {
                    var negate = +!j;
                    var firstCondition = currentState.match(new RegExp('^\\s?_?(' + lang.escapeRegExp(item[j]) + ')\\s?$', 'i'));
                    if (firstCondition) {
                        var secondCondition = currentState.match(new RegExp('([_]|^|\\s)(' + lang.escapeRegExp(firstCondition[1]) + ')($|\\s)', 'g'));
                        if (secondCondition) {
                            reg = currentState.replace(new RegExp(lang.escapeRegExp(item[j]), 'i'), function (result) {
                                var res = item[negate];
                                if (result.toUpperCase() == result) {
                                    res = res.toUpperCase();
                                } else if (result.charAt(0).toUpperCase() == result.charAt(0)) {
                                    res = res.substr(0, 0) + item[negate].charAt(0).toUpperCase() + res.substr(1);
                                }
                                return res;
                            });
                            this.insert(reg);
                            reg = "";
                        }
                    }
                }
            }
        };
        this.removeLines = function() {
            var rows = this.$getSelectedRows();
            this.session.removeFullLines(rows.first, rows.last);
            this.clearSelection();
        };

        this.duplicateSelection = function() {
            var sel = this.selection;
            var doc = this.session;
            var range = sel.getRange();
            var reverse = sel.isBackwards();
            if (range.isEmpty()) {
                var row = range.start.row;
                doc.duplicateLines(row, row);
            } else {
                var point = reverse ? range.start : range.end;
                var endPoint = doc.insert(point, doc.getTextRange(range), false);
                range.start = point;
                range.end = endPoint;

                sel.setSelectionRange(range, reverse);
            }
        };
        this.moveLinesDown = function() {
            this.$moveLines(1, false);
        };
        this.moveLinesUp = function() {
            this.$moveLines(-1, false);
        };
        this.moveText = function(range, toPosition, copy) {
            return this.session.moveText(range, toPosition, copy);
        };
        this.copyLinesUp = function() {
            this.$moveLines(-1, true);
        };
        this.copyLinesDown = function() {
            this.$moveLines(1, true);
        };
        this.$moveLines = function(dir, copy) {
            var rows, moved;
            var selection = this.selection;
            if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
                var range = selection.toOrientedRange();
                rows = this.$getSelectedRows(range);
                moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
                if (copy && dir == -1) moved = 0;
                range.moveBy(moved, 0);
                selection.fromOrientedRange(range);
            } else {
                var ranges = selection.rangeList.ranges;
                selection.rangeList.detach(this.session);
                this.inVirtualSelectionMode = true;
                
                var diff = 0;
                var totalDiff = 0;
                var l = ranges.length;
                for (var i = 0; i < l; i++) {
                    var rangeIndex = i;
                    ranges[i].moveBy(diff, 0);
                    rows = this.$getSelectedRows(ranges[i]);
                    var first = rows.first;
                    var last = rows.last;
                    while (++i < l) {
                        if (totalDiff) ranges[i].moveBy(totalDiff, 0);
                        var subRows = this.$getSelectedRows(ranges[i]);
                        if (copy && subRows.first != last)
                            break;
                        else if (!copy && subRows.first > last + 1)
                            break;
                        last = subRows.last;
                    }
                    i--;
                    diff = this.session.$moveLines(first, last, copy ? 0 : dir);
                    if (copy && dir == -1) rangeIndex = i + 1;
                    while (rangeIndex <= i) {
                        ranges[rangeIndex].moveBy(diff, 0);
                        rangeIndex++;
                    }
                    if (!copy) diff = 0;
                    totalDiff += diff;
                }
                
                selection.fromOrientedRange(selection.ranges[0]);
                selection.rangeList.attach(this.session);
                this.inVirtualSelectionMode = false;
            }
        };
        this.$getSelectedRows = function(range) {
            range = (range || this.getSelectionRange()).collapseRows();

            return {
                first: this.session.getRowFoldStart(range.start.row),
                last: this.session.getRowFoldEnd(range.end.row)
            };
        };

        this.onCompositionStart = function(compositionState) {
            this.renderer.showComposition(compositionState);
        };

        this.onCompositionUpdate = function(text) {
            this.renderer.setCompositionText(text);
        };

        this.onCompositionEnd = function() {
            this.renderer.hideComposition();
        };
        this.getFirstVisibleRow = function() {
            return this.renderer.getFirstVisibleRow();
        };
        this.getLastVisibleRow = function() {
            return this.renderer.getLastVisibleRow();
        };
        this.isRowVisible = function(row) {
            return (row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow());
        };
        this.isRowFullyVisible = function(row) {
            return (row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow());
        };
        this.$getVisibleRowCount = function() {
            return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
        };

        this.$moveByPage = function(dir, select) {
            var renderer = this.renderer;
            var config = this.renderer.layerConfig;
            var rows = dir * Math.floor(config.height / config.lineHeight);

            if (select === true) {
                this.selection.$moveSelection(function(){
                    this.moveCursorBy(rows, 0);
                });
            } else if (select === false) {
                this.selection.moveCursorBy(rows, 0);
                this.selection.clearSelection();
            }

            var scrollTop = renderer.scrollTop;

            renderer.scrollBy(0, rows * config.lineHeight);
            if (select != null)
                renderer.scrollCursorIntoView(null, 0.5);

            renderer.animateScrolling(scrollTop);
        };
        this.selectPageDown = function() {
            this.$moveByPage(1, true);
        };
        this.selectPageUp = function() {
            this.$moveByPage(-1, true);
        };
        this.gotoPageDown = function() {
           this.$moveByPage(1, false);
        };
        this.gotoPageUp = function() {
            this.$moveByPage(-1, false);
        };
        this.scrollPageDown = function() {
            this.$moveByPage(1);
        };
        this.scrollPageUp = function() {
            this.$moveByPage(-1);
        };
        this.scrollToRow = function(row) {
            this.renderer.scrollToRow(row);
        };
        this.scrollToLine = function(line, center, animate, callback) {
            this.renderer.scrollToLine(line, center, animate, callback);
        };
        this.centerSelection = function() {
            var range = this.getSelectionRange();
            var pos = {
                row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
                column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
            };
            this.renderer.alignCursor(pos, 0.5);
        };
        this.getCursorPosition = function() {
            return this.selection.getCursor();
        };
        this.getCursorPositionScreen = function() {
            return this.session.documentToScreenPosition(this.getCursorPosition());
        };
        this.getSelectionRange = function() {
            return this.selection.getRange();
        };
        this.selectAll = function() {
            this.selection.selectAll();
        };
        this.clearSelection = function() {
            this.selection.clearSelection();
        };
        this.moveCursorTo = function(row, column) {
            this.selection.moveCursorTo(row, column);
        };
        this.moveCursorToPosition = function(pos) {
            this.selection.moveCursorToPosition(pos);
        };
        this.jumpToMatching = function(select, expand) {
            var cursor = this.getCursorPosition();
            var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
            var prevToken = iterator.getCurrentToken();
            var token = prevToken || iterator.stepForward();

            if (!token) return;
            var matchType;
            var found = false;
            var depth = {};
            var i = cursor.column - token.start;
            var bracketType;
            var brackets = {
                ")": "(",
                "(": "(",
                "]": "[",
                "[": "[",
                "{": "{",
                "}": "{"
            };
            
            do {
                if (token.value.match(/[{}()\[\]]/g)) {
                    for (; i < token.value.length && !found; i++) {
                        if (!brackets[token.value[i]]) {
                            continue;
                        }

                        bracketType = brackets[token.value[i]] + '.' + token.type.replace("rparen", "lparen");

                        if (isNaN(depth[bracketType])) {
                            depth[bracketType] = 0;
                        }

                        switch (token.value[i]) {
                            case '(':
                            case '[':
                            case '{':
                                depth[bracketType]++;
                                break;
                            case ')':
                            case ']':
                            case '}':
                                depth[bracketType]--;

                                if (depth[bracketType] === -1) {
                                    matchType = 'bracket';
                                    found = true;
                                }
                            break;
                        }
                    }
                }
                else if (token.type.indexOf('tag-name') !== -1) {
                    if (isNaN(depth[token.value])) {
                        depth[token.value] = 0;
                    }
                    
                    if (prevToken.value === '<') {
                        depth[token.value]++;
                    }
                    else if (prevToken.value === '</') {
                        depth[token.value]--;
                    }
                    
                    if (depth[token.value] === -1) {
                        matchType = 'tag';
                        found = true;
                    }
                }

                if (!found) {
                    prevToken = token;
                    token = iterator.stepForward();
                    i = 0;
                }
            } while (token && !found);
            if (!matchType)
                return;

            var range, pos;
            if (matchType === 'bracket') {
                range = this.session.getBracketRange(cursor);
                if (!range) {
                    range = new Range(
                        iterator.getCurrentTokenRow(),
                        iterator.getCurrentTokenColumn() + i - 1,
                        iterator.getCurrentTokenRow(),
                        iterator.getCurrentTokenColumn() + i - 1
                    );
                    pos = range.start;
                    if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2)
                        range = this.session.getBracketRange(pos);
                }
            }
            else if (matchType === 'tag') {
                if (token && token.type.indexOf('tag-name') !== -1) 
                    var tag = token.value;
                else
                    return;

                range = new Range(
                    iterator.getCurrentTokenRow(),
                    iterator.getCurrentTokenColumn() - 2,
                    iterator.getCurrentTokenRow(),
                    iterator.getCurrentTokenColumn() - 2
                );
                if (range.compare(cursor.row, cursor.column) === 0) {
                    found = false;
                    do {
                        token = prevToken;
                        prevToken = iterator.stepBackward();
                        
                        if (prevToken) {
                            if (prevToken.type.indexOf('tag-close') !== -1) {
                                range.setEnd(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                            }

                            if (token.value === tag && token.type.indexOf('tag-name') !== -1) {
                                if (prevToken.value === '<') {
                                    depth[tag]++;
                                }
                                else if (prevToken.value === '</') {
                                    depth[tag]--;
                                }
                                
                                if (depth[tag] === 0)
                                    found = true;
                            }
                        }
                    } while (prevToken && !found);
                }
                if (token && token.type.indexOf('tag-name')) {
                    pos = range.start;
                    if (pos.row == cursor.row && Math.abs(pos.column - cursor.column) < 2)
                        pos = range.end;
                }
            }

            pos = range && range.cursor || pos;
            if (pos) {
                if (select) {
                    if (range && expand) {
                        this.selection.setRange(range);
                    } else if (range && range.isEqual(this.getSelectionRange())) {
                        this.clearSelection();
                    } else {
                        this.selection.selectTo(pos.row, pos.column);
                    }
                } else {
                    this.selection.moveTo(pos.row, pos.column);
                }
            }
        };
        this.gotoLine = function(lineNumber, column, animate) {
            this.selection.clearSelection();
            this.session.unfold({row: lineNumber - 1, column: column || 0});
            this.exitMultiSelectMode && this.exitMultiSelectMode();
            this.moveCursorTo(lineNumber - 1, column || 0);

            if (!this.isRowFullyVisible(lineNumber - 1))
                this.scrollToLine(lineNumber - 1, true, animate);
        };
        this.navigateTo = function(row, column) {
            this.selection.moveTo(row, column);
        };
        this.navigateUp = function(times) {
            if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
                var selectionStart = this.selection.anchor.getPosition();
                return this.moveCursorToPosition(selectionStart);
            }
            this.selection.clearSelection();
            this.selection.moveCursorBy(-times || -1, 0);
        };
        this.navigateDown = function(times) {
            if (this.selection.isMultiLine() && this.selection.isBackwards()) {
                var selectionEnd = this.selection.anchor.getPosition();
                return this.moveCursorToPosition(selectionEnd);
            }
            this.selection.clearSelection();
            this.selection.moveCursorBy(times || 1, 0);
        };
        this.navigateLeft = function(times) {
            if (!this.selection.isEmpty()) {
                var selectionStart = this.getSelectionRange().start;
                this.moveCursorToPosition(selectionStart);
            }
            else {
                times = times || 1;
                while (times--) {
                    this.selection.moveCursorLeft();
                }
            }
            this.clearSelection();
        };
        this.navigateRight = function(times) {
            if (!this.selection.isEmpty()) {
                var selectionEnd = this.getSelectionRange().end;
                this.moveCursorToPosition(selectionEnd);
            }
            else {
                times = times || 1;
                while (times--) {
                    this.selection.moveCursorRight();
                }
            }
            this.clearSelection();
        };
        this.navigateLineStart = function() {
            this.selection.moveCursorLineStart();
            this.clearSelection();
        };
        this.navigateLineEnd = function() {
            this.selection.moveCursorLineEnd();
            this.clearSelection();
        };
        this.navigateFileEnd = function() {
            this.selection.moveCursorFileEnd();
            this.clearSelection();
        };
        this.navigateFileStart = function() {
            this.selection.moveCursorFileStart();
            this.clearSelection();
        };
        this.navigateWordRight = function() {
            this.selection.moveCursorWordRight();
            this.clearSelection();
        };
        this.navigateWordLeft = function() {
            this.selection.moveCursorWordLeft();
            this.clearSelection();
        };
        this.replace = function(replacement, options) {
            if (options)
                this.$search.set(options);

            var range = this.$search.find(this.session);
            var replaced = 0;
            if (!range)
                return replaced;

            if (this.$tryReplace(range, replacement)) {
                replaced = 1;
            }

            this.selection.setSelectionRange(range);
            this.renderer.scrollSelectionIntoView(range.start, range.end);

            return replaced;
        };
        this.replaceAll = function(replacement, options) {
            if (options) {
                this.$search.set(options);
            }

            var ranges = this.$search.findAll(this.session);
            var replaced = 0;
            if (!ranges.length)
                return replaced;

            var selection = this.getSelectionRange();
            this.selection.moveTo(0, 0);

            for (var i = ranges.length - 1; i >= 0; --i) {
                if(this.$tryReplace(ranges[i], replacement)) {
                    replaced++;
                }
            }

            this.selection.setSelectionRange(selection);

            return replaced;
        };

        this.$tryReplace = function(range, replacement) {
            var input = this.session.getTextRange(range);
            replacement = this.$search.replace(input, replacement);
            if (replacement !== null) {
                range.end = this.session.replace(range, replacement);
                return range;
            } else {
                return null;
            }
        };
        this.getLastSearchOptions = function() {
            return this.$search.getOptions();
        };
        this.find = function(needle, options, animate) {
            if (!options)
                options = {};

            if (typeof needle == "string" || needle instanceof RegExp)
                options.needle = needle;
            else if (typeof needle == "object")
                oop.mixin(options, needle);

            var range = this.selection.getRange();
            if (options.needle == null) {
                needle = this.session.getTextRange(range)
                    || this.$search.$options.needle;
                if (!needle) {
                    range = this.session.getWordRange(range.start.row, range.start.column);
                    needle = this.session.getTextRange(range);
                }
                this.$search.set({needle: needle});
            }

            this.$search.set(options);
            if (!options.start)
                this.$search.set({start: range});

            var newRange = this.$search.find(this.session);
            if (options.preventScroll)
                return newRange;
            if (newRange) {
                this.revealRange(newRange, animate);
                return newRange;
            }
            if (options.backwards)
                range.start = range.end;
            else
                range.end = range.start;
            this.selection.setRange(range);
        };
        this.findNext = function(options, animate) {
            this.find({skipCurrent: true, backwards: false}, options, animate);
        };
        this.findPrevious = function(options, animate) {
            this.find(options, {skipCurrent: true, backwards: true}, animate);
        };

        this.revealRange = function(range, animate) {
            this.session.unfold(range);
            this.selection.setSelectionRange(range);

            var scrollTop = this.renderer.scrollTop;
            this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
            if (animate !== false)
                this.renderer.animateScrolling(scrollTop);
        };
        this.undo = function() {
            this.session.getUndoManager().undo(this.session);
            this.renderer.scrollCursorIntoView(null, 0.5);
        };
        this.redo = function() {
            this.session.getUndoManager().redo(this.session);
            this.renderer.scrollCursorIntoView(null, 0.5);
        };
        this.destroy = function() {
            this.renderer.destroy();
            this._signal("destroy", this);
            if (this.session)
                this.session.destroy();
            if (this._$emitInputEvent)
                this._$emitInputEvent.cancel();
            this.session = null;
        };
        this.setAutoScrollEditorIntoView = function(enable) {
            if (!enable)
                return;
            var rect;
            var self = this;
            var shouldScroll = false;
            if (!this.$scrollAnchor)
                this.$scrollAnchor = document.createElement("div");
            var scrollAnchor = this.$scrollAnchor;
            scrollAnchor.style.cssText = "position:absolute";
            this.container.insertBefore(scrollAnchor, this.container.firstChild);
            var onChangeSelection = this.on("changeSelection", function() {
                shouldScroll = true;
            });
            var onBeforeRender = this.renderer.on("beforeRender", function() {
                if (shouldScroll)
                    rect = self.renderer.container.getBoundingClientRect();
            });
            var onAfterRender = this.renderer.on("afterRender", function() {
                if (shouldScroll && rect && (self.isFocused()
                    || self.searchBox && self.searchBox.isFocused())
                ) {
                    var renderer = self.renderer;
                    var pos = renderer.$cursorLayer.$pixelPos;
                    var config = renderer.layerConfig;
                    var top = pos.top - config.offset;
                    if (pos.top >= 0 && top + rect.top < 0) {
                        shouldScroll = true;
                    } else if (pos.top < config.height &&
                        pos.top + rect.top + config.lineHeight > window.innerHeight) {
                        shouldScroll = false;
                    } else {
                        shouldScroll = null;
                    }
                    if (shouldScroll != null) {
                        scrollAnchor.style.top = top + "px";
                        scrollAnchor.style.left = pos.left + "px";
                        scrollAnchor.style.height = config.lineHeight + "px";
                        scrollAnchor.scrollIntoView(shouldScroll);
                    }
                    shouldScroll = rect = null;
                }
            });
            this.setAutoScrollEditorIntoView = function(enable) {
                if (enable)
                    return;
                delete this.setAutoScrollEditorIntoView;
                this.off("changeSelection", onChangeSelection);
                this.renderer.off("afterRender", onAfterRender);
                this.renderer.off("beforeRender", onBeforeRender);
            };
        };


        this.$resetCursorStyle = function() {
            var style = this.$cursorStyle || "ace";
            var cursorLayer = this.renderer.$cursorLayer;
            if (!cursorLayer)
                return;
            cursorLayer.setSmoothBlinking(/smooth/.test(style));
            cursorLayer.isBlinking = !this.$readOnly && style != "wide";
            dom.setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style));
        };
        this.prompt = function(message, options, callback) {
            var editor = this;
            config.loadModule("./ext/prompt", function (module) {
                module.prompt(editor, message, options, callback);
            });
        };

    }).call(Editor.prototype);



    config.defineOptions(Editor.prototype, "editor", {
        selectionStyle: {
            set: function(style) {
                this.onSelectionChange();
                this._signal("changeSelectionStyle", {data: style});
            },
            initialValue: "line"
        },
        highlightActiveLine: {
            set: function() {this.$updateHighlightActiveLine();},
            initialValue: true
        },
        highlightSelectedWord: {
            set: function(shouldHighlight) {this.$onSelectionChange();},
            initialValue: true
        },
        readOnly: {
            set: function(readOnly) {
                this.textInput.setReadOnly(readOnly);
                this.$resetCursorStyle(); 
            },
            initialValue: false
        },
        copyWithEmptySelection: {
            set: function(value) {
                this.textInput.setCopyWithEmptySelection(value);
            },
            initialValue: false
        },
        cursorStyle: {
            set: function(val) { this.$resetCursorStyle(); },
            values: ["ace", "slim", "smooth", "wide"],
            initialValue: "ace"
        },
        mergeUndoDeltas: {
            values: [false, true, "always"],
            initialValue: true
        },
        behavioursEnabled: {initialValue: true},
        wrapBehavioursEnabled: {initialValue: true},
        autoScrollEditorIntoView: {
            set: function(val) {this.setAutoScrollEditorIntoView(val);}
        },
        keyboardHandler: {
            set: function(val) { this.setKeyboardHandler(val); },
            get: function() { return this.$keybindingId; },
            handlesSet: true
        },
        value: {
            set: function(val) { this.session.setValue(val); },
            get: function() { return this.getValue(); },
            handlesSet: true,
            hidden: true
        },
        session: {
            set: function(val) { this.setSession(val); },
            get: function() { return this.session; },
            handlesSet: true,
            hidden: true
        },
        
        showLineNumbers: {
            set: function(show) {
                this.renderer.$gutterLayer.setShowLineNumbers(show);
                this.renderer.$loop.schedule(this.renderer.CHANGE_GUTTER);
                if (show && this.$relativeLineNumbers)
                    relativeNumberRenderer.attach(this);
                else
                    relativeNumberRenderer.detach(this);
            },
            initialValue: true
        },
        relativeLineNumbers: {
            set: function(value) {
                if (this.$showLineNumbers && value)
                    relativeNumberRenderer.attach(this);
                else
                    relativeNumberRenderer.detach(this);
            }
        },
        placeholder: {
            set: function(message) {
                if (!this.$updatePlaceholder) {
                    this.$updatePlaceholder = function() {
                        var value = this.renderer.$composition || this.getValue();
                        if (value && this.renderer.placeholderNode) {
                            this.renderer.off("afterRender", this.$updatePlaceholder);
                            dom.removeCssClass(this.container, "ace_hasPlaceholder");
                            this.renderer.placeholderNode.remove();
                            this.renderer.placeholderNode = null;
                        } else if (!value && !this.renderer.placeholderNode) {
                            this.renderer.on("afterRender", this.$updatePlaceholder);
                            dom.addCssClass(this.container, "ace_hasPlaceholder");
                            var el = dom.createElement("div");
                            el.className = "ace_placeholder";
                            el.textContent = this.$placeholder || "";
                            this.renderer.placeholderNode = el;
                            this.renderer.content.appendChild(this.renderer.placeholderNode);
                        }
                    }.bind(this);
                    this.on("input", this.$updatePlaceholder);
                }
                this.$updatePlaceholder();
            }
        },

        hScrollBarAlwaysVisible: "renderer",
        vScrollBarAlwaysVisible: "renderer",
        highlightGutterLine: "renderer",
        animatedScroll: "renderer",
        showInvisibles: "renderer",
        showPrintMargin: "renderer",
        printMarginColumn: "renderer",
        printMargin: "renderer",
        fadeFoldWidgets: "renderer",
        showFoldWidgets: "renderer",
        displayIndentGuides: "renderer",
        showGutter: "renderer",
        fontSize: "renderer",
        fontFamily: "renderer",
        maxLines: "renderer",
        minLines: "renderer",
        scrollPastEnd: "renderer",
        fixedWidthGutter: "renderer",
        theme: "renderer",
        hasCssTransforms: "renderer",
        maxPixelHeight: "renderer",
        useTextareaForIME: "renderer",

        scrollSpeed: "$mouseHandler",
        dragDelay: "$mouseHandler",
        dragEnabled: "$mouseHandler",
        focusTimeout: "$mouseHandler",
        tooltipFollowsMouse: "$mouseHandler",

        firstLineNumber: "session",
        overwrite: "session",
        newLineMode: "session",
        useWorker: "session",
        useSoftTabs: "session",
        navigateWithinSoftTabs: "session",
        tabSize: "session",
        wrap: "session",
        indentedSoftWrap: "session",
        foldStyle: "session",
        mode: "session"
    });


    var relativeNumberRenderer = {
        getText: function(session, row) {
            return (Math.abs(session.selection.lead.row - row) || (row + 1 + (row < 9 ? "\xb7" : ""))) + "";
        },
        getWidth: function(session, lastLineNumber, config) {
            return Math.max(
                lastLineNumber.toString().length,
                (config.lastRow + 1).toString().length,
                2
            ) * config.characterWidth;
        },
        update: function(e, editor) {
            editor.renderer.$loop.schedule(editor.renderer.CHANGE_GUTTER);
        },
        attach: function(editor) {
            editor.renderer.$gutterLayer.$renderer = this;
            editor.on("changeSelection", this.update);
            this.update(null, editor);
        },
        detach: function(editor) {
            if (editor.renderer.$gutterLayer.$renderer == this)
                editor.renderer.$gutterLayer.$renderer = null;
            editor.off("changeSelection", this.update);
            this.update(null, editor);
        }
    };

    exports.Editor = Editor;
    });

    ace.define("ace/undomanager",["require","exports","module","ace/range"], function(require, exports, module) {
    var UndoManager = function() {
        this.$maxRev = 0;
        this.$fromUndo = false;
        this.reset();
    };

    (function() {
        
        this.addSession = function(session) {
            this.$session = session;
        };
        this.add = function(delta, allowMerge, session) {
            if (this.$fromUndo) return;
            if (delta == this.$lastDelta) return;
            if (!this.$keepRedoStack) this.$redoStack.length = 0;
            if (allowMerge === false || !this.lastDeltas) {
                this.lastDeltas = [];
                this.$undoStack.push(this.lastDeltas);
                delta.id = this.$rev = ++this.$maxRev;
            }
            if (delta.action == "remove" || delta.action == "insert")
                this.$lastDelta = delta;
            this.lastDeltas.push(delta);
        };
        
        this.addSelection = function(selection, rev) {
            this.selections.push({
                value: selection,
                rev: rev || this.$rev
            });
        };
        
        this.startNewGroup = function() {
            this.lastDeltas = null;
            return this.$rev;
        };
        
        this.markIgnored = function(from, to) {
            if (to == null) to = this.$rev + 1;
            var stack = this.$undoStack;
            for (var i = stack.length; i--;) {
                var delta = stack[i][0];
                if (delta.id <= from)
                    break;
                if (delta.id < to)
                    delta.ignore = true;
            }
            this.lastDeltas = null;
        };
        
        this.getSelection = function(rev, after) {
            var stack = this.selections;
            for (var i = stack.length; i--;) {
                var selection = stack[i];
                if (selection.rev < rev) {
                    if (after)
                        selection = stack[i + 1];
                    return selection;
                }
            }
        };
        
        this.getRevision = function() {
            return this.$rev;
        };
        
        this.getDeltas = function(from, to) {
            if (to == null) to = this.$rev + 1;
            var stack = this.$undoStack;
            var end = null, start = 0;
            for (var i = stack.length; i--;) {
                var delta = stack[i][0];
                if (delta.id < to && !end)
                    end = i+1;
                if (delta.id <= from) {
                    start = i + 1;
                    break;
                }
            }
            return stack.slice(start, end);
        };
        
        this.getChangedRanges = function(from, to) {
            if (to == null) to = this.$rev + 1;
            
        };
        
        this.getChangedLines = function(from, to) {
            if (to == null) to = this.$rev + 1;
            
        };

        this.validateDeltaBoundaries = function(deltaSet, docLength, invertAction) {
            if (!deltaSet) {
                return false;
            }
            return deltaSet.every(function(delta) {
                var action = delta.action;
                if (invertAction && delta.action === "insert") action = "remove";
                if (invertAction && delta.action === "remove") action = "insert";
                switch(action) {
                    case "insert":
                        return delta.start.row <= docLength;
                    case "remove":
                        return delta.start.row < docLength && delta.end.row < docLength;
                    default:
                        return true;
                }
            });
        };
        this.undo = function(session, dontSelect) {
            this.lastDeltas = null;
            var stack = this.$undoStack;
            
            if (!rearrangeUndoStack(stack, stack.length))
                return;
            
            if (!session)
                session = this.$session;
            
            if (this.$redoStackBaseRev !== this.$rev && this.$redoStack.length)
                this.$redoStack = [];
            
            this.$fromUndo = true;
            
            var deltaSet = stack.pop();
            var undoSelectionRange = null;
            if (this.validateDeltaBoundaries(deltaSet, session.getLength(), true)) {
                undoSelectionRange = session.undoChanges(deltaSet, dontSelect);
                this.$redoStack.push(deltaSet);
                this.$syncRev();
            }
            
            this.$fromUndo = false;

            return undoSelectionRange;
        };
        this.redo = function(session, dontSelect) {
            this.lastDeltas = null;
            
            if (!session)
                session = this.$session;
            
            this.$fromUndo = true;
            if (this.$redoStackBaseRev != this.$rev) {
                var diff = this.getDeltas(this.$redoStackBaseRev, this.$rev + 1);
                rebaseRedoStack(this.$redoStack, diff);
                this.$redoStackBaseRev = this.$rev;
                this.$redoStack.forEach(function(x) {
                    x[0].id = ++this.$maxRev;
                }, this);
            }
            var deltaSet = this.$redoStack.pop();
            var redoSelectionRange = null;
            
            if (this.validateDeltaBoundaries(deltaSet, session.getLength(), false)) {
                redoSelectionRange = session.redoChanges(deltaSet, dontSelect);
                this.$undoStack.push(deltaSet);
                this.$syncRev();
            }
            this.$fromUndo = false;
            
            return redoSelectionRange;
        };
        
        this.$syncRev = function() {
            var stack = this.$undoStack;
            var nextDelta = stack[stack.length - 1];
            var id = nextDelta && nextDelta[0].id || 0;
            this.$redoStackBaseRev = id;
            this.$rev = id;
        };
        this.reset = function() {
            this.lastDeltas = null;
            this.$lastDelta = null;
            this.$undoStack = [];
            this.$redoStack = [];
            this.$rev = 0;
            this.mark = 0;
            this.$redoStackBaseRev = this.$rev;
            this.selections = [];
        };
        this.canUndo = function() {
            return this.$undoStack.length > 0;
        };
        this.canRedo = function() {
            return this.$redoStack.length > 0;
        };
        this.bookmark = function(rev) {
            if (rev == undefined)
                rev = this.$rev;
            this.mark = rev;
        };
        this.isAtBookmark = function() {
            return this.$rev === this.mark;
        };
        
        this.toJSON = function() {
            
        };
        
        this.fromJSON = function() {
            
        };
        
        this.hasUndo = this.canUndo;
        this.hasRedo = this.canRedo;
        this.isClean = this.isAtBookmark;
        this.markClean = this.bookmark;
        
        this.$prettyPrint = function(delta) {
            if (delta) return stringifyDelta(delta);
            return stringifyDelta(this.$undoStack) + "\n---\n" + stringifyDelta(this.$redoStack);
        };
    }).call(UndoManager.prototype);

    function rearrangeUndoStack(stack, pos) {
        for (var i = pos; i--; ) {
            var deltaSet = stack[i];
            if (deltaSet && !deltaSet[0].ignore) {
                while(i < pos - 1) {
                    var swapped = swapGroups(stack[i], stack[i + 1]);
                    stack[i] = swapped[0];
                    stack[i + 1] = swapped[1];
                    i++;
                }
                return true;
            }
        }
    }

    var Range = require("./range").Range;
    var cmp = Range.comparePoints;
    var comparePoints = Range.comparePoints;



    function clonePos(pos) {
        return {row: pos.row,column: pos.column};
    }
    function cloneDelta(d) {
        return {
            start: clonePos(d.start),
            end: clonePos(d.end),
            action: d.action,
            lines: d.lines.slice()
        };
    }
    function stringifyDelta(d) {
        d = d || this;
        if (Array.isArray(d)) {
            return d.map(stringifyDelta).join("\n");
        }
        var type = "";
        if (d.action) {
            type = d.action == "insert" ? "+" : "-";
            type += "[" + d.lines + "]";
        } else if (d.value) {
            if (Array.isArray(d.value)) {
                type = d.value.map(stringifyRange).join("\n");
            } else {
                type = stringifyRange(d.value);
            }
        }
        if (d.start) {
            type += stringifyRange(d);
        }
        if (d.id || d.rev) {
            type += "\t(" + (d.id || d.rev) + ")";
        }
        return type;
    }
    function stringifyRange(r) {
        return r.start.row + ":" + r.start.column 
            + "=>" + r.end.row + ":" + r.end.column;
    }

    function swap(d1, d2) {
        var i1 = d1.action == "insert";
        var i2 = d2.action == "insert";
        
        if (i1 && i2) {
            if (cmp(d2.start, d1.end) >= 0) {
                shift(d2, d1, -1);
            } else if (cmp(d2.start, d1.start) <= 0) {
                shift(d1, d2, +1);
            } else {
                return null;
            }
        } else if (i1 && !i2) {
            if (cmp(d2.start, d1.end) >= 0) {
                shift(d2, d1, -1);
            } else if (cmp(d2.end, d1.start) <= 0) {
                shift(d1, d2, -1);
            } else {
                return null;
            }
        } else if (!i1 && i2) {
            if (cmp(d2.start, d1.start) >= 0) {
                shift(d2, d1, +1);
            } else if (cmp(d2.start, d1.start) <= 0) {
                shift(d1, d2, +1);
            } else {
                return null;
            }
        } else if (!i1 && !i2) {
            if (cmp(d2.start, d1.start) >= 0) {
                shift(d2, d1, +1);
            } else if (cmp(d2.end, d1.start) <= 0) {
                shift(d1, d2, -1);
            } else {
                return null;
            }
        }
        return [d2, d1];
    }
    function swapGroups(ds1, ds2) {
        for (var i = ds1.length; i--; ) {
            for (var j = 0; j < ds2.length; j++) {
                if (!swap(ds1[i], ds2[j])) {
                    while (i < ds1.length) {
                        while (j--) {
                            swap(ds2[j], ds1[i]);
                        }
                        j = ds2.length;
                        i++;
                    }                
                    return [ds1, ds2];
                }
            }
        }
        ds1.selectionBefore = ds2.selectionBefore = 
        ds1.selectionAfter = ds2.selectionAfter = null;
        return [ds2, ds1];
    }
    function xform(d1, c1) {
        var i1 = d1.action == "insert";
        var i2 = c1.action == "insert";
        
        if (i1 && i2) {
            if (cmp(d1.start, c1.start) < 0) {
                shift(c1, d1, 1);
            } else {
                shift(d1, c1, 1);
            }
        } else if (i1 && !i2) {
            if (cmp(d1.start, c1.end) >= 0) {
                shift(d1, c1, -1);
            } else if (cmp(d1.start, c1.start) <= 0) {
                shift(c1, d1, +1);
            } else {
                shift(d1, Range.fromPoints(c1.start, d1.start), -1);
                shift(c1, d1, +1);
            }
        } else if (!i1 && i2) {
            if (cmp(c1.start, d1.end) >= 0) {
                shift(c1, d1, -1);
            } else if (cmp(c1.start, d1.start) <= 0) {
                shift(d1, c1, +1);
            } else {
                shift(c1, Range.fromPoints(d1.start, c1.start), -1);
                shift(d1, c1, +1);
            }
        } else if (!i1 && !i2) {
            if (cmp(c1.start, d1.end) >= 0) {
                shift(c1, d1, -1);
            } else if (cmp(c1.end, d1.start) <= 0) {
                shift(d1, c1, -1);
            } else {
                var before, after;
                if (cmp(d1.start, c1.start) < 0) {
                    before = d1;
                    d1 = splitDelta(d1, c1.start);
                }
                if (cmp(d1.end, c1.end) > 0) {
                    after = splitDelta(d1, c1.end);
                }

                shiftPos(c1.end, d1.start, d1.end, -1);
                if (after && !before) {
                    d1.lines = after.lines;
                    d1.start = after.start;
                    d1.end = after.end;
                    after = d1;
                }

                return [c1, before, after].filter(Boolean);
            }
        }
        return [c1, d1];
    }
        
    function shift(d1, d2, dir) {
        shiftPos(d1.start, d2.start, d2.end, dir);
        shiftPos(d1.end, d2.start, d2.end, dir);
    }
    function shiftPos(pos, start, end, dir) {
        if (pos.row == (dir == 1 ? start : end).row) {
            pos.column += dir * (end.column - start.column);
        }
        pos.row += dir * (end.row - start.row);
    }
    function splitDelta(c, pos) {
        var lines = c.lines;
        var end = c.end;
        c.end = clonePos(pos);    
        var rowsBefore = c.end.row - c.start.row;
        var otherLines = lines.splice(rowsBefore, lines.length);
        
        var col = rowsBefore ? pos.column : pos.column - c.start.column;
        lines.push(otherLines[0].substring(0, col));
        otherLines[0] = otherLines[0].substr(col)   ; 
        var rest = {
            start: clonePos(pos),
            end: end,
            lines: otherLines,
            action: c.action
        };
        return rest;
    }

    function moveDeltasByOne(redoStack, d) {
        d = cloneDelta(d);
        for (var j = redoStack.length; j--;) {
            var deltaSet = redoStack[j];
            for (var i = 0; i < deltaSet.length; i++) {
                var x = deltaSet[i];
                var xformed = xform(x, d);
                d = xformed[0];
                if (xformed.length != 2) {
                    if (xformed[2]) {
                        deltaSet.splice(i + 1, 1, xformed[1], xformed[2]);
                        i++;
                    } else if (!xformed[1]) {
                        deltaSet.splice(i, 1);
                        i--;
                    }
                }
            }
            if (!deltaSet.length) {
                redoStack.splice(j, 1); 
            }
        }
        return redoStack;
    }
    function rebaseRedoStack(redoStack, deltaSets) {
        for (var i = 0; i < deltaSets.length; i++) {
            var deltas = deltaSets[i];
            for (var j = 0; j < deltas.length; j++) {
                moveDeltasByOne(redoStack, deltas[j]);
            }
        }
    }

    exports.UndoManager = UndoManager;

    });

    ace.define("ace/layer/lines",["require","exports","module","ace/lib/dom"], function(require, exports, module) {

    var dom = require("../lib/dom");

    var Lines = function(element, canvasHeight) {
        this.element = element;
        this.canvasHeight = canvasHeight || 500000;
        this.element.style.height = (this.canvasHeight * 2) + "px";
        
        this.cells = [];
        this.cellCache = [];
        this.$offsetCoefficient = 0;
    };

    (function() {
        
        this.moveContainer = function(config) {
            dom.translate(this.element, 0, -((config.firstRowScreen * config.lineHeight) % this.canvasHeight) - config.offset * this.$offsetCoefficient);
        };    
        
        this.pageChanged = function(oldConfig, newConfig) {
            return (
                Math.floor((oldConfig.firstRowScreen * oldConfig.lineHeight) / this.canvasHeight) !==
                Math.floor((newConfig.firstRowScreen * newConfig.lineHeight) / this.canvasHeight)
            );
        };
        
        this.computeLineTop = function(row, config, session) {
            var screenTop = config.firstRowScreen * config.lineHeight;
            var screenPage = Math.floor(screenTop / this.canvasHeight);
            var lineTop = session.documentToScreenRow(row, 0) * config.lineHeight;
            return lineTop - (screenPage * this.canvasHeight);
        };
        
        this.computeLineHeight = function(row, config, session) {
            return config.lineHeight * session.getRowLineCount(row);
        };
        
        this.getLength = function() {
            return this.cells.length;
        };
        
        this.get = function(index) {
            return this.cells[index];
        };
        
        this.shift = function() {
            this.$cacheCell(this.cells.shift());
        };
        
        this.pop = function() {
            this.$cacheCell(this.cells.pop());
        };
        
        this.push = function(cell) {
            if (Array.isArray(cell)) {
                this.cells.push.apply(this.cells, cell);
                var fragment = dom.createFragment(this.element);
                for (var i=0; i<cell.length; i++) {
                    fragment.appendChild(cell[i].element);
                }
                this.element.appendChild(fragment);
            } else {
                this.cells.push(cell);
                this.element.appendChild(cell.element);
            }
        };
        
        this.unshift = function(cell) {
            if (Array.isArray(cell)) {
                this.cells.unshift.apply(this.cells, cell);
                var fragment = dom.createFragment(this.element);
                for (var i=0; i<cell.length; i++) {
                    fragment.appendChild(cell[i].element);
                }
                if (this.element.firstChild)
                    this.element.insertBefore(fragment, this.element.firstChild);
                else
                    this.element.appendChild(fragment);
            } else {
                this.cells.unshift(cell);
                this.element.insertAdjacentElement("afterbegin", cell.element);
            }
        };
        
        this.last = function() {
            if (this.cells.length)
                return this.cells[this.cells.length-1];
            else
                return null;
        };
        
        this.$cacheCell = function(cell) {
            if (!cell)
                return;
                
            cell.element.remove();
            this.cellCache.push(cell);
        };
        
        this.createCell = function(row, config, session, initElement) {
            var cell = this.cellCache.pop();
            if (!cell) {
                var element = dom.createElement("div");
                if (initElement)
                    initElement(element);
                
                this.element.appendChild(element);
                
                cell = {
                    element: element,
                    text: "",
                    row: row
                };
            }
            cell.row = row;
            
            return cell;
        };
        
    }).call(Lines.prototype);

    exports.Lines = Lines;

    });

    ace.define("ace/layer/gutter",["require","exports","module","ace/lib/dom","ace/lib/oop","ace/lib/lang","ace/lib/event_emitter","ace/layer/lines"], function(require, exports, module) {

    var dom = require("../lib/dom");
    var oop = require("../lib/oop");
    var lang = require("../lib/lang");
    var EventEmitter = require("../lib/event_emitter").EventEmitter;
    var Lines = require("./lines").Lines;

    var Gutter = function(parentEl) {
        this.element = dom.createElement("div");
        this.element.className = "ace_layer ace_gutter-layer";
        parentEl.appendChild(this.element);
        this.setShowFoldWidgets(this.$showFoldWidgets);
        
        this.gutterWidth = 0;

        this.$annotations = [];
        this.$updateAnnotations = this.$updateAnnotations.bind(this);
        
        this.$lines = new Lines(this.element);
        this.$lines.$offsetCoefficient = 1;
    };

    (function() {

        oop.implement(this, EventEmitter);

        this.setSession = function(session) {
            if (this.session)
                this.session.removeEventListener("change", this.$updateAnnotations);
            this.session = session;
            if (session)
                session.on("change", this.$updateAnnotations);
        };

        this.addGutterDecoration = function(row, className) {
            if (window.console)
                console.warn && console.warn("deprecated use session.addGutterDecoration");
            this.session.addGutterDecoration(row, className);
        };

        this.removeGutterDecoration = function(row, className) {
            if (window.console)
                console.warn && console.warn("deprecated use session.removeGutterDecoration");
            this.session.removeGutterDecoration(row, className);
        };

        this.setAnnotations = function(annotations) {
            this.$annotations = [];
            for (var i = 0; i < annotations.length; i++) {
                var annotation = annotations[i];
                var row = annotation.row;
                var rowInfo = this.$annotations[row];
                if (!rowInfo)
                    rowInfo = this.$annotations[row] = {text: []};
               
                var annoText = annotation.text;
                annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";

                if (rowInfo.text.indexOf(annoText) === -1)
                    rowInfo.text.push(annoText);

                var type = annotation.type;
                if (type == "error")
                    rowInfo.className = " ace_error";
                else if (type == "warning" && rowInfo.className != " ace_error")
                    rowInfo.className = " ace_warning";
                else if (type == "info" && (!rowInfo.className))
                    rowInfo.className = " ace_info";
            }
        };

        this.$updateAnnotations = function (delta) {
            if (!this.$annotations.length)
                return;
            var firstRow = delta.start.row;
            var len = delta.end.row - firstRow;
            if (len === 0) ; else if (delta.action == 'remove') {
                this.$annotations.splice(firstRow, len + 1, null);
            } else {
                var args = new Array(len + 1);
                args.unshift(firstRow, 1);
                this.$annotations.splice.apply(this.$annotations, args);
            }
        };

        this.update = function(config) {
            this.config = config;
            
            var session = this.session;
            var firstRow = config.firstRow;
            var lastRow = Math.min(config.lastRow + config.gutterOffset,  // needed to compensate for hor scollbar
                session.getLength() - 1);
                
            this.oldLastRow = lastRow;
            this.config = config;
            
            this.$lines.moveContainer(config);
            this.$updateCursorRow();
                
            var fold = session.getNextFoldLine(firstRow);
            var foldStart = fold ? fold.start.row : Infinity;

            var cell = null;
            var index = -1;
            var row = firstRow;
            
            while (true) {
                if (row > foldStart) {
                    row = fold.end.row + 1;
                    fold = session.getNextFoldLine(row, fold);
                    foldStart = fold ? fold.start.row : Infinity;
                }
                if (row > lastRow) {
                    while (this.$lines.getLength() > index + 1)
                        this.$lines.pop();
                        
                    break;
                }

                cell = this.$lines.get(++index);
                if (cell) {
                    cell.row = row;
                } else {
                    cell = this.$lines.createCell(row, config, this.session, onCreateCell);
                    this.$lines.push(cell);
                }

                this.$renderCell(cell, config, fold, row);
                row++;
            }
            
            this._signal("afterRender");
            this.$updateGutterWidth(config);
        };

        this.$updateGutterWidth = function(config) {
            var session = this.session;
            
            var gutterRenderer = session.gutterRenderer || this.$renderer;
            
            var firstLineNumber = session.$firstLineNumber;
            var lastLineText = this.$lines.last() ? this.$lines.last().text : "";
            
            if (this.$fixedWidth || session.$useWrapMode)
                lastLineText = session.getLength() + firstLineNumber - 1;

            var gutterWidth = gutterRenderer 
                ? gutterRenderer.getWidth(session, lastLineText, config)
                : lastLineText.toString().length * config.characterWidth;
            
            var padding = this.$padding || this.$computePadding();
            gutterWidth += padding.left + padding.right;
            if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
                this.gutterWidth = gutterWidth;
                this.element.parentNode.style.width = 
                this.element.style.width = Math.ceil(this.gutterWidth) + "px";
                this._signal("changeGutterWidth", gutterWidth);
            }
        };
        
        this.$updateCursorRow = function() {
            if (!this.$highlightGutterLine)
                return;
                
            var position = this.session.selection.getCursor();
            if (this.$cursorRow === position.row)
                return;
            
            this.$cursorRow = position.row;
        };
        
        this.updateLineHighlight = function() {
            if (!this.$highlightGutterLine)
                return;
            var row = this.session.selection.cursor.row;
            this.$cursorRow = row;

            if (this.$cursorCell && this.$cursorCell.row == row)
                return;
            if (this.$cursorCell)
                this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "");
            var cells = this.$lines.cells;
            this.$cursorCell = null;
            for (var i = 0; i < cells.length; i++) {
                var cell = cells[i];
                if (cell.row >= this.$cursorRow) {
                    if (cell.row > this.$cursorRow) {
                        var fold = this.session.getFoldLine(this.$cursorRow);
                        if (i > 0 && fold && fold.start.row == cells[i - 1].row)
                            cell = cells[i - 1];
                        else
                            break;
                    }
                    cell.element.className = "ace_gutter-active-line " + cell.element.className;
                    this.$cursorCell = cell;
                    break;
                }
            }
        };
        
        this.scrollLines = function(config) {
            var oldConfig = this.config;
            this.config = config;
            
            this.$updateCursorRow();
            if (this.$lines.pageChanged(oldConfig, config))
                return this.update(config);
            
            this.$lines.moveContainer(config);

            var lastRow = Math.min(config.lastRow + config.gutterOffset,  // needed to compensate for hor scollbar
                this.session.getLength() - 1);
            var oldLastRow = this.oldLastRow;
            this.oldLastRow = lastRow;
            
            if (!oldConfig || oldLastRow < config.firstRow)
                return this.update(config);

            if (lastRow < oldConfig.firstRow)
                return this.update(config);

            if (oldConfig.firstRow < config.firstRow)
                for (var row=this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row>0; row--)
                    this.$lines.shift();

            if (oldLastRow > lastRow)
                for (var row=this.session.getFoldedRowCount(lastRow + 1, oldLastRow); row>0; row--)
                    this.$lines.pop();

            if (config.firstRow < oldConfig.firstRow) {
                this.$lines.unshift(this.$renderLines(config, config.firstRow, oldConfig.firstRow - 1));
            }

            if (lastRow > oldLastRow) {
                this.$lines.push(this.$renderLines(config, oldLastRow + 1, lastRow));
            }
            
            this.updateLineHighlight();
            
            this._signal("afterRender");
            this.$updateGutterWidth(config);
        };

        this.$renderLines = function(config, firstRow, lastRow) {
            var fragment = [];
            var row = firstRow;
            var foldLine = this.session.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;

            while (true) {
                if (row > foldStart) {
                    row = foldLine.end.row+1;
                    foldLine = this.session.getNextFoldLine(row, foldLine);
                    foldStart = foldLine ? foldLine.start.row : Infinity;
                }
                if (row > lastRow)
                    break;

                var cell = this.$lines.createCell(row, config, this.session, onCreateCell);
                this.$renderCell(cell, config, foldLine, row);
                fragment.push(cell);

                row++;
            }
            return fragment;
        };
        
        this.$renderCell = function(cell, config, fold, row) {
            var element = cell.element;
            
            var session = this.session;
            
            var textNode = element.childNodes[0];
            var foldWidget = element.childNodes[1];

            var firstLineNumber = session.$firstLineNumber;
            
            var breakpoints = session.$breakpoints;
            var decorations = session.$decorations;
            var gutterRenderer = session.gutterRenderer || this.$renderer;
            var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
            var foldStart = fold ? fold.start.row : Number.MAX_VALUE;
            
            var className = "ace_gutter-cell ";
            if (this.$highlightGutterLine) {
                if (row == this.$cursorRow || (fold && row < this.$cursorRow && row >= foldStart &&  this.$cursorRow <= fold.end.row)) {
                    className += "ace_gutter-active-line ";
                    if (this.$cursorCell != cell) {
                        if (this.$cursorCell)
                            this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "");
                        this.$cursorCell = cell;
                    }
                }
            }
            
            if (breakpoints[row])
                className += breakpoints[row];
            if (decorations[row])
                className += decorations[row];
            if (this.$annotations[row])
                className += this.$annotations[row].className;
            if (element.className != className)
                element.className = className;

            if (foldWidgets) {
                var c = foldWidgets[row];
                if (c == null)
                    c = foldWidgets[row] = session.getFoldWidget(row);
            }

            if (c) {
                var className = "ace_fold-widget ace_" + c;
                if (c == "start" && row == foldStart && row < fold.end.row)
                    className += " ace_closed";
                else
                    className += " ace_open";
                if (foldWidget.className != className)
                    foldWidget.className = className;

                var foldHeight = config.lineHeight + "px";
                dom.setStyle(foldWidget.style, "height", foldHeight);
                dom.setStyle(foldWidget.style, "display", "inline-block");
            } else {
                if (foldWidget) {
                    dom.setStyle(foldWidget.style, "display", "none");
                }
            }
            
            var text = (gutterRenderer
                ? gutterRenderer.getText(session, row)
                : row + firstLineNumber).toString();
                
            if (text !== textNode.data) {
                textNode.data = text;
            }
            
            dom.setStyle(cell.element.style, "height", this.$lines.computeLineHeight(row, config, session) + "px");
            dom.setStyle(cell.element.style, "top", this.$lines.computeLineTop(row, config, session) + "px");
            
            cell.text = text;
            return cell;
        };

        this.$fixedWidth = false;
        
        this.$highlightGutterLine = true;
        this.$renderer = "";
        this.setHighlightGutterLine = function(highlightGutterLine) {
            this.$highlightGutterLine = highlightGutterLine;
        };
        
        this.$showLineNumbers = true;
        this.$renderer = "";
        this.setShowLineNumbers = function(show) {
            this.$renderer = !show && {
                getWidth: function() {return 0;},
                getText: function() {return "";}
            };
        };
        
        this.getShowLineNumbers = function() {
            return this.$showLineNumbers;
        };
        
        this.$showFoldWidgets = true;
        this.setShowFoldWidgets = function(show) {
            if (show)
                dom.addCssClass(this.element, "ace_folding-enabled");
            else
                dom.removeCssClass(this.element, "ace_folding-enabled");

            this.$showFoldWidgets = show;
            this.$padding = null;
        };
        
        this.getShowFoldWidgets = function() {
            return this.$showFoldWidgets;
        };

        this.$computePadding = function() {
            if (!this.element.firstChild)
                return {left: 0, right: 0};
            var style = dom.computedStyle(this.element.firstChild);
            this.$padding = {};
            this.$padding.left = (parseInt(style.borderLeftWidth) || 0)
                + (parseInt(style.paddingLeft) || 0) + 1;
            this.$padding.right = (parseInt(style.borderRightWidth) || 0)
                + (parseInt(style.paddingRight) || 0);
            return this.$padding;
        };

        this.getRegion = function(point) {
            var padding = this.$padding || this.$computePadding();
            var rect = this.element.getBoundingClientRect();
            if (point.x < padding.left + rect.left)
                return "markers";
            if (this.$showFoldWidgets && point.x > rect.right - padding.right)
                return "foldWidgets";
        };

    }).call(Gutter.prototype);

    function onCreateCell(element) {
        var textNode = document.createTextNode('');
        element.appendChild(textNode);
        
        var foldWidget = dom.createElement("span");
        element.appendChild(foldWidget);
        
        return element;
    }

    exports.Gutter = Gutter;

    });

    ace.define("ace/layer/marker",["require","exports","module","ace/range","ace/lib/dom"], function(require, exports, module) {

    var Range = require("../range").Range;
    var dom = require("../lib/dom");

    var Marker = function(parentEl) {
        this.element = dom.createElement("div");
        this.element.className = "ace_layer ace_marker-layer";
        parentEl.appendChild(this.element);
    };

    (function() {

        this.$padding = 0;

        this.setPadding = function(padding) {
            this.$padding = padding;
        };
        this.setSession = function(session) {
            this.session = session;
        };
        
        this.setMarkers = function(markers) {
            this.markers = markers;
        };
        
        this.elt = function(className, css) {
            var x = this.i != -1 && this.element.childNodes[this.i];
            if (!x) {
                x = document.createElement("div");
                this.element.appendChild(x);
                this.i = -1;
            } else {
                this.i++;
            }
            x.style.cssText = css;
            x.className = className;
        };

        this.update = function(config) {
            if (!config) return;

            this.config = config;

            this.i = 0;
            var html;
            for (var key in this.markers) {
                var marker = this.markers[key];

                if (!marker.range) {
                    marker.update(html, this, this.session, config);
                    continue;
                }

                var range = marker.range.clipRows(config.firstRow, config.lastRow);
                if (range.isEmpty()) continue;

                range = range.toScreenRange(this.session);
                if (marker.renderer) {
                    var top = this.$getTop(range.start.row, config);
                    var left = this.$padding + range.start.column * config.characterWidth;
                    marker.renderer(html, range, left, top, config);
                } else if (marker.type == "fullLine") {
                    this.drawFullLineMarker(html, range, marker.clazz, config);
                } else if (marker.type == "screenLine") {
                    this.drawScreenLineMarker(html, range, marker.clazz, config);
                } else if (range.isMultiLine()) {
                    if (marker.type == "text")
                        this.drawTextMarker(html, range, marker.clazz, config);
                    else
                        this.drawMultiLineMarker(html, range, marker.clazz, config);
                } else {
                    this.drawSingleLineMarker(html, range, marker.clazz + " ace_start" + " ace_br15", config);
                }
            }
            if (this.i !=-1) {
                while (this.i < this.element.childElementCount)
                    this.element.removeChild(this.element.lastChild);
            }
        };

        this.$getTop = function(row, layerConfig) {
            return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
        };

        function getBorderClass(tl, tr, br, bl) {
            return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);
        }
        this.drawTextMarker = function(stringBuilder, range, clazz, layerConfig, extraStyle) {
            var session = this.session;
            var start = range.start.row;
            var end = range.end.row;
            var row = start;
            var prev = 0; 
            var curr = 0;
            var next = session.getScreenLastRowColumn(row);
            var lineRange = new Range(row, range.start.column, row, curr);
            for (; row <= end; row++) {
                lineRange.start.row = lineRange.end.row = row;
                lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);
                lineRange.end.column = next;
                prev = curr;
                curr = next;
                next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;
                this.drawSingleLineMarker(stringBuilder, lineRange, 
                    clazz + (row == start  ? " ace_start" : "") + " ace_br"
                        + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end),
                    layerConfig, row == end ? 0 : 1, extraStyle);
            }
        };
        this.drawMultiLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
            var padding = this.$padding;
            var height = config.lineHeight;
            var top = this.$getTop(range.start.row, config);
            var left = padding + range.start.column * config.characterWidth;
            extraStyle = extraStyle || "";

            if (this.session.$bidiHandler.isBidiRow(range.start.row)) {
               var range1 = range.clone();
               range1.end.row = range1.start.row;
               range1.end.column = this.session.getLine(range1.start.row).length;
               this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br1 ace_start", config, null, extraStyle);
            } else {
                this.elt(
                    clazz + " ace_br1 ace_start",
                    "height:"+ height+ "px;"+ "right:0;"+ "top:"+top+ "px;left:"+ left+ "px;" + (extraStyle || "")
                );
            }
            if (this.session.$bidiHandler.isBidiRow(range.end.row)) {
               var range1 = range.clone();
               range1.start.row = range1.end.row;
               range1.start.column = 0;
               this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br12", config, null, extraStyle);
            } else {
                top = this.$getTop(range.end.row, config);
                var width = range.end.column * config.characterWidth;

                this.elt(
                    clazz + " ace_br12",
                    "height:"+ height+ "px;"+
                    "width:"+ width+ "px;"+
                    "top:"+ top+ "px;"+
                    "left:"+ padding+ "px;"+ (extraStyle || "")
                );
            }
            height = (range.end.row - range.start.row - 1) * config.lineHeight;
            if (height <= 0)
                return;
            top = this.$getTop(range.start.row + 1, config);
            
            var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);

            this.elt(
                clazz + (radiusClass ? " ace_br" + radiusClass : ""),
                "height:"+ height+ "px;"+
                "right:0;"+
                "top:"+ top+ "px;"+
                "left:"+ padding+ "px;"+ (extraStyle || "")
            );
        };
        this.drawSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
            if (this.session.$bidiHandler.isBidiRow(range.start.row))
                return this.drawBidiSingleLineMarker(stringBuilder, range, clazz, config, extraLength, extraStyle);
            var height = config.lineHeight;
            var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;

            var top = this.$getTop(range.start.row, config);
            var left = this.$padding + range.start.column * config.characterWidth;

            this.elt(
                clazz,
                "height:"+ height+ "px;"+
                "width:"+ width+ "px;"+
                "top:"+ top+ "px;"+
                "left:"+ left+ "px;"+ (extraStyle || "")
            );
        };
        this.drawBidiSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
            var height = config.lineHeight, top = this.$getTop(range.start.row, config), padding = this.$padding;
            var selections = this.session.$bidiHandler.getSelections(range.start.column, range.end.column);

            selections.forEach(function(selection) {
                this.elt(
                    clazz,
                    "height:" + height + "px;" +
                    "width:" + selection.width + (extraLength || 0) + "px;" +
                    "top:" + top + "px;" +
                    "left:" + (padding + selection.left) + "px;" + (extraStyle || "")
                );
            }, this);
        };

        this.drawFullLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
            var top = this.$getTop(range.start.row, config);
            var height = config.lineHeight;
            if (range.start.row != range.end.row)
                height += this.$getTop(range.end.row, config) - top;

            this.elt(
                clazz,
                "height:"+ height+ "px;"+
                "top:"+ top+ "px;"+
                "left:0;right:0;"+ (extraStyle || "")
            );
        };
        
        this.drawScreenLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
            var top = this.$getTop(range.start.row, config);
            var height = config.lineHeight;

            this.elt(
                clazz,
                "height:"+ height+ "px;"+
                "top:"+ top+ "px;"+
                "left:0;right:0;"+ (extraStyle || "")
            );
        };

    }).call(Marker.prototype);

    exports.Marker = Marker;

    });

    ace.define("ace/layer/text",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/layer/lines","ace/lib/event_emitter"], function(require, exports, module) {

    var oop = require("../lib/oop");
    var dom = require("../lib/dom");
    var lang = require("../lib/lang");
    var Lines = require("./lines").Lines;
    var EventEmitter = require("../lib/event_emitter").EventEmitter;

    var Text = function(parentEl) {
        this.dom = dom; 
        this.element = this.dom.createElement("div");
        this.element.className = "ace_layer ace_text-layer";
        parentEl.appendChild(this.element);
        this.$updateEolChar = this.$updateEolChar.bind(this);
        this.$lines = new Lines(this.element);
    };

    (function() {

        oop.implement(this, EventEmitter);

        this.EOF_CHAR = "\xB6";
        this.EOL_CHAR_LF = "\xAC";
        this.EOL_CHAR_CRLF = "\xa4";
        this.EOL_CHAR = this.EOL_CHAR_LF;
        this.TAB_CHAR = "\u2014"; //"\u21E5";
        this.SPACE_CHAR = "\xB7";
        this.$padding = 0;
        this.MAX_LINE_LENGTH = 10000;

        this.$updateEolChar = function() {
            var doc = this.session.doc;
            var unixMode = doc.getNewLineCharacter() == "\n" && doc.getNewLineMode() != "windows";
            var EOL_CHAR = unixMode ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;
            if (this.EOL_CHAR != EOL_CHAR) {
                this.EOL_CHAR = EOL_CHAR;
                return true;
            }
        };

        this.setPadding = function(padding) {
            this.$padding = padding;
            this.element.style.margin = "0 " + padding + "px";
        };

        this.getLineHeight = function() {
            return this.$fontMetrics.$characterSize.height || 0;
        };

        this.getCharacterWidth = function() {
            return this.$fontMetrics.$characterSize.width || 0;
        };
        
        this.$setFontMetrics = function(measure) {
            this.$fontMetrics = measure;
            this.$fontMetrics.on("changeCharacterSize", function(e) {
                this._signal("changeCharacterSize", e);
            }.bind(this));
            this.$pollSizeChanges();
        };

        this.checkForSizeChanges = function() {
            this.$fontMetrics.checkForSizeChanges();
        };
        this.$pollSizeChanges = function() {
            return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
        };
        this.setSession = function(session) {
            this.session = session;
            if (session)
                this.$computeTabString();
        };

        this.showInvisibles = false;
        this.setShowInvisibles = function(showInvisibles) {
            if (this.showInvisibles == showInvisibles)
                return false;

            this.showInvisibles = showInvisibles;
            this.$computeTabString();
            return true;
        };

        this.displayIndentGuides = true;
        this.setDisplayIndentGuides = function(display) {
            if (this.displayIndentGuides == display)
                return false;

            this.displayIndentGuides = display;
            this.$computeTabString();
            return true;
        };

        this.$tabStrings = [];
        this.onChangeTabSize =
        this.$computeTabString = function() {
            var tabSize = this.session.getTabSize();
            this.tabSize = tabSize;
            var tabStr = this.$tabStrings = [0];
            for (var i = 1; i < tabSize + 1; i++) {
                if (this.showInvisibles) {
                    var span = this.dom.createElement("span");
                    span.className = "ace_invisible ace_invisible_tab";
                    span.textContent = lang.stringRepeat(this.TAB_CHAR, i);
                    tabStr.push(span);
                } else {
                    tabStr.push(this.dom.createTextNode(lang.stringRepeat(" ", i), this.element));
                }
            }
            if (this.displayIndentGuides) {
                this.$indentGuideRe =  /\s\S| \t|\t |\s$/;
                var className = "ace_indent-guide";
                var spaceClass = "";
                var tabClass = "";
                if (this.showInvisibles) {
                    className += " ace_invisible";
                    spaceClass = " ace_invisible_space";
                    tabClass = " ace_invisible_tab";
                    var spaceContent = lang.stringRepeat(this.SPACE_CHAR, this.tabSize);
                    var tabContent = lang.stringRepeat(this.TAB_CHAR, this.tabSize);
                } else {
                    var spaceContent = lang.stringRepeat(" ", this.tabSize);
                    var tabContent = spaceContent;
                }

                var span = this.dom.createElement("span");
                span.className = className + spaceClass;
                span.textContent = spaceContent;
                this.$tabStrings[" "] = span;
                
                var span = this.dom.createElement("span");
                span.className = className + tabClass;
                span.textContent = tabContent;
                this.$tabStrings["\t"] = span;
            }
        };

        this.updateLines = function(config, firstRow, lastRow) {
            if (this.config.lastRow != config.lastRow ||
                this.config.firstRow != config.firstRow) {
                return this.update(config);
            }
            
            this.config = config;

            var first = Math.max(firstRow, config.firstRow);
            var last = Math.min(lastRow, config.lastRow);

            var lineElements = this.element.childNodes;
            var lineElementsIdx = 0;

            for (var row = config.firstRow; row < first; row++) {
                var foldLine = this.session.getFoldLine(row);
                if (foldLine) {
                    if (foldLine.containsRow(first)) {
                        first = foldLine.start.row;
                        break;
                    } else {
                        row = foldLine.end.row;
                    }
                }
                lineElementsIdx ++;
            }

            var heightChanged = false;
            var row = first;
            var foldLine = this.session.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;

            while (true) {
                if (row > foldStart) {
                    row = foldLine.end.row+1;
                    foldLine = this.session.getNextFoldLine(row, foldLine);
                    foldStart = foldLine ? foldLine.start.row :Infinity;
                }
                if (row > last)
                    break;

                var lineElement = lineElements[lineElementsIdx++];
                if (lineElement) {
                    this.dom.removeChildren(lineElement);
                    this.$renderLine(
                        lineElement, row, row == foldStart ? foldLine : false
                    );

                    if (heightChanged)
                        lineElement.style.top = this.$lines.computeLineTop(row, config, this.session) + "px";

                    var height = (config.lineHeight * this.session.getRowLength(row)) + "px";
                    if (lineElement.style.height != height) {
                        heightChanged = true;
                        lineElement.style.height = height;
                    }
                }
                row++;
            }
            if (heightChanged) {
                while (lineElementsIdx < this.$lines.cells.length) {
                    var cell = this.$lines.cells[lineElementsIdx++];
                    cell.element.style.top = this.$lines.computeLineTop(cell.row, config, this.session) + "px";
                }
            }
        };

        this.scrollLines = function(config) {
            var oldConfig = this.config;
            this.config = config;

            if (this.$lines.pageChanged(oldConfig, config))
                return this.update(config);
                
            this.$lines.moveContainer(config);
            
            var lastRow = config.lastRow;
            var oldLastRow = oldConfig ? oldConfig.lastRow : -1;

            if (!oldConfig || oldLastRow < config.firstRow)
                return this.update(config);

            if (lastRow < oldConfig.firstRow)
                return this.update(config);

            if (!oldConfig || oldConfig.lastRow < config.firstRow)
                return this.update(config);

            if (config.lastRow < oldConfig.firstRow)
                return this.update(config);

            if (oldConfig.firstRow < config.firstRow)
                for (var row=this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row>0; row--)
                    this.$lines.shift();

            if (oldConfig.lastRow > config.lastRow)
                for (var row=this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row>0; row--)
                    this.$lines.pop();

            if (config.firstRow < oldConfig.firstRow) {
                this.$lines.unshift(this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1));
            }

            if (config.lastRow > oldConfig.lastRow) {
                this.$lines.push(this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow));
            }
        };

        this.$renderLinesFragment = function(config, firstRow, lastRow) {
            var fragment = [];
            var row = firstRow;
            var foldLine = this.session.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;

            while (true) {
                if (row > foldStart) {
                    row = foldLine.end.row+1;
                    foldLine = this.session.getNextFoldLine(row, foldLine);
                    foldStart = foldLine ? foldLine.start.row : Infinity;
                }
                if (row > lastRow)
                    break;

                var line = this.$lines.createCell(row, config, this.session);
                
                var lineEl = line.element;
                this.dom.removeChildren(lineEl);
                dom.setStyle(lineEl.style, "height", this.$lines.computeLineHeight(row, config, this.session) + "px");
                dom.setStyle(lineEl.style, "top", this.$lines.computeLineTop(row, config, this.session) + "px");
                this.$renderLine(lineEl, row, row == foldStart ? foldLine : false);

                if (this.$useLineGroups()) {
                    lineEl.className = "ace_line_group";
                } else {
                    lineEl.className = "ace_line";
                }
                fragment.push(line);

                row++;
            }
            return fragment;
        };

        this.update = function(config) {
            this.$lines.moveContainer(config);
            
            this.config = config;

            var firstRow = config.firstRow;
            var lastRow = config.lastRow;

            var lines = this.$lines;
            while (lines.getLength())
                lines.pop();
                
            lines.push(this.$renderLinesFragment(config, firstRow, lastRow));
        };

        this.$textToken = {
            "text": true,
            "rparen": true,
            "lparen": true
        };

        this.$renderToken = function(parent, screenColumn, token, value) {
            var self = this;
            var re = /(\t)|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\uFEFF\uFFF9-\uFFFC]+)|(\u3000)|([\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3001-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]|[\uD800-\uDBFF][\uDC00-\uDFFF])/g;
            
            var valueFragment = this.dom.createFragment(this.element);

            var m;
            var i = 0;
            while (m = re.exec(value)) {
                var tab = m[1];
                var simpleSpace = m[2];
                var controlCharacter = m[3];
                var cjkSpace = m[4];
                var cjk = m[5];
                
                if (!self.showInvisibles && simpleSpace)
                    continue;

                var before = i != m.index ? value.slice(i, m.index) : "";

                i = m.index + m[0].length;
                
                if (before) {
                    valueFragment.appendChild(this.dom.createTextNode(before, this.element));
                }
                    
                if (tab) {
                    var tabSize = self.session.getScreenTabSize(screenColumn + m.index);
                    valueFragment.appendChild(self.$tabStrings[tabSize].cloneNode(true));
                    screenColumn += tabSize - 1;
                } else if (simpleSpace) {
                    if (self.showInvisibles) {
                        var span = this.dom.createElement("span");
                        span.className = "ace_invisible ace_invisible_space";
                        span.textContent = lang.stringRepeat(self.SPACE_CHAR, simpleSpace.length);
                        valueFragment.appendChild(span);
                    } else {
                        valueFragment.appendChild(this.com.createTextNode(simpleSpace, this.element));
                    }
                } else if (controlCharacter) {
                    var span = this.dom.createElement("span");
                    span.className = "ace_invisible ace_invisible_space ace_invalid";
                    span.textContent = lang.stringRepeat(self.SPACE_CHAR, controlCharacter.length);
                    valueFragment.appendChild(span);
                } else if (cjkSpace) {
                    screenColumn += 1;
                    
                    var span = this.dom.createElement("span");
                    span.style.width = (self.config.characterWidth * 2) + "px";
                    span.className = self.showInvisibles ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
                    span.textContent = self.showInvisibles ? self.SPACE_CHAR : cjkSpace;
                    valueFragment.appendChild(span);
                } else if (cjk) {
                    screenColumn += 1;
                    var span = this.dom.createElement("span");
                    span.style.width = (self.config.characterWidth * 2) + "px";
                    span.className = "ace_cjk";
                    span.textContent = cjk;
                    valueFragment.appendChild(span);
                }
            }
            
            valueFragment.appendChild(this.dom.createTextNode(i ? value.slice(i) : value, this.element));

            if (!this.$textToken[token.type]) {
                var classes = "ace_" + token.type.replace(/\./g, " ace_");
                var span = this.dom.createElement("span");
                if (token.type == "fold")
                    span.style.width = (token.value.length * this.config.characterWidth) + "px";
                    
                span.className = classes;
                span.appendChild(valueFragment);
                
                parent.appendChild(span);
            }
            else {
                parent.appendChild(valueFragment);
            }
            
            return screenColumn + value.length;
        };

        this.renderIndentGuide = function(parent, value, max) {
            var cols = value.search(this.$indentGuideRe);
            if (cols <= 0 || cols >= max)
                return value;
            if (value[0] == " ") {
                cols -= cols % this.tabSize;
                var count = cols/this.tabSize;
                for (var i=0; i<count; i++) {
                    parent.appendChild(this.$tabStrings[" "].cloneNode(true));
                }
                return value.substr(cols);
            } else if (value[0] == "\t") {
                for (var i=0; i<cols; i++) {
                    parent.appendChild(this.$tabStrings["\t"].cloneNode(true));
                }
                return value.substr(cols);
            }
            return value;
        };

        this.$createLineElement = function(parent) {
            var lineEl = this.dom.createElement("div");
            lineEl.className = "ace_line";
            lineEl.style.height = this.config.lineHeight + "px";
            
            return lineEl;
        };

        this.$renderWrappedLine = function(parent, tokens, splits) {
            var chars = 0;
            var split = 0;
            var splitChars = splits[0];
            var screenColumn = 0;

            var lineEl = this.$createLineElement();
            parent.appendChild(lineEl);
            
            for (var i = 0; i < tokens.length; i++) {
                var token = tokens[i];
                var value = token.value;
                if (i == 0 && this.displayIndentGuides) {
                    chars = value.length;
                    value = this.renderIndentGuide(lineEl, value, splitChars);
                    if (!value)
                        continue;
                    chars -= value.length;
                }

                if (chars + value.length < splitChars) {
                    screenColumn = this.$renderToken(lineEl, screenColumn, token, value);
                    chars += value.length;
                } else {
                    while (chars + value.length >= splitChars) {
                        screenColumn = this.$renderToken(
                            lineEl, screenColumn,
                            token, value.substring(0, splitChars - chars)
                        );
                        value = value.substring(splitChars - chars);
                        chars = splitChars;

                        lineEl = this.$createLineElement();
                        parent.appendChild(lineEl);

                        lineEl.appendChild(this.dom.createTextNode(lang.stringRepeat("\xa0", splits.indent), this.element));

                        split ++;
                        screenColumn = 0;
                        splitChars = splits[split] || Number.MAX_VALUE;
                    }
                    if (value.length != 0) {
                        chars += value.length;
                        screenColumn = this.$renderToken(
                            lineEl, screenColumn, token, value
                        );
                    }
                }
            }
            
            if (splits[splits.length - 1] > this.MAX_LINE_LENGTH)
                this.$renderOverflowMessage(lineEl, screenColumn, null, "", true);
        };

        this.$renderSimpleLine = function(parent, tokens) {
            var screenColumn = 0;
            var token = tokens[0];
            var value = token.value;
            if (this.displayIndentGuides)
                value = this.renderIndentGuide(parent, value);
            if (value)
                screenColumn = this.$renderToken(parent, screenColumn, token, value);
            for (var i = 1; i < tokens.length; i++) {
                token = tokens[i];
                value = token.value;
                if (screenColumn + value.length > this.MAX_LINE_LENGTH)
                    return this.$renderOverflowMessage(parent, screenColumn, token, value);
                screenColumn = this.$renderToken(parent, screenColumn, token, value);
            }
        };
        
        this.$renderOverflowMessage = function(parent, screenColumn, token, value, hide) {
            token && this.$renderToken(parent, screenColumn, token,
                value.slice(0, this.MAX_LINE_LENGTH - screenColumn));
                
            var overflowEl = this.dom.createElement("span");
            overflowEl.className = "ace_inline_button ace_keyword ace_toggle_wrap";
            overflowEl.textContent = hide ? "<hide>" : "<click to see more...>";
            
            parent.appendChild(overflowEl);        
        };
        this.$renderLine = function(parent, row, foldLine) {
            if (!foldLine && foldLine != false)
                foldLine = this.session.getFoldLine(row);

            if (foldLine)
                var tokens = this.$getFoldLineTokens(row, foldLine);
            else
                var tokens = this.session.getTokens(row);

            var lastLineEl = parent;
            if (tokens.length) {
                var splits = this.session.getRowSplitData(row);
                if (splits && splits.length) {
                    this.$renderWrappedLine(parent, tokens, splits);
                    var lastLineEl = parent.lastChild;
                } else {
                    var lastLineEl = parent;
                    if (this.$useLineGroups()) {
                        lastLineEl = this.$createLineElement();
                        parent.appendChild(lastLineEl);
                    }
                    this.$renderSimpleLine(lastLineEl, tokens);
                }
            } else if (this.$useLineGroups()) {
                lastLineEl = this.$createLineElement();
                parent.appendChild(lastLineEl);
            }

            if (this.showInvisibles && lastLineEl) {
                if (foldLine)
                    row = foldLine.end.row;

                var invisibleEl = this.dom.createElement("span");
                invisibleEl.className = "ace_invisible ace_invisible_eol";
                invisibleEl.textContent = row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR;
                
                lastLineEl.appendChild(invisibleEl);
            }
        };

        this.$getFoldLineTokens = function(row, foldLine) {
            var session = this.session;
            var renderTokens = [];

            function addTokens(tokens, from, to) {
                var idx = 0, col = 0;
                while ((col + tokens[idx].value.length) < from) {
                    col += tokens[idx].value.length;
                    idx++;

                    if (idx == tokens.length)
                        return;
                }
                if (col != from) {
                    var value = tokens[idx].value.substring(from - col);
                    if (value.length > (to - from))
                        value = value.substring(0, to - from);

                    renderTokens.push({
                        type: tokens[idx].type,
                        value: value
                    });

                    col = from + value.length;
                    idx += 1;
                }

                while (col < to && idx < tokens.length) {
                    var value = tokens[idx].value;
                    if (value.length + col > to) {
                        renderTokens.push({
                            type: tokens[idx].type,
                            value: value.substring(0, to - col)
                        });
                    } else
                        renderTokens.push(tokens[idx]);
                    col += value.length;
                    idx += 1;
                }
            }

            var tokens = session.getTokens(row);
            foldLine.walk(function(placeholder, row, column, lastColumn, isNewRow) {
                if (placeholder != null) {
                    renderTokens.push({
                        type: "fold",
                        value: placeholder
                    });
                } else {
                    if (isNewRow)
                        tokens = session.getTokens(row);

                    if (tokens.length)
                        addTokens(tokens, lastColumn, column);
                }
            }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);

            return renderTokens;
        };

        this.$useLineGroups = function() {
            return this.session.getUseWrapMode();
        };

        this.destroy = function() {};
    }).call(Text.prototype);

    exports.Text = Text;

    });

    ace.define("ace/layer/cursor",["require","exports","module","ace/lib/dom"], function(require, exports, module) {

    var dom = require("../lib/dom");

    var Cursor = function(parentEl) {
        this.element = dom.createElement("div");
        this.element.className = "ace_layer ace_cursor-layer";
        parentEl.appendChild(this.element);
        
        this.isVisible = false;
        this.isBlinking = true;
        this.blinkInterval = 1000;
        this.smoothBlinking = false;

        this.cursors = [];
        this.cursor = this.addCursor();
        dom.addCssClass(this.element, "ace_hidden-cursors");
        this.$updateCursors = this.$updateOpacity.bind(this);
    };

    (function() {
        
        this.$updateOpacity = function(val) {
            var cursors = this.cursors;
            for (var i = cursors.length; i--; )
                dom.setStyle(cursors[i].style, "opacity", val ? "" : "0");
        };

        this.$startCssAnimation = function() {
            var cursors = this.cursors;
            for (var i = cursors.length; i--; )
                cursors[i].style.animationDuration = this.blinkInterval + "ms";

            setTimeout(function() {
                dom.addCssClass(this.element, "ace_animate-blinking");
            }.bind(this));
        };
        
        this.$stopCssAnimation = function() {
            dom.removeCssClass(this.element, "ace_animate-blinking");
        };

        this.$padding = 0;
        this.setPadding = function(padding) {
            this.$padding = padding;
        };

        this.setSession = function(session) {
            this.session = session;
        };

        this.setBlinking = function(blinking) {
            if (blinking != this.isBlinking) {
                this.isBlinking = blinking;
                this.restartTimer();
            }
        };

        this.setBlinkInterval = function(blinkInterval) {
            if (blinkInterval != this.blinkInterval) {
                this.blinkInterval = blinkInterval;
                this.restartTimer();
            }
        };

        this.setSmoothBlinking = function(smoothBlinking) {
            if (smoothBlinking != this.smoothBlinking) {
                this.smoothBlinking = smoothBlinking;
                dom.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
                this.$updateCursors(true);
                this.restartTimer();
            }
        };

        this.addCursor = function() {
            var el = dom.createElement("div");
            el.className = "ace_cursor";
            this.element.appendChild(el);
            this.cursors.push(el);
            return el;
        };

        this.removeCursor = function() {
            if (this.cursors.length > 1) {
                var el = this.cursors.pop();
                el.parentNode.removeChild(el);
                return el;
            }
        };

        this.hideCursor = function() {
            this.isVisible = false;
            dom.addCssClass(this.element, "ace_hidden-cursors");
            this.restartTimer();
        };

        this.showCursor = function() {
            this.isVisible = true;
            dom.removeCssClass(this.element, "ace_hidden-cursors");
            this.restartTimer();
        };

        this.restartTimer = function() {
            var update = this.$updateCursors;
            clearInterval(this.intervalId);
            clearTimeout(this.timeoutId);
            this.$stopCssAnimation();

            if (this.smoothBlinking) {
                dom.removeCssClass(this.element, "ace_smooth-blinking");
            }
            
            update(true);

            if (!this.isBlinking || !this.blinkInterval || !this.isVisible) {
                this.$stopCssAnimation();
                return;
            }

            if (this.smoothBlinking) {
                setTimeout(function(){
                    dom.addCssClass(this.element, "ace_smooth-blinking");
                }.bind(this));
            }
            
            if (dom.HAS_CSS_ANIMATION) {
                this.$startCssAnimation();
            } else {
                var blink = function(){
                    this.timeoutId = setTimeout(function() {
                        update(false);
                    }, 0.6 * this.blinkInterval);
                }.bind(this);
        
                this.intervalId = setInterval(function() {
                    update(true);
                    blink();
                }, this.blinkInterval);
                blink();
            }
        };

        this.getPixelPosition = function(position, onScreen) {
            if (!this.config || !this.session)
                return {left : 0, top : 0};

            if (!position)
                position = this.session.selection.getCursor();
            var pos = this.session.documentToScreenPosition(position);
            var cursorLeft = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, position.row)
                ? this.session.$bidiHandler.getPosLeft(pos.column)
                : pos.column * this.config.characterWidth);

            var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) *
                this.config.lineHeight;

            return {left : cursorLeft, top : cursorTop};
        };

        this.isCursorInView = function(pixelPos, config) {
            return pixelPos.top >= 0 && pixelPos.top < config.maxHeight;
        };

        this.update = function(config) {
            this.config = config;

            var selections = this.session.$selectionMarkers;
            var i = 0, cursorIndex = 0;

            if (selections === undefined || selections.length === 0){
                selections = [{cursor: null}];
            }

            for (var i = 0, n = selections.length; i < n; i++) {
                var pixelPos = this.getPixelPosition(selections[i].cursor, true);
                if ((pixelPos.top > config.height + config.offset ||
                     pixelPos.top < 0) && i > 1) {
                    continue;
                }

                var element = this.cursors[cursorIndex++] || this.addCursor();
                var style = element.style;
                
                if (!this.drawCursor) {
                    if (!this.isCursorInView(pixelPos, config)) {
                        dom.setStyle(style, "display", "none");
                    } else {
                        dom.setStyle(style, "display", "block");
                        dom.translate(element, pixelPos.left, pixelPos.top);
                        dom.setStyle(style, "width", Math.round(config.characterWidth) + "px");
                        dom.setStyle(style, "height", config.lineHeight + "px");
                    }
                } else {
                    this.drawCursor(element, pixelPos, config, selections[i], this.session);
                }
            }
            while (this.cursors.length > cursorIndex)
                this.removeCursor();

            var overwrite = this.session.getOverwrite();
            this.$setOverwrite(overwrite);
            this.$pixelPos = pixelPos;
            this.restartTimer();
        };
        
        this.drawCursor = null;

        this.$setOverwrite = function(overwrite) {
            if (overwrite != this.overwrite) {
                this.overwrite = overwrite;
                if (overwrite)
                    dom.addCssClass(this.element, "ace_overwrite-cursors");
                else
                    dom.removeCssClass(this.element, "ace_overwrite-cursors");
            }
        };

        this.destroy = function() {
            clearInterval(this.intervalId);
            clearTimeout(this.timeoutId);
        };

    }).call(Cursor.prototype);

    exports.Cursor = Cursor;

    });

    ace.define("ace/scrollbar",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/event","ace/lib/event_emitter"], function(require, exports, module) {

    var oop = require("./lib/oop");
    var dom = require("./lib/dom");
    var event = require("./lib/event");
    var EventEmitter = require("./lib/event_emitter").EventEmitter;
    var MAX_SCROLL_H = 0x8000;
    var ScrollBar = function(parent) {
        this.element = dom.createElement("div");
        this.element.className = "ace_scrollbar ace_scrollbar" + this.classSuffix;

        this.inner = dom.createElement("div");
        this.inner.className = "ace_scrollbar-inner";
        this.inner.textContent = "\xa0";
        this.element.appendChild(this.inner);

        parent.appendChild(this.element);

        this.setVisible(false);
        this.skipEvent = false;

        event.addListener(this.element, "scroll", this.onScroll.bind(this));
        event.addListener(this.element, "mousedown", event.preventDefault);
    };

    (function() {
        oop.implement(this, EventEmitter);

        this.setVisible = function(isVisible) {
            this.element.style.display = isVisible ? "" : "none";
            this.isVisible = isVisible;
            this.coeff = 1;
        };
    }).call(ScrollBar.prototype);
    var VScrollBar = function(parent, renderer) {
        ScrollBar.call(this, parent);
        this.scrollTop = 0;
        this.scrollHeight = 0;
        renderer.$scrollbarWidth = 
        this.width = dom.scrollbarWidth(parent.ownerDocument);
        this.inner.style.width =
        this.element.style.width = (this.width || 15) + 5 + "px";
        this.$minWidth = 0;
    };

    oop.inherits(VScrollBar, ScrollBar);

    (function() {

        this.classSuffix = '-v';
        this.onScroll = function() {
            if (!this.skipEvent) {
                this.scrollTop = this.element.scrollTop;
                if (this.coeff != 1) {
                    var h = this.element.clientHeight / this.scrollHeight;
                    this.scrollTop = this.scrollTop * (1 - h) / (this.coeff - h);
                }
                this._emit("scroll", {data: this.scrollTop});
            }
            this.skipEvent = false;
        };
        this.getWidth = function() {
            return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
        };
        this.setHeight = function(height) {
            this.element.style.height = height + "px";
        };
        this.setInnerHeight = 
        this.setScrollHeight = function(height) {
            this.scrollHeight = height;
            if (height > MAX_SCROLL_H) {
                this.coeff = MAX_SCROLL_H / height;
                height = MAX_SCROLL_H;
            } else if (this.coeff != 1) {
                this.coeff = 1;
            }
            this.inner.style.height = height + "px";
        };
        this.setScrollTop = function(scrollTop) {
            if (this.scrollTop != scrollTop) {
                this.skipEvent = true;
                this.scrollTop = scrollTop;
                this.element.scrollTop = scrollTop * this.coeff;
            }
        };

    }).call(VScrollBar.prototype);
    var HScrollBar = function(parent, renderer) {
        ScrollBar.call(this, parent);
        this.scrollLeft = 0;
        this.height = renderer.$scrollbarWidth;
        this.inner.style.height =
        this.element.style.height = (this.height || 15) + 5 + "px";
    };

    oop.inherits(HScrollBar, ScrollBar);

    (function() {

        this.classSuffix = '-h';
        this.onScroll = function() {
            if (!this.skipEvent) {
                this.scrollLeft = this.element.scrollLeft;
                this._emit("scroll", {data: this.scrollLeft});
            }
            this.skipEvent = false;
        };
        this.getHeight = function() {
            return this.isVisible ? this.height : 0;
        };
        this.setWidth = function(width) {
            this.element.style.width = width + "px";
        };
        this.setInnerWidth = function(width) {
            this.inner.style.width = width + "px";
        };
        this.setScrollWidth = function(width) {
            this.inner.style.width = width + "px";
        };
        this.setScrollLeft = function(scrollLeft) {
            if (this.scrollLeft != scrollLeft) {
                this.skipEvent = true;
                this.scrollLeft = this.element.scrollLeft = scrollLeft;
            }
        };

    }).call(HScrollBar.prototype);


    exports.ScrollBar = VScrollBar; // backward compatibility
    exports.ScrollBarV = VScrollBar; // backward compatibility
    exports.ScrollBarH = HScrollBar; // backward compatibility

    exports.VScrollBar = VScrollBar;
    exports.HScrollBar = HScrollBar;
    });

    ace.define("ace/renderloop",["require","exports","module","ace/lib/event"], function(require, exports, module) {

    var event = require("./lib/event");


    var RenderLoop = function(onRender, win) {
        this.onRender = onRender;
        this.pending = false;
        this.changes = 0;
        this.$recursionLimit = 2;
        this.window = win || window;
        var _self = this;
        this._flush = function(ts) {
            _self.pending = false;
            var changes = _self.changes;

            if (changes) {
                event.blockIdle(100);
                _self.changes = 0;
                _self.onRender(changes);
            }
            
            if (_self.changes) {
                if (_self.$recursionLimit-- < 0) return;
                _self.schedule();
            } else {
                _self.$recursionLimit = 2;
            }
        };
    };

    (function() {

        this.schedule = function(change) {
            this.changes = this.changes | change;
            if (this.changes && !this.pending) {
                event.nextFrame(this._flush);
                this.pending = true;
            }
        };

        this.clear = function(change) {
            var changes = this.changes;
            this.changes = 0;
            return changes;
        };

    }).call(RenderLoop.prototype);

    exports.RenderLoop = RenderLoop;
    });

    ace.define("ace/layer/font_metrics",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/event","ace/lib/useragent","ace/lib/event_emitter"], function(require, exports, module) {

    var oop = require("../lib/oop");
    var dom = require("../lib/dom");
    var lang = require("../lib/lang");
    var event = require("../lib/event");
    var useragent = require("../lib/useragent");
    var EventEmitter = require("../lib/event_emitter").EventEmitter;

    var CHAR_COUNT = 256;
    var USE_OBSERVER = typeof ResizeObserver == "function";
    var L = 200;

    var FontMetrics = exports.FontMetrics = function(parentEl) {
        this.el = dom.createElement("div");
        this.$setMeasureNodeStyles(this.el.style, true);
        
        this.$main = dom.createElement("div");
        this.$setMeasureNodeStyles(this.$main.style);
        
        this.$measureNode = dom.createElement("div");
        this.$setMeasureNodeStyles(this.$measureNode.style);
        
        
        this.el.appendChild(this.$main);
        this.el.appendChild(this.$measureNode);
        parentEl.appendChild(this.el);
        
        this.$measureNode.innerHTML = lang.stringRepeat("X", CHAR_COUNT);
        
        this.$characterSize = {width: 0, height: 0};
        
        
        if (USE_OBSERVER)
            this.$addObserver();
        else
            this.checkForSizeChanges();
    };

    (function() {

        oop.implement(this, EventEmitter);
            
        this.$characterSize = {width: 0, height: 0};
        
        this.$setMeasureNodeStyles = function(style, isRoot) {
            style.width = style.height = "auto";
            style.left = style.top = "0px";
            style.visibility = "hidden";
            style.position = "absolute";
            style.whiteSpace = "pre";

            if (useragent.isIE < 8) {
                style["font-family"] = "inherit";
            } else {
                style.font = "inherit";
            }
            style.overflow = isRoot ? "hidden" : "visible";
        };

        this.checkForSizeChanges = function(size) {
            if (size === undefined)
                size = this.$measureSizes();
            if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
                this.$measureNode.style.fontWeight = "bold";
                var boldSize = this.$measureSizes();
                this.$measureNode.style.fontWeight = "";
                this.$characterSize = size;
                this.charSizes = Object.create(null);
                this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
                this._emit("changeCharacterSize", {data: size});
            }
        };
        
        this.$addObserver = function() {
            var self = this;
            this.$observer = new window.ResizeObserver(function(e) {
                var rect = e[0].contentRect;
                self.checkForSizeChanges({
                    height: rect.height,
                    width: rect.width / CHAR_COUNT
                });
            });
            this.$observer.observe(this.$measureNode);
        };

        this.$pollSizeChanges = function() {
            if (this.$pollSizeChangesTimer || this.$observer)
                return this.$pollSizeChangesTimer;
            var self = this;
            
            return this.$pollSizeChangesTimer = event.onIdle(function cb() {
                self.checkForSizeChanges();
                event.onIdle(cb, 500);
            }, 500);
        };
        
        this.setPolling = function(val) {
            if (val) {
                this.$pollSizeChanges();
            } else if (this.$pollSizeChangesTimer) {
                clearInterval(this.$pollSizeChangesTimer);
                this.$pollSizeChangesTimer = 0;
            }
        };

        this.$measureSizes = function(node) {
            var size = {
                height: (node || this.$measureNode).clientHeight,
                width: (node || this.$measureNode).clientWidth / CHAR_COUNT
            };
            if (size.width === 0 || size.height === 0)
                return null;
            return size;
        };

        this.$measureCharWidth = function(ch) {
            this.$main.innerHTML = lang.stringRepeat(ch, CHAR_COUNT);
            var rect = this.$main.getBoundingClientRect();
            return rect.width / CHAR_COUNT;
        };
        
        this.getCharacterWidth = function(ch) {
            var w = this.charSizes[ch];
            if (w === undefined) {
                w = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
            }
            return w;
        };

        this.destroy = function() {
            clearInterval(this.$pollSizeChangesTimer);
            if (this.$observer)
                this.$observer.disconnect();
            if (this.el && this.el.parentNode)
                this.el.parentNode.removeChild(this.el);
        };

        
        this.$getZoom = function getZoom(element) {
            if (!element) return 1;
            return (window.getComputedStyle(element).zoom || 1) * getZoom(element.parentElement);
        };
        this.$initTransformMeasureNodes = function() {
            var t = function(t, l) {
                return ["div", {
                    style: "position: absolute;top:" + t + "px;left:" + l + "px;"
                }];
            };
            this.els = dom.buildDom([t(0, 0), t(L, 0), t(0, L), t(L, L)], this.el);
        };
        this.transformCoordinates = function(clientPos, elPos) {
            if (clientPos) {
                var zoom = this.$getZoom(this.el);
                clientPos = mul(1 / zoom, clientPos);
            }
            function solve(l1, l2, r) {
                var det = l1[1] * l2[0] - l1[0] * l2[1];
                return [
                    (-l2[1] * r[0] + l2[0] * r[1]) / det,
                    (+l1[1] * r[0] - l1[0] * r[1]) / det
                ];
            }
            function sub(a, b) { return [a[0] - b[0], a[1] - b[1]]; }
            function add(a, b) { return [a[0] + b[0], a[1] + b[1]]; }
            function mul(a, b) { return [a * b[0], a * b[1]]; }

            if (!this.els)
                this.$initTransformMeasureNodes();
            
            function p(el) {
                var r = el.getBoundingClientRect();
                return [r.left, r.top];
            }

            var a = p(this.els[0]);
            var b = p(this.els[1]);
            var c = p(this.els[2]);
            var d = p(this.els[3]);

            var h = solve(sub(d, b), sub(d, c), sub(add(b, c), add(d, a)));

            var m1 = mul(1 + h[0], sub(b, a));
            var m2 = mul(1 + h[1], sub(c, a));
            
            if (elPos) {
                var x = elPos;
                var k = h[0] * x[0] / L + h[1] * x[1] / L + 1;
                var ut = add(mul(x[0], m1), mul(x[1], m2));
                return  add(mul(1 / k / L, ut), a);
            }
            var u = sub(clientPos, a);
            var f = solve(sub(m1, mul(h[0], u)), sub(m2, mul(h[1], u)), u);
            return mul(L, f);
        };
        
    }).call(FontMetrics.prototype);

    });

    ace.define("ace/virtual_renderer",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/config","ace/layer/gutter","ace/layer/marker","ace/layer/text","ace/layer/cursor","ace/scrollbar","ace/scrollbar","ace/renderloop","ace/layer/font_metrics","ace/lib/event_emitter","ace/lib/useragent"], function(require, exports, module) {

    var oop = require("./lib/oop");
    var dom = require("./lib/dom");
    var config = require("./config");
    var GutterLayer = require("./layer/gutter").Gutter;
    var MarkerLayer = require("./layer/marker").Marker;
    var TextLayer = require("./layer/text").Text;
    var CursorLayer = require("./layer/cursor").Cursor;
    var HScrollBar = require("./scrollbar").HScrollBar;
    var VScrollBar = require("./scrollbar").VScrollBar;
    var RenderLoop = require("./renderloop").RenderLoop;
    var FontMetrics = require("./layer/font_metrics").FontMetrics;
    var EventEmitter = require("./lib/event_emitter").EventEmitter;
    var editorCss = "\
.ace_br1 {border-top-left-radius    : 3px;}\
.ace_br2 {border-top-right-radius   : 3px;}\
.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}\
.ace_br4 {border-bottom-right-radius: 3px;}\
.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}\
.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}\
.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}\
.ace_br8 {border-bottom-left-radius : 3px;}\
.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}\
.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}\
.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}\
.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}\
.ace_editor {\
position: relative;\
overflow: hidden;\
font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;\
direction: ltr;\
text-align: left;\
-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\
}\
.ace_scroller {\
position: absolute;\
overflow: hidden;\
top: 0;\
bottom: 0;\
background-color: inherit;\
-ms-user-select: none;\
-moz-user-select: none;\
-webkit-user-select: none;\
user-select: none;\
cursor: text;\
}\
.ace_content {\
position: absolute;\
box-sizing: border-box;\
min-width: 100%;\
contain: style size layout;\
font-variant-ligatures: no-common-ligatures;\
}\
.ace_dragging .ace_scroller:before{\
position: absolute;\
top: 0;\
left: 0;\
right: 0;\
bottom: 0;\
content: '';\
background: rgba(250, 250, 250, 0.01);\
z-index: 1000;\
}\
.ace_dragging.ace_dark .ace_scroller:before{\
background: rgba(0, 0, 0, 0.01);\
}\
.ace_selecting, .ace_selecting * {\
cursor: text !important;\
}\
.ace_gutter {\
position: absolute;\
overflow : hidden;\
width: auto;\
top: 0;\
bottom: 0;\
left: 0;\
cursor: default;\
z-index: 4;\
-ms-user-select: none;\
-moz-user-select: none;\
-webkit-user-select: none;\
user-select: none;\
contain: style size layout;\
}\
.ace_gutter-active-line {\
position: absolute;\
left: 0;\
right: 0;\
}\
.ace_scroller.ace_scroll-left {\
box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;\
}\
.ace_gutter-cell {\
position: absolute;\
top: 0;\
left: 0;\
right: 0;\
padding-left: 19px;\
padding-right: 6px;\
background-repeat: no-repeat;\
}\
.ace_gutter-cell.ace_error {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==\");\
background-repeat: no-repeat;\
background-position: 2px center;\
}\
.ace_gutter-cell.ace_warning {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==\");\
background-position: 2px center;\
}\
.ace_gutter-cell.ace_info {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=\");\
background-position: 2px center;\
}\
.ace_dark .ace_gutter-cell.ace_info {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC\");\
}\
.ace_scrollbar {\
contain: strict;\
position: absolute;\
right: 0;\
bottom: 0;\
z-index: 6;\
}\
.ace_scrollbar-inner {\
position: absolute;\
cursor: text;\
left: 0;\
top: 0;\
}\
.ace_scrollbar-v{\
overflow-x: hidden;\
overflow-y: scroll;\
top: 0;\
}\
.ace_scrollbar-h {\
overflow-x: scroll;\
overflow-y: hidden;\
left: 0;\
}\
.ace_print-margin {\
position: absolute;\
height: 100%;\
}\
.ace_text-input {\
position: absolute;\
z-index: 0;\
width: 0.5em;\
height: 1em;\
opacity: 0;\
background: transparent;\
-moz-appearance: none;\
appearance: none;\
border: none;\
resize: none;\
outline: none;\
overflow: hidden;\
font: inherit;\
padding: 0 1px;\
margin: 0 -1px;\
contain: strict;\
-ms-user-select: text;\
-moz-user-select: text;\
-webkit-user-select: text;\
user-select: text;\
white-space: pre!important;\
}\
.ace_text-input.ace_composition {\
background: transparent;\
color: inherit;\
z-index: 1000;\
opacity: 1;\
}\
.ace_composition_placeholder { color: transparent }\
.ace_composition_marker { \
border-bottom: 1px solid;\
position: absolute;\
border-radius: 0;\
margin-top: 1px;\
}\
[ace_nocontext=true] {\
transform: none!important;\
filter: none!important;\
clip-path: none!important;\
mask : none!important;\
contain: none!important;\
perspective: none!important;\
mix-blend-mode: initial!important;\
z-index: auto;\
}\
.ace_layer {\
z-index: 1;\
position: absolute;\
overflow: hidden;\
word-wrap: normal;\
white-space: pre;\
height: 100%;\
width: 100%;\
box-sizing: border-box;\
pointer-events: none;\
}\
.ace_gutter-layer {\
position: relative;\
width: auto;\
text-align: right;\
pointer-events: auto;\
height: 1000000px;\
contain: style size layout;\
}\
.ace_text-layer {\
font: inherit !important;\
position: absolute;\
height: 1000000px;\
width: 1000000px;\
contain: style size layout;\
}\
.ace_text-layer > .ace_line, .ace_text-layer > .ace_line_group {\
contain: style size layout;\
position: absolute;\
top: 0;\
left: 0;\
right: 0;\
}\
.ace_hidpi .ace_text-layer,\
.ace_hidpi .ace_gutter-layer,\
.ace_hidpi .ace_content,\
.ace_hidpi .ace_gutter {\
contain: strict;\
will-change: transform;\
}\
.ace_hidpi .ace_text-layer > .ace_line, \
.ace_hidpi .ace_text-layer > .ace_line_group {\
contain: strict;\
}\
.ace_cjk {\
display: inline-block;\
text-align: center;\
}\
.ace_cursor-layer {\
z-index: 4;\
}\
.ace_cursor {\
z-index: 4;\
position: absolute;\
box-sizing: border-box;\
border-left: 2px solid;\
transform: translatez(0);\
}\
.ace_multiselect .ace_cursor {\
border-left-width: 1px;\
}\
.ace_slim-cursors .ace_cursor {\
border-left-width: 1px;\
}\
.ace_overwrite-cursors .ace_cursor {\
border-left-width: 0;\
border-bottom: 1px solid;\
}\
.ace_hidden-cursors .ace_cursor {\
opacity: 0.2;\
}\
.ace_hasPlaceholder .ace_hidden-cursors .ace_cursor {\
opacity: 0;\
}\
.ace_smooth-blinking .ace_cursor {\
transition: opacity 0.18s;\
}\
.ace_animate-blinking .ace_cursor {\
animation-duration: 1000ms;\
animation-timing-function: step-end;\
animation-name: blink-ace-animate;\
animation-iteration-count: infinite;\
}\
.ace_animate-blinking.ace_smooth-blinking .ace_cursor {\
animation-duration: 1000ms;\
animation-timing-function: ease-in-out;\
animation-name: blink-ace-animate-smooth;\
}\
@keyframes blink-ace-animate {\
from, to { opacity: 1; }\
60% { opacity: 0; }\
}\
@keyframes blink-ace-animate-smooth {\
from, to { opacity: 1; }\
45% { opacity: 1; }\
60% { opacity: 0; }\
85% { opacity: 0; }\
}\
.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {\
position: absolute;\
z-index: 3;\
}\
.ace_marker-layer .ace_selection {\
position: absolute;\
z-index: 5;\
}\
.ace_marker-layer .ace_bracket {\
position: absolute;\
z-index: 6;\
}\
.ace_marker-layer .ace_error_bracket {\
position: absolute;\
border-bottom: 1px solid #DE5555;\
border-radius: 0;\
}\
.ace_marker-layer .ace_active-line {\
position: absolute;\
z-index: 2;\
}\
.ace_marker-layer .ace_selected-word {\
position: absolute;\
z-index: 4;\
box-sizing: border-box;\
}\
.ace_line .ace_fold {\
box-sizing: border-box;\
display: inline-block;\
height: 11px;\
margin-top: -2px;\
vertical-align: middle;\
background-image:\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=\");\
background-repeat: no-repeat, repeat-x;\
background-position: center center, top left;\
color: transparent;\
border: 1px solid black;\
border-radius: 2px;\
cursor: pointer;\
pointer-events: auto;\
}\
.ace_dark .ace_fold {\
}\
.ace_fold:hover{\
background-image:\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC\");\
}\
.ace_tooltip {\
background-color: #FFF;\
background-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));\
border: 1px solid gray;\
border-radius: 1px;\
box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\
color: black;\
max-width: 100%;\
padding: 3px 4px;\
position: fixed;\
z-index: 999999;\
box-sizing: border-box;\
cursor: default;\
white-space: pre;\
word-wrap: break-word;\
line-height: normal;\
font-style: normal;\
font-weight: normal;\
letter-spacing: normal;\
pointer-events: none;\
}\
.ace_folding-enabled > .ace_gutter-cell {\
padding-right: 13px;\
}\
.ace_fold-widget {\
box-sizing: border-box;\
margin: 0 -12px 0 1px;\
display: none;\
width: 11px;\
vertical-align: top;\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==\");\
background-repeat: no-repeat;\
background-position: center;\
border-radius: 3px;\
border: 1px solid transparent;\
cursor: pointer;\
}\
.ace_folding-enabled .ace_fold-widget {\
display: inline-block;   \
}\
.ace_fold-widget.ace_end {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==\");\
}\
.ace_fold-widget.ace_closed {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==\");\
}\
.ace_fold-widget:hover {\
border: 1px solid rgba(0, 0, 0, 0.3);\
background-color: rgba(255, 255, 255, 0.2);\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\
}\
.ace_fold-widget:active {\
border: 1px solid rgba(0, 0, 0, 0.4);\
background-color: rgba(0, 0, 0, 0.05);\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\
}\
.ace_dark .ace_fold-widget {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC\");\
}\
.ace_dark .ace_fold-widget.ace_end {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==\");\
}\
.ace_dark .ace_fold-widget.ace_closed {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==\");\
}\
.ace_dark .ace_fold-widget:hover {\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
background-color: rgba(255, 255, 255, 0.1);\
}\
.ace_dark .ace_fold-widget:active {\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
}\
.ace_inline_button {\
border: 1px solid lightgray;\
display: inline-block;\
margin: -1px 8px;\
padding: 0 5px;\
pointer-events: auto;\
cursor: pointer;\
}\
.ace_inline_button:hover {\
border-color: gray;\
background: rgba(200,200,200,0.2);\
display: inline-block;\
pointer-events: auto;\
}\
.ace_fold-widget.ace_invalid {\
background-color: #FFB4B4;\
border-color: #DE5555;\
}\
.ace_fade-fold-widgets .ace_fold-widget {\
transition: opacity 0.4s ease 0.05s;\
opacity: 0;\
}\
.ace_fade-fold-widgets:hover .ace_fold-widget {\
transition: opacity 0.05s ease 0.05s;\
opacity:1;\
}\
.ace_underline {\
text-decoration: underline;\
}\
.ace_bold {\
font-weight: bold;\
}\
.ace_nobold .ace_bold {\
font-weight: normal;\
}\
.ace_italic {\
font-style: italic;\
}\
.ace_error-marker {\
background-color: rgba(255, 0, 0,0.2);\
position: absolute;\
z-index: 9;\
}\
.ace_highlight-marker {\
background-color: rgba(255, 255, 0,0.2);\
position: absolute;\
z-index: 8;\
}\
.ace_mobile-menu {\
position: absolute;\
line-height: 1.5;\
border-radius: 4px;\
-ms-user-select: none;\
-moz-user-select: none;\
-webkit-user-select: none;\
user-select: none;\
background: white;\
box-shadow: 1px 3px 2px grey;\
border: 1px solid #dcdcdc;\
color: black;\
}\
.ace_dark > .ace_mobile-menu {\
background: #333;\
color: #ccc;\
box-shadow: 1px 3px 2px grey;\
border: 1px solid #444;\
}\
.ace_mobile-button {\
padding: 2px;\
cursor: pointer;\
overflow: hidden;\
}\
.ace_mobile-button:hover {\
background-color: #eee;\
opacity:1;\
}\
.ace_mobile-button:active {\
background-color: #ddd;\
}\
.ace_placeholder {\
font-family: arial;\
transform: scale(0.9);\
transform-origin: left;\
white-space: pre;\
opacity: 0.7;\
margin: 0 10px;\
}";

    var useragent = require("./lib/useragent");
    var HIDE_TEXTAREA = useragent.isIE;

    dom.importCssString(editorCss, "ace_editor.css");

    var VirtualRenderer = function(container, theme) {
        var _self = this;

        this.container = container || dom.createElement("div");

        dom.addCssClass(this.container, "ace_editor");
        if (dom.HI_DPI) dom.addCssClass(this.container, "ace_hidpi");

        this.setTheme(theme);

        this.$gutter = dom.createElement("div");
        this.$gutter.className = "ace_gutter";
        this.container.appendChild(this.$gutter);
        this.$gutter.setAttribute("aria-hidden", true);

        this.scroller = dom.createElement("div");
        this.scroller.className = "ace_scroller";
        
        this.container.appendChild(this.scroller);

        this.content = dom.createElement("div");
        this.content.className = "ace_content";
        this.scroller.appendChild(this.content);

        this.$gutterLayer = new GutterLayer(this.$gutter);
        this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));

        this.$markerBack = new MarkerLayer(this.content);

        var textLayer = this.$textLayer = new TextLayer(this.content);
        this.canvas = textLayer.element;

        this.$markerFront = new MarkerLayer(this.content);

        this.$cursorLayer = new CursorLayer(this.content);
        this.$horizScroll = false;
        this.$vScroll = false;

        this.scrollBar = 
        this.scrollBarV = new VScrollBar(this.container, this);
        this.scrollBarH = new HScrollBar(this.container, this);
        this.scrollBarV.addEventListener("scroll", function(e) {
            if (!_self.$scrollAnimation)
                _self.session.setScrollTop(e.data - _self.scrollMargin.top);
        });
        this.scrollBarH.addEventListener("scroll", function(e) {
            if (!_self.$scrollAnimation)
                _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
        });

        this.scrollTop = 0;
        this.scrollLeft = 0;

        this.cursorPos = {
            row : 0,
            column : 0
        };

        this.$fontMetrics = new FontMetrics(this.container);
        this.$textLayer.$setFontMetrics(this.$fontMetrics);
        this.$textLayer.addEventListener("changeCharacterSize", function(e) {
            _self.updateCharacterSize();
            _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
            _self._signal("changeCharacterSize", e);
        });

        this.$size = {
            width: 0,
            height: 0,
            scrollerHeight: 0,
            scrollerWidth: 0,
            $dirty: true
        };

        this.layerConfig = {
            width : 1,
            padding : 0,
            firstRow : 0,
            firstRowScreen: 0,
            lastRow : 0,
            lineHeight : 0,
            characterWidth : 0,
            minHeight : 1,
            maxHeight : 1,
            offset : 0,
            height : 1,
            gutterOffset: 1
        };
        
        this.scrollMargin = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0,
            v: 0,
            h: 0
        };
        
        this.margin = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0,
            v: 0,
            h: 0
        };
        
        this.$keepTextAreaAtCursor = !useragent.isIOS;

        this.$loop = new RenderLoop(
            this.$renderChanges.bind(this),
            this.container.ownerDocument.defaultView
        );
        this.$loop.schedule(this.CHANGE_FULL);

        this.updateCharacterSize();
        this.setPadding(4);
        config.resetOptions(this);
        config._signal("renderer", this);
    };

    (function() {

        this.CHANGE_CURSOR = 1;
        this.CHANGE_MARKER = 2;
        this.CHANGE_GUTTER = 4;
        this.CHANGE_SCROLL = 8;
        this.CHANGE_LINES = 16;
        this.CHANGE_TEXT = 32;
        this.CHANGE_SIZE = 64;
        this.CHANGE_MARKER_BACK = 128;
        this.CHANGE_MARKER_FRONT = 256;
        this.CHANGE_FULL = 512;
        this.CHANGE_H_SCROLL = 1024;

        oop.implement(this, EventEmitter);

        this.updateCharacterSize = function() {
            if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
                this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
                this.setStyle("ace_nobold", !this.$allowBoldFonts);
            }

            this.layerConfig.characterWidth =
            this.characterWidth = this.$textLayer.getCharacterWidth();
            this.layerConfig.lineHeight =
            this.lineHeight = this.$textLayer.getLineHeight();
            this.$updatePrintMargin();
            dom.setStyle(this.scroller.style, "line-height", this.lineHeight + "px");
        };
        this.setSession = function(session) {
            if (this.session)
                this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);
                
            this.session = session;
            if (session && this.scrollMargin.top && session.getScrollTop() <= 0)
                session.setScrollTop(-this.scrollMargin.top);

            this.$cursorLayer.setSession(session);
            this.$markerBack.setSession(session);
            this.$markerFront.setSession(session);
            this.$gutterLayer.setSession(session);
            this.$textLayer.setSession(session);
            if (!session)
                return;
            
            this.$loop.schedule(this.CHANGE_FULL);
            this.session.$setFontMetrics(this.$fontMetrics);
            this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;
            
            this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
            this.onChangeNewLineMode();
            this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
        };
        this.updateLines = function(firstRow, lastRow, force) {
            if (lastRow === undefined)
                lastRow = Infinity;

            if (!this.$changedLines) {
                this.$changedLines = {
                    firstRow: firstRow,
                    lastRow: lastRow
                };
            }
            else {
                if (this.$changedLines.firstRow > firstRow)
                    this.$changedLines.firstRow = firstRow;

                if (this.$changedLines.lastRow < lastRow)
                    this.$changedLines.lastRow = lastRow;
            }
            if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
                if (force)
                    this.$changedLines.lastRow = this.layerConfig.lastRow;
                else
                    return;
            }
            if (this.$changedLines.firstRow > this.layerConfig.lastRow)
                return;
            this.$loop.schedule(this.CHANGE_LINES);
        };

        this.onChangeNewLineMode = function() {
            this.$loop.schedule(this.CHANGE_TEXT);
            this.$textLayer.$updateEolChar();
            this.session.$bidiHandler.setEolChar(this.$textLayer.EOL_CHAR);
        };
        
        this.onChangeTabSize = function() {
            this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
            this.$textLayer.onChangeTabSize();
        };
        this.updateText = function() {
            this.$loop.schedule(this.CHANGE_TEXT);
        };
        this.updateFull = function(force) {
            if (force)
                this.$renderChanges(this.CHANGE_FULL, true);
            else
                this.$loop.schedule(this.CHANGE_FULL);
        };
        this.updateFontSize = function() {
            this.$textLayer.checkForSizeChanges();
        };

        this.$changes = 0;
        this.$updateSizeAsync = function() {
            if (this.$loop.pending)
                this.$size.$dirty = true;
            else
                this.onResize();
        };
        this.onResize = function(force, gutterWidth, width, height) {
            if (this.resizing > 2)
                return;
            else if (this.resizing > 0)
                this.resizing++;
            else
                this.resizing = force ? 1 : 0;
            var el = this.container;
            if (!height)
                height = el.clientHeight || el.scrollHeight;
            if (!width)
                width = el.clientWidth || el.scrollWidth;
            var changes = this.$updateCachedSize(force, gutterWidth, width, height);

            
            if (!this.$size.scrollerHeight || (!width && !height))
                return this.resizing = 0;

            if (force)
                this.$gutterLayer.$padding = null;

            if (force)
                this.$renderChanges(changes | this.$changes, true);
            else
                this.$loop.schedule(changes | this.$changes);

            if (this.resizing)
                this.resizing = 0;
            this.scrollBarV.scrollLeft = this.scrollBarV.scrollTop = null;
        };
        
        this.$updateCachedSize = function(force, gutterWidth, width, height) {
            height -= (this.$extraHeight || 0);
            var changes = 0;
            var size = this.$size;
            var oldSize = {
                width: size.width,
                height: size.height,
                scrollerHeight: size.scrollerHeight,
                scrollerWidth: size.scrollerWidth
            };
            if (height && (force || size.height != height)) {
                size.height = height;
                changes |= this.CHANGE_SIZE;

                size.scrollerHeight = size.height;
                if (this.$horizScroll)
                    size.scrollerHeight -= this.scrollBarH.getHeight();
                this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";

                changes = changes | this.CHANGE_SCROLL;
            }

            if (width && (force || size.width != width)) {
                changes |= this.CHANGE_SIZE;
                size.width = width;
                
                if (gutterWidth == null)
                    gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
                
                this.gutterWidth = gutterWidth;
                
                dom.setStyle(this.scrollBarH.element.style, "left", gutterWidth + "px");
                dom.setStyle(this.scroller.style, "left", gutterWidth + this.margin.left + "px");
                size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth() - this.margin.h);
                dom.setStyle(this.$gutter.style, "left", this.margin.left + "px");
                
                var right = this.scrollBarV.getWidth() + "px";
                dom.setStyle(this.scrollBarH.element.style, "right", right);
                dom.setStyle(this.scroller.style, "right", right);
                dom.setStyle(this.scroller.style, "bottom", this.scrollBarH.getHeight());

                if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force) {
                    changes |= this.CHANGE_FULL;
                }
            }
            
            size.$dirty = !width || !height;

            if (changes)
                this._signal("resize", oldSize);

            return changes;
        };

        this.onGutterResize = function(width) {
            var gutterWidth = this.$showGutter ? width : 0;
            if (gutterWidth != this.gutterWidth)
                this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);

            if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
                this.$loop.schedule(this.CHANGE_FULL);
            } else if (this.$size.$dirty) {
                this.$loop.schedule(this.CHANGE_FULL);
            } else {
                this.$computeLayerConfig();
            }
        };
        this.adjustWrapLimit = function() {
            var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
            var limit = Math.floor(availableWidth / this.characterWidth);
            return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
        };
        this.setAnimatedScroll = function(shouldAnimate){
            this.setOption("animatedScroll", shouldAnimate);
        };
        this.getAnimatedScroll = function() {
            return this.$animatedScroll;
        };
        this.setShowInvisibles = function(showInvisibles) {
            this.setOption("showInvisibles", showInvisibles);
            this.session.$bidiHandler.setShowInvisibles(showInvisibles);
        };
        this.getShowInvisibles = function() {
            return this.getOption("showInvisibles");
        };
        this.getDisplayIndentGuides = function() {
            return this.getOption("displayIndentGuides");
        };

        this.setDisplayIndentGuides = function(display) {
            this.setOption("displayIndentGuides", display);
        };
        this.setShowPrintMargin = function(showPrintMargin) {
            this.setOption("showPrintMargin", showPrintMargin);
        };
        this.getShowPrintMargin = function() {
            return this.getOption("showPrintMargin");
        };
        this.setPrintMarginColumn = function(showPrintMargin) {
            this.setOption("printMarginColumn", showPrintMargin);
        };
        this.getPrintMarginColumn = function() {
            return this.getOption("printMarginColumn");
        };
        this.getShowGutter = function(){
            return this.getOption("showGutter");
        };
        this.setShowGutter = function(show){
            return this.setOption("showGutter", show);
        };

        this.getFadeFoldWidgets = function(){
            return this.getOption("fadeFoldWidgets");
        };

        this.setFadeFoldWidgets = function(show) {
            this.setOption("fadeFoldWidgets", show);
        };

        this.setHighlightGutterLine = function(shouldHighlight) {
            this.setOption("highlightGutterLine", shouldHighlight);
        };

        this.getHighlightGutterLine = function() {
            return this.getOption("highlightGutterLine");
        };

        this.$updatePrintMargin = function() {
            if (!this.$showPrintMargin && !this.$printMarginEl)
                return;

            if (!this.$printMarginEl) {
                var containerEl = dom.createElement("div");
                containerEl.className = "ace_layer ace_print-margin-layer";
                this.$printMarginEl = dom.createElement("div");
                this.$printMarginEl.className = "ace_print-margin";
                containerEl.appendChild(this.$printMarginEl);
                this.content.insertBefore(containerEl, this.content.firstChild);
            }

            var style = this.$printMarginEl.style;
            style.left = Math.round(this.characterWidth * this.$printMarginColumn + this.$padding) + "px";
            style.visibility = this.$showPrintMargin ? "visible" : "hidden";
            
            if (this.session && this.session.$wrap == -1)
                this.adjustWrapLimit();
        };
        this.getContainerElement = function() {
            return this.container;
        };
        this.getMouseEventTarget = function() {
            return this.scroller;
        };
        this.getTextAreaContainer = function() {
            return this.container;
        };
        this.$moveTextAreaToCursor = function() {
            if (this.$isMousePressed) return;
            var style = this.textarea.style;
            var composition = this.$composition;
            if (!this.$keepTextAreaAtCursor && !composition) {
                dom.translate(this.textarea, -100, 0);
                return;
            }
            var pixelPos = this.$cursorLayer.$pixelPos;
            if (!pixelPos)
                return;
            if (composition && composition.markerRange)
                pixelPos = this.$cursorLayer.getPixelPosition(composition.markerRange.start, true);
            
            var config = this.layerConfig;
            var posTop = pixelPos.top;
            var posLeft = pixelPos.left;
            posTop -= config.offset;

            var h = composition && composition.useTextareaForIME ? this.lineHeight : HIDE_TEXTAREA ? 0 : 1;
            if (posTop < 0 || posTop > config.height - h) {
                dom.translate(this.textarea, 0, 0);
                return;
            }

            var w = 1;
            var maxTop = this.$size.height - h;
            if (!composition) {
                posTop += this.lineHeight;
            }
            else {
                if (composition.useTextareaForIME) {
                    var val = this.textarea.value;
                    w = this.characterWidth * (this.session.$getStringScreenWidth(val)[0]);
                }
                else {
                    posTop += this.lineHeight + 2;
                }
            }
            
            posLeft -= this.scrollLeft;
            if (posLeft > this.$size.scrollerWidth - w)
                posLeft = this.$size.scrollerWidth - w;

            posLeft += this.gutterWidth + this.margin.left;

            dom.setStyle(style, "height", h + "px");
            dom.setStyle(style, "width", w + "px");
            dom.translate(this.textarea, Math.min(posLeft, this.$size.scrollerWidth - w), Math.min(posTop, maxTop));
        };
        this.getFirstVisibleRow = function() {
            return this.layerConfig.firstRow;
        };
        this.getFirstFullyVisibleRow = function() {
            return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
        };
        this.getLastFullyVisibleRow = function() {
            var config = this.layerConfig;
            var lastRow = config.lastRow;
            var top = this.session.documentToScreenRow(lastRow, 0) * config.lineHeight;
            if (top - this.session.getScrollTop() > config.height - config.lineHeight)
                return lastRow - 1;
            return lastRow;
        };
        this.getLastVisibleRow = function() {
            return this.layerConfig.lastRow;
        };

        this.$padding = null;
        this.setPadding = function(padding) {
            this.$padding = padding;
            this.$textLayer.setPadding(padding);
            this.$cursorLayer.setPadding(padding);
            this.$markerFront.setPadding(padding);
            this.$markerBack.setPadding(padding);
            this.$loop.schedule(this.CHANGE_FULL);
            this.$updatePrintMargin();
        };
        
        this.setScrollMargin = function(top, bottom, left, right) {
            var sm = this.scrollMargin;
            sm.top = top|0;
            sm.bottom = bottom|0;
            sm.right = right|0;
            sm.left = left|0;
            sm.v = sm.top + sm.bottom;
            sm.h = sm.left + sm.right;
            if (sm.top && this.scrollTop <= 0 && this.session)
                this.session.setScrollTop(-sm.top);
            this.updateFull();
        };
        
        this.setMargin = function(top, bottom, left, right) {
            var sm = this.margin;
            sm.top = top|0;
            sm.bottom = bottom|0;
            sm.right = right|0;
            sm.left = left|0;
            sm.v = sm.top + sm.bottom;
            sm.h = sm.left + sm.right;
            this.$updateCachedSize(true, this.gutterWidth, this.$size.width, this.$size.height);
            this.updateFull();
        };
        this.getHScrollBarAlwaysVisible = function() {
            return this.$hScrollBarAlwaysVisible;
        };
        this.setHScrollBarAlwaysVisible = function(alwaysVisible) {
            this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
        };
        this.getVScrollBarAlwaysVisible = function() {
            return this.$vScrollBarAlwaysVisible;
        };
        this.setVScrollBarAlwaysVisible = function(alwaysVisible) {
            this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
        };

        this.$updateScrollBarV = function() {
            var scrollHeight = this.layerConfig.maxHeight;
            var scrollerHeight = this.$size.scrollerHeight;
            if (!this.$maxLines && this.$scrollPastEnd) {
                scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
                if (this.scrollTop > scrollHeight - scrollerHeight) {
                    scrollHeight = this.scrollTop + scrollerHeight;
                    this.scrollBarV.scrollTop = null;
                }
            }
            this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
            this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
        };
        this.$updateScrollBarH = function() {
            this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
            this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
        };
        
        this.$frozen = false;
        this.freeze = function() {
            this.$frozen = true;
        };
        
        this.unfreeze = function() {
            this.$frozen = false;
        };

        this.$renderChanges = function(changes, force) {
            if (this.$changes) {
                changes |= this.$changes;
                this.$changes = 0;
            }
            if ((!this.session || !this.container.offsetWidth || this.$frozen) || (!changes && !force)) {
                this.$changes |= changes;
                return; 
            } 
            if (this.$size.$dirty) {
                this.$changes |= changes;
                return this.onResize(true);
            }
            if (!this.lineHeight) {
                this.$textLayer.checkForSizeChanges();
            }
            
            this._signal("beforeRender", changes);
            
            if (this.session && this.session.$bidiHandler)
                this.session.$bidiHandler.updateCharacterWidths(this.$fontMetrics);

            var config = this.layerConfig;
            if (changes & this.CHANGE_FULL ||
                changes & this.CHANGE_SIZE ||
                changes & this.CHANGE_TEXT ||
                changes & this.CHANGE_LINES ||
                changes & this.CHANGE_SCROLL ||
                changes & this.CHANGE_H_SCROLL
            ) {
                changes |= this.$computeLayerConfig() | this.$loop.clear();
                if (config.firstRow != this.layerConfig.firstRow && config.firstRowScreen == this.layerConfig.firstRowScreen) {
                    var st = this.scrollTop + (config.firstRow - this.layerConfig.firstRow) * this.lineHeight;
                    if (st > 0) {
                        this.scrollTop = st;
                        changes = changes | this.CHANGE_SCROLL;
                        changes |= this.$computeLayerConfig() | this.$loop.clear();
                    }
                }
                config = this.layerConfig;
                this.$updateScrollBarV();
                if (changes & this.CHANGE_H_SCROLL)
                    this.$updateScrollBarH();
                
                dom.translate(this.content, -this.scrollLeft, -config.offset);
                
                var width = config.width + 2 * this.$padding + "px";
                var height = config.minHeight + "px";
                
                dom.setStyle(this.content.style, "width", width);
                dom.setStyle(this.content.style, "height", height);
            }
            if (changes & this.CHANGE_H_SCROLL) {
                dom.translate(this.content, -this.scrollLeft, -config.offset);
                this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller" : "ace_scroller ace_scroll-left";
            }
            if (changes & this.CHANGE_FULL) {
                this.$changedLines = null;
                this.$textLayer.update(config);
                if (this.$showGutter)
                    this.$gutterLayer.update(config);
                this.$markerBack.update(config);
                this.$markerFront.update(config);
                this.$cursorLayer.update(config);
                this.$moveTextAreaToCursor();
                this._signal("afterRender", changes);
                return;
            }
            if (changes & this.CHANGE_SCROLL) {
                this.$changedLines = null;
                if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)
                    this.$textLayer.update(config);
                else
                    this.$textLayer.scrollLines(config);

                if (this.$showGutter) {
                    if (changes & this.CHANGE_GUTTER || changes & this.CHANGE_LINES)
                        this.$gutterLayer.update(config);
                    else
                        this.$gutterLayer.scrollLines(config);
                }
                this.$markerBack.update(config);
                this.$markerFront.update(config);
                this.$cursorLayer.update(config);
                this.$moveTextAreaToCursor();
                this._signal("afterRender", changes);
                return;
            }

            if (changes & this.CHANGE_TEXT) {
                this.$changedLines = null;
                this.$textLayer.update(config);
                if (this.$showGutter)
                    this.$gutterLayer.update(config);
            }
            else if (changes & this.CHANGE_LINES) {
                if (this.$updateLines() || (changes & this.CHANGE_GUTTER) && this.$showGutter)
                    this.$gutterLayer.update(config);
            }
            else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
                if (this.$showGutter)
                    this.$gutterLayer.update(config);
            }
            else if (changes & this.CHANGE_CURSOR) {
                if (this.$highlightGutterLine)
                    this.$gutterLayer.updateLineHighlight(config);
            }

            if (changes & this.CHANGE_CURSOR) {
                this.$cursorLayer.update(config);
                this.$moveTextAreaToCursor();
            }

            if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
                this.$markerFront.update(config);
            }

            if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
                this.$markerBack.update(config);
            }

            this._signal("afterRender", changes);
        };

        
        this.$autosize = function() {
            var height = this.session.getScreenLength() * this.lineHeight;
            var maxHeight = this.$maxLines * this.lineHeight;
            var desiredHeight = Math.min(maxHeight, 
                Math.max((this.$minLines || 1) * this.lineHeight, height)
            ) + this.scrollMargin.v + (this.$extraHeight || 0);
            if (this.$horizScroll)
                desiredHeight += this.scrollBarH.getHeight();
            if (this.$maxPixelHeight && desiredHeight > this.$maxPixelHeight)
                desiredHeight = this.$maxPixelHeight;
            
            var hideScrollbars = desiredHeight <= 2 * this.lineHeight;
            var vScroll = !hideScrollbars && height > maxHeight;
            
            if (desiredHeight != this.desiredHeight ||
                this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
                if (vScroll != this.$vScroll) {
                    this.$vScroll = vScroll;
                    this.scrollBarV.setVisible(vScroll);
                }
                
                var w = this.container.clientWidth;
                this.container.style.height = desiredHeight + "px";
                this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
                this.desiredHeight = desiredHeight;
                
                this._signal("autosize");
            }
        };
        
        this.$computeLayerConfig = function() {
            var session = this.session;
            var size = this.$size;
            
            var hideScrollbars = size.height <= 2 * this.lineHeight;
            var screenLines = this.session.getScreenLength();
            var maxHeight = screenLines * this.lineHeight;

            var longestLine = this.$getLongestLine();
            
            var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible ||
                size.scrollerWidth - longestLine - 2 * this.$padding < 0);

            var hScrollChanged = this.$horizScroll !== horizScroll;
            if (hScrollChanged) {
                this.$horizScroll = horizScroll;
                this.scrollBarH.setVisible(horizScroll);
            }
            var vScrollBefore = this.$vScroll; // autosize can change vscroll value in which case we need to update longestLine
            if (this.$maxLines && this.lineHeight > 1)
                this.$autosize();

            var minHeight = size.scrollerHeight + this.lineHeight;
            
            var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd
                ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd
                : 0;
            maxHeight += scrollPastEnd;
            
            var sm = this.scrollMargin;
            this.session.setScrollTop(Math.max(-sm.top,
                Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));

            this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft, 
                longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));
            
            var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible ||
                size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);
            var vScrollChanged = vScrollBefore !== vScroll;
            if (vScrollChanged) {
                this.$vScroll = vScroll;
                this.scrollBarV.setVisible(vScroll);
            }

            var offset = this.scrollTop % this.lineHeight;
            var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
            var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
            var lastRow = firstRow + lineCount;
            var firstRowScreen, firstRowHeight;
            var lineHeight = this.lineHeight;
            firstRow = session.screenToDocumentRow(firstRow, 0);
            var foldLine = session.getFoldLine(firstRow);
            if (foldLine) {
                firstRow = foldLine.start.row;
            }

            firstRowScreen = session.documentToScreenRow(firstRow, 0);
            firstRowHeight = session.getRowLength(firstRow) * lineHeight;

            lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
            minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight +
                                                    firstRowHeight;

            offset = this.scrollTop - firstRowScreen * lineHeight;

            var changes = 0;
            if (this.layerConfig.width != longestLine || hScrollChanged) 
                changes = this.CHANGE_H_SCROLL;
            if (hScrollChanged || vScrollChanged) {
                changes |= this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
                this._signal("scrollbarVisibilityChanged");
                if (vScrollChanged)
                    longestLine = this.$getLongestLine();
            }
            
            this.layerConfig = {
                width : longestLine,
                padding : this.$padding,
                firstRow : firstRow,
                firstRowScreen: firstRowScreen,
                lastRow : lastRow,
                lineHeight : lineHeight,
                characterWidth : this.characterWidth,
                minHeight : minHeight,
                maxHeight : maxHeight,
                offset : offset,
                gutterOffset : lineHeight ? Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)) : 0,
                height : this.$size.scrollerHeight
            };

            if (this.session.$bidiHandler)
                this.session.$bidiHandler.setContentWidth(longestLine - this.$padding);

            return changes;
        };

        this.$updateLines = function() {
            if (!this.$changedLines) return;
            var firstRow = this.$changedLines.firstRow;
            var lastRow = this.$changedLines.lastRow;
            this.$changedLines = null;

            var layerConfig = this.layerConfig;

            if (firstRow > layerConfig.lastRow + 1) { return; }
            if (lastRow < layerConfig.firstRow) { return; }
            if (lastRow === Infinity) {
                if (this.$showGutter)
                    this.$gutterLayer.update(layerConfig);
                this.$textLayer.update(layerConfig);
                return;
            }
            this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
            return true;
        };

        this.$getLongestLine = function() {
            var charCount = this.session.getScreenWidth();
            if (this.showInvisibles && !this.session.$useWrapMode)
                charCount += 1;
                
            if (this.$textLayer && charCount > this.$textLayer.MAX_LINE_LENGTH)
                charCount = this.$textLayer.MAX_LINE_LENGTH + 30;

            return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
        };
        this.updateFrontMarkers = function() {
            this.$markerFront.setMarkers(this.session.getMarkers(true));
            this.$loop.schedule(this.CHANGE_MARKER_FRONT);
        };
        this.updateBackMarkers = function() {
            this.$markerBack.setMarkers(this.session.getMarkers());
            this.$loop.schedule(this.CHANGE_MARKER_BACK);
        };
        this.addGutterDecoration = function(row, className){
            this.$gutterLayer.addGutterDecoration(row, className);
        };
        this.removeGutterDecoration = function(row, className){
            this.$gutterLayer.removeGutterDecoration(row, className);
        };
        this.updateBreakpoints = function(rows) {
            this.$loop.schedule(this.CHANGE_GUTTER);
        };
        this.setAnnotations = function(annotations) {
            this.$gutterLayer.setAnnotations(annotations);
            this.$loop.schedule(this.CHANGE_GUTTER);
        };
        this.updateCursor = function() {
            this.$loop.schedule(this.CHANGE_CURSOR);
        };
        this.hideCursor = function() {
            this.$cursorLayer.hideCursor();
        };
        this.showCursor = function() {
            this.$cursorLayer.showCursor();
        };

        this.scrollSelectionIntoView = function(anchor, lead, offset) {
            this.scrollCursorIntoView(anchor, offset);
            this.scrollCursorIntoView(lead, offset);
        };
        this.scrollCursorIntoView = function(cursor, offset, $viewMargin) {
            if (this.$size.scrollerHeight === 0)
                return;

            var pos = this.$cursorLayer.getPixelPosition(cursor);

            var left = pos.left;
            var top = pos.top;
            
            var topMargin = $viewMargin && $viewMargin.top || 0;
            var bottomMargin = $viewMargin && $viewMargin.bottom || 0;
            
            var scrollTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
            
            if (scrollTop + topMargin > top) {
                if (offset && scrollTop + topMargin > top + this.lineHeight)
                    top -= offset * this.$size.scrollerHeight;
                if (top === 0)
                    top = -this.scrollMargin.top;
                this.session.setScrollTop(top);
            } else if (scrollTop + this.$size.scrollerHeight - bottomMargin < top + this.lineHeight) {
                if (offset && scrollTop + this.$size.scrollerHeight - bottomMargin < top -  this.lineHeight)
                    top += offset * this.$size.scrollerHeight;
                this.session.setScrollTop(top + this.lineHeight + bottomMargin - this.$size.scrollerHeight);
            }

            var scrollLeft = this.scrollLeft;

            if (scrollLeft > left) {
                if (left < this.$padding + 2 * this.layerConfig.characterWidth)
                    left = -this.scrollMargin.left;
                this.session.setScrollLeft(left);
            } else if (scrollLeft + this.$size.scrollerWidth < left + this.characterWidth) {
                this.session.setScrollLeft(Math.round(left + this.characterWidth - this.$size.scrollerWidth));
            } else if (scrollLeft <= this.$padding && left - scrollLeft < this.characterWidth) {
                this.session.setScrollLeft(0);
            }
        };
        this.getScrollTop = function() {
            return this.session.getScrollTop();
        };
        this.getScrollLeft = function() {
            return this.session.getScrollLeft();
        };
        this.getScrollTopRow = function() {
            return this.scrollTop / this.lineHeight;
        };
        this.getScrollBottomRow = function() {
            return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
        };
        this.scrollToRow = function(row) {
            this.session.setScrollTop(row * this.lineHeight);
        };

        this.alignCursor = function(cursor, alignment) {
            if (typeof cursor == "number")
                cursor = {row: cursor, column: 0};

            var pos = this.$cursorLayer.getPixelPosition(cursor);
            var h = this.$size.scrollerHeight - this.lineHeight;
            var offset = pos.top - h * (alignment || 0);

            this.session.setScrollTop(offset);
            return offset;
        };

        this.STEPS = 8;
        this.$calcSteps = function(fromValue, toValue){
            var i = 0;
            var l = this.STEPS;
            var steps = [];

            var func  = function(t, x_min, dx) {
                return dx * (Math.pow(t - 1, 3) + 1) + x_min;
            };

            for (i = 0; i < l; ++i)
                steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));

            return steps;
        };
        this.scrollToLine = function(line, center, animate, callback) {
            var pos = this.$cursorLayer.getPixelPosition({row: line, column: 0});
            var offset = pos.top;
            if (center)
                offset -= this.$size.scrollerHeight / 2;

            var initialScroll = this.scrollTop;
            this.session.setScrollTop(offset);
            if (animate !== false)
                this.animateScrolling(initialScroll, callback);
        };

        this.animateScrolling = function(fromValue, callback) {
            var toValue = this.scrollTop;
            if (!this.$animatedScroll)
                return;
            var _self = this;
            
            if (fromValue == toValue)
                return;
            
            if (this.$scrollAnimation) {
                var oldSteps = this.$scrollAnimation.steps;
                if (oldSteps.length) {
                    fromValue = oldSteps[0];
                    if (fromValue == toValue)
                        return;
                }
            }
            
            var steps = _self.$calcSteps(fromValue, toValue);
            this.$scrollAnimation = {from: fromValue, to: toValue, steps: steps};

            clearInterval(this.$timer);

            _self.session.setScrollTop(steps.shift());
            _self.session.$scrollTop = toValue;
            this.$timer = setInterval(function() {
                if (steps.length) {
                    _self.session.setScrollTop(steps.shift());
                    _self.session.$scrollTop = toValue;
                } else if (toValue != null) {
                    _self.session.$scrollTop = -1;
                    _self.session.setScrollTop(toValue);
                    toValue = null;
                } else {
                    _self.$timer = clearInterval(_self.$timer);
                    _self.$scrollAnimation = null;
                    callback && callback();
                }
            }, 10);
        };
        this.scrollToY = function(scrollTop) {
            if (this.scrollTop !== scrollTop) {
                this.$loop.schedule(this.CHANGE_SCROLL);
                this.scrollTop = scrollTop;
            }
        };
        this.scrollToX = function(scrollLeft) {
            if (this.scrollLeft !== scrollLeft)
                this.scrollLeft = scrollLeft;
            this.$loop.schedule(this.CHANGE_H_SCROLL);
        };
        this.scrollTo = function(x, y) {
            this.session.setScrollTop(y);
            this.session.setScrollLeft(y);
        };
        this.scrollBy = function(deltaX, deltaY) {
            deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
            deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
        };
        this.isScrollableBy = function(deltaX, deltaY) {
            if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)
               return true;
            if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight
                - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)
               return true;
            if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)
                return true;
            if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth
                - this.layerConfig.width < -1 + this.scrollMargin.right)
               return true;
        };

        this.pixelToScreenCoordinates = function(x, y) {
            var canvasPos;
            if (this.$hasCssTransforms) {
                canvasPos = {top:0, left: 0};
                var p = this.$fontMetrics.transformCoordinates([x, y]);
                x = p[1] - this.gutterWidth - this.margin.left;
                y = p[0];
            } else {
                canvasPos = this.scroller.getBoundingClientRect();
            }
            
            var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
            var offset = offsetX / this.characterWidth;
            var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
            var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);

            return {row: row, column: col, side: offset - col > 0 ? 1 : -1, offsetX:  offsetX};
        };

        this.screenToTextCoordinates = function(x, y) {
            var canvasPos;
            if (this.$hasCssTransforms) {
                canvasPos = {top:0, left: 0};
                var p = this.$fontMetrics.transformCoordinates([x, y]);
                x = p[1] - this.gutterWidth - this.margin.left;
                y = p[0];
            } else {
                canvasPos = this.scroller.getBoundingClientRect();
            }

            var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
            var offset = offsetX / this.characterWidth;
            var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);

            var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);

            return this.session.screenToDocumentPosition(row, Math.max(col, 0), offsetX);
        };
        this.textToScreenCoordinates = function(row, column) {
            var canvasPos = this.scroller.getBoundingClientRect();
            var pos = this.session.documentToScreenPosition(row, column);

            var x = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, row)
                 ? this.session.$bidiHandler.getPosLeft(pos.column)
                 : Math.round(pos.column * this.characterWidth));
            
            var y = pos.row * this.lineHeight;

            return {
                pageX: canvasPos.left + x - this.scrollLeft,
                pageY: canvasPos.top + y - this.scrollTop
            };
        };
        this.visualizeFocus = function() {
            dom.addCssClass(this.container, "ace_focus");
        };
        this.visualizeBlur = function() {
            dom.removeCssClass(this.container, "ace_focus");
        };
        this.showComposition = function(composition) {
            this.$composition = composition;
            if (!composition.cssText) {
                composition.cssText = this.textarea.style.cssText;
            }
            composition.useTextareaForIME = this.$useTextareaForIME;
            
            if (this.$useTextareaForIME) {
                dom.addCssClass(this.textarea, "ace_composition");
                this.textarea.style.cssText = "";
                this.$moveTextAreaToCursor();
                this.$cursorLayer.element.style.display = "none";
            }
            else {
                composition.markerId = this.session.addMarker(composition.markerRange, "ace_composition_marker", "text");
            }
        };
        this.setCompositionText = function(text) {
            var cursor = this.session.selection.cursor;
            this.addToken(text, "composition_placeholder", cursor.row, cursor.column);
            this.$moveTextAreaToCursor();
        };
        this.hideComposition = function() {
            if (!this.$composition)
                return;
            
            if (this.$composition.markerId)
                this.session.removeMarker(this.$composition.markerId);

            dom.removeCssClass(this.textarea, "ace_composition");
            this.textarea.style.cssText = this.$composition.cssText;
            this.$composition = null;
            this.$cursorLayer.element.style.display = "";
        };
        
        this.addToken = function(text, type, row, column) {
            var session = this.session;
            session.bgTokenizer.lines[row] = null;
            var newToken = {type: type, value: text};
            var tokens = session.getTokens(row);
            if (column == null) {
                tokens.push(newToken);
            } else {
                var l = 0;
                for (var i =0; i < tokens.length; i++) {
                    var token = tokens[i];
                    l += token.value.length;
                    if (column <= l) {
                        var diff = token.value.length - (l - column);
                        var before = token.value.slice(0, diff);
                        var after = token.value.slice(diff);
        
                        tokens.splice(i, 1, {type: token.type, value: before},  newToken,  {type: token.type, value: after});
                        break;
                    }
                }
            }
            this.updateLines(row, row);
        };
        this.setTheme = function(theme, cb) {
            var _self = this;
            this.$themeId = theme;
            _self._dispatchEvent('themeChange',{theme:theme});

            if (!theme || typeof theme == "string") {
                var moduleName = theme || this.$options.theme.initialValue;
                config.loadModule(["theme", moduleName], afterLoad);
            } else {
                afterLoad(theme);
            }

            function afterLoad(module) {
                if (_self.$themeId != theme)
                    return cb && cb();
                if (!module || !module.cssClass)
                    throw new Error("couldn't load module " + theme + " or it didn't call define");
                if (module.$id)
                    _self.$themeId = module.$id;
                dom.importCssString(
                    module.cssText,
                    module.cssClass,
                    _self.container
                );

                if (_self.theme)
                    dom.removeCssClass(_self.container, _self.theme.cssClass);

                var padding = "padding" in module ? module.padding 
                    : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
                if (_self.$padding && padding != _self.$padding)
                    _self.setPadding(padding);
                _self.$theme = module.cssClass;

                _self.theme = module;
                dom.addCssClass(_self.container, module.cssClass);
                dom.setCssClass(_self.container, "ace_dark", module.isDark);
                if (_self.$size) {
                    _self.$size.width = 0;
                    _self.$updateSizeAsync();
                }

                _self._dispatchEvent('themeLoaded', {theme:module});
                cb && cb();
            }
        };
        this.getTheme = function() {
            return this.$themeId;
        };
        this.setStyle = function(style, include) {
            dom.setCssClass(this.container, style, include !== false);
        };
        this.unsetStyle = function(style) {
            dom.removeCssClass(this.container, style);
        };
        
        this.setCursorStyle = function(style) {
            dom.setStyle(this.scroller.style, "cursor", style);
        };
        this.setMouseCursor = function(cursorStyle) {
            dom.setStyle(this.scroller.style, "cursor", cursorStyle);
        };
        
        this.attachToShadowRoot = function() {
            dom.importCssString(editorCss, "ace_editor.css", this.container);
        };
        this.destroy = function() {
            this.freeze();
            this.$fontMetrics.destroy();
            this.$cursorLayer.destroy();
        };

    }).call(VirtualRenderer.prototype);


    config.defineOptions(VirtualRenderer.prototype, "renderer", {
        animatedScroll: {initialValue: false},
        showInvisibles: {
            set: function(value) {
                if (this.$textLayer.setShowInvisibles(value))
                    this.$loop.schedule(this.CHANGE_TEXT);
            },
            initialValue: false
        },
        showPrintMargin: {
            set: function() { this.$updatePrintMargin(); },
            initialValue: true
        },
        printMarginColumn: {
            set: function() { this.$updatePrintMargin(); },
            initialValue: 80
        },
        printMargin: {
            set: function(val) {
                if (typeof val == "number")
                    this.$printMarginColumn = val;
                this.$showPrintMargin = !!val;
                this.$updatePrintMargin();
            },
            get: function() {
                return this.$showPrintMargin && this.$printMarginColumn; 
            }
        },
        showGutter: {
            set: function(show){
                this.$gutter.style.display = show ? "block" : "none";
                this.$loop.schedule(this.CHANGE_FULL);
                this.onGutterResize();
            },
            initialValue: true
        },
        fadeFoldWidgets: {
            set: function(show) {
                dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
            },
            initialValue: false
        },
        showFoldWidgets: {
            set: function(show) {
                this.$gutterLayer.setShowFoldWidgets(show);
                this.$loop.schedule(this.CHANGE_GUTTER);
            },
            initialValue: true
        },
        displayIndentGuides: {
            set: function(show) {
                if (this.$textLayer.setDisplayIndentGuides(show))
                    this.$loop.schedule(this.CHANGE_TEXT);
            },
            initialValue: true
        },
        highlightGutterLine: {
            set: function(shouldHighlight) {
                this.$gutterLayer.setHighlightGutterLine(shouldHighlight);
                this.$loop.schedule(this.CHANGE_GUTTER);
            },
            initialValue: true
        },
        hScrollBarAlwaysVisible: {
            set: function(val) {
                if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
                    this.$loop.schedule(this.CHANGE_SCROLL);
            },
            initialValue: false
        },
        vScrollBarAlwaysVisible: {
            set: function(val) {
                if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
                    this.$loop.schedule(this.CHANGE_SCROLL);
            },
            initialValue: false
        },
        fontSize: {
            set: function(size) {
                if (typeof size == "number")
                    size = size + "px";
                this.container.style.fontSize = size;
                this.updateFontSize();
            },
            initialValue: 12
        },
        fontFamily: {
            set: function(name) {
                this.container.style.fontFamily = name;
                this.updateFontSize();
            }
        },
        maxLines: {
            set: function(val) {
                this.updateFull();
            }
        },
        minLines: {
            set: function(val) {
                if (!(this.$minLines < 0x1ffffffffffff))
                    this.$minLines = 0;
                this.updateFull();
            }
        },
        maxPixelHeight: {
            set: function(val) {
                this.updateFull();
            },
            initialValue: 0
        },
        scrollPastEnd: {
            set: function(val) {
                val = +val || 0;
                if (this.$scrollPastEnd == val)
                    return;
                this.$scrollPastEnd = val;
                this.$loop.schedule(this.CHANGE_SCROLL);
            },
            initialValue: 0,
            handlesSet: true
        },
        fixedWidthGutter: {
            set: function(val) {
                this.$gutterLayer.$fixedWidth = !!val;
                this.$loop.schedule(this.CHANGE_GUTTER);
            }
        },
        theme: {
            set: function(val) { this.setTheme(val); },
            get: function() { return this.$themeId || this.theme; },
            initialValue: "./theme/textmate",
            handlesSet: true
        },
        hasCssTransforms: {
        },
        useTextareaForIME: {
            initialValue: !useragent.isMobile && !useragent.isIE
        }
    });

    exports.VirtualRenderer = VirtualRenderer;
    });

    ace.define("ace/worker/worker_client",["require","exports","module","ace/lib/oop","ace/lib/net","ace/lib/event_emitter","ace/config"], function(require, exports, module) {

    var oop = require("../lib/oop");
    var net = require("../lib/net");
    var EventEmitter = require("../lib/event_emitter").EventEmitter;
    var config = require("../config");

    function $workerBlob(workerUrl) {
        var script = "importScripts('" + net.qualifyURL(workerUrl) + "');";
        try {
            return new Blob([script], {"type": "application/javascript"});
        } catch (e) { // Backwards-compatibility
            var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
            var blobBuilder = new BlobBuilder();
            blobBuilder.append(script);
            return blobBuilder.getBlob("application/javascript");
        }
    }

    function createWorker(workerUrl) {
        if (typeof Worker == "undefined")
            return { postMessage: function() {}, terminate: function() {} };
        if (config.get("loadWorkerFromBlob")) {
            var blob = $workerBlob(workerUrl);
            var URL = window.URL || window.webkitURL;
            var blobURL = URL.createObjectURL(blob);
            return new Worker(blobURL);
        }
        return new Worker(workerUrl);
    }

    var WorkerClient = function(worker) {
        if (!worker.postMessage)
            worker = this.$createWorkerFromOldConfig.apply(this, arguments);

        this.$worker = worker;
        this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
        this.changeListener = this.changeListener.bind(this);
        this.onMessage = this.onMessage.bind(this);

        this.callbackId = 1;
        this.callbacks = {};

        this.$worker.onmessage = this.onMessage;
    };

    (function(){

        oop.implement(this, EventEmitter);

        this.$createWorkerFromOldConfig = function(topLevelNamespaces, mod, classname, workerUrl, importScripts) {
            if (require.nameToUrl && !require.toUrl)
                require.toUrl = require.nameToUrl;

            if (config.get("packaged") || !require.toUrl) {
                workerUrl = workerUrl || config.moduleUrl(mod, "worker");
            } else {
                var normalizePath = this.$normalizePath;
                workerUrl = workerUrl || normalizePath(require.toUrl("ace/worker/worker.js", null, "_"));

                var tlns = {};
                topLevelNamespaces.forEach(function(ns) {
                    tlns[ns] = normalizePath(require.toUrl(ns, null, "_").replace(/(\.js)?(\?.*)?$/, ""));
                });
            }

            this.$worker = createWorker(workerUrl);
            if (importScripts) {
                this.send("importScripts", importScripts);
            }
            this.$worker.postMessage({
                init : true,
                tlns : tlns,
                module : mod,
                classname : classname
            });
            return this.$worker;
        };

        this.onMessage = function(e) {
            var msg = e.data;
            switch (msg.type) {
                case "event":
                    this._signal(msg.name, {data: msg.data});
                    break;
                case "call":
                    var callback = this.callbacks[msg.id];
                    if (callback) {
                        callback(msg.data);
                        delete this.callbacks[msg.id];
                    }
                    break;
                case "error":
                    this.reportError(msg.data);
                    break;
                case "log":
                    window.console && console.log && console.log.apply(console, msg.data);
                    break;
            }
        };
        
        this.reportError = function(err) {
            window.console && console.error && console.error(err);
        };

        this.$normalizePath = function(path) {
            return net.qualifyURL(path);
        };

        this.terminate = function() {
            this._signal("terminate", {});
            this.deltaQueue = null;
            this.$worker.terminate();
            this.$worker = null;
            if (this.$doc)
                this.$doc.off("change", this.changeListener);
            this.$doc = null;
        };

        this.send = function(cmd, args) {
            this.$worker.postMessage({command: cmd, args: args});
        };

        this.call = function(cmd, args, callback) {
            if (callback) {
                var id = this.callbackId++;
                this.callbacks[id] = callback;
                args.push(id);
            }
            this.send(cmd, args);
        };

        this.emit = function(event, data) {
            try {
                if (data.data && data.data.err)
                    data.data.err = {message: data.data.err.message, stack: data.data.err.stack, code: data.data.err.code};
                this.$worker.postMessage({event: event, data: {data: data.data}});
            }
            catch(ex) {
                console.error(ex.stack);
            }
        };

        this.attachToDocument = function(doc) {
            if (this.$doc)
                this.terminate();

            this.$doc = doc;
            this.call("setValue", [doc.getValue()]);
            doc.on("change", this.changeListener);
        };

        this.changeListener = function(delta) {
            if (!this.deltaQueue) {
                this.deltaQueue = [];
                setTimeout(this.$sendDeltaQueue, 0);
            }
            if (delta.action == "insert")
                this.deltaQueue.push(delta.start, delta.lines);
            else
                this.deltaQueue.push(delta.start, delta.end);
        };

        this.$sendDeltaQueue = function() {
            var q = this.deltaQueue;
            if (!q) return;
            this.deltaQueue = null;
            if (q.length > 50 && q.length > this.$doc.getLength() >> 1) {
                this.call("setValue", [this.$doc.getValue()]);
            } else
                this.emit("change", {data: q});
        };

    }).call(WorkerClient.prototype);


    var UIWorkerClient = function(topLevelNamespaces, mod, classname) {
        var main = null;
        var emitSync = false;
        var sender = Object.create(EventEmitter);

        var messageBuffer = [];
        var workerClient = new WorkerClient({
            messageBuffer: messageBuffer,
            terminate: function() {},
            postMessage: function(e) {
                messageBuffer.push(e);
                if (!main) return;
                if (emitSync)
                    setTimeout(processNext);
                else
                    processNext();
            }
        });

        workerClient.setEmitSync = function(val) { emitSync = val; };

        var processNext = function() {
            var msg = messageBuffer.shift();
            if (msg.command)
                main[msg.command].apply(main, msg.args);
            else if (msg.event)
                sender._signal(msg.event, msg.data);
        };

        sender.postMessage = function(msg) {
            workerClient.onMessage({data: msg});
        };
        sender.callback = function(data, callbackId) {
            this.postMessage({type: "call", id: callbackId, data: data});
        };
        sender.emit = function(name, data) {
            this.postMessage({type: "event", name: name, data: data});
        };

        config.loadModule(["worker", mod], function(Main) {
            main = new Main[classname](sender);
            while (messageBuffer.length)
                processNext();
        });

        return workerClient;
    };

    exports.UIWorkerClient = UIWorkerClient;
    exports.WorkerClient = WorkerClient;
    exports.createWorker = createWorker;


    });

    ace.define("ace/placeholder",["require","exports","module","ace/range","ace/lib/event_emitter","ace/lib/oop"], function(require, exports, module) {

    var Range = require("./range").Range;
    var EventEmitter = require("./lib/event_emitter").EventEmitter;
    var oop = require("./lib/oop");

    var PlaceHolder = function(session, length, pos, others, mainClass, othersClass) {
        var _self = this;
        this.length = length;
        this.session = session;
        this.doc = session.getDocument();
        this.mainClass = mainClass;
        this.othersClass = othersClass;
        this.$onUpdate = this.onUpdate.bind(this);
        this.doc.on("change", this.$onUpdate);
        this.$others = others;
        
        this.$onCursorChange = function() {
            setTimeout(function() {
                _self.onCursorChange();
            });
        };
        
        this.$pos = pos;
        var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || {length: -1};
        this.$undoStackDepth = undoStack.length;
        this.setup();

        session.selection.on("changeCursor", this.$onCursorChange);
    };

    (function() {

        oop.implement(this, EventEmitter);
        this.setup = function() {
            var _self = this;
            var doc = this.doc;
            var session = this.session;
            
            this.selectionBefore = session.selection.toJSON();
            if (session.selection.inMultiSelectMode)
                session.selection.toSingleRange();

            this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);
            var pos = this.pos;
            pos.$insertRight = true;
            pos.detach();
            pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
            this.others = [];
            this.$others.forEach(function(other) {
                var anchor = doc.createAnchor(other.row, other.column);
                anchor.$insertRight = true;
                anchor.detach();
                _self.others.push(anchor);
            });
            session.setUndoSelect(false);
        };
        this.showOtherMarkers = function() {
            if (this.othersActive) return;
            var session = this.session;
            var _self = this;
            this.othersActive = true;
            this.others.forEach(function(anchor) {
                anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column+_self.length), _self.othersClass, null, false);
            });
        };
        this.hideOtherMarkers = function() {
            if (!this.othersActive) return;
            this.othersActive = false;
            for (var i = 0; i < this.others.length; i++) {
                this.session.removeMarker(this.others[i].markerId);
            }
        };
        this.onUpdate = function(delta) {
            if (this.$updating)
                return this.updateAnchors(delta);
                
            var range = delta;
            if (range.start.row !== range.end.row) return;
            if (range.start.row !== this.pos.row) return;
            this.$updating = true;
            var lengthDiff = delta.action === "insert" ? range.end.column - range.start.column : range.start.column - range.end.column;
            var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;
            var distanceFromStart = range.start.column - this.pos.column;
            
            this.updateAnchors(delta);
            
            if (inMainRange)
                this.length += lengthDiff;

            if (inMainRange && !this.session.$fromUndo) {
                if (delta.action === 'insert') {
                    for (var i = this.others.length - 1; i >= 0; i--) {
                        var otherPos = this.others[i];
                        var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
                        this.doc.insertMergedLines(newPos, delta.lines);
                    }
                } else if (delta.action === 'remove') {
                    for (var i = this.others.length - 1; i >= 0; i--) {
                        var otherPos = this.others[i];
                        var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
                        this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
                    }
                }
            }
            
            this.$updating = false;
            this.updateMarkers();
        };
        
        this.updateAnchors = function(delta) {
            this.pos.onChange(delta);
            for (var i = this.others.length; i--;)
                this.others[i].onChange(delta);
            this.updateMarkers();
        };
        
        this.updateMarkers = function() {
            if (this.$updating)
                return;
            var _self = this;
            var session = this.session;
            var updateMarker = function(pos, className) {
                session.removeMarker(pos.markerId);
                pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column+_self.length), className, null, false);
            };
            updateMarker(this.pos, this.mainClass);
            for (var i = this.others.length; i--;)
                updateMarker(this.others[i], this.othersClass);
        };

        this.onCursorChange = function(event) {
            if (this.$updating || !this.session) return;
            var pos = this.session.selection.getCursor();
            if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
                this.showOtherMarkers();
                this._emit("cursorEnter", event);
            } else {
                this.hideOtherMarkers();
                this._emit("cursorLeave", event);
            }
        };    
        this.detach = function() {
            this.session.removeMarker(this.pos && this.pos.markerId);
            this.hideOtherMarkers();
            this.doc.removeEventListener("change", this.$onUpdate);
            this.session.selection.removeEventListener("changeCursor", this.$onCursorChange);
            this.session.setUndoSelect(true);
            this.session = null;
        };
        this.cancel = function() {
            if (this.$undoStackDepth === -1)
                return;
            var undoManager = this.session.getUndoManager();
            var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;
            for (var i = 0; i < undosRequired; i++) {
                undoManager.undo(this.session, true);
            }
            if (this.selectionBefore)
                this.session.selection.fromJSON(this.selectionBefore);
        };
    }).call(PlaceHolder.prototype);


    exports.PlaceHolder = PlaceHolder;
    });

    ace.define("ace/mouse/multi_select_handler",["require","exports","module","ace/lib/event","ace/lib/useragent"], function(require, exports, module) {

    var event = require("../lib/event");
    var useragent = require("../lib/useragent");
    function isSamePoint(p1, p2) {
        return p1.row == p2.row && p1.column == p2.column;
    }

    function onMouseDown(e) {
        var ev = e.domEvent;
        var alt = ev.altKey;
        var shift = ev.shiftKey;
        var ctrl = ev.ctrlKey;
        var accel = e.getAccelKey();
        var button = e.getButton();
        
        if (ctrl && useragent.isMac)
            button = ev.button;

        if (e.editor.inMultiSelectMode && button == 2) {
            e.editor.textInput.onContextMenu(e.domEvent);
            return;
        }
        
        if (!ctrl && !alt && !accel) {
            if (button === 0 && e.editor.inMultiSelectMode)
                e.editor.exitMultiSelectMode();
            return;
        }
        
        if (button !== 0)
            return;

        var editor = e.editor;
        var selection = editor.selection;
        var isMultiSelect = editor.inMultiSelectMode;
        var pos = e.getDocumentPosition();
        var cursor = selection.getCursor();
        var inSelection = e.inSelection() || (selection.isEmpty() && isSamePoint(pos, cursor));

        var mouseX = e.x, mouseY = e.y;
        var onMouseSelection = function(e) {
            mouseX = e.clientX;
            mouseY = e.clientY;
        };
        
        var session = editor.session;
        var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
        var screenCursor = screenAnchor;
        
        var selectionMode;
        if (editor.$mouseHandler.$enableJumpToDef) {
            if (ctrl && alt || accel && alt)
                selectionMode = shift ? "block" : "add";
            else if (alt && editor.$blockSelectEnabled)
                selectionMode = "block";
        } else {
            if (accel && !alt) {
                selectionMode = "add";
                if (!isMultiSelect && shift)
                    return;
            } else if (alt && editor.$blockSelectEnabled) {
                selectionMode = "block";
            }
        }
        
        if (selectionMode && useragent.isMac && ev.ctrlKey) {
            editor.$mouseHandler.cancelContextMenu();
        }

        if (selectionMode == "add") {
            if (!isMultiSelect && inSelection)
                return; // dragging

            if (!isMultiSelect) {
                var range = selection.toOrientedRange();
                editor.addSelectionMarker(range);
            }

            var oldRange = selection.rangeList.rangeAtPoint(pos);
            
            editor.inVirtualSelectionMode = true;
            
            if (shift) {
                oldRange = null;
                range = selection.ranges[0] || range;
                editor.removeSelectionMarker(range);
            }
            editor.once("mouseup", function() {
                var tmpSel = selection.toOrientedRange();

                if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))
                    selection.substractPoint(tmpSel.cursor);
                else {
                    if (shift) {
                        selection.substractPoint(range.cursor);
                    } else if (range) {
                        editor.removeSelectionMarker(range);
                        selection.addRange(range);
                    }
                    selection.addRange(tmpSel);
                }
                editor.inVirtualSelectionMode = false;
            });

        } else if (selectionMode == "block") {
            e.stop();
            editor.inVirtualSelectionMode = true;        
            var initialRange;
            var rectSel = [];
            var blockSelect = function() {
                var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
                var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column, newCursor.offsetX);

                if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor, selection.lead))
                    return;
                screenCursor = newCursor;
                
                editor.selection.moveToPosition(cursor);
                editor.renderer.scrollCursorIntoView();

                editor.removeSelectionMarkers(rectSel);
                rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
                if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())
                    rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
                rectSel.forEach(editor.addSelectionMarker, editor);
                editor.updateSelectionMarkers();
            };
            if (isMultiSelect && !accel) {
                selection.toSingleRange();
            } else if (!isMultiSelect && accel) {
                initialRange = selection.toOrientedRange();
                editor.addSelectionMarker(initialRange);
            }
            
            if (shift)
                screenAnchor = session.documentToScreenPosition(selection.lead);            
            else
                selection.moveToPosition(pos);
            
            screenCursor = {row: -1, column: -1};

            var onMouseSelectionEnd = function(e) {
                blockSelect();
                clearInterval(timerId);
                editor.removeSelectionMarkers(rectSel);
                if (!rectSel.length)
                    rectSel = [selection.toOrientedRange()];
                if (initialRange) {
                    editor.removeSelectionMarker(initialRange);
                    selection.toSingleRange(initialRange);
                }
                for (var i = 0; i < rectSel.length; i++)
                    selection.addRange(rectSel[i]);
                editor.inVirtualSelectionMode = false;
                editor.$mouseHandler.$clickSelection = null;
            };

            var onSelectionInterval = blockSelect;

            event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
            var timerId = setInterval(function() {onSelectionInterval();}, 20);

            return e.preventDefault();
        }
    }


    exports.onMouseDown = onMouseDown;

    });

    ace.define("ace/commands/multi_select_commands",["require","exports","module","ace/keyboard/hash_handler"], function(require, exports, module) {
    exports.defaultCommands = [{
        name: "addCursorAbove",
        description: "Add cursor above",
        exec: function(editor) { editor.selectMoreLines(-1); },
        bindKey: {win: "Ctrl-Alt-Up", mac: "Ctrl-Alt-Up"},
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "addCursorBelow",
        description: "Add cursor below",
        exec: function(editor) { editor.selectMoreLines(1); },
        bindKey: {win: "Ctrl-Alt-Down", mac: "Ctrl-Alt-Down"},
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "addCursorAboveSkipCurrent",
        description: "Add cursor above (skip current)",
        exec: function(editor) { editor.selectMoreLines(-1, true); },
        bindKey: {win: "Ctrl-Alt-Shift-Up", mac: "Ctrl-Alt-Shift-Up"},
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "addCursorBelowSkipCurrent",
        description: "Add cursor below (skip current)",
        exec: function(editor) { editor.selectMoreLines(1, true); },
        bindKey: {win: "Ctrl-Alt-Shift-Down", mac: "Ctrl-Alt-Shift-Down"},
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selectMoreBefore",
        description: "Select more before",
        exec: function(editor) { editor.selectMore(-1); },
        bindKey: {win: "Ctrl-Alt-Left", mac: "Ctrl-Alt-Left"},
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selectMoreAfter",
        description: "Select more after",
        exec: function(editor) { editor.selectMore(1); },
        bindKey: {win: "Ctrl-Alt-Right", mac: "Ctrl-Alt-Right"},
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selectNextBefore",
        description: "Select next before",
        exec: function(editor) { editor.selectMore(-1, true); },
        bindKey: {win: "Ctrl-Alt-Shift-Left", mac: "Ctrl-Alt-Shift-Left"},
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selectNextAfter",
        description: "Select next after",
        exec: function(editor) { editor.selectMore(1, true); },
        bindKey: {win: "Ctrl-Alt-Shift-Right", mac: "Ctrl-Alt-Shift-Right"},
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "toggleSplitSelectionIntoLines",
        description: "Split into lines",
        exec: function(editor) {
            if (editor.multiSelect.rangeCount > 1)
                editor.multiSelect.joinSelections();
            else
                editor.multiSelect.splitIntoLines();
        },
        bindKey: {win: "Ctrl-Alt-L", mac: "Ctrl-Alt-L"},
        readOnly: true
    }, {
        name: "splitSelectionIntoLines",
        description: "Split into lines",
        exec: function(editor) { editor.multiSelect.splitIntoLines(); },
        readOnly: true
    }, {
        name: "alignCursors",
        description: "Align cursors",
        exec: function(editor) { editor.alignCursors(); },
        bindKey: {win: "Ctrl-Alt-A", mac: "Ctrl-Alt-A"},
        scrollIntoView: "cursor"
    }, {
        name: "findAll",
        description: "Find all",
        exec: function(editor) { editor.findAll(); },
        bindKey: {win: "Ctrl-Alt-K", mac: "Ctrl-Alt-G"},
        scrollIntoView: "cursor",
        readOnly: true
    }];
    exports.multiSelectCommands = [{
        name: "singleSelection",
        description: "Single selection",
        bindKey: "esc",
        exec: function(editor) { editor.exitMultiSelectMode(); },
        scrollIntoView: "cursor",
        readOnly: true,
        isAvailable: function(editor) {return editor && editor.inMultiSelectMode;}
    }];

    var HashHandler = require("../keyboard/hash_handler").HashHandler;
    exports.keyboardHandler = new HashHandler(exports.multiSelectCommands);

    });

    ace.define("ace/multi_select",["require","exports","module","ace/range_list","ace/range","ace/selection","ace/mouse/multi_select_handler","ace/lib/event","ace/lib/lang","ace/commands/multi_select_commands","ace/search","ace/edit_session","ace/editor","ace/config"], function(require, exports, module) {

    var RangeList = require("./range_list").RangeList;
    var Range = require("./range").Range;
    var Selection = require("./selection").Selection;
    var onMouseDown = require("./mouse/multi_select_handler").onMouseDown;
    var event = require("./lib/event");
    var lang = require("./lib/lang");
    var commands = require("./commands/multi_select_commands");
    exports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
    var Search = require("./search").Search;
    var search = new Search();

    function find(session, needle, dir) {
        search.$options.wrap = true;
        search.$options.needle = needle;
        search.$options.backwards = dir == -1;
        return search.find(session);
    }
    var EditSession = require("./edit_session").EditSession;
    (function() {
        this.getSelectionMarkers = function() {
            return this.$selectionMarkers;
        };
    }).call(EditSession.prototype);
    (function() {
        this.ranges = null;
        this.rangeList = null;
        this.addRange = function(range, $blockChangeEvents) {
            if (!range)
                return;

            if (!this.inMultiSelectMode && this.rangeCount === 0) {
                var oldRange = this.toOrientedRange();
                this.rangeList.add(oldRange);
                this.rangeList.add(range);
                if (this.rangeList.ranges.length != 2) {
                    this.rangeList.removeAll();
                    return $blockChangeEvents || this.fromOrientedRange(range);
                }
                this.rangeList.removeAll();
                this.rangeList.add(oldRange);
                this.$onAddRange(oldRange);
            }

            if (!range.cursor)
                range.cursor = range.end;

            var removed = this.rangeList.add(range);

            this.$onAddRange(range);

            if (removed.length)
                this.$onRemoveRange(removed);

            if (this.rangeCount > 1 && !this.inMultiSelectMode) {
                this._signal("multiSelect");
                this.inMultiSelectMode = true;
                this.session.$undoSelect = false;
                this.rangeList.attach(this.session);
            }

            return $blockChangeEvents || this.fromOrientedRange(range);
        };
        this.toSingleRange = function(range) {
            range = range || this.ranges[0];
            var removed = this.rangeList.removeAll();
            if (removed.length)
                this.$onRemoveRange(removed);

            range && this.fromOrientedRange(range);
        };
        this.substractPoint = function(pos) {
            var removed = this.rangeList.substractPoint(pos);
            if (removed) {
                this.$onRemoveRange(removed);
                return removed[0];
            }
        };
        this.mergeOverlappingRanges = function() {
            var removed = this.rangeList.merge();
            if (removed.length)
                this.$onRemoveRange(removed);
        };

        this.$onAddRange = function(range) {
            this.rangeCount = this.rangeList.ranges.length;
            this.ranges.unshift(range);
            this._signal("addRange", {range: range});
        };

        this.$onRemoveRange = function(removed) {
            this.rangeCount = this.rangeList.ranges.length;
            if (this.rangeCount == 1 && this.inMultiSelectMode) {
                var lastRange = this.rangeList.ranges.pop();
                removed.push(lastRange);
                this.rangeCount = 0;
            }

            for (var i = removed.length; i--; ) {
                var index = this.ranges.indexOf(removed[i]);
                this.ranges.splice(index, 1);
            }

            this._signal("removeRange", {ranges: removed});

            if (this.rangeCount === 0 && this.inMultiSelectMode) {
                this.inMultiSelectMode = false;
                this._signal("singleSelect");
                this.session.$undoSelect = true;
                this.rangeList.detach(this.session);
            }

            lastRange = lastRange || this.ranges[0];
            if (lastRange && !lastRange.isEqual(this.getRange()))
                this.fromOrientedRange(lastRange);
        };
        this.$initRangeList = function() {
            if (this.rangeList)
                return;

            this.rangeList = new RangeList();
            this.ranges = [];
            this.rangeCount = 0;
        };
        this.getAllRanges = function() {
            return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
        };
        this.splitIntoLines = function () {
            var ranges = this.ranges.length ? this.ranges : [this.getRange()];
            var newRanges = [];
            for (var i = 0; i < ranges.length; i++) {
                var range = ranges[i];
                var row = range.start.row;
                var endRow = range.end.row;
                if (row === endRow) {
                    newRanges.push(range.clone());
                } else {
                    newRanges.push(new Range(row, range.start.column, row, this.session.getLine(row).length));
                    while (++row < endRow)
                        newRanges.push(this.getLineRange(row, true));
                    newRanges.push(new Range(endRow, 0, endRow, range.end.column));
                }
                if (i == 0 && !this.isBackwards())
                    newRanges = newRanges.reverse();
            }
            this.toSingleRange();
            for (var i = newRanges.length; i--;)
                this.addRange(newRanges[i]);
        };
        
        this.joinSelections = function () {
            var ranges = this.rangeList.ranges;
            var lastRange = ranges[ranges.length - 1];
            var range = Range.fromPoints(ranges[0].start, lastRange.end);

            this.toSingleRange();
            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
        };
        this.toggleBlockSelection = function () {
            if (this.rangeCount > 1) {
                var ranges = this.rangeList.ranges;
                var lastRange = ranges[ranges.length - 1];
                var range = Range.fromPoints(ranges[0].start, lastRange.end);

                this.toSingleRange();
                this.setSelectionRange(range, lastRange.cursor == lastRange.start);
            } else {
                var cursor = this.session.documentToScreenPosition(this.cursor);
                var anchor = this.session.documentToScreenPosition(this.anchor);

                var rectSel = this.rectangularRangeBlock(cursor, anchor);
                rectSel.forEach(this.addRange, this);
            }
        };
        this.rectangularRangeBlock = function(screenCursor, screenAnchor, includeEmptyLines) {
            var rectSel = [];

            var xBackwards = screenCursor.column < screenAnchor.column;
            if (xBackwards) {
                var startColumn = screenCursor.column;
                var endColumn = screenAnchor.column;
                var startOffsetX = screenCursor.offsetX;
                var endOffsetX = screenAnchor.offsetX;
            } else {
                var startColumn = screenAnchor.column;
                var endColumn = screenCursor.column;
                var startOffsetX = screenAnchor.offsetX;
                var endOffsetX = screenCursor.offsetX;
            }

            var yBackwards = screenCursor.row < screenAnchor.row;
            if (yBackwards) {
                var startRow = screenCursor.row;
                var endRow = screenAnchor.row;
            } else {
                var startRow = screenAnchor.row;
                var endRow = screenCursor.row;
            }

            if (startColumn < 0)
                startColumn = 0;
            if (startRow < 0)
                startRow = 0;

            if (startRow == endRow)
                includeEmptyLines = true;

            var docEnd;
            for (var row = startRow; row <= endRow; row++) {
                var range = Range.fromPoints(
                    this.session.screenToDocumentPosition(row, startColumn, startOffsetX),
                    this.session.screenToDocumentPosition(row, endColumn, endOffsetX)
                );
                if (range.isEmpty()) {
                    if (docEnd && isSamePoint(range.end, docEnd))
                        break;
                    docEnd = range.end;
                }
                range.cursor = xBackwards ? range.start : range.end;
                rectSel.push(range);
            }

            if (yBackwards)
                rectSel.reverse();

            if (!includeEmptyLines) {
                var end = rectSel.length - 1;
                while (rectSel[end].isEmpty() && end > 0)
                    end--;
                if (end > 0) {
                    var start = 0;
                    while (rectSel[start].isEmpty())
                        start++;
                }
                for (var i = end; i >= start; i--) {
                    if (rectSel[i].isEmpty())
                        rectSel.splice(i, 1);
                }
            }

            return rectSel;
        };
    }).call(Selection.prototype);
    var Editor = require("./editor").Editor;
    (function() {
        this.updateSelectionMarkers = function() {
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
        };
        this.addSelectionMarker = function(orientedRange) {
            if (!orientedRange.cursor)
                orientedRange.cursor = orientedRange.end;

            var style = this.getSelectionStyle();
            orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style);

            this.session.$selectionMarkers.push(orientedRange);
            this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
            return orientedRange;
        };
        this.removeSelectionMarker = function(range) {
            if (!range.marker)
                return;
            this.session.removeMarker(range.marker);
            var index = this.session.$selectionMarkers.indexOf(range);
            if (index != -1)
                this.session.$selectionMarkers.splice(index, 1);
            this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
        };

        this.removeSelectionMarkers = function(ranges) {
            var markerList = this.session.$selectionMarkers;
            for (var i = ranges.length; i--; ) {
                var range = ranges[i];
                if (!range.marker)
                    continue;
                this.session.removeMarker(range.marker);
                var index = markerList.indexOf(range);
                if (index != -1)
                    markerList.splice(index, 1);
            }
            this.session.selectionMarkerCount = markerList.length;
        };

        this.$onAddRange = function(e) {
            this.addSelectionMarker(e.range);
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
        };

        this.$onRemoveRange = function(e) {
            this.removeSelectionMarkers(e.ranges);
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
        };

        this.$onMultiSelect = function(e) {
            if (this.inMultiSelectMode)
                return;
            this.inMultiSelectMode = true;

            this.setStyle("ace_multiselect");
            this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
            this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);

            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
        };

        this.$onSingleSelect = function(e) {
            if (this.session.multiSelect.inVirtualMode)
                return;
            this.inMultiSelectMode = false;

            this.unsetStyle("ace_multiselect");
            this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);

            this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
            this._emit("changeSelection");
        };

        this.$onMultiSelectExec = function(e) {
            var command = e.command;
            var editor = e.editor;
            if (!editor.multiSelect)
                return;
            if (!command.multiSelectAction) {
                var result = command.exec(editor, e.args || {});
                editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
                editor.multiSelect.mergeOverlappingRanges();
            } else if (command.multiSelectAction == "forEach") {
                result = editor.forEachSelection(command, e.args);
            } else if (command.multiSelectAction == "forEachLine") {
                result = editor.forEachSelection(command, e.args, true);
            } else if (command.multiSelectAction == "single") {
                editor.exitMultiSelectMode();
                result = command.exec(editor, e.args || {});
            } else {
                result = command.multiSelectAction(editor, e.args || {});
            }
            return result;
        }; 
        this.forEachSelection = function(cmd, args, options) {
            if (this.inVirtualSelectionMode)
                return;
            var keepOrder = options && options.keepOrder;
            var $byLines = options == true || options && options.$byLines;
            var session = this.session;
            var selection = this.selection;
            var rangeList = selection.rangeList;
            var ranges = (keepOrder ? selection : rangeList).ranges;
            var result;
            
            if (!ranges.length)
                return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
            
            var reg = selection._eventRegistry;
            selection._eventRegistry = {};

            var tmpSel = new Selection(session);
            this.inVirtualSelectionMode = true;
            for (var i = ranges.length; i--;) {
                if ($byLines) {
                    while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row)
                        i--;
                }
                tmpSel.fromOrientedRange(ranges[i]);
                tmpSel.index = i;
                this.selection = session.selection = tmpSel;
                var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
                if (!result && cmdResult !== undefined)
                    result = cmdResult;
                tmpSel.toOrientedRange(ranges[i]);
            }
            tmpSel.detach();

            this.selection = session.selection = selection;
            this.inVirtualSelectionMode = false;
            selection._eventRegistry = reg;
            selection.mergeOverlappingRanges();
            if (selection.ranges[0])
                selection.fromOrientedRange(selection.ranges[0]);
            
            var anim = this.renderer.$scrollAnimation;
            this.onCursorChange();
            this.onSelectionChange();
            if (anim && anim.from == anim.to)
                this.renderer.animateScrolling(anim.from);
            
            return result;
        };
        this.exitMultiSelectMode = function() {
            if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
                return;
            this.multiSelect.toSingleRange();
        };

        this.getSelectedText = function() {
            var text = "";
            if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
                var ranges = this.multiSelect.rangeList.ranges;
                var buf = [];
                for (var i = 0; i < ranges.length; i++) {
                    buf.push(this.session.getTextRange(ranges[i]));
                }
                var nl = this.session.getDocument().getNewLineCharacter();
                text = buf.join(nl);
                if (text.length == (buf.length - 1) * nl.length)
                    text = "";
            } else if (!this.selection.isEmpty()) {
                text = this.session.getTextRange(this.getSelectionRange());
            }
            return text;
        };
        
        this.$checkMultiselectChange = function(e, anchor) {
            if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
                var range = this.multiSelect.ranges[0];
                if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor)
                    return;
                var pos = anchor == this.multiSelect.anchor
                    ? range.cursor == range.start ? range.end : range.start
                    : range.cursor;
                if (pos.row != anchor.row 
                    || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)
                    this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
                else
                    this.multiSelect.mergeOverlappingRanges();
            }
        };
        this.findAll = function(needle, options, additive) {
            options = options || {};
            options.needle = needle || options.needle;
            if (options.needle == undefined) {
                var range = this.selection.isEmpty()
                    ? this.selection.getWordRange()
                    : this.selection.getRange();
                options.needle = this.session.getTextRange(range);
            }    
            this.$search.set(options);
            
            var ranges = this.$search.findAll(this.session);
            if (!ranges.length)
                return 0;

            var selection = this.multiSelect;

            if (!additive)
                selection.toSingleRange(ranges[0]);

            for (var i = ranges.length; i--; )
                selection.addRange(ranges[i], true);
            if (range && selection.rangeList.rangeAtPoint(range.start))
                selection.addRange(range, true);
            
            return ranges.length;
        };
        this.selectMoreLines = function(dir, skip) {
            var range = this.selection.toOrientedRange();
            var isBackwards = range.cursor == range.end;

            var screenLead = this.session.documentToScreenPosition(range.cursor);
            if (this.selection.$desiredColumn)
                screenLead.column = this.selection.$desiredColumn;

            var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);

            if (!range.isEmpty()) {
                var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
                var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
            } else {
                var anchor = lead;
            }

            if (isBackwards) {
                var newRange = Range.fromPoints(lead, anchor);
                newRange.cursor = newRange.start;
            } else {
                var newRange = Range.fromPoints(anchor, lead);
                newRange.cursor = newRange.end;
            }

            newRange.desiredColumn = screenLead.column;
            if (!this.selection.inMultiSelectMode) {
                this.selection.addRange(range);
            } else {
                if (skip)
                    var toRemove = range.cursor;
            }

            this.selection.addRange(newRange);
            if (toRemove)
                this.selection.substractPoint(toRemove);
        };
        this.transposeSelections = function(dir) {
            var session = this.session;
            var sel = session.multiSelect;
            var all = sel.ranges;

            for (var i = all.length; i--; ) {
                var range = all[i];
                if (range.isEmpty()) {
                    var tmp = session.getWordRange(range.start.row, range.start.column);
                    range.start.row = tmp.start.row;
                    range.start.column = tmp.start.column;
                    range.end.row = tmp.end.row;
                    range.end.column = tmp.end.column;
                }
            }
            sel.mergeOverlappingRanges();

            var words = [];
            for (var i = all.length; i--; ) {
                var range = all[i];
                words.unshift(session.getTextRange(range));
            }

            if (dir < 0)
                words.unshift(words.pop());
            else
                words.push(words.shift());

            for (var i = all.length; i--; ) {
                var range = all[i];
                var tmp = range.clone();
                session.replace(range, words[i]);
                range.start.row = tmp.start.row;
                range.start.column = tmp.start.column;
            }
            sel.fromOrientedRange(sel.ranges[0]);
        };
        this.selectMore = function(dir, skip, stopAtFirst) {
            var session = this.session;
            var sel = session.multiSelect;

            var range = sel.toOrientedRange();
            if (range.isEmpty()) {
                range = session.getWordRange(range.start.row, range.start.column);
                range.cursor = dir == -1 ? range.start : range.end;
                this.multiSelect.addRange(range);
                if (stopAtFirst)
                    return;
            }
            var needle = session.getTextRange(range);

            var newRange = find(session, needle, dir);
            if (newRange) {
                newRange.cursor = dir == -1 ? newRange.start : newRange.end;
                this.session.unfold(newRange);
                this.multiSelect.addRange(newRange);
                this.renderer.scrollCursorIntoView(null, 0.5);
            }
            if (skip)
                this.multiSelect.substractPoint(range.cursor);
        };
        this.alignCursors = function() {
            var session = this.session;
            var sel = session.multiSelect;
            var ranges = sel.ranges;
            var row = -1;
            var sameRowRanges = ranges.filter(function(r) {
                if (r.cursor.row == row)
                    return true;
                row = r.cursor.row;
            });
            
            if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
                var range = this.selection.getRange();
                var fr = range.start.row, lr = range.end.row;
                var guessRange = fr == lr;
                if (guessRange) {
                    var max = this.session.getLength();
                    var line;
                    do {
                        line = this.session.getLine(lr);
                    } while (/[=:]/.test(line) && ++lr < max);
                    do {
                        line = this.session.getLine(fr);
                    } while (/[=:]/.test(line) && --fr > 0);
                    
                    if (fr < 0) fr = 0;
                    if (lr >= max) lr = max - 1;
                }
                var lines = this.session.removeFullLines(fr, lr);
                lines = this.$reAlignText(lines, guessRange);
                this.session.insert({row: fr, column: 0}, lines.join("\n") + "\n");
                if (!guessRange) {
                    range.start.column = 0;
                    range.end.column = lines[lines.length - 1].length;
                }
                this.selection.setRange(range);
            } else {
                sameRowRanges.forEach(function(r) {
                    sel.substractPoint(r.cursor);
                });

                var maxCol = 0;
                var minSpace = Infinity;
                var spaceOffsets = ranges.map(function(r) {
                    var p = r.cursor;
                    var line = session.getLine(p.row);
                    var spaceOffset = line.substr(p.column).search(/\S/g);
                    if (spaceOffset == -1)
                        spaceOffset = 0;

                    if (p.column > maxCol)
                        maxCol = p.column;
                    if (spaceOffset < minSpace)
                        minSpace = spaceOffset;
                    return spaceOffset;
                });
                ranges.forEach(function(r, i) {
                    var p = r.cursor;
                    var l = maxCol - p.column;
                    var d = spaceOffsets[i] - minSpace;
                    if (l > d)
                        session.insert(p, lang.stringRepeat(" ", l - d));
                    else
                        session.remove(new Range(p.row, p.column, p.row, p.column - l + d));

                    r.start.column = r.end.column = maxCol;
                    r.start.row = r.end.row = p.row;
                    r.cursor = r.end;
                });
                sel.fromOrientedRange(ranges[0]);
                this.renderer.updateCursor();
                this.renderer.updateBackMarkers();
            }
        };

        this.$reAlignText = function(lines, forceLeft) {
            var isLeftAligned = true, isRightAligned = true;
            var startW, textW, endW;

            return lines.map(function(line) {
                var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
                if (!m)
                    return [line];

                if (startW == null) {
                    startW = m[1].length;
                    textW = m[2].length;
                    endW = m[3].length;
                    return m;
                }

                if (startW + textW + endW != m[1].length + m[2].length + m[3].length)
                    isRightAligned = false;
                if (startW != m[1].length)
                    isLeftAligned = false;

                if (startW > m[1].length)
                    startW = m[1].length;
                if (textW < m[2].length)
                    textW = m[2].length;
                if (endW > m[3].length)
                    endW = m[3].length;

                return m;
            }).map(forceLeft ? alignLeft :
                isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);

            function spaces(n) {
                return lang.stringRepeat(" ", n);
            }

            function alignLeft(m) {
                return !m[2] ? m[0] : spaces(startW) + m[2]
                    + spaces(textW - m[2].length + endW)
                    + m[4].replace(/^([=:])\s+/, "$1 ");
            }
            function alignRight(m) {
                return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2]
                    + spaces(endW)
                    + m[4].replace(/^([=:])\s+/, "$1 ");
            }
            function unAlign(m) {
                return !m[2] ? m[0] : spaces(startW) + m[2]
                    + spaces(endW)
                    + m[4].replace(/^([=:])\s+/, "$1 ");
            }
        };
    }).call(Editor.prototype);


    function isSamePoint(p1, p2) {
        return p1.row == p2.row && p1.column == p2.column;
    }
    exports.onSessionChange = function(e) {
        var session = e.session;
        if (session && !session.multiSelect) {
            session.$selectionMarkers = [];
            session.selection.$initRangeList();
            session.multiSelect = session.selection;
        }
        this.multiSelect = session && session.multiSelect;

        var oldSession = e.oldSession;
        if (oldSession) {
            oldSession.multiSelect.off("addRange", this.$onAddRange);
            oldSession.multiSelect.off("removeRange", this.$onRemoveRange);
            oldSession.multiSelect.off("multiSelect", this.$onMultiSelect);
            oldSession.multiSelect.off("singleSelect", this.$onSingleSelect);
            oldSession.multiSelect.lead.off("change", this.$checkMultiselectChange);
            oldSession.multiSelect.anchor.off("change", this.$checkMultiselectChange);
        }

        if (session) {
            session.multiSelect.on("addRange", this.$onAddRange);
            session.multiSelect.on("removeRange", this.$onRemoveRange);
            session.multiSelect.on("multiSelect", this.$onMultiSelect);
            session.multiSelect.on("singleSelect", this.$onSingleSelect);
            session.multiSelect.lead.on("change", this.$checkMultiselectChange);
            session.multiSelect.anchor.on("change", this.$checkMultiselectChange);
        }

        if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {
            if (session.selection.inMultiSelectMode)
                this.$onMultiSelect();
            else
                this.$onSingleSelect();
        }
    };
    function MultiSelect(editor) {
        if (editor.$multiselectOnSessionChange)
            return;
        editor.$onAddRange = editor.$onAddRange.bind(editor);
        editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
        editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
        editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
        editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);
        editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);

        editor.$multiselectOnSessionChange(editor);
        editor.on("changeSession", editor.$multiselectOnSessionChange);

        editor.on("mousedown", onMouseDown);
        editor.commands.addCommands(commands.defaultCommands);

        addAltCursorListeners(editor);
    }

    function addAltCursorListeners(editor){
        if (!editor.textInput) return;
        var el = editor.textInput.getElement();
        var altCursor = false;
        event.addListener(el, "keydown", function(e) {
            var altDown = e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey);
            if (editor.$blockSelectEnabled && altDown) {
                if (!altCursor) {
                    editor.renderer.setMouseCursor("crosshair");
                    altCursor = true;
                }
            } else if (altCursor) {
                reset();
            }
        });

        event.addListener(el, "keyup", reset);
        event.addListener(el, "blur", reset);
        function reset(e) {
            if (altCursor) {
                editor.renderer.setMouseCursor("");
                altCursor = false;
            }
        }
    }

    exports.MultiSelect = MultiSelect;


    require("./config").defineOptions(Editor.prototype, "editor", {
        enableMultiselect: {
            set: function(val) {
                MultiSelect(this);
                if (val) {
                    this.on("changeSession", this.$multiselectOnSessionChange);
                    this.on("mousedown", onMouseDown);
                } else {
                    this.off("changeSession", this.$multiselectOnSessionChange);
                    this.off("mousedown", onMouseDown);
                }
            },
            value: true
        },
        enableBlockSelect: {
            set: function(val) {
                this.$blockSelectEnabled = val;
            },
            value: true
        }
    });



    });

    ace.define("ace/mode/folding/fold_mode",["require","exports","module","ace/range"], function(require, exports, module) {

    var Range = require("../../range").Range;

    var FoldMode = exports.FoldMode = function() {};

    (function() {

        this.foldingStartMarker = null;
        this.foldingStopMarker = null;
        this.getFoldWidget = function(session, foldStyle, row) {
            var line = session.getLine(row);
            if (this.foldingStartMarker.test(line))
                return "start";
            if (foldStyle == "markbeginend"
                    && this.foldingStopMarker
                    && this.foldingStopMarker.test(line))
                return "end";
            return "";
        };

        this.getFoldWidgetRange = function(session, foldStyle, row) {
            return null;
        };

        this.indentationBlock = function(session, row, column) {
            var re = /\S/;
            var line = session.getLine(row);
            var startLevel = line.search(re);
            if (startLevel == -1)
                return;

            var startColumn = column || line.length;
            var maxRow = session.getLength();
            var startRow = row;
            var endRow = row;

            while (++row < maxRow) {
                var level = session.getLine(row).search(re);

                if (level == -1)
                    continue;

                if (level <= startLevel) {
                    var token = session.getTokenAt(row, 0);
                    if (!token || token.type !== "string")
                        break;
                }

                endRow = row;
            }

            if (endRow > startRow) {
                var endColumn = session.getLine(endRow).length;
                return new Range(startRow, startColumn, endRow, endColumn);
            }
        };

        this.openingBracketBlock = function(session, bracket, row, column, typeRe) {
            var start = {row: row, column: column + 1};
            var end = session.$findClosingBracket(bracket, start, typeRe);
            if (!end)
                return;

            var fw = session.foldWidgets[end.row];
            if (fw == null)
                fw = session.getFoldWidget(end.row);

            if (fw == "start" && end.row > start.row) {
                end.row --;
                end.column = session.getLine(end.row).length;
            }
            return Range.fromPoints(start, end);
        };

        this.closingBracketBlock = function(session, bracket, row, column, typeRe) {
            var end = {row: row, column: column};
            var start = session.$findOpeningBracket(bracket, end);

            if (!start)
                return;

            start.column++;
            end.column--;

            return  Range.fromPoints(start, end);
        };
    }).call(FoldMode.prototype);

    });

    ace.define("ace/theme/textmate",["require","exports","module","ace/lib/dom"], function(require, exports, module) {

    exports.isDark = false;
    exports.cssClass = "ace-tm";
    exports.cssText = ".ace-tm .ace_gutter {\
background: #f0f0f0;\
color: #333;\
}\
.ace-tm .ace_print-margin {\
width: 1px;\
background: #e8e8e8;\
}\
.ace-tm .ace_fold {\
background-color: #6B72E6;\
}\
.ace-tm {\
background-color: #FFFFFF;\
color: black;\
}\
.ace-tm .ace_cursor {\
color: black;\
}\
.ace-tm .ace_invisible {\
color: rgb(191, 191, 191);\
}\
.ace-tm .ace_storage,\
.ace-tm .ace_keyword {\
color: blue;\
}\
.ace-tm .ace_constant {\
color: rgb(197, 6, 11);\
}\
.ace-tm .ace_constant.ace_buildin {\
color: rgb(88, 72, 246);\
}\
.ace-tm .ace_constant.ace_language {\
color: rgb(88, 92, 246);\
}\
.ace-tm .ace_constant.ace_library {\
color: rgb(6, 150, 14);\
}\
.ace-tm .ace_invalid {\
background-color: rgba(255, 0, 0, 0.1);\
color: red;\
}\
.ace-tm .ace_support.ace_function {\
color: rgb(60, 76, 114);\
}\
.ace-tm .ace_support.ace_constant {\
color: rgb(6, 150, 14);\
}\
.ace-tm .ace_support.ace_type,\
.ace-tm .ace_support.ace_class {\
color: rgb(109, 121, 222);\
}\
.ace-tm .ace_keyword.ace_operator {\
color: rgb(104, 118, 135);\
}\
.ace-tm .ace_string {\
color: rgb(3, 106, 7);\
}\
.ace-tm .ace_comment {\
color: rgb(76, 136, 107);\
}\
.ace-tm .ace_comment.ace_doc {\
color: rgb(0, 102, 255);\
}\
.ace-tm .ace_comment.ace_doc.ace_tag {\
color: rgb(128, 159, 191);\
}\
.ace-tm .ace_constant.ace_numeric {\
color: rgb(0, 0, 205);\
}\
.ace-tm .ace_variable {\
color: rgb(49, 132, 149);\
}\
.ace-tm .ace_xml-pe {\
color: rgb(104, 104, 91);\
}\
.ace-tm .ace_entity.ace_name.ace_function {\
color: #0000A2;\
}\
.ace-tm .ace_heading {\
color: rgb(12, 7, 255);\
}\
.ace-tm .ace_list {\
color:rgb(185, 6, 144);\
}\
.ace-tm .ace_meta.ace_tag {\
color:rgb(0, 22, 142);\
}\
.ace-tm .ace_string.ace_regex {\
color: rgb(255, 0, 0)\
}\
.ace-tm .ace_marker-layer .ace_selection {\
background: rgb(181, 213, 255);\
}\
.ace-tm.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px white;\
}\
.ace-tm .ace_marker-layer .ace_step {\
background: rgb(252, 255, 0);\
}\
.ace-tm .ace_marker-layer .ace_stack {\
background: rgb(164, 229, 101);\
}\
.ace-tm .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid rgb(192, 192, 192);\
}\
.ace-tm .ace_marker-layer .ace_active-line {\
background: rgba(0, 0, 0, 0.07);\
}\
.ace-tm .ace_gutter-active-line {\
background-color : #dcdcdc;\
}\
.ace-tm .ace_marker-layer .ace_selected-word {\
background: rgb(250, 250, 255);\
border: 1px solid rgb(200, 200, 250);\
}\
.ace-tm .ace_indent-guide {\
background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\") right repeat-y;\
}\
";
    exports.$id = "ace/theme/textmate";

    var dom = require("../lib/dom");
    dom.importCssString(exports.cssText, exports.cssClass);
    });

    ace.define("ace/line_widgets",["require","exports","module","ace/lib/dom"], function(require, exports, module) {

    var dom = require("./lib/dom");

    function LineWidgets(session) {
        this.session = session;
        this.session.widgetManager = this;
        this.session.getRowLength = this.getRowLength;
        this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
        this.updateOnChange = this.updateOnChange.bind(this);
        this.renderWidgets = this.renderWidgets.bind(this);
        this.measureWidgets = this.measureWidgets.bind(this);
        this.session._changedWidgets = [];
        this.$onChangeEditor = this.$onChangeEditor.bind(this);
        
        this.session.on("change", this.updateOnChange);
        this.session.on("changeFold", this.updateOnFold);
        this.session.on("changeEditor", this.$onChangeEditor);
    }

    (function() {
        this.getRowLength = function(row) {
            var h;
            if (this.lineWidgets)
                h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
            else 
                h = 0;
            if (!this.$useWrapMode || !this.$wrapData[row]) {
                return 1 + h;
            } else {
                return this.$wrapData[row].length + 1 + h;
            }
        };

        this.$getWidgetScreenLength = function() {
            var screenRows = 0;
            this.lineWidgets.forEach(function(w){
                if (w && w.rowCount && !w.hidden)
                    screenRows += w.rowCount;
            });
            return screenRows;
        };    
        
        this.$onChangeEditor = function(e) {
            this.attach(e.editor);
        };
        
        this.attach = function(editor) {
            if (editor  && editor.widgetManager && editor.widgetManager != this)
                editor.widgetManager.detach();

            if (this.editor == editor)
                return;

            this.detach();
            this.editor = editor;
            
            if (editor) {
                editor.widgetManager = this;
                editor.renderer.on("beforeRender", this.measureWidgets);
                editor.renderer.on("afterRender", this.renderWidgets);
            }
        };
        this.detach = function(e) {
            var editor = this.editor;
            if (!editor)
                return;
            
            this.editor = null;
            editor.widgetManager = null;
            
            editor.renderer.off("beforeRender", this.measureWidgets);
            editor.renderer.off("afterRender", this.renderWidgets);
            var lineWidgets = this.session.lineWidgets;
            lineWidgets && lineWidgets.forEach(function(w) {
                if (w && w.el && w.el.parentNode) {
                    w._inDocument = false;
                    w.el.parentNode.removeChild(w.el);
                }
            });
        };

        this.updateOnFold = function(e, session) {
            var lineWidgets = session.lineWidgets;
            if (!lineWidgets || !e.action)
                return;
            var fold = e.data;
            var start = fold.start.row;
            var end = fold.end.row;
            var hide = e.action == "add";
            for (var i = start + 1; i < end; i++) {
                if (lineWidgets[i])
                    lineWidgets[i].hidden = hide;
            }
            if (lineWidgets[end]) {
                if (hide) {
                    if (!lineWidgets[start])
                        lineWidgets[start] = lineWidgets[end];
                    else
                        lineWidgets[end].hidden = hide;
                } else {
                    if (lineWidgets[start] == lineWidgets[end])
                        lineWidgets[start] = undefined;
                    lineWidgets[end].hidden = hide;
                }
            }
        };
        
        this.updateOnChange = function(delta) {
            var lineWidgets = this.session.lineWidgets;
            if (!lineWidgets) return;
            
            var startRow = delta.start.row;
            var len = delta.end.row - startRow;

            if (len === 0) ; else if (delta.action == "remove") {
                var removed = lineWidgets.splice(startRow + 1, len);
                if (!lineWidgets[startRow] && removed[removed.length - 1]) {
                    lineWidgets[startRow] = removed.pop();
                }
                removed.forEach(function(w) {
                    w && this.removeLineWidget(w);
                }, this);
                this.$updateRows();
            } else {
                var args = new Array(len);
                if (lineWidgets[startRow] && lineWidgets[startRow].column != null) {
                    if (delta.start.column > lineWidgets[startRow].column)
                        startRow++;
                }
                args.unshift(startRow, 0);
                lineWidgets.splice.apply(lineWidgets, args);
                this.$updateRows();
            }
        };
        
        this.$updateRows = function() {
            var lineWidgets = this.session.lineWidgets;
            if (!lineWidgets) return;
            var noWidgets = true;
            lineWidgets.forEach(function(w, i) {
                if (w) {
                    noWidgets = false;
                    w.row = i;
                    while (w.$oldWidget) {
                        w.$oldWidget.row = i;
                        w = w.$oldWidget;
                    }
                }
            });
            if (noWidgets)
                this.session.lineWidgets = null;
        };

        this.$registerLineWidget = function(w) {
            if (!this.session.lineWidgets)
                this.session.lineWidgets = new Array(this.session.getLength());
            
            var old = this.session.lineWidgets[w.row];
            if (old) {
                w.$oldWidget = old;
                if (old.el && old.el.parentNode) {
                    old.el.parentNode.removeChild(old.el);
                    old._inDocument = false;
                }
            }
                
            this.session.lineWidgets[w.row] = w;
            return w;
        };
        
        this.addLineWidget = function(w) {
            this.$registerLineWidget(w);
            w.session = this.session;
            
            if (!this.editor) return w;
            
            var renderer = this.editor.renderer;
            if (w.html && !w.el) {
                w.el = dom.createElement("div");
                w.el.innerHTML = w.html;
            }
            if (w.el) {
                dom.addCssClass(w.el, "ace_lineWidgetContainer");
                w.el.style.position = "absolute";
                w.el.style.zIndex = 5;
                renderer.container.appendChild(w.el);
                w._inDocument = true;
                
                if (!w.coverGutter) {
                    w.el.style.zIndex = 3;
                }
                if (w.pixelHeight == null) {
                    w.pixelHeight = w.el.offsetHeight;
                }
            }
            if (w.rowCount == null) {
                w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;
            }
            
            var fold = this.session.getFoldAt(w.row, 0);
            w.$fold = fold;
            if (fold) {
                var lineWidgets = this.session.lineWidgets;
                if (w.row == fold.end.row && !lineWidgets[fold.start.row])
                    lineWidgets[fold.start.row] = w;
                else
                    w.hidden = true;
            }
                
            this.session._emit("changeFold", {data:{start:{row: w.row}}});
            
            this.$updateRows();
            this.renderWidgets(null, renderer);
            this.onWidgetChanged(w);
            return w;
        };
        
        this.removeLineWidget = function(w) {
            w._inDocument = false;
            w.session = null;
            if (w.el && w.el.parentNode)
                w.el.parentNode.removeChild(w.el);
            if (w.editor && w.editor.destroy) try {
                w.editor.destroy();
            } catch(e){}
            if (this.session.lineWidgets) {
                var w1 = this.session.lineWidgets[w.row];
                if (w1 == w) {
                    this.session.lineWidgets[w.row] = w.$oldWidget;
                    if (w.$oldWidget)
                        this.onWidgetChanged(w.$oldWidget);
                } else {
                    while (w1) {
                        if (w1.$oldWidget == w) {
                            w1.$oldWidget = w.$oldWidget;
                            break;
                        }
                        w1 = w1.$oldWidget;
                    }
                }
            }
            this.session._emit("changeFold", {data:{start:{row: w.row}}});
            this.$updateRows();
        };
        
        this.getWidgetsAtRow = function(row) {
            var lineWidgets = this.session.lineWidgets;
            var w = lineWidgets && lineWidgets[row];
            var list = [];
            while (w) {
                list.push(w);
                w = w.$oldWidget;
            }
            return list;
        };
        
        this.onWidgetChanged = function(w) {
            this.session._changedWidgets.push(w);
            this.editor && this.editor.renderer.updateFull();
        };
        
        this.measureWidgets = function(e, renderer) {
            var changedWidgets = this.session._changedWidgets;
            var config = renderer.layerConfig;
            
            if (!changedWidgets || !changedWidgets.length) return;
            var min = Infinity;
            for (var i = 0; i < changedWidgets.length; i++) {
                var w = changedWidgets[i];
                if (!w || !w.el) continue;
                if (w.session != this.session) continue;
                if (!w._inDocument) {
                    if (this.session.lineWidgets[w.row] != w)
                        continue;
                    w._inDocument = true;
                    renderer.container.appendChild(w.el);
                }
                
                w.h = w.el.offsetHeight;
                
                if (!w.fixedWidth) {
                    w.w = w.el.offsetWidth;
                    w.screenWidth = Math.ceil(w.w / config.characterWidth);
                }
                
                var rowCount = w.h / config.lineHeight;
                if (w.coverLine) {
                    rowCount -= this.session.getRowLineCount(w.row);
                    if (rowCount < 0)
                        rowCount = 0;
                }
                if (w.rowCount != rowCount) {
                    w.rowCount = rowCount;
                    if (w.row < min)
                        min = w.row;
                }
            }
            if (min != Infinity) {
                this.session._emit("changeFold", {data:{start:{row: min}}});
                this.session.lineWidgetWidth = null;
            }
            this.session._changedWidgets = [];
        };
        
        this.renderWidgets = function(e, renderer) {
            var config = renderer.layerConfig;
            var lineWidgets = this.session.lineWidgets;
            if (!lineWidgets)
                return;
            var first = Math.min(this.firstRow, config.firstRow);
            var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);
            
            while (first > 0 && !lineWidgets[first])
                first--;
            
            this.firstRow = config.firstRow;
            this.lastRow = config.lastRow;

            renderer.$cursorLayer.config = config;
            for (var i = first; i <= last; i++) {
                var w = lineWidgets[i];
                if (!w || !w.el) continue;
                if (w.hidden) {
                    w.el.style.top = -100 - (w.pixelHeight || 0) + "px";
                    continue;
                }
                if (!w._inDocument) {
                    w._inDocument = true;
                    renderer.container.appendChild(w.el);
                }
                var top = renderer.$cursorLayer.getPixelPosition({row: i, column:0}, true).top;
                if (!w.coverLine)
                    top += config.lineHeight * this.session.getRowLineCount(w.row);
                w.el.style.top = top - config.offset + "px";
                
                var left = w.coverGutter ? 0 : renderer.gutterWidth;
                if (!w.fixedWidth)
                    left -= renderer.scrollLeft;
                w.el.style.left = left + "px";
                
                if (w.fullWidth && w.screenWidth) {
                    w.el.style.minWidth = config.width + 2 * config.padding + "px";
                }
                
                if (w.fixedWidth) {
                    w.el.style.right = renderer.scrollBar.getWidth() + "px";
                } else {
                    w.el.style.right = "";
                }
            }
        };
        
    }).call(LineWidgets.prototype);


    exports.LineWidgets = LineWidgets;

    });

    ace.define("ace/ext/error_marker",["require","exports","module","ace/line_widgets","ace/lib/dom","ace/range"], function(require, exports, module) {
    var LineWidgets = require("../line_widgets").LineWidgets;
    var dom = require("../lib/dom");
    var Range = require("../range").Range;

    function binarySearch(array, needle, comparator) {
        var first = 0;
        var last = array.length - 1;

        while (first <= last) {
            var mid = (first + last) >> 1;
            var c = comparator(needle, array[mid]);
            if (c > 0)
                first = mid + 1;
            else if (c < 0)
                last = mid - 1;
            else
                return mid;
        }
        return -(first + 1);
    }

    function findAnnotations(session, row, dir) {
        var annotations = session.getAnnotations().sort(Range.comparePoints);
        if (!annotations.length)
            return;
        
        var i = binarySearch(annotations, {row: row, column: -1}, Range.comparePoints);
        if (i < 0)
            i = -i - 1;
        
        if (i >= annotations.length)
            i = dir > 0 ? 0 : annotations.length - 1;
        else if (i === 0 && dir < 0)
            i = annotations.length - 1;
        
        var annotation = annotations[i];
        if (!annotation || !dir)
            return;

        if (annotation.row === row) {
            do {
                annotation = annotations[i += dir];
            } while (annotation && annotation.row === row);
            if (!annotation)
                return annotations.slice();
        }
        
        
        var matched = [];
        row = annotation.row;
        do {
            matched[dir < 0 ? "unshift" : "push"](annotation);
            annotation = annotations[i += dir];
        } while (annotation && annotation.row == row);
        return matched.length && matched;
    }

    exports.showErrorMarker = function(editor, dir) {
        var session = editor.session;
        if (!session.widgetManager) {
            session.widgetManager = new LineWidgets(session);
            session.widgetManager.attach(editor);
        }
        
        var pos = editor.getCursorPosition();
        var row = pos.row;
        var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function(w) {
            return w.type == "errorMarker";
        })[0];
        if (oldWidget) {
            oldWidget.destroy();
        } else {
            row -= dir;
        }
        var annotations = findAnnotations(session, row, dir);
        var gutterAnno;
        if (annotations) {
            var annotation = annotations[0];
            pos.column = (annotation.pos && typeof annotation.column != "number"
                ? annotation.pos.sc
                : annotation.column) || 0;
            pos.row = annotation.row;
            gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
        } else if (oldWidget) {
            return;
        } else {
            gutterAnno = {
                text: ["Looks good!"],
                className: "ace_ok"
            };
        }
        editor.session.unfold(pos.row);
        editor.selection.moveToPosition(pos);
        
        var w = {
            row: pos.row, 
            fixedWidth: true,
            coverGutter: true,
            el: dom.createElement("div"),
            type: "errorMarker"
        };
        var el = w.el.appendChild(dom.createElement("div"));
        var arrow = w.el.appendChild(dom.createElement("div"));
        arrow.className = "error_widget_arrow " + gutterAnno.className;
        
        var left = editor.renderer.$cursorLayer
            .getPixelPosition(pos).left;
        arrow.style.left = left + editor.renderer.gutterWidth - 5 + "px";
        
        w.el.className = "error_widget_wrapper";
        el.className = "error_widget " + gutterAnno.className;
        el.innerHTML = gutterAnno.text.join("<br>");
        
        el.appendChild(dom.createElement("div"));
        
        var kb = function(_, hashId, keyString) {
            if (hashId === 0 && (keyString === "esc" || keyString === "return")) {
                w.destroy();
                return {command: "null"};
            }
        };
        
        w.destroy = function() {
            if (editor.$mouseHandler.isMousePressed)
                return;
            editor.keyBinding.removeKeyboardHandler(kb);
            session.widgetManager.removeLineWidget(w);
            editor.off("changeSelection", w.destroy);
            editor.off("changeSession", w.destroy);
            editor.off("mouseup", w.destroy);
            editor.off("change", w.destroy);
        };
        
        editor.keyBinding.addKeyboardHandler(kb);
        editor.on("changeSelection", w.destroy);
        editor.on("changeSession", w.destroy);
        editor.on("mouseup", w.destroy);
        editor.on("change", w.destroy);
        
        editor.session.widgetManager.addLineWidget(w);
        
        w.el.onmousedown = editor.focus.bind(editor);
        
        editor.renderer.scrollCursorIntoView(null, 0.5, {bottom: w.el.offsetHeight});
    };


    dom.importCssString("\
    .error_widget_wrapper {\
        background: inherit;\
        color: inherit;\
        border:none\
    }\
    .error_widget {\
        border-top: solid 2px;\
        border-bottom: solid 2px;\
        margin: 5px 0;\
        padding: 10px 40px;\
        white-space: pre-wrap;\
    }\
    .error_widget.ace_error, .error_widget_arrow.ace_error{\
        border-color: #ff5a5a\
    }\
    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\
        border-color: #F1D817\
    }\
    .error_widget.ace_info, .error_widget_arrow.ace_info{\
        border-color: #5a5a5a\
    }\
    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\
        border-color: #5aaa5a\
    }\
    .error_widget_arrow {\
        position: absolute;\
        border: solid 5px;\
        border-top-color: transparent!important;\
        border-right-color: transparent!important;\
        border-left-color: transparent!important;\
        top: -5px;\
    }\
", "");

    });

    ace.define("ace/ace",["require","exports","module","ace/lib/fixoldbrowsers","ace/lib/dom","ace/lib/event","ace/range","ace/editor","ace/edit_session","ace/undomanager","ace/virtual_renderer","ace/worker/worker_client","ace/keyboard/hash_handler","ace/placeholder","ace/multi_select","ace/mode/folding/fold_mode","ace/theme/textmate","ace/ext/error_marker","ace/config"], function(require, exports, module) {

    require("./lib/fixoldbrowsers");

    var dom = require("./lib/dom");
    var event = require("./lib/event");

    var Range = require("./range").Range;
    var Editor = require("./editor").Editor;
    var EditSession = require("./edit_session").EditSession;
    var UndoManager = require("./undomanager").UndoManager;
    var Renderer = require("./virtual_renderer").VirtualRenderer;
    require("./worker/worker_client");
    require("./keyboard/hash_handler");
    require("./placeholder");
    require("./multi_select");
    require("./mode/folding/fold_mode");
    require("./theme/textmate");
    require("./ext/error_marker");

    exports.config = require("./config");
    exports.require = require;
    exports.edit = function(el, options) {
        if (typeof el == "string") {
            var _id = el;
            el = document.getElementById(_id);
            if (!el)
                throw new Error("ace.edit can't find div #" + _id);
        }

        if (el && el.env && el.env.editor instanceof Editor)
            return el.env.editor;

        var value = "";
        if (el && /input|textarea/i.test(el.tagName)) {
            var oldNode = el;
            value = oldNode.value;
            el = dom.createElement("pre");
            oldNode.parentNode.replaceChild(el, oldNode);
        } else if (el) {
            value = el.textContent;
            el.innerHTML = "";
        }

        var doc = exports.createEditSession(value);

        var editor = new Editor(new Renderer(el), doc, options);

        var env = {
            document: doc,
            editor: editor,
            onResize: editor.resize.bind(editor, null)
        };
        if (oldNode) env.textarea = oldNode;
        event.addListener(window, "resize", env.onResize);
        editor.on("destroy", function() {
            event.removeListener(window, "resize", env.onResize);
            env.editor.container.env = null; // prevent memory leak on old ie
        });
        editor.container.env = editor.env = env;
        return editor;
    };
    exports.createEditSession = function(text, mode) {
        var doc = new EditSession(text, mode);
        doc.setUndoManager(new UndoManager());
        return doc;
    };
    exports.Range = Range;
    exports.Editor = Editor;
    exports.EditSession = EditSession;
    exports.UndoManager = UndoManager;
    exports.VirtualRenderer = Renderer;
    exports.version = exports.config.version;
    });            (function() {
                    ace.require(["ace/ace"], function(a) {
                        if (a) {
                            a.config.init(true);
                            a.define = ace.define;
                        }
                        if (!window.ace)
                            window.ace = a;
                        for (var key in a) if (a.hasOwnProperty(key))
                            window.ace[key] = a[key];
                        window.ace["default"] = window.ace;
                        if ( module) {
                            module.exports = window.ace;
                        }
                    });
                })();
    });

    var extLanguage_tools = createCommonjsModule(function (module, exports) {
    ace.define("ace/snippets",["require","exports","module","ace/lib/oop","ace/lib/event_emitter","ace/lib/lang","ace/range","ace/range_list","ace/keyboard/hash_handler","ace/tokenizer","ace/clipboard","ace/lib/dom","ace/editor"], function(require, exports, module) {
    var oop = require("./lib/oop");
    var EventEmitter = require("./lib/event_emitter").EventEmitter;
    var lang = require("./lib/lang");
    var Range = require("./range").Range;
    var RangeList = require("./range_list").RangeList;
    var HashHandler = require("./keyboard/hash_handler").HashHandler;
    var Tokenizer = require("./tokenizer").Tokenizer;
    var clipboard = require("./clipboard");

    var VARIABLES = {
        CURRENT_WORD: function(editor) {
            return editor.session.getTextRange(editor.session.getWordRange());
        },
        SELECTION: function(editor, name, indentation) {
            var text = editor.session.getTextRange();
            if (indentation)
                return text.replace(/\n\r?([ \t]*\S)/g, "\n" + indentation + "$1");
            return text;
        },
        CURRENT_LINE: function(editor) {
            return editor.session.getLine(editor.getCursorPosition().row);
        },
        PREV_LINE: function(editor) {
            return editor.session.getLine(editor.getCursorPosition().row - 1);
        },
        LINE_INDEX: function(editor) {
            return editor.getCursorPosition().row;
        },
        LINE_NUMBER: function(editor) {
            return editor.getCursorPosition().row + 1;
        },
        SOFT_TABS: function(editor) {
            return editor.session.getUseSoftTabs() ? "YES" : "NO";
        },
        TAB_SIZE: function(editor) {
            return editor.session.getTabSize();
        },
        CLIPBOARD: function(editor) {
            return clipboard.getText && clipboard.getText();
        },
        FILENAME: function(editor) {
            return /[^/\\]*$/.exec(this.FILEPATH(editor))[0];
        },
        FILENAME_BASE: function(editor) {
            return /[^/\\]*$/.exec(this.FILEPATH(editor))[0].replace(/\.[^.]*$/, "");
        },
        DIRECTORY: function(editor) {
            return this.FILEPATH(editor).replace(/[^/\\]*$/, "");
        },
        FILEPATH: function(editor) { return "/not implemented.txt"; },
        WORKSPACE_NAME: function() { return "Unknown"; },
        FULLNAME: function() { return "Unknown"; },
        BLOCK_COMMENT_START: function(editor) {
            var mode = editor.session.$mode || {};
            return mode.blockComment && mode.blockComment.start || "";
        },
        BLOCK_COMMENT_END: function(editor) {
            var mode = editor.session.$mode || {};
            return mode.blockComment && mode.blockComment.end || "";
        },
        LINE_COMMENT: function(editor) {
            var mode = editor.session.$mode || {};
            return mode.lineCommentStart || "";
        },
        CURRENT_YEAR: date.bind(null, {year: "numeric"}),
        CURRENT_YEAR_SHORT: date.bind(null, {year: "2-digit"}),
        CURRENT_MONTH: date.bind(null, {month: "numeric"}),
        CURRENT_MONTH_NAME: date.bind(null, {month: "long"}),
        CURRENT_MONTH_NAME_SHORT: date.bind(null, {month: "short"}),
        CURRENT_DATE: date.bind(null, {day: "2-digit"}),
        CURRENT_DAY_NAME: date.bind(null, {weekday: "long"}),
        CURRENT_DAY_NAME_SHORT: date.bind(null, {weekday: "short"}),
        CURRENT_HOUR: date.bind(null, {hour: "2-digit", hour12: false}),
        CURRENT_MINUTE: date.bind(null, {minute: "2-digit"}),
        CURRENT_SECOND: date.bind(null, {second: "2-digit"})
    };

    VARIABLES.SELECTED_TEXT = VARIABLES.SELECTION;

    function date(dateFormat) {
        var str = new Date().toLocaleString("en-us", dateFormat);
        return str.length == 1 ? "0" + str : str;
    }

    var SnippetManager = function() {
        this.snippetMap = {};
        this.snippetNameMap = {};
    };

    (function() {
        oop.implement(this, EventEmitter);
        
        this.getTokenizer = function() {
            return SnippetManager.$tokenizer || this.createTokenizer();
        };
        
        this.createTokenizer = function() {
            function TabstopToken(str) {
                str = str.substr(1);
                if (/^\d+$/.test(str))
                    return [{tabstopId: parseInt(str, 10)}];
                return [{text: str}];
            }
            function escape(ch) {
                return "(?:[^\\\\" + ch + "]|\\\\.)";
            }
            var formatMatcher = {
                regex: "/(" + escape("/") + "+)/", 
                onMatch: function(val, state, stack) {
                    var ts = stack[0];
                    ts.fmtString = true;
                    ts.guard = val.slice(1, -1);
                    ts.flag = "";
                    return "";
                },
                next: "formatString"
            };
            
            SnippetManager.$tokenizer = new Tokenizer({
                start: [
                    {regex: /\\./, onMatch: function(val, state, stack) {
                        var ch = val[1];
                        if (ch == "}" && stack.length) {
                            val = ch;
                        } else if ("`$\\".indexOf(ch) != -1) {
                            val = ch;
                        }
                        return [val];
                    }},
                    {regex: /}/, onMatch: function(val, state, stack) {
                        return [stack.length ? stack.shift() : val];
                    }},
                    {regex: /\$(?:\d+|\w+)/, onMatch: TabstopToken},
                    {regex: /\$\{[\dA-Z_a-z]+/, onMatch: function(str, state, stack) {
                        var t = TabstopToken(str.substr(1));
                        stack.unshift(t[0]);
                        return t;
                    }, next: "snippetVar"},
                    {regex: /\n/, token: "newline", merge: false}
                ],
                snippetVar: [
                    {regex: "\\|" + escape("\\|") + "*\\|", onMatch: function(val, state, stack) {
                        var choices = val.slice(1, -1).replace(/\\[,|\\]|,/g, function(operator) {
                            return operator.length == 2 ? operator[1] : "\x00";
                        }).split("\x00");
                        stack[0].choices = choices;
                        return [choices[0]];
                    }, next: "start"},
                    formatMatcher,
                    {regex: "([^:}\\\\]|\\\\.)*:?", token: "", next: "start"}
                ],
                formatString: [
                    {regex: /:/, onMatch: function(val, state, stack) {
                        if (stack.length && stack[0].expectElse) {
                            stack[0].expectElse = false;
                            stack[0].ifEnd = {elseEnd: stack[0]};
                            return [stack[0].ifEnd];
                        }
                        return ":";
                    }},
                    {regex: /\\./, onMatch: function(val, state, stack) {
                        var ch = val[1];
                        if (ch == "}" && stack.length)
                            val = ch;
                        else if ("`$\\".indexOf(ch) != -1)
                            val = ch;
                        else if (ch == "n")
                            val = "\n";
                        else if (ch == "t")
                            val = "\t";
                        else if ("ulULE".indexOf(ch) != -1)
                            val = {changeCase: ch, local: ch > "a"};
                        return [val];
                    }},
                    {regex: "/\\w*}", onMatch: function(val, state, stack) {
                        var next = stack.shift();
                        if (next)
                            next.flag = val.slice(1, -1);
                        this.next = next && next.tabstopId ? "start" : "";
                        return [next || val];
                    }, next: "start"},
                    {regex: /\$(?:\d+|\w+)/, onMatch: function(val, state, stack) {
                        return [{text: val.slice(1)}];
                    }},
                    {regex: /\${\w+/, onMatch: function(val, state, stack) {
                        var token = {text: val.slice(2)};
                        stack.unshift(token);
                        return [token];
                    }, next: "formatStringVar"},
                    {regex: /\n/, token: "newline", merge: false},
                    {regex: /}/, onMatch: function(val, state, stack) {
                        var next = stack.shift();
                        this.next = next && next.tabstopId ? "start" : "";
                        return [next || val];
                    }, next: "start"}
                ],
                formatStringVar: [
                    {regex: /:\/\w+}/, onMatch: function(val, state, stack) {
                        var ts = stack[0];
                        ts.formatFunction = val.slice(2, -1);
                        return [stack.shift()];
                    }, next: "formatString"},
                    formatMatcher,
                    {regex: /:[\?\-+]?/, onMatch: function(val, state, stack) {
                        if (val[1] == "+")
                            stack[0].ifEnd = stack[0];
                        if (val[1] == "?")
                            stack[0].expectElse = true;
                    }, next: "formatString"},
                    {regex: "([^:}\\\\]|\\\\.)*:?", token: "", next: "formatString"}
                ]
            });
            return SnippetManager.$tokenizer;
        };

        this.tokenizeTmSnippet = function(str, startState) {
            return this.getTokenizer().getLineTokens(str, startState).tokens.map(function(x) {
                return x.value || x;
            });
        };
        
        this.getVariableValue = function(editor, name, indentation) {
            if (/^\d+$/.test(name))
                return (this.variables.__ || {})[name] || "";
            if (/^[A-Z]\d+$/.test(name))
                return (this.variables[name[0] + "__"] || {})[name.substr(1)] || "";
            
            name = name.replace(/^TM_/, "");
            if (!this.variables.hasOwnProperty(name))
                return "";
            var value = this.variables[name];
            if (typeof value == "function")
                value = this.variables[name](editor, name, indentation);
            return value == null ? "" : value;
        };
        
        this.variables = VARIABLES;
        this.tmStrFormat = function(str, ch, editor) {
            if (!ch.fmt) return str;
            var flag = ch.flag || "";
            var re = ch.guard;
            re = new RegExp(re, flag.replace(/[^gim]/g, ""));
            var fmtTokens = typeof ch.fmt == "string" ? this.tokenizeTmSnippet(ch.fmt, "formatString") : ch.fmt;
            var _self = this;
            var formatted = str.replace(re, function() {
                var oldArgs = _self.variables.__;
                _self.variables.__ = [].slice.call(arguments);
                var fmtParts = _self.resolveVariables(fmtTokens, editor);
                var gChangeCase = "E";
                for (var i  = 0; i < fmtParts.length; i++) {
                    var ch = fmtParts[i];
                    if (typeof ch == "object") {
                        fmtParts[i] = "";
                        if (ch.changeCase && ch.local) {
                            var next = fmtParts[i + 1];
                            if (next && typeof next == "string") {
                                if (ch.changeCase == "u")
                                    fmtParts[i] = next[0].toUpperCase();
                                else
                                    fmtParts[i] = next[0].toLowerCase();
                                fmtParts[i + 1] = next.substr(1);
                            }
                        } else if (ch.changeCase) {
                            gChangeCase = ch.changeCase;
                        }
                    } else if (gChangeCase == "U") {
                        fmtParts[i] = ch.toUpperCase();
                    } else if (gChangeCase == "L") {
                        fmtParts[i] = ch.toLowerCase();
                    }
                }
                _self.variables.__ = oldArgs;
                return fmtParts.join("");
            });
            return formatted;
        };
        
        this.tmFormatFunction = function(str, ch, editor) {
            if (ch.formatFunction == "upcase")
                return str.toUpperCase();
            if (ch.formatFunction == "downcase")
                return str.toLowerCase();
            return str;
        };

        this.resolveVariables = function(snippet, editor) {
            var result = [];
            var indentation = "";
            var afterNewLine = true;
            for (var i = 0; i < snippet.length; i++) {
                var ch = snippet[i];
                if (typeof ch == "string") {
                    result.push(ch);
                    if (ch == "\n") {
                        afterNewLine = true;
                        indentation = "";
                    }
                    else if (afterNewLine) {
                        indentation = /^\t*/.exec(ch)[0];
                        afterNewLine = /\S/.test(ch);
                    }
                    continue;
                }
                if (!ch)  continue;
                afterNewLine = false;
                
                if (ch.fmtString) {
                    var j = snippet.indexOf(ch, i + 1);
                    if (j == -1) j = snippet.length;
                    ch.fmt = snippet.slice(i + 1, j);
                    i = j;
                }
                
                if (ch.text) {
                    var value = this.getVariableValue(editor, ch.text, indentation) + "";
                    if (ch.fmtString)
                        value = this.tmStrFormat(value, ch, editor);
                    if (ch.formatFunction)
                        value = this.tmFormatFunction(value, ch, editor);
                    
                    if (value && !ch.ifEnd) {
                        result.push(value);
                        gotoNext(ch);
                    } else if (!value && ch.ifEnd) {
                        gotoNext(ch.ifEnd);
                    }
                } else if (ch.elseEnd) {
                    gotoNext(ch.elseEnd);
                } else if (ch.tabstopId != null) {
                    result.push(ch);
                } else if (ch.changeCase != null) {
                    result.push(ch);
                }
            }
            function gotoNext(ch) {
                var i1 = snippet.indexOf(ch, i + 1);
                if (i1 != -1)
                    i = i1;
            }
            return result;
        };

        this.insertSnippetForSelection = function(editor, snippetText) {
            var cursor = editor.getCursorPosition();
            var line = editor.session.getLine(cursor.row);
            var tabString = editor.session.getTabString();
            var indentString = line.match(/^\s*/)[0];
            
            if (cursor.column < indentString.length)
                indentString = indentString.slice(0, cursor.column);

            snippetText = snippetText.replace(/\r/g, "");
            var tokens = this.tokenizeTmSnippet(snippetText);
            tokens = this.resolveVariables(tokens, editor);
            tokens = tokens.map(function(x) {
                if (x == "\n")
                    return x + indentString;
                if (typeof x == "string")
                    return x.replace(/\t/g, tabString);
                return x;
            });
            var tabstops = [];
            tokens.forEach(function(p, i) {
                if (typeof p != "object")
                    return;
                var id = p.tabstopId;
                var ts = tabstops[id];
                if (!ts) {
                    ts = tabstops[id] = [];
                    ts.index = id;
                    ts.value = "";
                    ts.parents = {};
                }
                if (ts.indexOf(p) !== -1)
                    return;
                if (p.choices && !ts.choices)
                    ts.choices = p.choices;
                ts.push(p);
                var i1 = tokens.indexOf(p, i + 1);
                if (i1 === -1)
                    return;

                var value = tokens.slice(i + 1, i1);
                var isNested = value.some(function(t) {return typeof t === "object";});
                if (isNested && !ts.value) {
                    ts.value = value;
                } else if (value.length && (!ts.value || typeof ts.value !== "string")) {
                    ts.value = value.join("");
                }
            });
            tabstops.forEach(function(ts) {ts.length = 0;});
            var expanding = {};
            function copyValue(val) {
                var copy = [];
                for (var i = 0; i < val.length; i++) {
                    var p = val[i];
                    if (typeof p == "object") {
                        if (expanding[p.tabstopId])
                            continue;
                        var j = val.lastIndexOf(p, i - 1);
                        p = copy[j] || {tabstopId: p.tabstopId};
                    }
                    copy[i] = p;
                }
                return copy;
            }
            for (var i = 0; i < tokens.length; i++) {
                var p = tokens[i];
                if (typeof p != "object")
                    continue;
                var id = p.tabstopId;
                var ts = tabstops[id];
                var i1 = tokens.indexOf(p, i + 1);
                if (expanding[id]) {
                    if (expanding[id] === p) {
                        delete expanding[id];
                        Object.keys(expanding).forEach(function(parentId) {
                            ts.parents[parentId] = true;
                        });
                    }
                    continue;
                }
                expanding[id] = p;
                var value = ts.value;
                if (typeof value !== "string")
                    value = copyValue(value);
                else if (p.fmt)
                    value = this.tmStrFormat(value, p, editor);
                tokens.splice.apply(tokens, [i + 1, Math.max(0, i1 - i)].concat(value, p));

                if (ts.indexOf(p) === -1)
                    ts.push(p);
            }
            var row = 0, column = 0;
            var text = "";
            tokens.forEach(function(t) {
                if (typeof t === "string") {
                    var lines = t.split("\n");
                    if (lines.length > 1){
                        column = lines[lines.length - 1].length;
                        row += lines.length - 1;
                    } else
                        column += t.length;
                    text += t;
                } else if (t) {
                    if (!t.start)
                        t.start = {row: row, column: column};
                    else
                        t.end = {row: row, column: column};
                }
            });
            var range = editor.getSelectionRange();
            var end = editor.session.replace(range, text);

            var tabstopManager = new TabstopManager(editor);
            var selectionId = editor.inVirtualSelectionMode && editor.selection.index;
            tabstopManager.addTabstops(tabstops, range.start, end, selectionId);
        };
        
        this.insertSnippet = function(editor, snippetText) {
            var self = this;
            if (editor.inVirtualSelectionMode)
                return self.insertSnippetForSelection(editor, snippetText);
            
            editor.forEachSelection(function() {
                self.insertSnippetForSelection(editor, snippetText);
            }, null, {keepOrder: true});
            
            if (editor.tabstopManager)
                editor.tabstopManager.tabNext();
        };

        this.$getScope = function(editor) {
            var scope = editor.session.$mode.$id || "";
            scope = scope.split("/").pop();
            if (scope === "html" || scope === "php") {
                if (scope === "php" && !editor.session.$mode.inlinePhp) 
                    scope = "html";
                var c = editor.getCursorPosition();
                var state = editor.session.getState(c.row);
                if (typeof state === "object") {
                    state = state[0];
                }
                if (state.substring) {
                    if (state.substring(0, 3) == "js-")
                        scope = "javascript";
                    else if (state.substring(0, 4) == "css-")
                        scope = "css";
                    else if (state.substring(0, 4) == "php-")
                        scope = "php";
                }
            }
            
            return scope;
        };

        this.getActiveScopes = function(editor) {
            var scope = this.$getScope(editor);
            var scopes = [scope];
            var snippetMap = this.snippetMap;
            if (snippetMap[scope] && snippetMap[scope].includeScopes) {
                scopes.push.apply(scopes, snippetMap[scope].includeScopes);
            }
            scopes.push("_");
            return scopes;
        };

        this.expandWithTab = function(editor, options) {
            var self = this;
            var result = editor.forEachSelection(function() {
                return self.expandSnippetForSelection(editor, options);
            }, null, {keepOrder: true});
            if (result && editor.tabstopManager)
                editor.tabstopManager.tabNext();
            return result;
        };
        
        this.expandSnippetForSelection = function(editor, options) {
            var cursor = editor.getCursorPosition();
            var line = editor.session.getLine(cursor.row);
            var before = line.substring(0, cursor.column);
            var after = line.substr(cursor.column);

            var snippetMap = this.snippetMap;
            var snippet;
            this.getActiveScopes(editor).some(function(scope) {
                var snippets = snippetMap[scope];
                if (snippets)
                    snippet = this.findMatchingSnippet(snippets, before, after);
                return !!snippet;
            }, this);
            if (!snippet)
                return false;
            if (options && options.dryRun)
                return true;
            editor.session.doc.removeInLine(cursor.row,
                cursor.column - snippet.replaceBefore.length,
                cursor.column + snippet.replaceAfter.length
            );

            this.variables.M__ = snippet.matchBefore;
            this.variables.T__ = snippet.matchAfter;
            this.insertSnippetForSelection(editor, snippet.content);

            this.variables.M__ = this.variables.T__ = null;
            return true;
        };

        this.findMatchingSnippet = function(snippetList, before, after) {
            for (var i = snippetList.length; i--;) {
                var s = snippetList[i];
                if (s.startRe && !s.startRe.test(before))
                    continue;
                if (s.endRe && !s.endRe.test(after))
                    continue;
                if (!s.startRe && !s.endRe)
                    continue;

                s.matchBefore = s.startRe ? s.startRe.exec(before) : [""];
                s.matchAfter = s.endRe ? s.endRe.exec(after) : [""];
                s.replaceBefore = s.triggerRe ? s.triggerRe.exec(before)[0] : "";
                s.replaceAfter = s.endTriggerRe ? s.endTriggerRe.exec(after)[0] : "";
                return s;
            }
        };

        this.snippetMap = {};
        this.snippetNameMap = {};
        this.register = function(snippets, scope) {
            var snippetMap = this.snippetMap;
            var snippetNameMap = this.snippetNameMap;
            var self = this;
            
            if (!snippets) 
                snippets = [];
            
            function wrapRegexp(src) {
                if (src && !/^\^?\(.*\)\$?$|^\\b$/.test(src))
                    src = "(?:" + src + ")";

                return src || "";
            }
            function guardedRegexp(re, guard, opening) {
                re = wrapRegexp(re);
                guard = wrapRegexp(guard);
                if (opening) {
                    re = guard + re;
                    if (re && re[re.length - 1] != "$")
                        re = re + "$";
                } else {
                    re = re + guard;
                    if (re && re[0] != "^")
                        re = "^" + re;
                }
                return new RegExp(re);
            }

            function addSnippet(s) {
                if (!s.scope)
                    s.scope = scope || "_";
                scope = s.scope;
                if (!snippetMap[scope]) {
                    snippetMap[scope] = [];
                    snippetNameMap[scope] = {};
                }

                var map = snippetNameMap[scope];
                if (s.name) {
                    var old = map[s.name];
                    if (old)
                        self.unregister(old);
                    map[s.name] = s;
                }
                snippetMap[scope].push(s);

                if (s.tabTrigger && !s.trigger) {
                    if (!s.guard && /^\w/.test(s.tabTrigger))
                        s.guard = "\\b";
                    s.trigger = lang.escapeRegExp(s.tabTrigger);
                }
                
                if (!s.trigger && !s.guard && !s.endTrigger && !s.endGuard)
                    return;
                
                s.startRe = guardedRegexp(s.trigger, s.guard, true);
                s.triggerRe = new RegExp(s.trigger);

                s.endRe = guardedRegexp(s.endTrigger, s.endGuard, true);
                s.endTriggerRe = new RegExp(s.endTrigger);
            }

            if (snippets && snippets.content)
                addSnippet(snippets);
            else if (Array.isArray(snippets))
                snippets.forEach(addSnippet);
            
            this._signal("registerSnippets", {scope: scope});
        };
        this.unregister = function(snippets, scope) {
            var snippetMap = this.snippetMap;
            var snippetNameMap = this.snippetNameMap;

            function removeSnippet(s) {
                var nameMap = snippetNameMap[s.scope||scope];
                if (nameMap && nameMap[s.name]) {
                    delete nameMap[s.name];
                    var map = snippetMap[s.scope||scope];
                    var i = map && map.indexOf(s);
                    if (i >= 0)
                        map.splice(i, 1);
                }
            }
            if (snippets.content)
                removeSnippet(snippets);
            else if (Array.isArray(snippets))
                snippets.forEach(removeSnippet);
        };
        this.parseSnippetFile = function(str) {
            str = str.replace(/\r/g, "");
            var list = [], snippet = {};
            var re = /^#.*|^({[\s\S]*})\s*$|^(\S+) (.*)$|^((?:\n*\t.*)+)/gm;
            var m;
            while (m = re.exec(str)) {
                if (m[1]) {
                    try {
                        snippet = JSON.parse(m[1]);
                        list.push(snippet);
                    } catch (e) {}
                } if (m[4]) {
                    snippet.content = m[4].replace(/^\t/gm, "");
                    list.push(snippet);
                    snippet = {};
                } else {
                    var key = m[2], val = m[3];
                    if (key == "regex") {
                        var guardRe = /\/((?:[^\/\\]|\\.)*)|$/g;
                        snippet.guard = guardRe.exec(val)[1];
                        snippet.trigger = guardRe.exec(val)[1];
                        snippet.endTrigger = guardRe.exec(val)[1];
                        snippet.endGuard = guardRe.exec(val)[1];
                    } else if (key == "snippet") {
                        snippet.tabTrigger = val.match(/^\S*/)[0];
                        if (!snippet.name)
                            snippet.name = val;
                    } else {
                        snippet[key] = val;
                    }
                }
            }
            return list;
        };
        this.getSnippetByName = function(name, editor) {
            var snippetMap = this.snippetNameMap;
            var snippet;
            this.getActiveScopes(editor).some(function(scope) {
                var snippets = snippetMap[scope];
                if (snippets)
                    snippet = snippets[name];
                return !!snippet;
            }, this);
            return snippet;
        };

    }).call(SnippetManager.prototype);


    var TabstopManager = function(editor) {
        if (editor.tabstopManager)
            return editor.tabstopManager;
        editor.tabstopManager = this;
        this.$onChange = this.onChange.bind(this);
        this.$onChangeSelection = lang.delayedCall(this.onChangeSelection.bind(this)).schedule;
        this.$onChangeSession = this.onChangeSession.bind(this);
        this.$onAfterExec = this.onAfterExec.bind(this);
        this.attach(editor);
    };
    (function() {
        this.attach = function(editor) {
            this.index = 0;
            this.ranges = [];
            this.tabstops = [];
            this.$openTabstops = null;
            this.selectedTabstop = null;

            this.editor = editor;
            this.editor.on("change", this.$onChange);
            this.editor.on("changeSelection", this.$onChangeSelection);
            this.editor.on("changeSession", this.$onChangeSession);
            this.editor.commands.on("afterExec", this.$onAfterExec);
            this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
        };
        this.detach = function() {
            this.tabstops.forEach(this.removeTabstopMarkers, this);
            this.ranges = null;
            this.tabstops = null;
            this.selectedTabstop = null;
            this.editor.removeListener("change", this.$onChange);
            this.editor.removeListener("changeSelection", this.$onChangeSelection);
            this.editor.removeListener("changeSession", this.$onChangeSession);
            this.editor.commands.removeListener("afterExec", this.$onAfterExec);
            this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler);
            this.editor.tabstopManager = null;
            this.editor = null;
        };

        this.onChange = function(delta) {
            var isRemove = delta.action[0] == "r";
            var selectedTabstop = this.selectedTabstop || {};
            var parents = selectedTabstop.parents || {};
            var tabstops = (this.tabstops || []).slice();
            for (var i = 0; i < tabstops.length; i++) {
                var ts = tabstops[i];
                var active = ts == selectedTabstop || parents[ts.index];
                ts.rangeList.$bias = active ? 0 : 1;
                
                if (delta.action == "remove" && ts !== selectedTabstop) {
                    var parentActive = ts.parents && ts.parents[selectedTabstop.index];
                    var startIndex = ts.rangeList.pointIndex(delta.start, parentActive);
                    startIndex = startIndex < 0 ? -startIndex - 1 : startIndex + 1;
                    var endIndex = ts.rangeList.pointIndex(delta.end, parentActive);
                    endIndex = endIndex < 0 ? -endIndex - 1 : endIndex - 1;
                    var toRemove = ts.rangeList.ranges.slice(startIndex, endIndex);
                    for (var j = 0; j < toRemove.length; j++)
                        this.removeRange(toRemove[j]);
                }
                ts.rangeList.$onChange(delta);
            }
            var session = this.editor.session;
            if (!this.$inChange && isRemove && session.getLength() == 1 && !session.getValue())
                this.detach();
        };
        this.updateLinkedFields = function() {
            var ts = this.selectedTabstop;
            if (!ts || !ts.hasLinkedRanges || !ts.firstNonLinked)
                return;
            this.$inChange = true;
            var session = this.editor.session;
            var text = session.getTextRange(ts.firstNonLinked);
            for (var i = 0; i < ts.length; i++) {
                var range = ts[i];
                if (!range.linked)
                    continue;
                var original = range.original;
                var fmt = exports.snippetManager.tmStrFormat(text, original, this.editor);
                session.replace(range, fmt);
            }
            this.$inChange = false;
        };
        this.onAfterExec = function(e) {
            if (e.command && !e.command.readOnly)
                this.updateLinkedFields();
        };
        this.onChangeSelection = function() {
            if (!this.editor)
                return;
            var lead = this.editor.selection.lead;
            var anchor = this.editor.selection.anchor;
            var isEmpty = this.editor.selection.isEmpty();
            for (var i = 0; i < this.ranges.length; i++) {
                if (this.ranges[i].linked)
                    continue;
                var containsLead = this.ranges[i].contains(lead.row, lead.column);
                var containsAnchor = isEmpty || this.ranges[i].contains(anchor.row, anchor.column);
                if (containsLead && containsAnchor)
                    return;
            }
            this.detach();
        };
        this.onChangeSession = function() {
            this.detach();
        };
        this.tabNext = function(dir) {
            var max = this.tabstops.length;
            var index = this.index + (dir || 1);
            index = Math.min(Math.max(index, 1), max);
            if (index == max)
                index = 0;
            this.selectTabstop(index);
            if (index === 0)
                this.detach();
        };
        this.selectTabstop = function(index) {
            this.$openTabstops = null;
            var ts = this.tabstops[this.index];
            if (ts)
                this.addTabstopMarkers(ts);
            this.index = index;
            ts = this.tabstops[this.index];
            if (!ts || !ts.length)
                return;
            
            this.selectedTabstop = ts;
            var range = ts.firstNonLinked || ts;
            if (!this.editor.inVirtualSelectionMode) {
                var sel = this.editor.multiSelect;
                sel.toSingleRange(range.clone());
                for (var i = 0; i < ts.length; i++) {
                    if (ts.hasLinkedRanges && ts[i].linked)
                        continue;
                    sel.addRange(ts[i].clone(), true);
                }
                if (sel.ranges[0])
                    sel.addRange(sel.ranges[0].clone());
            } else {
                this.editor.selection.setRange(range);
            }
            
            this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
            if (this.selectedTabstop && this.selectedTabstop.choices)
                this.editor.execCommand("startAutocomplete", {matches: this.selectedTabstop.choices});
        };
        this.addTabstops = function(tabstops, start, end) {
            var useLink = this.useLink || !this.editor.getOption("enableMultiselect");
            
            if (!this.$openTabstops)
                this.$openTabstops = [];
            if (!tabstops[0]) {
                var p = Range.fromPoints(end, end);
                moveRelative(p.start, start);
                moveRelative(p.end, start);
                tabstops[0] = [p];
                tabstops[0].index = 0;
            }

            var i = this.index;
            var arg = [i + 1, 0];
            var ranges = this.ranges;
            tabstops.forEach(function(ts, index) {
                var dest = this.$openTabstops[index] || ts;
                
                for (var i = 0; i < ts.length; i++) {
                    var p = ts[i];
                    var range = Range.fromPoints(p.start, p.end || p.start);
                    movePoint(range.start, start);
                    movePoint(range.end, start);
                    range.original = p;
                    range.tabstop = dest;
                    ranges.push(range);
                    if (dest != ts)
                        dest.unshift(range);
                    else
                        dest[i] = range;
                    if (p.fmtString || (dest.firstNonLinked && useLink)) {
                        range.linked = true;
                        dest.hasLinkedRanges = true;
                    } else if (!dest.firstNonLinked)
                        dest.firstNonLinked = range;
                }
                if (!dest.firstNonLinked)
                    dest.hasLinkedRanges = false;
                if (dest === ts) {
                    arg.push(dest);
                    this.$openTabstops[index] = dest;
                }
                this.addTabstopMarkers(dest);
                dest.rangeList = dest.rangeList || new RangeList();
                dest.rangeList.$bias = 0;
                dest.rangeList.addList(dest);
            }, this);
            
            if (arg.length > 2) {
                if (this.tabstops.length)
                    arg.push(arg.splice(2, 1)[0]);
                this.tabstops.splice.apply(this.tabstops, arg);
            }
        };

        this.addTabstopMarkers = function(ts) {
            var session = this.editor.session;
            ts.forEach(function(range) {
                if  (!range.markerId)
                    range.markerId = session.addMarker(range, "ace_snippet-marker", "text");
            });
        };
        this.removeTabstopMarkers = function(ts) {
            var session = this.editor.session;
            ts.forEach(function(range) {
                session.removeMarker(range.markerId);
                range.markerId = null;
            });
        };
        this.removeRange = function(range) {
            var i = range.tabstop.indexOf(range);
            if (i != -1) range.tabstop.splice(i, 1);
            i = this.ranges.indexOf(range);
            if (i != -1) this.ranges.splice(i, 1);
            i = range.tabstop.rangeList.ranges.indexOf(range);
            if (i != -1) range.tabstop.splice(i, 1);
            this.editor.session.removeMarker(range.markerId);
            if (!range.tabstop.length) {
                i = this.tabstops.indexOf(range.tabstop);
                if (i != -1)
                    this.tabstops.splice(i, 1);
                if (!this.tabstops.length)
                    this.detach();
            }
        };

        this.keyboardHandler = new HashHandler();
        this.keyboardHandler.bindKeys({
            "Tab": function(editor) {
                if (exports.snippetManager && exports.snippetManager.expandWithTab(editor))
                    return;
                editor.tabstopManager.tabNext(1);
                editor.renderer.scrollCursorIntoView();
            },
            "Shift-Tab": function(editor) {
                editor.tabstopManager.tabNext(-1);
                editor.renderer.scrollCursorIntoView();
            },
            "Esc": function(editor) {
                editor.tabstopManager.detach();
            }
        });
    }).call(TabstopManager.prototype);



    var movePoint = function(point, diff) {
        if (point.row == 0)
            point.column += diff.column;
        point.row += diff.row;
    };

    var moveRelative = function(point, start) {
        if (point.row == start.row)
            point.column -= start.column;
        point.row -= start.row;
    };


    require("./lib/dom").importCssString("\
.ace_snippet-marker {\
    -moz-box-sizing: border-box;\
    box-sizing: border-box;\
    background: rgba(194, 193, 208, 0.09);\
    border: 1px dotted rgba(211, 208, 235, 0.62);\
    position: absolute;\
}");

    exports.snippetManager = new SnippetManager();


    var Editor = require("./editor").Editor;
    (function() {
        this.insertSnippet = function(content, options) {
            return exports.snippetManager.insertSnippet(this, content, options);
        };
        this.expandSnippet = function(options) {
            return exports.snippetManager.expandWithTab(this, options);
        };
    }).call(Editor.prototype);

    });

    ace.define("ace/autocomplete/popup",["require","exports","module","ace/virtual_renderer","ace/editor","ace/range","ace/lib/event","ace/lib/lang","ace/lib/dom"], function(require, exports, module) {

    var Renderer = require("../virtual_renderer").VirtualRenderer;
    var Editor = require("../editor").Editor;
    var Range = require("../range").Range;
    var event = require("../lib/event");
    var lang = require("../lib/lang");
    var dom = require("../lib/dom");

    var $singleLineEditor = function(el) {
        var renderer = new Renderer(el);

        renderer.$maxLines = 4;

        var editor = new Editor(renderer);

        editor.setHighlightActiveLine(false);
        editor.setShowPrintMargin(false);
        editor.renderer.setShowGutter(false);
        editor.renderer.setHighlightGutterLine(false);

        editor.$mouseHandler.$focusTimeout = 0;
        editor.$highlightTagPending = true;

        return editor;
    };

    var AcePopup = function(parentNode) {
        var el = dom.createElement("div");
        var popup = new $singleLineEditor(el);

        if (parentNode)
            parentNode.appendChild(el);
        el.style.display = "none";
        popup.renderer.content.style.cursor = "default";
        popup.renderer.setStyle("ace_autocomplete");

        popup.setOption("displayIndentGuides", false);
        popup.setOption("dragDelay", 150);

        var noop = function(){};

        popup.focus = noop;
        popup.$isFocused = true;

        popup.renderer.$cursorLayer.restartTimer = noop;
        popup.renderer.$cursorLayer.element.style.opacity = 0;

        popup.renderer.$maxLines = 8;
        popup.renderer.$keepTextAreaAtCursor = false;

        popup.setHighlightActiveLine(false);
        popup.session.highlight("");
        popup.session.$searchHighlight.clazz = "ace_highlight-marker";

        popup.on("mousedown", function(e) {
            var pos = e.getDocumentPosition();
            popup.selection.moveToPosition(pos);
            selectionMarker.start.row = selectionMarker.end.row = pos.row;
            e.stop();
        });

        var lastMouseEvent;
        var hoverMarker = new Range(-1,0,-1,Infinity);
        var selectionMarker = new Range(-1,0,-1,Infinity);
        selectionMarker.id = popup.session.addMarker(selectionMarker, "ace_active-line", "fullLine");
        popup.setSelectOnHover = function(val) {
            if (!val) {
                hoverMarker.id = popup.session.addMarker(hoverMarker, "ace_line-hover", "fullLine");
            } else if (hoverMarker.id) {
                popup.session.removeMarker(hoverMarker.id);
                hoverMarker.id = null;
            }
        };
        popup.setSelectOnHover(false);
        popup.on("mousemove", function(e) {
            if (!lastMouseEvent) {
                lastMouseEvent = e;
                return;
            }
            if (lastMouseEvent.x == e.x && lastMouseEvent.y == e.y) {
                return;
            }
            lastMouseEvent = e;
            lastMouseEvent.scrollTop = popup.renderer.scrollTop;
            var row = lastMouseEvent.getDocumentPosition().row;
            if (hoverMarker.start.row != row) {
                if (!hoverMarker.id)
                    popup.setRow(row);
                setHoverMarker(row);
            }
        });
        popup.renderer.on("beforeRender", function() {
            if (lastMouseEvent && hoverMarker.start.row != -1) {
                lastMouseEvent.$pos = null;
                var row = lastMouseEvent.getDocumentPosition().row;
                if (!hoverMarker.id)
                    popup.setRow(row);
                setHoverMarker(row, true);
            }
        });
        popup.renderer.on("afterRender", function() {
            var row = popup.getRow();
            var t = popup.renderer.$textLayer;
            var selected = t.element.childNodes[row - t.config.firstRow];
            if (selected !== t.selectedNode && t.selectedNode)
                dom.removeCssClass(t.selectedNode, "ace_selected");
            t.selectedNode = selected;
            if (selected)
                dom.addCssClass(selected, "ace_selected");
        });
        var hideHoverMarker = function() { setHoverMarker(-1); };
        var setHoverMarker = function(row, suppressRedraw) {
            if (row !== hoverMarker.start.row) {
                hoverMarker.start.row = hoverMarker.end.row = row;
                if (!suppressRedraw)
                    popup.session._emit("changeBackMarker");
                popup._emit("changeHoverMarker");
            }
        };
        popup.getHoveredRow = function() {
            return hoverMarker.start.row;
        };

        event.addListener(popup.container, "mouseout", hideHoverMarker);
        popup.on("hide", hideHoverMarker);
        popup.on("changeSelection", hideHoverMarker);

        popup.session.doc.getLength = function() {
            return popup.data.length;
        };
        popup.session.doc.getLine = function(i) {
            var data = popup.data[i];
            if (typeof data == "string")
                return data;
            return (data && data.value) || "";
        };

        var bgTokenizer = popup.session.bgTokenizer;
        bgTokenizer.$tokenizeRow = function(row) {
            var data = popup.data[row];
            var tokens = [];
            if (!data)
                return tokens;
            if (typeof data == "string")
                data = {value: data};
            var caption = data.caption || data.value || data.name;

            function addToken(value, className) {
                value && tokens.push({
                    type: (data.className || "") + (className || ""), 
                    value: value
                });
            }
            
            var lower = caption.toLowerCase();
            var filterText = (popup.filterText || "").toLowerCase();
            var lastIndex = 0;
            var lastI = 0;
            for (var i = 0; i <= filterText.length; i++) {
                if (i != lastI && (data.matchMask & (1 << i) || i == filterText.length)) {
                    var sub = filterText.slice(lastI, i);
                    lastI = i;
                    var index = lower.indexOf(sub, lastIndex);
                    if (index == -1) continue;
                    addToken(caption.slice(lastIndex, index), "");
                    lastIndex = index + sub.length;
                    addToken(caption.slice(index, lastIndex), "completion-highlight");
                }
            }
            addToken(caption.slice(lastIndex, caption.length), "");
            
            if (data.meta)
                tokens.push({type: "completion-meta", value: data.meta});
            if (data.message)
                tokens.push({type: "completion-message", value: data.message});

            return tokens;
        };
        bgTokenizer.$updateOnChange = noop;
        bgTokenizer.start = noop;

        popup.session.$computeWidth = function() {
            return this.screenWidth = 0;
        };
        popup.isOpen = false;
        popup.isTopdown = false;
        popup.autoSelect = true;
        popup.filterText = "";

        popup.data = [];
        popup.setData = function(list, filterText) {
            popup.filterText = filterText || "";
            popup.setValue(lang.stringRepeat("\n", list.length), -1);
            popup.data = list || [];
            popup.setRow(0);
        };
        popup.getData = function(row) {
            return popup.data[row];
        };

        popup.getRow = function() {
            return selectionMarker.start.row;
        };
        popup.setRow = function(line) {
            line = Math.max(this.autoSelect ? 0 : -1, Math.min(this.data.length, line));
            if (selectionMarker.start.row != line) {
                popup.selection.clearSelection();
                selectionMarker.start.row = selectionMarker.end.row = line || 0;
                popup.session._emit("changeBackMarker");
                popup.moveCursorTo(line || 0, 0);
                if (popup.isOpen)
                    popup._signal("select");
            }
        };

        popup.on("changeSelection", function() {
            if (popup.isOpen)
                popup.setRow(popup.selection.lead.row);
            popup.renderer.scrollCursorIntoView();
        });

        popup.hide = function() {
            this.container.style.display = "none";
            this._signal("hide");
            popup.isOpen = false;
        };
        popup.show = function(pos, lineHeight, topdownOnly) {
            var el = this.container;
            var screenHeight = window.innerHeight;
            var screenWidth = window.innerWidth;
            var renderer = this.renderer;
            var maxH = renderer.$maxLines * lineHeight * 1.4;
            var top = pos.top + this.$borderSize;
            var allowTopdown = top > screenHeight / 2 && !topdownOnly;
            if (allowTopdown && top + lineHeight + maxH > screenHeight) {
                renderer.$maxPixelHeight = top - 2 * this.$borderSize;
                el.style.top = "";
                el.style.bottom = screenHeight - top + "px";
                popup.isTopdown = false;
            } else {
                top += lineHeight;
                renderer.$maxPixelHeight = screenHeight - top - 0.2 * lineHeight;
                el.style.top = top + "px";
                el.style.bottom = "";
                popup.isTopdown = true;
            }

            el.style.display = "";

            var left = pos.left;
            if (left + el.offsetWidth > screenWidth)
                left = screenWidth - el.offsetWidth;

            el.style.left = left + "px";

            this._signal("show");
            lastMouseEvent = null;
            popup.isOpen = true;
        };

        popup.goTo = function(where) {
            var row = this.getRow();
            var max = this.session.getLength() - 1;

            switch(where) {
                case "up": row = row <= 0 ? max : row - 1; break;
                case "down": row = row >= max ? -1 : row + 1; break;
                case "start": row = 0; break;
                case "end": row = max; break;
            }

            this.setRow(row);
        };


        popup.getTextLeftOffset = function() {
            return this.$borderSize + this.renderer.$padding + this.$imageSize;
        };

        popup.$imageSize = 0;
        popup.$borderSize = 1;

        return popup;
    };

    dom.importCssString("\
.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {\
    background-color: #CAD6FA;\
    z-index: 1;\
}\
.ace_dark.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {\
    background-color: #3a674e;\
}\
.ace_editor.ace_autocomplete .ace_line-hover {\
    border: 1px solid #abbffe;\
    margin-top: -1px;\
    background: rgba(233,233,253,0.4);\
    position: absolute;\
    z-index: 2;\
}\
.ace_dark.ace_editor.ace_autocomplete .ace_line-hover {\
    border: 1px solid rgba(109, 150, 13, 0.8);\
    background: rgba(58, 103, 78, 0.62);\
}\
.ace_completion-meta {\
    opacity: 0.5;\
    margin: 0.9em;\
}\
.ace_completion-message {\
    color: blue;\
}\
.ace_editor.ace_autocomplete .ace_completion-highlight{\
    color: #2d69c7;\
}\
.ace_dark.ace_editor.ace_autocomplete .ace_completion-highlight{\
    color: #93ca12;\
}\
.ace_editor.ace_autocomplete {\
    width: 300px;\
    z-index: 200000;\
    border: 1px lightgray solid;\
    position: fixed;\
    box-shadow: 2px 3px 5px rgba(0,0,0,.2);\
    line-height: 1.4;\
    background: #fefefe;\
    color: #111;\
}\
.ace_dark.ace_editor.ace_autocomplete {\
    border: 1px #484747 solid;\
    box-shadow: 2px 3px 5px rgba(0, 0, 0, 0.51);\
    line-height: 1.4;\
    background: #25282c;\
    color: #c1c1c1;\
}", "autocompletion.css");

    exports.AcePopup = AcePopup;
    exports.$singleLineEditor = $singleLineEditor;
    });

    ace.define("ace/autocomplete/util",["require","exports","module"], function(require, exports, module) {

    exports.parForEach = function(array, fn, callback) {
        var completed = 0;
        var arLength = array.length;
        if (arLength === 0)
            callback();
        for (var i = 0; i < arLength; i++) {
            fn(array[i], function(result, err) {
                completed++;
                if (completed === arLength)
                    callback(result, err);
            });
        }
    };

    var ID_REGEX = /[a-zA-Z_0-9\$\-\u00A2-\u2000\u2070-\uFFFF]/;

    exports.retrievePrecedingIdentifier = function(text, pos, regex) {
        regex = regex || ID_REGEX;
        var buf = [];
        for (var i = pos-1; i >= 0; i--) {
            if (regex.test(text[i]))
                buf.push(text[i]);
            else
                break;
        }
        return buf.reverse().join("");
    };

    exports.retrieveFollowingIdentifier = function(text, pos, regex) {
        regex = regex || ID_REGEX;
        var buf = [];
        for (var i = pos; i < text.length; i++) {
            if (regex.test(text[i]))
                buf.push(text[i]);
            else
                break;
        }
        return buf;
    };

    exports.getCompletionPrefix = function (editor) {
        var pos = editor.getCursorPosition();
        var line = editor.session.getLine(pos.row);
        var prefix;
        editor.completers.forEach(function(completer) {
            if (completer.identifierRegexps) {
                completer.identifierRegexps.forEach(function(identifierRegex) {
                    if (!prefix && identifierRegex)
                        prefix = this.retrievePrecedingIdentifier(line, pos.column, identifierRegex);
                }.bind(this));
            }
        }.bind(this));
        return prefix || this.retrievePrecedingIdentifier(line, pos.column);
    };

    });

    ace.define("ace/autocomplete",["require","exports","module","ace/keyboard/hash_handler","ace/autocomplete/popup","ace/autocomplete/util","ace/lib/lang","ace/lib/dom","ace/snippets","ace/config"], function(require, exports, module) {

    var HashHandler = require("./keyboard/hash_handler").HashHandler;
    var AcePopup = require("./autocomplete/popup").AcePopup;
    var util = require("./autocomplete/util");
    var lang = require("./lib/lang");
    var dom = require("./lib/dom");
    var snippetManager = require("./snippets").snippetManager;
    var config = require("./config");

    var Autocomplete = function() {
        this.autoInsert = false;
        this.autoSelect = true;
        this.exactMatch = false;
        this.gatherCompletionsId = 0;
        this.keyboardHandler = new HashHandler();
        this.keyboardHandler.bindKeys(this.commands);

        this.blurListener = this.blurListener.bind(this);
        this.changeListener = this.changeListener.bind(this);
        this.mousedownListener = this.mousedownListener.bind(this);
        this.mousewheelListener = this.mousewheelListener.bind(this);

        this.changeTimer = lang.delayedCall(function() {
            this.updateCompletions(true);
        }.bind(this));

        this.tooltipTimer = lang.delayedCall(this.updateDocTooltip.bind(this), 50);
    };

    (function() {

        this.$init = function() {
            this.popup = new AcePopup(document.body || document.documentElement);
            this.popup.on("click", function(e) {
                this.insertMatch();
                e.stop();
            }.bind(this));
            this.popup.focus = this.editor.focus.bind(this.editor);
            this.popup.on("show", this.tooltipTimer.bind(null, null));
            this.popup.on("select", this.tooltipTimer.bind(null, null));
            this.popup.on("changeHoverMarker", this.tooltipTimer.bind(null, null));
            return this.popup;
        };

        this.getPopup = function() {
            return this.popup || this.$init();
        };

        this.openPopup = function(editor, prefix, keepPopupPosition) {
            if (!this.popup)
                this.$init();

            this.popup.autoSelect = this.autoSelect;

            this.popup.setData(this.completions.filtered, this.completions.filterText);

            editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
            
            var renderer = editor.renderer;
            this.popup.setRow(this.autoSelect ? 0 : -1);
            if (!keepPopupPosition) {
                this.popup.setTheme(editor.getTheme());
                this.popup.setFontSize(editor.getFontSize());

                var lineHeight = renderer.layerConfig.lineHeight;

                var pos = renderer.$cursorLayer.getPixelPosition(this.base, true);
                pos.left -= this.popup.getTextLeftOffset();

                var rect = editor.container.getBoundingClientRect();
                pos.top += rect.top - renderer.layerConfig.offset;
                pos.left += rect.left - editor.renderer.scrollLeft;
                pos.left += renderer.gutterWidth;

                this.popup.show(pos, lineHeight);
            } else if (keepPopupPosition && !prefix) {
                this.detach();
            }
        };

        this.detach = function() {
            this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler);
            this.editor.off("changeSelection", this.changeListener);
            this.editor.off("blur", this.blurListener);
            this.editor.off("mousedown", this.mousedownListener);
            this.editor.off("mousewheel", this.mousewheelListener);
            this.changeTimer.cancel();
            this.hideDocTooltip();

            this.gatherCompletionsId += 1;
            if (this.popup && this.popup.isOpen)
                this.popup.hide();

            if (this.base)
                this.base.detach();
            this.activated = false;
            this.completions = this.base = null;
        };

        this.changeListener = function(e) {
            var cursor = this.editor.selection.lead;
            if (cursor.row != this.base.row || cursor.column < this.base.column) {
                this.detach();
            }
            if (this.activated)
                this.changeTimer.schedule();
            else
                this.detach();
        };

        this.blurListener = function(e) {
            var el = document.activeElement;
            var text = this.editor.textInput.getElement();
            var fromTooltip = e.relatedTarget && this.tooltipNode && this.tooltipNode.contains(e.relatedTarget);
            var container = this.popup && this.popup.container;
            if (el != text && el.parentNode != container && !fromTooltip
                && el != this.tooltipNode && e.relatedTarget != text
            ) {
                this.detach();
            }
        };

        this.mousedownListener = function(e) {
            this.detach();
        };

        this.mousewheelListener = function(e) {
            this.detach();
        };

        this.goTo = function(where) {
            this.popup.goTo(where);
        };

        this.insertMatch = function(data, options) {
            if (!data)
                data = this.popup.getData(this.popup.getRow());
            if (!data)
                return false;

            if (data.completer && data.completer.insertMatch) {
                data.completer.insertMatch(this.editor, data);
            } else {
                if (this.completions.filterText) {
                    var ranges = this.editor.selection.getAllRanges();
                    for (var i = 0, range; range = ranges[i]; i++) {
                        range.start.column -= this.completions.filterText.length;
                        this.editor.session.remove(range);
                    }
                }
                if (data.snippet)
                    snippetManager.insertSnippet(this.editor, data.snippet);
                else
                    this.editor.execCommand("insertstring", data.value || data);
            }
            this.detach();
        };


        this.commands = {
            "Up": function(editor) { editor.completer.goTo("up"); },
            "Down": function(editor) { editor.completer.goTo("down"); },
            "Ctrl-Up|Ctrl-Home": function(editor) { editor.completer.goTo("start"); },
            "Ctrl-Down|Ctrl-End": function(editor) { editor.completer.goTo("end"); },

            "Esc": function(editor) { editor.completer.detach(); },
            "Return": function(editor) { return editor.completer.insertMatch(); },
            "Shift-Return": function(editor) { editor.completer.insertMatch(null, {deleteSuffix: true}); },
            "Tab": function(editor) {
                var result = editor.completer.insertMatch();
                if (!result && !editor.tabstopManager)
                    editor.completer.goTo("down");
                else
                    return result;
            },

            "PageUp": function(editor) { editor.completer.popup.gotoPageUp(); },
            "PageDown": function(editor) { editor.completer.popup.gotoPageDown(); }
        };

        this.gatherCompletions = function(editor, callback) {
            var session = editor.getSession();
            var pos = editor.getCursorPosition();

            var prefix = util.getCompletionPrefix(editor);

            this.base = session.doc.createAnchor(pos.row, pos.column - prefix.length);
            this.base.$insertRight = true;

            var matches = [];
            var total = editor.completers.length;
            editor.completers.forEach(function(completer, i) {
                completer.getCompletions(editor, session, pos, prefix, function(err, results) {
                    if (!err && results)
                        matches = matches.concat(results);
                    callback(null, {
                        prefix: util.getCompletionPrefix(editor),
                        matches: matches,
                        finished: (--total === 0)
                    });
                });
            });
            return true;
        };

        this.showPopup = function(editor, options) {
            if (this.editor)
                this.detach();

            this.activated = true;

            this.editor = editor;
            if (editor.completer != this) {
                if (editor.completer)
                    editor.completer.detach();
                editor.completer = this;
            }

            editor.on("changeSelection", this.changeListener);
            editor.on("blur", this.blurListener);
            editor.on("mousedown", this.mousedownListener);
            editor.on("mousewheel", this.mousewheelListener);

            this.updateCompletions(false, options);
        };

        this.updateCompletions = function(keepPopupPosition, options) {
            if (keepPopupPosition && this.base && this.completions) {
                var pos = this.editor.getCursorPosition();
                var prefix = this.editor.session.getTextRange({start: this.base, end: pos});
                if (prefix == this.completions.filterText)
                    return;
                this.completions.setFilter(prefix);
                if (!this.completions.filtered.length)
                    return this.detach();
                if (this.completions.filtered.length == 1
                && this.completions.filtered[0].value == prefix
                && !this.completions.filtered[0].snippet)
                    return this.detach();
                this.openPopup(this.editor, prefix, keepPopupPosition);
                return;
            }
            
            if (options && options.matches) {
                var pos = this.editor.getSelectionRange().start;
                this.base = this.editor.session.doc.createAnchor(pos.row, pos.column);
                this.base.$insertRight = true;
                this.completions = new FilteredList(options.matches);
                return this.openPopup(this.editor, "", keepPopupPosition);
            }
            var _id = this.gatherCompletionsId;
            this.gatherCompletions(this.editor, function(err, results) {
                var detachIfFinished = function() {
                    if (!results.finished) return;
                    return this.detach();
                }.bind(this);

                var prefix = results.prefix;
                var matches = results && results.matches;

                if (!matches || !matches.length)
                    return detachIfFinished();
                if (prefix.indexOf(results.prefix) !== 0 || _id != this.gatherCompletionsId)
                    return;

                this.completions = new FilteredList(matches);

                if (this.exactMatch)
                    this.completions.exactMatch = true;

                this.completions.setFilter(prefix);
                var filtered = this.completions.filtered;
                if (!filtered.length)
                    return detachIfFinished();
                if (filtered.length == 1 && filtered[0].value == prefix && !filtered[0].snippet)
                    return detachIfFinished();
                if (this.autoInsert && filtered.length == 1 && results.finished)
                    return this.insertMatch(filtered[0]);

                this.openPopup(this.editor, prefix, keepPopupPosition);
            }.bind(this));
        };

        this.cancelContextMenu = function() {
            this.editor.$mouseHandler.cancelContextMenu();
        };

        this.updateDocTooltip = function() {
            var popup = this.popup;
            var all = popup.data;
            var selected = all && (all[popup.getHoveredRow()] || all[popup.getRow()]);
            var doc = null;
            if (!selected || !this.editor || !this.popup.isOpen)
                return this.hideDocTooltip();
            this.editor.completers.some(function(completer) {
                if (completer.getDocTooltip)
                    doc = completer.getDocTooltip(selected);
                return doc;
            });
            if (!doc && typeof selected != "string")
                doc = selected;

            if (typeof doc == "string")
                doc = {docText: doc};
            if (!doc || !(doc.docHTML || doc.docText))
                return this.hideDocTooltip();
            this.showDocTooltip(doc);
        };

        this.showDocTooltip = function(item) {
            if (!this.tooltipNode) {
                this.tooltipNode = dom.createElement("div");
                this.tooltipNode.className = "ace_tooltip ace_doc-tooltip";
                this.tooltipNode.style.margin = 0;
                this.tooltipNode.style.pointerEvents = "auto";
                this.tooltipNode.tabIndex = -1;
                this.tooltipNode.onblur = this.blurListener.bind(this);
                this.tooltipNode.onclick = this.onTooltipClick.bind(this);
            }

            var tooltipNode = this.tooltipNode;
            if (item.docHTML) {
                tooltipNode.innerHTML = item.docHTML;
            } else if (item.docText) {
                tooltipNode.textContent = item.docText;
            }

            if (!tooltipNode.parentNode)
                document.body.appendChild(tooltipNode);
            var popup = this.popup;
            var rect = popup.container.getBoundingClientRect();
            tooltipNode.style.top = popup.container.style.top;
            tooltipNode.style.bottom = popup.container.style.bottom;

            tooltipNode.style.display = "block";
            if (window.innerWidth - rect.right < 320) {
                if (rect.left < 320) {
                    if(popup.isTopdown) {
                        tooltipNode.style.top = rect.bottom + "px";
                        tooltipNode.style.left = rect.left + "px";
                        tooltipNode.style.right = "";
                        tooltipNode.style.bottom = "";
                    } else {
                        tooltipNode.style.top = popup.container.offsetTop - tooltipNode.offsetHeight + "px";
                        tooltipNode.style.left = rect.left + "px";
                        tooltipNode.style.right = "";
                        tooltipNode.style.bottom = "";
                    }
                } else {
                    tooltipNode.style.right = window.innerWidth - rect.left + "px";
                    tooltipNode.style.left = "";
                }
            } else {
                tooltipNode.style.left = (rect.right + 1) + "px";
                tooltipNode.style.right = "";
            }
        };

        this.hideDocTooltip = function() {
            this.tooltipTimer.cancel();
            if (!this.tooltipNode) return;
            var el = this.tooltipNode;
            if (!this.editor.isFocused() && document.activeElement == el)
                this.editor.focus();
            this.tooltipNode = null;
            if (el.parentNode)
                el.parentNode.removeChild(el);
        };
        
        this.onTooltipClick = function(e) {
            var a = e.target;
            while (a && a != this.tooltipNode) {
                if (a.nodeName == "A" && a.href) {
                    a.rel = "noreferrer";
                    a.target = "_blank";
                    break;
                }
                a = a.parentNode;
            }
        };

        this.destroy = function() {
            this.detach();
            if (this.popup) {
                this.popup.destroy();
                var el = this.popup.container;
                if (el && el.parentNode)
                    el.parentNode.removeChild(el);
            }
            if (this.editor && this.editor.completer == this)
                this.editor.completer == null;
            this.popup = null;
        };

    }).call(Autocomplete.prototype);


    Autocomplete.for = function(editor) {
        if (editor.completer) {
            return editor.completer;
        }
        if (config.get("sharedPopups")) {
            if (!Autocomplete.$shared)
                Autocomplete.$sharedInstance = new Autocomplete();
            editor.completer = Autocomplete.$sharedInstance;
        } else {
            editor.completer = new Autocomplete();
            editor.once("destroy", function(e, editor) {
                editor.completer.destroy();
            });
        }
        return editor.completer;
    };

    Autocomplete.startCommand = {
        name: "startAutocomplete",
        exec: function(editor, options) {
            var completer = Autocomplete.for(editor);
            completer.autoInsert = false;
            completer.autoSelect = true;
            completer.showPopup(editor, options);
            completer.cancelContextMenu();
        },
        bindKey: "Ctrl-Space|Ctrl-Shift-Space|Alt-Space"
    };

    var FilteredList = function(array, filterText) {
        this.all = array;
        this.filtered = array;
        this.filterText = filterText || "";
        this.exactMatch = false;
    };
    (function(){
        this.setFilter = function(str) {
            if (str.length > this.filterText && str.lastIndexOf(this.filterText, 0) === 0)
                var matches = this.filtered;
            else
                var matches = this.all;

            this.filterText = str;
            matches = this.filterCompletions(matches, this.filterText);
            matches = matches.sort(function(a, b) {
                return b.exactMatch - a.exactMatch || b.$score - a.$score 
                    || (a.caption || a.value).localeCompare(b.caption || b.value);
            });
            var prev = null;
            matches = matches.filter(function(item){
                var caption = item.snippet || item.caption || item.value;
                if (caption === prev) return false;
                prev = caption;
                return true;
            });

            this.filtered = matches;
        };
        this.filterCompletions = function(items, needle) {
            var results = [];
            var upper = needle.toUpperCase();
            var lower = needle.toLowerCase();
            loop: for (var i = 0, item; item = items[i]; i++) {
                var caption = item.caption || item.value || item.snippet;
                if (!caption) continue;
                var lastIndex = -1;
                var matchMask = 0;
                var penalty = 0;
                var index, distance;

                if (this.exactMatch) {
                    if (needle !== caption.substr(0, needle.length))
                        continue loop;
                } else {
                    var fullMatchIndex = caption.toLowerCase().indexOf(lower);
                    if (fullMatchIndex > -1) {
                        penalty = fullMatchIndex;
                    } else {
                        for (var j = 0; j < needle.length; j++) {
                            var i1 = caption.indexOf(lower[j], lastIndex + 1);
                            var i2 = caption.indexOf(upper[j], lastIndex + 1);
                            index = (i1 >= 0) ? ((i2 < 0 || i1 < i2) ? i1 : i2) : i2;
                            if (index < 0)
                                continue loop;
                            distance = index - lastIndex - 1;
                            if (distance > 0) {
                                if (lastIndex === -1)
                                    penalty += 10;
                                penalty += distance;
                                matchMask = matchMask | (1 << j);
                            }
                            lastIndex = index;
                        }
                    }
                }
                item.matchMask = matchMask;
                item.exactMatch = penalty ? 0 : 1;
                item.$score = (item.score || 0) - penalty;
                results.push(item);
            }
            return results;
        };
    }).call(FilteredList.prototype);

    exports.Autocomplete = Autocomplete;
    exports.FilteredList = FilteredList;

    });

    ace.define("ace/autocomplete/text_completer",["require","exports","module","ace/range"], function(require, exports, module) {
        var Range = require("../range").Range;
        
        var splitRegex = /[^a-zA-Z_0-9\$\-\u00C0-\u1FFF\u2C00-\uD7FF\w]+/;

        function getWordIndex(doc, pos) {
            var textBefore = doc.getTextRange(Range.fromPoints({row: 0, column:0}, pos));
            return textBefore.split(splitRegex).length - 1;
        }
        function wordDistance(doc, pos) {
            var prefixPos = getWordIndex(doc, pos);
            var words = doc.getValue().split(splitRegex);
            var wordScores = Object.create(null);
            
            var currentWord = words[prefixPos];

            words.forEach(function(word, idx) {
                if (!word || word === currentWord) return;

                var distance = Math.abs(prefixPos - idx);
                var score = words.length - distance;
                if (wordScores[word]) {
                    wordScores[word] = Math.max(score, wordScores[word]);
                } else {
                    wordScores[word] = score;
                }
            });
            return wordScores;
        }

        exports.getCompletions = function(editor, session, pos, prefix, callback) {
            var wordScore = wordDistance(session, pos);
            var wordList = Object.keys(wordScore);
            callback(null, wordList.map(function(word) {
                return {
                    caption: word,
                    value: word,
                    score: wordScore[word],
                    meta: "local"
                };
            }));
        };
    });

    ace.define("ace/ext/language_tools",["require","exports","module","ace/snippets","ace/autocomplete","ace/config","ace/lib/lang","ace/autocomplete/util","ace/autocomplete/text_completer","ace/editor","ace/config"], function(require, exports, module) {

    var snippetManager = require("../snippets").snippetManager;
    var Autocomplete = require("../autocomplete").Autocomplete;
    var config = require("../config");
    var lang = require("../lib/lang");
    var util = require("../autocomplete/util");

    var textCompleter = require("../autocomplete/text_completer");
    var keyWordCompleter = {
        getCompletions: function(editor, session, pos, prefix, callback) {
            if (session.$mode.completer) {
                return session.$mode.completer.getCompletions(editor, session, pos, prefix, callback);
            }
            var state = editor.session.getState(pos.row);
            var completions = session.$mode.getCompletions(state, session, pos, prefix);
            callback(null, completions);
        }
    };

    var snippetCompleter = {
        getCompletions: function(editor, session, pos, prefix, callback) {
            var scopes = [];
            var token = session.getTokenAt(pos.row, pos.column);
            if (token && token.type.match(/(tag-name|tag-open|tag-whitespace|attribute-name|attribute-value)\.xml$/))
                scopes.push('html-tag');
            else
                scopes = snippetManager.getActiveScopes(editor);

            var snippetMap = snippetManager.snippetMap;
            var completions = [];
            scopes.forEach(function(scope) {
                var snippets = snippetMap[scope] || [];
                for (var i = snippets.length; i--;) {
                    var s = snippets[i];
                    var caption = s.name || s.tabTrigger;
                    if (!caption)
                        continue;
                    completions.push({
                        caption: caption,
                        snippet: s.content,
                        meta: s.tabTrigger && !s.name ? s.tabTrigger + "\u21E5 " : "snippet",
                        type: "snippet"
                    });
                }
            }, this);
            callback(null, completions);
        },
        getDocTooltip: function(item) {
            if (item.type == "snippet" && !item.docHTML) {
                item.docHTML = [
                    "<b>", lang.escapeHTML(item.caption), "</b>", "<hr></hr>",
                    lang.escapeHTML(item.snippet)
                ].join("");
            }
        }
    };

    var completers = [snippetCompleter, textCompleter, keyWordCompleter];
    exports.setCompleters = function(val) {
        completers.length = 0;
        if (val) completers.push.apply(completers, val);
    };
    exports.addCompleter = function(completer) {
        completers.push(completer);
    };
    exports.textCompleter = textCompleter;
    exports.keyWordCompleter = keyWordCompleter;
    exports.snippetCompleter = snippetCompleter;

    var expandSnippet = {
        name: "expandSnippet",
        exec: function(editor) {
            return snippetManager.expandWithTab(editor);
        },
        bindKey: "Tab"
    };

    var onChangeMode = function(e, editor) {
        loadSnippetsForMode(editor.session.$mode);
    };

    var loadSnippetsForMode = function(mode) {
        var id = mode.$id;
        if (!snippetManager.files)
            snippetManager.files = {};
        loadSnippetFile(id);
        if (mode.modes)
            mode.modes.forEach(loadSnippetsForMode);
    };

    var loadSnippetFile = function(id) {
        if (!id || snippetManager.files[id])
            return;
        var snippetFilePath = id.replace("mode", "snippets");
        snippetManager.files[id] = {};
        config.loadModule(snippetFilePath, function(m) {
            if (m) {
                snippetManager.files[id] = m;
                if (!m.snippets && m.snippetText)
                    m.snippets = snippetManager.parseSnippetFile(m.snippetText);
                snippetManager.register(m.snippets || [], m.scope);
                if (m.includeScopes) {
                    snippetManager.snippetMap[m.scope].includeScopes = m.includeScopes;
                    m.includeScopes.forEach(function(x) {
                        loadSnippetFile("ace/mode/" + x);
                    });
                }
            }
        });
    };

    var doLiveAutocomplete = function(e) {
        var editor = e.editor;
        var hasCompleter = editor.completer && editor.completer.activated;
        if (e.command.name === "backspace") {
            if (hasCompleter && !util.getCompletionPrefix(editor))
                editor.completer.detach();
        }
        else if (e.command.name === "insertstring") {
            var prefix = util.getCompletionPrefix(editor);
            if (prefix && !hasCompleter) {
                var completer = Autocomplete.for(editor);
                completer.autoInsert = false;
                completer.showPopup(editor);
            }
        }
    };

    var Editor = require("../editor").Editor;
    require("../config").defineOptions(Editor.prototype, "editor", {
        enableBasicAutocompletion: {
            set: function(val) {
                if (val) {
                    if (!this.completers)
                        this.completers = Array.isArray(val)? val: completers;
                    this.commands.addCommand(Autocomplete.startCommand);
                } else {
                    this.commands.removeCommand(Autocomplete.startCommand);
                }
            },
            value: false
        },
        enableLiveAutocompletion: {
            set: function(val) {
                if (val) {
                    if (!this.completers)
                        this.completers = Array.isArray(val)? val: completers;
                    this.commands.on('afterExec', doLiveAutocomplete);
                } else {
                    this.commands.removeListener('afterExec', doLiveAutocomplete);
                }
            },
            value: false
        },
        enableSnippets: {
            set: function(val) {
                if (val) {
                    this.commands.addCommand(expandSnippet);
                    this.on("changeMode", onChangeMode);
                    onChangeMode(null, this);
                } else {
                    this.commands.removeCommand(expandSnippet);
                    this.off("changeMode", onChangeMode);
                }
            },
            value: false
        }
    });
    });                (function() {
                        ace.require(["ace/ext/language_tools"], function(m) {
                            if ( module) {
                                module.exports = m;
                            }
                        });
                    })();
    });

    var text$1 = createCommonjsModule(function (module, exports) {
    ace.define("ace/snippets/text",["require","exports","module"], function(require, exports, module) {

    exports.snippetText =undefined;
    exports.scope = "text";

    });                (function() {
                        ace.require(["ace/snippets/text"], function(m) {
                            if ( module) {
                                module.exports = m;
                            }
                        });
                    })();
    });

    var javascript = createCommonjsModule(function (module, exports) {
    ace.define("ace/snippets/javascript",["require","exports","module"], function(require, exports, module) {

    exports.snippetText = "# Prototype\n\
snippet proto\n\
	${1:class_name}.prototype.${2:method_name} = function(${3:first_argument}) {\n\
		${4:// body...}\n\
	};\n\
# Function\n\
snippet fun\n\
	function ${1?:function_name}(${2:argument}) {\n\
		${3:// body...}\n\
	}\n\
# Anonymous Function\n\
regex /((=)\\s*|(:)\\s*|(\\()|\\b)/f/(\\))?/\n\
snippet f\n\
	function${M1?: ${1:functionName}}($2) {\n\
		${0:$TM_SELECTED_TEXT}\n\
	}${M2?;}${M3?,}${M4?)}\n\
# Immediate function\n\
trigger \\(?f\\(\n\
endTrigger \\)?\n\
snippet f(\n\
	(function(${1}) {\n\
		${0:${TM_SELECTED_TEXT:/* code */}}\n\
	}(${1}));\n\
# if\n\
snippet if\n\
	if (${1:true}) {\n\
		${0}\n\
	}\n\
# if ... else\n\
snippet ife\n\
	if (${1:true}) {\n\
		${2}\n\
	} else {\n\
		${0}\n\
	}\n\
# tertiary conditional\n\
snippet ter\n\
	${1:/* condition */} ? ${2:a} : ${3:b}\n\
# switch\n\
snippet switch\n\
	switch (${1:expression}) {\n\
		case '${3:case}':\n\
			${4:// code}\n\
			break;\n\
		${5}\n\
		default:\n\
			${2:// code}\n\
	}\n\
# case\n\
snippet case\n\
	case '${1:case}':\n\
		${2:// code}\n\
		break;\n\
	${3}\n\
\n\
# while (...) {...}\n\
snippet wh\n\
	while (${1:/* condition */}) {\n\
		${0:/* code */}\n\
	}\n\
# try\n\
snippet try\n\
	try {\n\
		${0:/* code */}\n\
	} catch (e) {}\n\
# do...while\n\
snippet do\n\
	do {\n\
		${2:/* code */}\n\
	} while (${1:/* condition */});\n\
# Object Method\n\
snippet :f\n\
regex /([,{[])|^\\s*/:f/\n\
	${1:method_name}: function(${2:attribute}) {\n\
		${0}\n\
	}${3:,}\n\
# setTimeout function\n\
snippet setTimeout\n\
regex /\\b/st|timeout|setTimeo?u?t?/\n\
	setTimeout(function() {${3:$TM_SELECTED_TEXT}}, ${1:10});\n\
# Get Elements\n\
snippet gett\n\
	getElementsBy${1:TagName}('${2}')${3}\n\
# Get Element\n\
snippet get\n\
	getElementBy${1:Id}('${2}')${3}\n\
# console.log (Firebug)\n\
snippet cl\n\
	console.log(${1});\n\
# return\n\
snippet ret\n\
	return ${1:result}\n\
# for (property in object ) { ... }\n\
snippet fori\n\
	for (var ${1:prop} in ${2:Things}) {\n\
		${0:$2[$1]}\n\
	}\n\
# hasOwnProperty\n\
snippet has\n\
	hasOwnProperty(${1})\n\
# docstring\n\
snippet /**\n\
	/**\n\
	 * ${1:description}\n\
	 *\n\
	 */\n\
snippet @par\n\
regex /^\\s*\\*\\s*/@(para?m?)?/\n\
	@param {${1:type}} ${2:name} ${3:description}\n\
snippet @ret\n\
	@return {${1:type}} ${2:description}\n\
# JSON.parse\n\
snippet jsonp\n\
	JSON.parse(${1:jstr});\n\
# JSON.stringify\n\
snippet jsons\n\
	JSON.stringify(${1:object});\n\
# self-defining function\n\
snippet sdf\n\
	var ${1:function_name} = function(${2:argument}) {\n\
		${3:// initial code ...}\n\
\n\
		$1 = function($2) {\n\
			${4:// main code}\n\
		};\n\
	}\n\
# singleton\n\
snippet sing\n\
	function ${1:Singleton} (${2:argument}) {\n\
		// the cached instance\n\
		var instance;\n\
\n\
		// rewrite the constructor\n\
		$1 = function $1($2) {\n\
			return instance;\n\
		};\n\
		\n\
		// carry over the prototype properties\n\
		$1.prototype = this;\n\
\n\
		// the instance\n\
		instance = new $1();\n\
\n\
		// reset the constructor pointer\n\
		instance.constructor = $1;\n\
\n\
		${3:// code ...}\n\
\n\
		return instance;\n\
	}\n\
# class\n\
snippet class\n\
regex /^\\s*/clas{0,2}/\n\
	var ${1:class} = function(${20}) {\n\
		$40$0\n\
	};\n\
	\n\
	(function() {\n\
		${60:this.prop = \"\"}\n\
	}).call(${1:class}.prototype);\n\
	\n\
	exports.${1:class} = ${1:class};\n\
# \n\
snippet for-\n\
	for (var ${1:i} = ${2:Things}.length; ${1:i}--; ) {\n\
		${0:${2:Things}[${1:i}];}\n\
	}\n\
# for (...) {...}\n\
snippet for\n\
	for (var ${1:i} = 0; $1 < ${2:Things}.length; $1++) {\n\
		${3:$2[$1]}$0\n\
	}\n\
# for (...) {...} (Improved Native For-Loop)\n\
snippet forr\n\
	for (var ${1:i} = ${2:Things}.length - 1; $1 >= 0; $1--) {\n\
		${3:$2[$1]}$0\n\
	}\n\
\n\
\n\
#modules\n\
snippet def\n\
	define(function(require, exports, module) {\n\
	\"use strict\";\n\
	var ${1/.*\\///} = require(\"${1}\");\n\
	\n\
	$TM_SELECTED_TEXT\n\
	});\n\
snippet req\n\
guard ^\\s*\n\
	var ${1/.*\\///} = require(\"${1}\");\n\
	$0\n\
snippet requ\n\
guard ^\\s*\n\
	var ${1/.*\\/(.)/\\u$1/} = require(\"${1}\").${1/.*\\/(.)/\\u$1/};\n\
	$0\n\
";
    exports.scope = "javascript";

    });                (function() {
                        ace.require(["ace/snippets/javascript"], function(m) {
                            if ( module) {
                                module.exports = m;
                            }
                        });
                    })();
    });

    var modeJavascript = createCommonjsModule(function (module, exports) {
    ace.define("ace/mode/doc_comment_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/text_highlight_rules"], function(require, exports, module) {

    var oop = require("../lib/oop");
    var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

    var DocCommentHighlightRules = function() {
        this.$rules = {
            "start" : [ {
                token : "comment.doc.tag",
                regex : "@[\\w\\d_]+" // TODO: fix email addresses
            }, 
            DocCommentHighlightRules.getTagRule(),
            {
                defaultToken : "comment.doc",
                caseInsensitive: true
            }]
        };
    };

    oop.inherits(DocCommentHighlightRules, TextHighlightRules);

    DocCommentHighlightRules.getTagRule = function(start) {
        return {
            token : "comment.doc.tag.storage.type",
            regex : "\\b(?:TODO|FIXME|XXX|HACK)\\b"
        };
    };

    DocCommentHighlightRules.getStartRule = function(start) {
        return {
            token : "comment.doc", // doc comment
            regex : "\\/\\*(?=\\*)",
            next  : start
        };
    };

    DocCommentHighlightRules.getEndRule = function (start) {
        return {
            token : "comment.doc", // closing comment
            regex : "\\*\\/",
            next  : start
        };
    };


    exports.DocCommentHighlightRules = DocCommentHighlightRules;

    });

    ace.define("ace/mode/javascript_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/doc_comment_highlight_rules","ace/mode/text_highlight_rules"], function(require, exports, module) {

    var oop = require("../lib/oop");
    var DocCommentHighlightRules = require("./doc_comment_highlight_rules").DocCommentHighlightRules;
    var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
    var identifierRe = "[a-zA-Z\\$_\u00a1-\uffff][a-zA-Z\\d\\$_\u00a1-\uffff]*";

    var JavaScriptHighlightRules = function(options) {
        var keywordMapper = this.createKeywordMapper({
            "variable.language":
                "Array|Boolean|Date|Function|Iterator|Number|Object|RegExp|String|Proxy|"  + // Constructors
                "Namespace|QName|XML|XMLList|"                                             + // E4X
                "ArrayBuffer|Float32Array|Float64Array|Int16Array|Int32Array|Int8Array|"   +
                "Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray|"                    +
                "Error|EvalError|InternalError|RangeError|ReferenceError|StopIteration|"   + // Errors
                "SyntaxError|TypeError|URIError|"                                          +
                "decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|eval|isFinite|" + // Non-constructor functions
                "isNaN|parseFloat|parseInt|"                                               +
                "JSON|Math|"                                                               + // Other
                "this|arguments|prototype|window|document"                                 , // Pseudo
            "keyword":
                "const|yield|import|get|set|async|await|" +
                "break|case|catch|continue|default|delete|do|else|finally|for|function|" +
                "if|in|of|instanceof|new|return|switch|throw|try|typeof|let|var|while|with|debugger|" +
                "__parent__|__count__|escape|unescape|with|__proto__|" +
                "class|enum|extends|super|export|implements|private|public|interface|package|protected|static",
            "storage.type":
                "const|let|var|function",
            "constant.language":
                "null|Infinity|NaN|undefined",
            "support.function":
                "alert",
            "constant.language.boolean": "true|false"
        }, "identifier");
        var kwBeforeRe = "case|do|else|finally|in|instanceof|return|throw|try|typeof|yield|void";

        var escapedRe = "\\\\(?:x[0-9a-fA-F]{2}|" + // hex
            "u[0-9a-fA-F]{4}|" + // unicode
            "u{[0-9a-fA-F]{1,6}}|" + // es6 unicode
            "[0-2][0-7]{0,2}|" + // oct
            "3[0-7][0-7]?|" + // oct
            "[4-7][0-7]?|" + //oct
            ".)";

        this.$rules = {
            "no_regex" : [
                DocCommentHighlightRules.getStartRule("doc-start"),
                comments("no_regex"),
                {
                    token : "string",
                    regex : "'(?=.)",
                    next  : "qstring"
                }, {
                    token : "string",
                    regex : '"(?=.)',
                    next  : "qqstring"
                }, {
                    token : "constant.numeric", // hexadecimal, octal and binary
                    regex : /0(?:[xX][0-9a-fA-F]+|[oO][0-7]+|[bB][01]+)\b/
                }, {
                    token : "constant.numeric", // decimal integers and floats
                    regex : /(?:\d\d*(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+\b)?/
                }, {
                    token : [
                        "storage.type", "punctuation.operator", "support.function",
                        "punctuation.operator", "entity.name.function", "text","keyword.operator"
                    ],
                    regex : "(" + identifierRe + ")(\\.)(prototype)(\\.)(" + identifierRe +")(\\s*)(=)",
                    next: "function_arguments"
                }, {
                    token : [
                        "storage.type", "punctuation.operator", "entity.name.function", "text",
                        "keyword.operator", "text", "storage.type", "text", "paren.lparen"
                    ],
                    regex : "(" + identifierRe + ")(\\.)(" + identifierRe +")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
                    next: "function_arguments"
                }, {
                    token : [
                        "entity.name.function", "text", "keyword.operator", "text", "storage.type",
                        "text", "paren.lparen"
                    ],
                    regex : "(" + identifierRe +")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
                    next: "function_arguments"
                }, {
                    token : [
                        "storage.type", "punctuation.operator", "entity.name.function", "text",
                        "keyword.operator", "text",
                        "storage.type", "text", "entity.name.function", "text", "paren.lparen"
                    ],
                    regex : "(" + identifierRe + ")(\\.)(" + identifierRe +")(\\s*)(=)(\\s*)(function)(\\s+)(\\w+)(\\s*)(\\()",
                    next: "function_arguments"
                }, {
                    token : [
                        "storage.type", "text", "entity.name.function", "text", "paren.lparen"
                    ],
                    regex : "(function)(\\s+)(" + identifierRe + ")(\\s*)(\\()",
                    next: "function_arguments"
                }, {
                    token : [
                        "entity.name.function", "text", "punctuation.operator",
                        "text", "storage.type", "text", "paren.lparen"
                    ],
                    regex : "(" + identifierRe + ")(\\s*)(:)(\\s*)(function)(\\s*)(\\()",
                    next: "function_arguments"
                }, {
                    token : [
                        "text", "text", "storage.type", "text", "paren.lparen"
                    ],
                    regex : "(:)(\\s*)(function)(\\s*)(\\()",
                    next: "function_arguments"
                }, {
                    token : "keyword",
                    regex : "from(?=\\s*('|\"))"
                }, {
                    token : "keyword",
                    regex : "(?:" + kwBeforeRe + ")\\b",
                    next : "start"
                }, {
                    token : ["support.constant"],
                    regex : /that\b/
                }, {
                    token : ["storage.type", "punctuation.operator", "support.function.firebug"],
                    regex : /(console)(\.)(warn|info|log|error|time|trace|timeEnd|assert)\b/
                }, {
                    token : keywordMapper,
                    regex : identifierRe
                }, {
                    token : "punctuation.operator",
                    regex : /[.](?![.])/,
                    next  : "property"
                }, {
                    token : "storage.type",
                    regex : /=>/,
                    next  : "start"
                }, {
                    token : "keyword.operator",
                    regex : /--|\+\+|\.{3}|===|==|=|!=|!==|<+=?|>+=?|!|&&|\|\||\?:|[!$%&*+\-~\/^]=?/,
                    next  : "start"
                }, {
                    token : "punctuation.operator",
                    regex : /[?:,;.]/,
                    next  : "start"
                }, {
                    token : "paren.lparen",
                    regex : /[\[({]/,
                    next  : "start"
                }, {
                    token : "paren.rparen",
                    regex : /[\])}]/
                }, {
                    token: "comment",
                    regex: /^#!.*$/
                }
            ],
            property: [{
                    token : "text",
                    regex : "\\s+"
                }, {
                    token : [
                        "storage.type", "punctuation.operator", "entity.name.function", "text",
                        "keyword.operator", "text",
                        "storage.type", "text", "entity.name.function", "text", "paren.lparen"
                    ],
                    regex : "(" + identifierRe + ")(\\.)(" + identifierRe +")(\\s*)(=)(\\s*)(function)(?:(\\s+)(\\w+))?(\\s*)(\\()",
                    next: "function_arguments"
                }, {
                    token : "punctuation.operator",
                    regex : /[.](?![.])/
                }, {
                    token : "support.function",
                    regex : /(s(?:h(?:ift|ow(?:Mod(?:elessDialog|alDialog)|Help))|croll(?:X|By(?:Pages|Lines)?|Y|To)?|t(?:op|rike)|i(?:n|zeToContent|debar|gnText)|ort|u(?:p|b(?:str(?:ing)?)?)|pli(?:ce|t)|e(?:nd|t(?:Re(?:sizable|questHeader)|M(?:i(?:nutes|lliseconds)|onth)|Seconds|Ho(?:tKeys|urs)|Year|Cursor|Time(?:out)?|Interval|ZOptions|Date|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Date|FullYear)|FullYear|Active)|arch)|qrt|lice|avePreferences|mall)|h(?:ome|andleEvent)|navigate|c(?:har(?:CodeAt|At)|o(?:s|n(?:cat|textual|firm)|mpile)|eil|lear(?:Timeout|Interval)?|a(?:ptureEvents|ll)|reate(?:StyleSheet|Popup|EventObject))|t(?:o(?:GMTString|S(?:tring|ource)|U(?:TCString|pperCase)|Lo(?:caleString|werCase))|est|a(?:n|int(?:Enabled)?))|i(?:s(?:NaN|Finite)|ndexOf|talics)|d(?:isableExternalCapture|ump|etachEvent)|u(?:n(?:shift|taint|escape|watch)|pdateCommands)|j(?:oin|avaEnabled)|p(?:o(?:p|w)|ush|lugins.refresh|a(?:ddings|rse(?:Int|Float)?)|r(?:int|ompt|eference))|e(?:scape|nableExternalCapture|val|lementFromPoint|x(?:p|ec(?:Script|Command)?))|valueOf|UTC|queryCommand(?:State|Indeterm|Enabled|Value)|f(?:i(?:nd|le(?:ModifiedDate|Size|CreatedDate|UpdatedDate)|xed)|o(?:nt(?:size|color)|rward)|loor|romCharCode)|watch|l(?:ink|o(?:ad|g)|astIndexOf)|a(?:sin|nchor|cos|t(?:tachEvent|ob|an(?:2)?)|pply|lert|b(?:s|ort))|r(?:ou(?:nd|teEvents)|e(?:size(?:By|To)|calc|turnValue|place|verse|l(?:oad|ease(?:Capture|Events)))|andom)|g(?:o|et(?:ResponseHeader|M(?:i(?:nutes|lliseconds)|onth)|Se(?:conds|lection)|Hours|Year|Time(?:zoneOffset)?|Da(?:y|te)|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Da(?:y|te)|FullYear)|FullYear|A(?:ttention|llResponseHeaders)))|m(?:in|ove(?:B(?:y|elow)|To(?:Absolute)?|Above)|ergeAttributes|a(?:tch|rgins|x))|b(?:toa|ig|o(?:ld|rderWidths)|link|ack))\b(?=\()/
                }, {
                    token : "support.function.dom",
                    regex : /(s(?:ub(?:stringData|mit)|plitText|e(?:t(?:NamedItem|Attribute(?:Node)?)|lect))|has(?:ChildNodes|Feature)|namedItem|c(?:l(?:ick|o(?:se|neNode))|reate(?:C(?:omment|DATASection|aption)|T(?:Head|extNode|Foot)|DocumentFragment|ProcessingInstruction|E(?:ntityReference|lement)|Attribute))|tabIndex|i(?:nsert(?:Row|Before|Cell|Data)|tem)|open|delete(?:Row|C(?:ell|aption)|T(?:Head|Foot)|Data)|focus|write(?:ln)?|a(?:dd|ppend(?:Child|Data))|re(?:set|place(?:Child|Data)|move(?:NamedItem|Child|Attribute(?:Node)?)?)|get(?:NamedItem|Element(?:sBy(?:Name|TagName|ClassName)|ById)|Attribute(?:Node)?)|blur)\b(?=\()/
                }, {
                    token :  "support.constant",
                    regex : /(s(?:ystemLanguage|cr(?:ipts|ollbars|een(?:X|Y|Top|Left))|t(?:yle(?:Sheets)?|atus(?:Text|bar)?)|ibling(?:Below|Above)|ource|uffixes|e(?:curity(?:Policy)?|l(?:ection|f)))|h(?:istory|ost(?:name)?|as(?:h|Focus))|y|X(?:MLDocument|SLDocument)|n(?:ext|ame(?:space(?:s|URI)|Prop))|M(?:IN_VALUE|AX_VALUE)|c(?:haracterSet|o(?:n(?:structor|trollers)|okieEnabled|lorDepth|mp(?:onents|lete))|urrent|puClass|l(?:i(?:p(?:boardData)?|entInformation)|osed|asses)|alle(?:e|r)|rypto)|t(?:o(?:olbar|p)|ext(?:Transform|Indent|Decoration|Align)|ags)|SQRT(?:1_2|2)|i(?:n(?:ner(?:Height|Width)|put)|ds|gnoreCase)|zIndex|o(?:scpu|n(?:readystatechange|Line)|uter(?:Height|Width)|p(?:sProfile|ener)|ffscreenBuffering)|NEGATIVE_INFINITY|d(?:i(?:splay|alog(?:Height|Top|Width|Left|Arguments)|rectories)|e(?:scription|fault(?:Status|Ch(?:ecked|arset)|View)))|u(?:ser(?:Profile|Language|Agent)|n(?:iqueID|defined)|pdateInterval)|_content|p(?:ixelDepth|ort|ersonalbar|kcs11|l(?:ugins|atform)|a(?:thname|dding(?:Right|Bottom|Top|Left)|rent(?:Window|Layer)?|ge(?:X(?:Offset)?|Y(?:Offset)?))|r(?:o(?:to(?:col|type)|duct(?:Sub)?|mpter)|e(?:vious|fix)))|e(?:n(?:coding|abledPlugin)|x(?:ternal|pando)|mbeds)|v(?:isibility|endor(?:Sub)?|Linkcolor)|URLUnencoded|P(?:I|OSITIVE_INFINITY)|f(?:ilename|o(?:nt(?:Size|Family|Weight)|rmName)|rame(?:s|Element)|gColor)|E|whiteSpace|l(?:i(?:stStyleType|n(?:eHeight|kColor))|o(?:ca(?:tion(?:bar)?|lName)|wsrc)|e(?:ngth|ft(?:Context)?)|a(?:st(?:M(?:odified|atch)|Index|Paren)|yer(?:s|X)|nguage))|a(?:pp(?:MinorVersion|Name|Co(?:deName|re)|Version)|vail(?:Height|Top|Width|Left)|ll|r(?:ity|guments)|Linkcolor|bove)|r(?:ight(?:Context)?|e(?:sponse(?:XML|Text)|adyState))|global|x|m(?:imeTypes|ultiline|enubar|argin(?:Right|Bottom|Top|Left))|L(?:N(?:10|2)|OG(?:10E|2E))|b(?:o(?:ttom|rder(?:Width|RightWidth|BottomWidth|Style|Color|TopWidth|LeftWidth))|ufferDepth|elow|ackground(?:Color|Image)))\b/
                }, {
                    token : "identifier",
                    regex : identifierRe
                }, {
                    regex: "",
                    token: "empty",
                    next: "no_regex"
                }
            ],
            "start": [
                DocCommentHighlightRules.getStartRule("doc-start"),
                comments("start"),
                {
                    token: "string.regexp",
                    regex: "\\/",
                    next: "regex"
                }, {
                    token : "text",
                    regex : "\\s+|^$",
                    next : "start"
                }, {
                    token: "empty",
                    regex: "",
                    next: "no_regex"
                }
            ],
            "regex": [
                {
                    token: "regexp.keyword.operator",
                    regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
                }, {
                    token: "string.regexp",
                    regex: "/[sxngimy]*",
                    next: "no_regex"
                }, {
                    token : "invalid",
                    regex: /\{\d+\b,?\d*\}[+*]|[+*$^?][+*]|[$^][?]|\?{3,}/
                }, {
                    token : "constant.language.escape",
                    regex: /\(\?[:=!]|\)|\{\d+\b,?\d*\}|[+*]\?|[()$^+*?.]/
                }, {
                    token : "constant.language.delimiter",
                    regex: /\|/
                }, {
                    token: "constant.language.escape",
                    regex: /\[\^?/,
                    next: "regex_character_class"
                }, {
                    token: "empty",
                    regex: "$",
                    next: "no_regex"
                }, {
                    defaultToken: "string.regexp"
                }
            ],
            "regex_character_class": [
                {
                    token: "regexp.charclass.keyword.operator",
                    regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
                }, {
                    token: "constant.language.escape",
                    regex: "]",
                    next: "regex"
                }, {
                    token: "constant.language.escape",
                    regex: "-"
                }, {
                    token: "empty",
                    regex: "$",
                    next: "no_regex"
                }, {
                    defaultToken: "string.regexp.charachterclass"
                }
            ],
            "function_arguments": [
                {
                    token: "variable.parameter",
                    regex: identifierRe
                }, {
                    token: "punctuation.operator",
                    regex: "[, ]+"
                }, {
                    token: "punctuation.operator",
                    regex: "$"
                }, {
                    token: "empty",
                    regex: "",
                    next: "no_regex"
                }
            ],
            "qqstring" : [
                {
                    token : "constant.language.escape",
                    regex : escapedRe
                }, {
                    token : "string",
                    regex : "\\\\$",
                    consumeLineEnd  : true
                }, {
                    token : "string",
                    regex : '"|$',
                    next  : "no_regex"
                }, {
                    defaultToken: "string"
                }
            ],
            "qstring" : [
                {
                    token : "constant.language.escape",
                    regex : escapedRe
                }, {
                    token : "string",
                    regex : "\\\\$",
                    consumeLineEnd  : true
                }, {
                    token : "string",
                    regex : "'|$",
                    next  : "no_regex"
                }, {
                    defaultToken: "string"
                }
            ]
        };


        if (!options || !options.noES6) {
            this.$rules.no_regex.unshift({
                regex: "[{}]", onMatch: function(val, state, stack) {
                    this.next = val == "{" ? this.nextState : "";
                    if (val == "{" && stack.length) {
                        stack.unshift("start", state);
                    }
                    else if (val == "}" && stack.length) {
                        stack.shift();
                        this.next = stack.shift();
                        if (this.next.indexOf("string") != -1 || this.next.indexOf("jsx") != -1)
                            return "paren.quasi.end";
                    }
                    return val == "{" ? "paren.lparen" : "paren.rparen";
                },
                nextState: "start"
            }, {
                token : "string.quasi.start",
                regex : /`/,
                push  : [{
                    token : "constant.language.escape",
                    regex : escapedRe
                }, {
                    token : "paren.quasi.start",
                    regex : /\${/,
                    push  : "start"
                }, {
                    token : "string.quasi.end",
                    regex : /`/,
                    next  : "pop"
                }, {
                    defaultToken: "string.quasi"
                }]
            });

            if (!options || options.jsx != false)
                JSX.call(this);
        }

        this.embedRules(DocCommentHighlightRules, "doc-",
            [ DocCommentHighlightRules.getEndRule("no_regex") ]);

        this.normalizeRules();
    };

    oop.inherits(JavaScriptHighlightRules, TextHighlightRules);

    function JSX() {
        var tagRegex = identifierRe.replace("\\d", "\\d\\-");
        var jsxTag = {
            onMatch : function(val, state, stack) {
                var offset = val.charAt(1) == "/" ? 2 : 1;
                if (offset == 1) {
                    if (state != this.nextState)
                        stack.unshift(this.next, this.nextState, 0);
                    else
                        stack.unshift(this.next);
                    stack[2]++;
                } else if (offset == 2) {
                    if (state == this.nextState) {
                        stack[1]--;
                        if (!stack[1] || stack[1] < 0) {
                            stack.shift();
                            stack.shift();
                        }
                    }
                }
                return [{
                    type: "meta.tag.punctuation." + (offset == 1 ? "" : "end-") + "tag-open.xml",
                    value: val.slice(0, offset)
                }, {
                    type: "meta.tag.tag-name.xml",
                    value: val.substr(offset)
                }];
            },
            regex : "</?" + tagRegex + "",
            next: "jsxAttributes",
            nextState: "jsx"
        };
        this.$rules.start.unshift(jsxTag);
        var jsxJsRule = {
            regex: "{",
            token: "paren.quasi.start",
            push: "start"
        };
        this.$rules.jsx = [
            jsxJsRule,
            jsxTag,
            {include : "reference"},
            {defaultToken: "string"}
        ];
        this.$rules.jsxAttributes = [{
            token : "meta.tag.punctuation.tag-close.xml",
            regex : "/?>",
            onMatch : function(value, currentState, stack) {
                if (currentState == stack[0])
                    stack.shift();
                if (value.length == 2) {
                    if (stack[0] == this.nextState)
                        stack[1]--;
                    if (!stack[1] || stack[1] < 0) {
                        stack.splice(0, 2);
                    }
                }
                this.next = stack[0] || "start";
                return [{type: this.token, value: value}];
            },
            nextState: "jsx"
        },
        jsxJsRule,
        comments("jsxAttributes"),
        {
            token : "entity.other.attribute-name.xml",
            regex : tagRegex
        }, {
            token : "keyword.operator.attribute-equals.xml",
            regex : "="
        }, {
            token : "text.tag-whitespace.xml",
            regex : "\\s+"
        }, {
            token : "string.attribute-value.xml",
            regex : "'",
            stateName : "jsx_attr_q",
            push : [
                {token : "string.attribute-value.xml", regex: "'", next: "pop"},
                {include : "reference"},
                {defaultToken : "string.attribute-value.xml"}
            ]
        }, {
            token : "string.attribute-value.xml",
            regex : '"',
            stateName : "jsx_attr_qq",
            push : [
                {token : "string.attribute-value.xml", regex: '"', next: "pop"},
                {include : "reference"},
                {defaultToken : "string.attribute-value.xml"}
            ]
        },
        jsxTag
        ];
        this.$rules.reference = [{
            token : "constant.language.escape.reference.xml",
            regex : "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
        }];
    }

    function comments(next) {
        return [
            {
                token : "comment", // multi line comment
                regex : /\/\*/,
                next: [
                    DocCommentHighlightRules.getTagRule(),
                    {token : "comment", regex : "\\*\\/", next : next || "pop"},
                    {defaultToken : "comment", caseInsensitive: true}
                ]
            }, {
                token : "comment",
                regex : "\\/\\/",
                next: [
                    DocCommentHighlightRules.getTagRule(),
                    {token : "comment", regex : "$|^", next : next || "pop"},
                    {defaultToken : "comment", caseInsensitive: true}
                ]
            }
        ];
    }
    exports.JavaScriptHighlightRules = JavaScriptHighlightRules;
    });

    ace.define("ace/mode/matching_brace_outdent",["require","exports","module","ace/range"], function(require, exports, module) {

    var Range = require("../range").Range;

    var MatchingBraceOutdent = function() {};

    (function() {

        this.checkOutdent = function(line, input) {
            if (! /^\s+$/.test(line))
                return false;

            return /^\s*\}/.test(input);
        };

        this.autoOutdent = function(doc, row) {
            var line = doc.getLine(row);
            var match = line.match(/^(\s*\})/);

            if (!match) return 0;

            var column = match[1].length;
            var openBracePos = doc.findMatchingBracket({row: row, column: column});

            if (!openBracePos || openBracePos.row == row) return 0;

            var indent = this.$getIndent(doc.getLine(openBracePos.row));
            doc.replace(new Range(row, 0, row, column-1), indent);
        };

        this.$getIndent = function(line) {
            return line.match(/^\s*/)[0];
        };

    }).call(MatchingBraceOutdent.prototype);

    exports.MatchingBraceOutdent = MatchingBraceOutdent;
    });

    ace.define("ace/mode/folding/cstyle",["require","exports","module","ace/lib/oop","ace/range","ace/mode/folding/fold_mode"], function(require, exports, module) {

    var oop = require("../../lib/oop");
    var Range = require("../../range").Range;
    var BaseFoldMode = require("./fold_mode").FoldMode;

    var FoldMode = exports.FoldMode = function(commentRegex) {
        if (commentRegex) {
            this.foldingStartMarker = new RegExp(
                this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start)
            );
            this.foldingStopMarker = new RegExp(
                this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end)
            );
        }
    };
    oop.inherits(FoldMode, BaseFoldMode);

    (function() {
        
        this.foldingStartMarker = /([\{\[\(])[^\}\]\)]*$|^\s*(\/\*)/;
        this.foldingStopMarker = /^[^\[\{\(]*([\}\]\)])|^[\s\*]*(\*\/)/;
        this.singleLineBlockCommentRe= /^\s*(\/\*).*\*\/\s*$/;
        this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/;
        this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/;
        this._getFoldWidgetBase = this.getFoldWidget;
        this.getFoldWidget = function(session, foldStyle, row) {
            var line = session.getLine(row);
        
            if (this.singleLineBlockCommentRe.test(line)) {
                if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line))
                    return "";
            }
        
            var fw = this._getFoldWidgetBase(session, foldStyle, row);
        
            if (!fw && this.startRegionRe.test(line))
                return "start"; // lineCommentRegionStart
        
            return fw;
        };

        this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {
            var line = session.getLine(row);
            
            if (this.startRegionRe.test(line))
                return this.getCommentRegionBlock(session, line, row);
            
            var match = line.match(this.foldingStartMarker);
            if (match) {
                var i = match.index;

                if (match[1])
                    return this.openingBracketBlock(session, match[1], row, i);
                    
                var range = session.getCommentFoldRange(row, i + match[0].length, 1);
                
                if (range && !range.isMultiLine()) {
                    if (forceMultiline) {
                        range = this.getSectionRange(session, row);
                    } else if (foldStyle != "all")
                        range = null;
                }
                
                return range;
            }

            if (foldStyle === "markbegin")
                return;

            var match = line.match(this.foldingStopMarker);
            if (match) {
                var i = match.index + match[0].length;

                if (match[1])
                    return this.closingBracketBlock(session, match[1], row, i);

                return session.getCommentFoldRange(row, i, -1);
            }
        };
        
        this.getSectionRange = function(session, row) {
            var line = session.getLine(row);
            var startIndent = line.search(/\S/);
            var startRow = row;
            var startColumn = line.length;
            row = row + 1;
            var endRow = row;
            var maxRow = session.getLength();
            while (++row < maxRow) {
                line = session.getLine(row);
                var indent = line.search(/\S/);
                if (indent === -1)
                    continue;
                if  (startIndent > indent)
                    break;
                var subRange = this.getFoldWidgetRange(session, "all", row);
                
                if (subRange) {
                    if (subRange.start.row <= startRow) {
                        break;
                    } else if (subRange.isMultiLine()) {
                        row = subRange.end.row;
                    } else if (startIndent == indent) {
                        break;
                    }
                }
                endRow = row;
            }
            
            return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
        };
        this.getCommentRegionBlock = function(session, line, row) {
            var startColumn = line.search(/\s*$/);
            var maxRow = session.getLength();
            var startRow = row;
            
            var re = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/;
            var depth = 1;
            while (++row < maxRow) {
                line = session.getLine(row);
                var m = re.exec(line);
                if (!m) continue;
                if (m[1]) depth--;
                else depth++;

                if (!depth) break;
            }

            var endRow = row;
            if (endRow > startRow) {
                return new Range(startRow, startColumn, endRow, line.length);
            }
        };

    }).call(FoldMode.prototype);

    });

    ace.define("ace/mode/javascript",["require","exports","module","ace/lib/oop","ace/mode/text","ace/mode/javascript_highlight_rules","ace/mode/matching_brace_outdent","ace/worker/worker_client","ace/mode/behaviour/cstyle","ace/mode/folding/cstyle"], function(require, exports, module) {

    var oop = require("../lib/oop");
    var TextMode = require("./text").Mode;
    var JavaScriptHighlightRules = require("./javascript_highlight_rules").JavaScriptHighlightRules;
    var MatchingBraceOutdent = require("./matching_brace_outdent").MatchingBraceOutdent;
    var WorkerClient = require("../worker/worker_client").WorkerClient;
    var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;
    var CStyleFoldMode = require("./folding/cstyle").FoldMode;

    var Mode = function() {
        this.HighlightRules = JavaScriptHighlightRules;
        
        this.$outdent = new MatchingBraceOutdent();
        this.$behaviour = new CstyleBehaviour();
        this.foldingRules = new CStyleFoldMode();
    };
    oop.inherits(Mode, TextMode);

    (function() {

        this.lineCommentStart = "//";
        this.blockComment = {start: "/*", end: "*/"};
        this.$quotes = {'"': '"', "'": "'", "`": "`"};

        this.getNextLineIndent = function(state, line, tab) {
            var indent = this.$getIndent(line);

            var tokenizedLine = this.getTokenizer().getLineTokens(line, state);
            var tokens = tokenizedLine.tokens;
            var endState = tokenizedLine.state;

            if (tokens.length && tokens[tokens.length-1].type == "comment") {
                return indent;
            }

            if (state == "start" || state == "no_regex") {
                var match = line.match(/^.*(?:\bcase\b.*:|[\{\(\[])\s*$/);
                if (match) {
                    indent += tab;
                }
            } else if (state == "doc-start") {
                if (endState == "start" || endState == "no_regex") {
                    return "";
                }
                var match = line.match(/^\s*(\/?)\*/);
                if (match) {
                    if (match[1]) {
                        indent += " ";
                    }
                    indent += "* ";
                }
            }

            return indent;
        };

        this.checkOutdent = function(state, line, input) {
            return this.$outdent.checkOutdent(line, input);
        };

        this.autoOutdent = function(state, doc, row) {
            this.$outdent.autoOutdent(doc, row);
        };

        this.createWorker = function(session) {
            var worker = new WorkerClient(["ace"], "ace/mode/javascript_worker", "JavaScriptWorker");
            worker.attachToDocument(session.getDocument());

            worker.on("annotate", function(results) {
                session.setAnnotations(results.data);
            });

            worker.on("terminate", function() {
                session.clearAnnotations();
            });

            return worker;
        };

        this.$id = "ace/mode/javascript";
    }).call(Mode.prototype);

    exports.Mode = Mode;
    });                (function() {
                        ace.require(["ace/mode/javascript"], function(m) {
                            if ( module) {
                                module.exports = m;
                            }
                        });
                    })();
    });

    var themeTomorrow_night = createCommonjsModule(function (module, exports) {
    ace.define("ace/theme/tomorrow_night",["require","exports","module","ace/lib/dom"], function(require, exports, module) {

    exports.isDark = true;
    exports.cssClass = "ace-tomorrow-night";
    exports.cssText = ".ace-tomorrow-night .ace_gutter {\
background: #25282c;\
color: #C5C8C6\
}\
.ace-tomorrow-night .ace_print-margin {\
width: 1px;\
background: #25282c\
}\
.ace-tomorrow-night {\
background-color: #1D1F21;\
color: #C5C8C6\
}\
.ace-tomorrow-night .ace_cursor {\
color: #AEAFAD\
}\
.ace-tomorrow-night .ace_marker-layer .ace_selection {\
background: #373B41\
}\
.ace-tomorrow-night.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px #1D1F21;\
}\
.ace-tomorrow-night .ace_marker-layer .ace_step {\
background: rgb(102, 82, 0)\
}\
.ace-tomorrow-night .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid #4B4E55\
}\
.ace-tomorrow-night .ace_marker-layer .ace_active-line {\
background: #282A2E\
}\
.ace-tomorrow-night .ace_gutter-active-line {\
background-color: #282A2E\
}\
.ace-tomorrow-night .ace_marker-layer .ace_selected-word {\
border: 1px solid #373B41\
}\
.ace-tomorrow-night .ace_invisible {\
color: #4B4E55\
}\
.ace-tomorrow-night .ace_keyword,\
.ace-tomorrow-night .ace_meta,\
.ace-tomorrow-night .ace_storage,\
.ace-tomorrow-night .ace_storage.ace_type,\
.ace-tomorrow-night .ace_support.ace_type {\
color: #B294BB\
}\
.ace-tomorrow-night .ace_keyword.ace_operator {\
color: #8ABEB7\
}\
.ace-tomorrow-night .ace_constant.ace_character,\
.ace-tomorrow-night .ace_constant.ace_language,\
.ace-tomorrow-night .ace_constant.ace_numeric,\
.ace-tomorrow-night .ace_keyword.ace_other.ace_unit,\
.ace-tomorrow-night .ace_support.ace_constant,\
.ace-tomorrow-night .ace_variable.ace_parameter {\
color: #DE935F\
}\
.ace-tomorrow-night .ace_constant.ace_other {\
color: #CED1CF\
}\
.ace-tomorrow-night .ace_invalid {\
color: #CED2CF;\
background-color: #DF5F5F\
}\
.ace-tomorrow-night .ace_invalid.ace_deprecated {\
color: #CED2CF;\
background-color: #B798BF\
}\
.ace-tomorrow-night .ace_fold {\
background-color: #81A2BE;\
border-color: #C5C8C6\
}\
.ace-tomorrow-night .ace_entity.ace_name.ace_function,\
.ace-tomorrow-night .ace_support.ace_function,\
.ace-tomorrow-night .ace_variable {\
color: #81A2BE\
}\
.ace-tomorrow-night .ace_support.ace_class,\
.ace-tomorrow-night .ace_support.ace_type {\
color: #F0C674\
}\
.ace-tomorrow-night .ace_heading,\
.ace-tomorrow-night .ace_markup.ace_heading,\
.ace-tomorrow-night .ace_string {\
color: #B5BD68\
}\
.ace-tomorrow-night .ace_entity.ace_name.ace_tag,\
.ace-tomorrow-night .ace_entity.ace_other.ace_attribute-name,\
.ace-tomorrow-night .ace_meta.ace_tag,\
.ace-tomorrow-night .ace_string.ace_regexp,\
.ace-tomorrow-night .ace_variable {\
color: #CC6666\
}\
.ace-tomorrow-night .ace_comment {\
color: #969896\
}\
.ace-tomorrow-night .ace_indent-guide {\
background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWNgYGBgYHB3d/8PAAOIAdULw8qMAAAAAElFTkSuQmCC) right repeat-y\
}";

    var dom = require("../lib/dom");
    dom.importCssString(exports.cssText, exports.cssClass);
    });                (function() {
                        ace.require(["ace/theme/tomorrow_night"], function(m) {
                            if ( module) {
                                module.exports = m;
                            }
                        });
                    })();
    });

    const { subscribe: subscribe$1, update: update$1 } = writable([]);
    function updateSolution(id, solution) {
      // fetch('http://localhost:3000/updateSolution/' + id, {
      //   method: 'POST',
      //   headers: {
      //     Accept: 'application/json',
      //     'Content-Type': 'application/json'
      //   },
      //   body: JSON.stringify({ solution: solution })
      // }).then((res) => {
      //   return update((tabs) => {
      //     return tabs.map((problem) => {
      //       if (problem.id === id) {
      //         return { ...problem, solution: solution };
      //       }
      //       return problem;
      //     });
      //   });
      // });
      return update$1((tabs) => {
        return tabs.map((problem) => {
          if (problem.id === id) {
            return { ...problem, solution: solution };
          }
          return problem;
        });
      });
    }
    function updateStore(problems) {
      console.log(problems);
      return update$1((tabs) => [
        ...tabs.map((problem) => {
          return { ...problem, active: false };
        }),
        ...problems.map((problem, index) => {
          if (index === 0) {
            return { ...problem, active: true, solution: 'function Solution(){}' };
          }
          return { ...problem, active: false, solution: 'function Solution(){}' };
        }),
      ]);
    }

    function activate(active) {
      return update$1((tabs) =>
        tabs.map((tab) => ({ ...tab, active: active === tab.id }))
      );
    }
    // function updateData() {
    //   fetch('http://localhost:3000/allData', {
    //     method: 'GET',
    //   })
    //     .then(res => {
    //       console.log(res);
    //       return res.json();
    //     })
    //     .then(data => {
    //       console.log(data);
    //       return update(() =>
    //         data.data.map((problem, index) => {
    //           return { ...problem, active: index === 0, changeData: false };
    //         }),
    //       );
    //     })
    //     .catch(err => {
    //       console.log(err);
    //     });
    // }

    // function add() {
    //   let newProblem = {
    //     id: Math.floor(Math.random() * 100000000),
    //     problem: '',
    //     test_case: '[]',
    //     test_output: '[]',
    //     solution: 'function solution() { return 1; }',
    //   };
    //   fetch('http://localhost:3000/addNewProblem', {
    //     method: 'POST',
    //     headers: {
    //       Accept: 'application/json',
    //       'Content-Type': 'application/json',
    //     },
    //     body: JSON.stringify(newProblem),
    //   })
    //     .then(res => {
    //       console.log(res);
    //       return update(tabs => [
    //         ...tabs.map(problem => {
    //           return { ...problem, active: false };
    //         }),
    //         { ...newProblem, active: true, changeData: true },
    //       ]);
    //     })
    //     .catch(err => {
    //       console.log(err);
    //     });
    // }

    // function newProblemData(id, newData) {
    //   fetch('http://localhost:3000/problem/' + id, {
    //     method: 'POST',
    //     headers: {
    //       Accept: 'application/json',
    //       'Content-Type': 'application/json',
    //     },
    //     body: JSON.stringify({problem:newData}),
    //   })
    //     .then(res => {
    //       return update(tabs =>
    //         tabs.map(problem => {
    //           if (problem.id === id) {
    //             return { ...problem, problem:newData };
    //           }
    //           return problem;
    //         }),
    //       );
    //     })
    //     .catch(err => {
    //       console.log(err);
    //     });
    // }

    // function updateTestInput(id, value) {
    //   fetch('http://localhost:3000/updateSolution/' + id, {
    //     method: 'POST',
    //     headers: {
    //       Accept: 'application/json',
    //       'Content-Type': 'application/json',
    //     },
    //     body: JSON.stringify({ test_case: String(value) }),
    //   }).then(res => {
    //     return update(tabs =>
    //       tabs.map(tab => {
    //         if (tab.id !== id) {
    //           return tab;
    //         }
    //         return { ...tab, test_case: String(value) };
    //       }),
    //     );
    //   });
    // }

    // function updateTestOutput(id, value) {
    //   fetch('http://localhost:3000/updateSolution/' + id, {
    //     method: 'POST',
    //     headers: {
    //       Accept: 'application/json',
    //       'Content-Type': 'application/json',
    //     },
    //     body: JSON.stringify({ test_output: String(value) }),
    //   }).then(res => {
    //     return update(tabs =>
    //       tabs.map(tab => {
    //         if (tab.id !== id) {
    //           return tab;
    //         }
    //         return { ...tab, test_output: String(value) };
    //       }),
    //     );
    //   });
    // }
    // function changeDataUpdate(id) {
    //   return update(tabs =>
    //     tabs.map(tab => {
    //       if (tab.id !== id) {
    //         return tab;
    //       }
    //       let change = !tab.changeData;
    //       return { ...tab, changeData: change };
    //     }),
    //   );
    // }

    // function deleteTab(id) {
    //   fetch('http://localhost:3000/problem/' + id, {
    //     method: 'DELETE',
    //   }).then(res => {
    //     return update(tabs => {
    //       return tabs.filter(tab => tab.id !== id);
    //     });
    //   });
    // }

    const dataStore = {
      subscribe: subscribe$1,
      activate,
      updateStore,
      updateSolution
    };

    const currentTab = derived(dataStore, ($dataStore) =>
      $dataStore.find(({ active }) => active)
    );

    /* src/EditorWindow.svelte generated by Svelte v3.18.1 */
    const file$1 = "src/EditorWindow.svelte";

    function create_fragment$3(ctx) {
    	let div;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "id", "editor");
    			attr_dev(div, "class", "editor flex-grow svelte-wxlfxg");
    			add_location(div, file$1, 53, 0, 1805);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			dispose = listen_dev(div, "keydown", /*onInput*/ ctx[0], false, false, false);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let $currentTab;
    	validate_store(currentTab, "currentTab");
    	component_subscribe($$self, currentTab, $$value => $$invalidate(2, $currentTab = $$value));
    	let editor;

    	onMount(() => {
    		ace.config.set("basePath", "ace-builds/src-noconflict/");
    		editor = ace.edit("editor");

    		editor.setOptions({
    			enableBasicAutocompletion: true,
    			enableSnippets: true,
    			highlightActiveLine: true,
    			showPrintMargin: false,
    			theme: "ace/theme/tomorrow_night",
    			mode: "ace/mode/javascript",
    			enableLiveAutocompletion: true,
    			useWorker: false
    		});
    	});

    	afterUpdate(() => {
    		var pos = editor.session.selection.toJSON();
    		editor.session.setValue($currentTab.solution);
    		editor.session.selection.fromJSON(pos);
    	});

    	const onInput = (function onInput() {
    		let timer;

    		return e => {
    			clearTimeout(timer);

    			timer = setTimeout(
    				() => {
    					dataStore.updateSolution($currentTab.id, editor.getValue());
    				},
    				500
    			);
    		};
    	})();

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("editor" in $$props) editor = $$props.editor;
    		if ("$currentTab" in $$props) currentTab.set($currentTab = $$props.$currentTab);
    	};

    	return [onInput];
    }

    class EditorWindow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EditorWindow",
    			options,
    			id: create_fragment$3.name
    		});
    	}
    }

    function setCookie(cname, cvalue, exhours) {
      var d = new Date();
      d.setTime(d.getTime() + exhours * 60 * 60 * 1000);
      var expires = 'expires=' + d.toUTCString();
      document.cookie = cname + '=' + cvalue + ';' + expires + ';path=/';
    }

    function getCookie(cname) {
      var name = cname + '=';
      var ca = document.cookie.split(';');
      for (var i = 0; i < ca.length; i++) {
        var c = ca[i];
        while (c.charAt(0) == ' ') {
          c = c.substring(1);
        }
        if (c.indexOf(name) == 0) {
          return c.substring(name.length, c.length);
        }
      }
      return '';
    }
    const cookieHandler = {
      getCookie,
      setCookie
    };

    var nodejsCustomInspectSymbol = typeof Symbol === 'function' && typeof Symbol.for === 'function' ? Symbol.for('nodejs.util.inspect.custom') : undefined;

    function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
    var MAX_ARRAY_LENGTH = 10;
    var MAX_RECURSIVE_DEPTH = 2;
    /**
     * Used to print values in error messages.
     */

    function inspect(value) {
      return formatValue(value, []);
    }

    function formatValue(value, seenValues) {
      switch (_typeof(value)) {
        case 'string':
          return JSON.stringify(value);

        case 'function':
          return value.name ? "[function ".concat(value.name, "]") : '[function]';

        case 'object':
          if (value === null) {
            return 'null';
          }

          return formatObjectValue(value, seenValues);

        default:
          return String(value);
      }
    }

    function formatObjectValue(value, previouslySeenValues) {
      if (previouslySeenValues.indexOf(value) !== -1) {
        return '[Circular]';
      }

      var seenValues = [].concat(previouslySeenValues, [value]);
      var customInspectFn = getCustomFn(value);

      if (customInspectFn !== undefined) {
        // $FlowFixMe(>=0.90.0)
        var customValue = customInspectFn.call(value); // check for infinite recursion

        if (customValue !== value) {
          return typeof customValue === 'string' ? customValue : formatValue(customValue, seenValues);
        }
      } else if (Array.isArray(value)) {
        return formatArray(value, seenValues);
      }

      return formatObject(value, seenValues);
    }

    function formatObject(object, seenValues) {
      var keys = Object.keys(object);

      if (keys.length === 0) {
        return '{}';
      }

      if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return '[' + getObjectTag(object) + ']';
      }

      var properties = keys.map(function (key) {
        var value = formatValue(object[key], seenValues);
        return key + ': ' + value;
      });
      return '{ ' + properties.join(', ') + ' }';
    }

    function formatArray(array, seenValues) {
      if (array.length === 0) {
        return '[]';
      }

      if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return '[Array]';
      }

      var len = Math.min(MAX_ARRAY_LENGTH, array.length);
      var remaining = array.length - len;
      var items = [];

      for (var i = 0; i < len; ++i) {
        items.push(formatValue(array[i], seenValues));
      }

      if (remaining === 1) {
        items.push('... 1 more item');
      } else if (remaining > 1) {
        items.push("... ".concat(remaining, " more items"));
      }

      return '[' + items.join(', ') + ']';
    }

    function getCustomFn(object) {
      var customInspectFn = object[String(nodejsCustomInspectSymbol)];

      if (typeof customInspectFn === 'function') {
        return customInspectFn;
      }

      if (typeof object.inspect === 'function') {
        return object.inspect;
      }
    }

    function getObjectTag(object) {
      var tag = Object.prototype.toString.call(object).replace(/^\[object /, '').replace(/]$/, '');

      if (tag === 'Object' && typeof object.constructor === 'function') {
        var name = object.constructor.name;

        if (typeof name === 'string' && name !== '') {
          return name;
        }
      }

      return tag;
    }

    function devAssert(condition, message) {
      var booleanCondition = Boolean(condition);

      if (!booleanCondition) {
        throw new Error(message);
      }
    }

    /**
     * The `defineToJSON()` function defines toJSON() and inspect() prototype
     * methods, if no function provided they become aliases for toString().
     */

    function defineToJSON(classObject) {
      var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : classObject.prototype.toString;
      classObject.prototype.toJSON = fn;
      classObject.prototype.inspect = fn;

      if (nodejsCustomInspectSymbol) {
        classObject.prototype[nodejsCustomInspectSymbol] = fn;
      }
    }

    function _typeof$1(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$1 = function _typeof(obj) { return typeof obj; }; } else { _typeof$1 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$1(obj); }

    /**
     * Return true if `value` is object-like. A value is object-like if it's not
     * `null` and has a `typeof` result of "object".
     */
    function isObjectLike(value) {
      return _typeof$1(value) == 'object' && value !== null;
    }

    /**
     * Represents a location in a Source.
     */

    /**
     * Takes a Source and a UTF-8 character offset, and returns the corresponding
     * line and column as a SourceLocation.
     */
    function getLocation(source, position) {
      var lineRegexp = /\r\n|[\n\r]/g;
      var line = 1;
      var column = position + 1;
      var match;

      while ((match = lineRegexp.exec(source.body)) && match.index < position) {
        line += 1;
        column = position + 1 - (match.index + match[0].length);
      }

      return {
        line: line,
        column: column
      };
    }

    /**
     * Render a helpful description of the location in the GraphQL Source document.
     */

    function printLocation(location) {
      return printSourceLocation(location.source, getLocation(location.source, location.start));
    }
    /**
     * Render a helpful description of the location in the GraphQL Source document.
     */

    function printSourceLocation(source, sourceLocation) {
      var firstLineColumnOffset = source.locationOffset.column - 1;
      var body = whitespace(firstLineColumnOffset) + source.body;
      var lineIndex = sourceLocation.line - 1;
      var lineOffset = source.locationOffset.line - 1;
      var lineNum = sourceLocation.line + lineOffset;
      var columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
      var columnNum = sourceLocation.column + columnOffset;
      var locationStr = "".concat(source.name, ":").concat(lineNum, ":").concat(columnNum, "\n");
      var lines = body.split(/\r\n|[\n\r]/g);
      var locationLine = lines[lineIndex]; // Special case for minified documents

      if (locationLine.length > 120) {
        var sublineIndex = Math.floor(columnNum / 80);
        var sublineColumnNum = columnNum % 80;
        var sublines = [];

        for (var i = 0; i < locationLine.length; i += 80) {
          sublines.push(locationLine.slice(i, i + 80));
        }

        return locationStr + printPrefixedLines([["".concat(lineNum), sublines[0]]].concat(sublines.slice(1, sublineIndex + 1).map(function (subline) {
          return ['', subline];
        }), [[' ', whitespace(sublineColumnNum - 1) + '^'], ['', sublines[sublineIndex + 1]]]));
      }

      return locationStr + printPrefixedLines([// Lines specified like this: ["prefix", "string"],
      ["".concat(lineNum - 1), lines[lineIndex - 1]], ["".concat(lineNum), locationLine], ['', whitespace(columnNum - 1) + '^'], ["".concat(lineNum + 1), lines[lineIndex + 1]]]);
    }

    function printPrefixedLines(lines) {
      var existingLines = lines.filter(function (_ref) {
        var _ = _ref[0],
            line = _ref[1];
        return line !== undefined;
      });
      var padLen = Math.max.apply(Math, existingLines.map(function (_ref2) {
        var prefix = _ref2[0];
        return prefix.length;
      }));
      return existingLines.map(function (_ref3) {
        var prefix = _ref3[0],
            line = _ref3[1];
        return lpad(padLen, prefix) + (line ? ' | ' + line : ' |');
      }).join('\n');
    }

    function whitespace(len) {
      return Array(len + 1).join(' ');
    }

    function lpad(len, str) {
      return whitespace(len - str.length) + str;
    }

    /**
     * A GraphQLError describes an Error found during the parse, validate, or
     * execute phases of performing a GraphQL operation. In addition to a message
     * and stack trace, it also includes information about the locations in a
     * GraphQL document and/or execution result that correspond to the Error.
     */

    function GraphQLError( // eslint-disable-line no-redeclare
    message, nodes, source, positions, path, originalError, extensions) {
      // Compute list of blame nodes.
      var _nodes = Array.isArray(nodes) ? nodes.length !== 0 ? nodes : undefined : nodes ? [nodes] : undefined; // Compute locations in the source for the given nodes/positions.


      var _source = source;

      if (!_source && _nodes) {
        var node = _nodes[0];
        _source = node && node.loc && node.loc.source;
      }

      var _positions = positions;

      if (!_positions && _nodes) {
        _positions = _nodes.reduce(function (list, node) {
          if (node.loc) {
            list.push(node.loc.start);
          }

          return list;
        }, []);
      }

      if (_positions && _positions.length === 0) {
        _positions = undefined;
      }

      var _locations;

      if (positions && source) {
        _locations = positions.map(function (pos) {
          return getLocation(source, pos);
        });
      } else if (_nodes) {
        _locations = _nodes.reduce(function (list, node) {
          if (node.loc) {
            list.push(getLocation(node.loc.source, node.loc.start));
          }

          return list;
        }, []);
      }

      var _extensions = extensions;

      if (_extensions == null && originalError != null) {
        var originalExtensions = originalError.extensions;

        if (isObjectLike(originalExtensions)) {
          _extensions = originalExtensions;
        }
      }

      Object.defineProperties(this, {
        message: {
          value: message,
          // By being enumerable, JSON.stringify will include `message` in the
          // resulting output. This ensures that the simplest possible GraphQL
          // service adheres to the spec.
          enumerable: true,
          writable: true
        },
        locations: {
          // Coercing falsey values to undefined ensures they will not be included
          // in JSON.stringify() when not provided.
          value: _locations || undefined,
          // By being enumerable, JSON.stringify will include `locations` in the
          // resulting output. This ensures that the simplest possible GraphQL
          // service adheres to the spec.
          enumerable: Boolean(_locations)
        },
        path: {
          // Coercing falsey values to undefined ensures they will not be included
          // in JSON.stringify() when not provided.
          value: path || undefined,
          // By being enumerable, JSON.stringify will include `path` in the
          // resulting output. This ensures that the simplest possible GraphQL
          // service adheres to the spec.
          enumerable: Boolean(path)
        },
        nodes: {
          value: _nodes || undefined
        },
        source: {
          value: _source || undefined
        },
        positions: {
          value: _positions || undefined
        },
        originalError: {
          value: originalError
        },
        extensions: {
          // Coercing falsey values to undefined ensures they will not be included
          // in JSON.stringify() when not provided.
          value: _extensions || undefined,
          // By being enumerable, JSON.stringify will include `path` in the
          // resulting output. This ensures that the simplest possible GraphQL
          // service adheres to the spec.
          enumerable: Boolean(_extensions)
        }
      }); // Include (non-enumerable) stack trace.

      if (originalError && originalError.stack) {
        Object.defineProperty(this, 'stack', {
          value: originalError.stack,
          writable: true,
          configurable: true
        });
      } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, GraphQLError);
      } else {
        Object.defineProperty(this, 'stack', {
          value: Error().stack,
          writable: true,
          configurable: true
        });
      }
    }
    GraphQLError.prototype = Object.create(Error.prototype, {
      constructor: {
        value: GraphQLError
      },
      name: {
        value: 'GraphQLError'
      },
      toString: {
        value: function toString() {
          return printError(this);
        }
      }
    });
    /**
     * Prints a GraphQLError to a string, representing useful location information
     * about the error's position in the source.
     */

    function printError(error) {
      var output = error.message;

      if (error.nodes) {
        for (var _i2 = 0, _error$nodes2 = error.nodes; _i2 < _error$nodes2.length; _i2++) {
          var node = _error$nodes2[_i2];

          if (node.loc) {
            output += '\n\n' + printLocation(node.loc);
          }
        }
      } else if (error.source && error.locations) {
        for (var _i4 = 0, _error$locations2 = error.locations; _i4 < _error$locations2.length; _i4++) {
          var location = _error$locations2[_i4];
          output += '\n\n' + printSourceLocation(error.source, location);
        }
      }

      return output;
    }

    /**
     * Produces a GraphQLError representing a syntax error, containing useful
     * descriptive information about the syntax error's position in the source.
     */

    function syntaxError(source, position, description) {
      return new GraphQLError("Syntax Error: ".concat(description), undefined, source, [position]);
    }

    /**
     * The set of allowed kind values for AST nodes.
     */
    var Kind = Object.freeze({
      // Name
      NAME: 'Name',
      // Document
      DOCUMENT: 'Document',
      OPERATION_DEFINITION: 'OperationDefinition',
      VARIABLE_DEFINITION: 'VariableDefinition',
      SELECTION_SET: 'SelectionSet',
      FIELD: 'Field',
      ARGUMENT: 'Argument',
      // Fragments
      FRAGMENT_SPREAD: 'FragmentSpread',
      INLINE_FRAGMENT: 'InlineFragment',
      FRAGMENT_DEFINITION: 'FragmentDefinition',
      // Values
      VARIABLE: 'Variable',
      INT: 'IntValue',
      FLOAT: 'FloatValue',
      STRING: 'StringValue',
      BOOLEAN: 'BooleanValue',
      NULL: 'NullValue',
      ENUM: 'EnumValue',
      LIST: 'ListValue',
      OBJECT: 'ObjectValue',
      OBJECT_FIELD: 'ObjectField',
      // Directives
      DIRECTIVE: 'Directive',
      // Types
      NAMED_TYPE: 'NamedType',
      LIST_TYPE: 'ListType',
      NON_NULL_TYPE: 'NonNullType',
      // Type System Definitions
      SCHEMA_DEFINITION: 'SchemaDefinition',
      OPERATION_TYPE_DEFINITION: 'OperationTypeDefinition',
      // Type Definitions
      SCALAR_TYPE_DEFINITION: 'ScalarTypeDefinition',
      OBJECT_TYPE_DEFINITION: 'ObjectTypeDefinition',
      FIELD_DEFINITION: 'FieldDefinition',
      INPUT_VALUE_DEFINITION: 'InputValueDefinition',
      INTERFACE_TYPE_DEFINITION: 'InterfaceTypeDefinition',
      UNION_TYPE_DEFINITION: 'UnionTypeDefinition',
      ENUM_TYPE_DEFINITION: 'EnumTypeDefinition',
      ENUM_VALUE_DEFINITION: 'EnumValueDefinition',
      INPUT_OBJECT_TYPE_DEFINITION: 'InputObjectTypeDefinition',
      // Directive Definitions
      DIRECTIVE_DEFINITION: 'DirectiveDefinition',
      // Type System Extensions
      SCHEMA_EXTENSION: 'SchemaExtension',
      // Type Extensions
      SCALAR_TYPE_EXTENSION: 'ScalarTypeExtension',
      OBJECT_TYPE_EXTENSION: 'ObjectTypeExtension',
      INTERFACE_TYPE_EXTENSION: 'InterfaceTypeExtension',
      UNION_TYPE_EXTENSION: 'UnionTypeExtension',
      ENUM_TYPE_EXTENSION: 'EnumTypeExtension',
      INPUT_OBJECT_TYPE_EXTENSION: 'InputObjectTypeExtension'
    });
    /**
     * The enum type representing the possible kind values of AST nodes.
     */

    /**
     * The `defineToStringTag()` function checks first to see if the runtime
     * supports the `Symbol` class and then if the `Symbol.toStringTag` constant
     * is defined as a `Symbol` instance. If both conditions are met, the
     * Symbol.toStringTag property is defined as a getter that returns the
     * supplied class constructor's name.
     *
     * @method defineToStringTag
     *
     * @param {Class<any>} classObject a class such as Object, String, Number but
     * typically one of your own creation through the class keyword; `class A {}`,
     * for example.
     */
    function defineToStringTag(classObject) {
      if (typeof Symbol === 'function' && Symbol.toStringTag) {
        Object.defineProperty(classObject.prototype, Symbol.toStringTag, {
          get: function get() {
            return this.constructor.name;
          }
        });
      }
    }

    /**
     * A representation of source input to GraphQL.
     * `name` and `locationOffset` are optional. They are useful for clients who
     * store GraphQL documents in source files; for example, if the GraphQL input
     * starts at line 40 in a file named Foo.graphql, it might be useful for name to
     * be "Foo.graphql" and location to be `{ line: 40, column: 0 }`.
     * line and column in locationOffset are 1-indexed
     */
    var Source = function Source(body, name, locationOffset) {
      this.body = body;
      this.name = name || 'GraphQL request';
      this.locationOffset = locationOffset || {
        line: 1,
        column: 1
      };
      this.locationOffset.line > 0 || devAssert(0, 'line in locationOffset is 1-indexed and must be positive');
      this.locationOffset.column > 0 || devAssert(0, 'column in locationOffset is 1-indexed and must be positive');
    }; // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported

    defineToStringTag(Source);

    /**
     * Produces the value of a block string from its parsed raw value, similar to
     * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.
     *
     * This implements the GraphQL spec's BlockStringValue() static algorithm.
     */
    function dedentBlockStringValue(rawString) {
      // Expand a block string's raw value into independent lines.
      var lines = rawString.split(/\r\n|[\n\r]/g); // Remove common indentation from all lines but first.

      var commonIndent = getBlockStringIndentation(lines);

      if (commonIndent !== 0) {
        for (var i = 1; i < lines.length; i++) {
          lines[i] = lines[i].slice(commonIndent);
        }
      } // Remove leading and trailing blank lines.


      while (lines.length > 0 && isBlank(lines[0])) {
        lines.shift();
      }

      while (lines.length > 0 && isBlank(lines[lines.length - 1])) {
        lines.pop();
      } // Return a string of the lines joined with U+000A.


      return lines.join('\n');
    } // @internal

    function getBlockStringIndentation(lines) {
      var commonIndent = null;

      for (var i = 1; i < lines.length; i++) {
        var line = lines[i];
        var indent = leadingWhitespace(line);

        if (indent === line.length) {
          continue; // skip empty lines
        }

        if (commonIndent === null || indent < commonIndent) {
          commonIndent = indent;

          if (commonIndent === 0) {
            break;
          }
        }
      }

      return commonIndent === null ? 0 : commonIndent;
    }

    function leadingWhitespace(str) {
      var i = 0;

      while (i < str.length && (str[i] === ' ' || str[i] === '\t')) {
        i++;
      }

      return i;
    }

    function isBlank(str) {
      return leadingWhitespace(str) === str.length;
    }
    /**
     * Print a block string in the indented block form by adding a leading and
     * trailing blank line. However, if a block string starts with whitespace and is
     * a single-line, adding a leading blank line would strip that whitespace.
     */


    function printBlockString(value) {
      var indentation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var preferMultipleLines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var isSingleLine = value.indexOf('\n') === -1;
      var hasLeadingSpace = value[0] === ' ' || value[0] === '\t';
      var hasTrailingQuote = value[value.length - 1] === '"';
      var printAsMultipleLines = !isSingleLine || hasTrailingQuote || preferMultipleLines;
      var result = ''; // Format a multi-line block quote to account for leading space.

      if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {
        result += '\n' + indentation;
      }

      result += indentation ? value.replace(/\n/g, '\n' + indentation) : value;

      if (printAsMultipleLines) {
        result += '\n';
      }

      return '"""' + result.replace(/"""/g, '\\"""') + '"""';
    }

    /**
     * An exported enum describing the different kinds of tokens that the
     * lexer emits.
     */
    var TokenKind = Object.freeze({
      SOF: '<SOF>',
      EOF: '<EOF>',
      BANG: '!',
      DOLLAR: '$',
      AMP: '&',
      PAREN_L: '(',
      PAREN_R: ')',
      SPREAD: '...',
      COLON: ':',
      EQUALS: '=',
      AT: '@',
      BRACKET_L: '[',
      BRACKET_R: ']',
      BRACE_L: '{',
      PIPE: '|',
      BRACE_R: '}',
      NAME: 'Name',
      INT: 'Int',
      FLOAT: 'Float',
      STRING: 'String',
      BLOCK_STRING: 'BlockString',
      COMMENT: 'Comment'
    });
    /**
     * The enum type representing the token kinds values.
     */

    /**
     * Given a Source object, this returns a Lexer for that source.
     * A Lexer is a stateful stream generator in that every time
     * it is advanced, it returns the next token in the Source. Assuming the
     * source lexes, the final Token emitted by the lexer will be of kind
     * EOF, after which the lexer will repeatedly return the same EOF token
     * whenever called.
     */

    function createLexer(source, options) {
      var startOfFileToken = new Tok(TokenKind.SOF, 0, 0, 0, 0, null);
      var lexer = {
        source: source,
        options: options,
        lastToken: startOfFileToken,
        token: startOfFileToken,
        line: 1,
        lineStart: 0,
        advance: advanceLexer,
        lookahead: lookahead
      };
      return lexer;
    }

    function advanceLexer() {
      this.lastToken = this.token;
      var token = this.token = this.lookahead();
      return token;
    }

    function lookahead() {
      var token = this.token;

      if (token.kind !== TokenKind.EOF) {
        do {
          // Note: next is only mutable during parsing, so we cast to allow this.
          token = token.next || (token.next = readToken(this, token));
        } while (token.kind === TokenKind.COMMENT);
      }

      return token;
    }
    /**
     * Helper function for constructing the Token object.
     */

    function Tok(kind, start, end, line, column, prev, value) {
      this.kind = kind;
      this.start = start;
      this.end = end;
      this.line = line;
      this.column = column;
      this.value = value;
      this.prev = prev;
      this.next = null;
    } // Print a simplified form when appearing in JSON/util.inspect.


    defineToJSON(Tok, function () {
      return {
        kind: this.kind,
        value: this.value,
        line: this.line,
        column: this.column
      };
    });

    function printCharCode(code) {
      return (// NaN/undefined represents access beyond the end of the file.
        isNaN(code) ? TokenKind.EOF : // Trust JSON for ASCII.
        code < 0x007f ? JSON.stringify(String.fromCharCode(code)) : // Otherwise print the escaped form.
        "\"\\u".concat(('00' + code.toString(16).toUpperCase()).slice(-4), "\"")
      );
    }
    /**
     * Gets the next token from the source starting at the given position.
     *
     * This skips over whitespace until it finds the next lexable token, then lexes
     * punctuators immediately or calls the appropriate helper function for more
     * complicated tokens.
     */


    function readToken(lexer, prev) {
      var source = lexer.source;
      var body = source.body;
      var bodyLength = body.length;
      var pos = positionAfterWhitespace(body, prev.end, lexer);
      var line = lexer.line;
      var col = 1 + pos - lexer.lineStart;

      if (pos >= bodyLength) {
        return new Tok(TokenKind.EOF, bodyLength, bodyLength, line, col, prev);
      }

      var code = body.charCodeAt(pos); // SourceCharacter

      switch (code) {
        // !
        case 33:
          return new Tok(TokenKind.BANG, pos, pos + 1, line, col, prev);
        // #

        case 35:
          return readComment(source, pos, line, col, prev);
        // $

        case 36:
          return new Tok(TokenKind.DOLLAR, pos, pos + 1, line, col, prev);
        // &

        case 38:
          return new Tok(TokenKind.AMP, pos, pos + 1, line, col, prev);
        // (

        case 40:
          return new Tok(TokenKind.PAREN_L, pos, pos + 1, line, col, prev);
        // )

        case 41:
          return new Tok(TokenKind.PAREN_R, pos, pos + 1, line, col, prev);
        // .

        case 46:
          if (body.charCodeAt(pos + 1) === 46 && body.charCodeAt(pos + 2) === 46) {
            return new Tok(TokenKind.SPREAD, pos, pos + 3, line, col, prev);
          }

          break;
        // :

        case 58:
          return new Tok(TokenKind.COLON, pos, pos + 1, line, col, prev);
        // =

        case 61:
          return new Tok(TokenKind.EQUALS, pos, pos + 1, line, col, prev);
        // @

        case 64:
          return new Tok(TokenKind.AT, pos, pos + 1, line, col, prev);
        // [

        case 91:
          return new Tok(TokenKind.BRACKET_L, pos, pos + 1, line, col, prev);
        // ]

        case 93:
          return new Tok(TokenKind.BRACKET_R, pos, pos + 1, line, col, prev);
        // {

        case 123:
          return new Tok(TokenKind.BRACE_L, pos, pos + 1, line, col, prev);
        // |

        case 124:
          return new Tok(TokenKind.PIPE, pos, pos + 1, line, col, prev);
        // }

        case 125:
          return new Tok(TokenKind.BRACE_R, pos, pos + 1, line, col, prev);
        // A-Z _ a-z

        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 95:
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
          return readName(source, pos, line, col, prev);
        // - 0-9

        case 45:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          return readNumber(source, pos, code, line, col, prev);
        // "

        case 34:
          if (body.charCodeAt(pos + 1) === 34 && body.charCodeAt(pos + 2) === 34) {
            return readBlockString(source, pos, line, col, prev, lexer);
          }

          return readString(source, pos, line, col, prev);
      }

      throw syntaxError(source, pos, unexpectedCharacterMessage(code));
    }
    /**
     * Report a message that an unexpected character was encountered.
     */


    function unexpectedCharacterMessage(code) {
      if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {
        return "Cannot contain the invalid character ".concat(printCharCode(code), ".");
      }

      if (code === 39) {
        // '
        return 'Unexpected single quote character (\'), did you mean to use a double quote (")?';
      }

      return "Cannot parse the unexpected character ".concat(printCharCode(code), ".");
    }
    /**
     * Reads from body starting at startPosition until it finds a non-whitespace
     * character, then returns the position of that character for lexing.
     */


    function positionAfterWhitespace(body, startPosition, lexer) {
      var bodyLength = body.length;
      var position = startPosition;

      while (position < bodyLength) {
        var code = body.charCodeAt(position); // tab | space | comma | BOM

        if (code === 9 || code === 32 || code === 44 || code === 0xfeff) {
          ++position;
        } else if (code === 10) {
          // new line
          ++position;
          ++lexer.line;
          lexer.lineStart = position;
        } else if (code === 13) {
          // carriage return
          if (body.charCodeAt(position + 1) === 10) {
            position += 2;
          } else {
            ++position;
          }

          ++lexer.line;
          lexer.lineStart = position;
        } else {
          break;
        }
      }

      return position;
    }
    /**
     * Reads a comment token from the source file.
     *
     * #[\u0009\u0020-\uFFFF]*
     */


    function readComment(source, start, line, col, prev) {
      var body = source.body;
      var code;
      var position = start;

      do {
        code = body.charCodeAt(++position);
      } while (!isNaN(code) && ( // SourceCharacter but not LineTerminator
      code > 0x001f || code === 0x0009));

      return new Tok(TokenKind.COMMENT, start, position, line, col, prev, body.slice(start + 1, position));
    }
    /**
     * Reads a number token from the source file, either a float
     * or an int depending on whether a decimal point appears.
     *
     * Int:   -?(0|[1-9][0-9]*)
     * Float: -?(0|[1-9][0-9]*)(\.[0-9]+)?((E|e)(+|-)?[0-9]+)?
     */


    function readNumber(source, start, firstCode, line, col, prev) {
      var body = source.body;
      var code = firstCode;
      var position = start;
      var isFloat = false;

      if (code === 45) {
        // -
        code = body.charCodeAt(++position);
      }

      if (code === 48) {
        // 0
        code = body.charCodeAt(++position);

        if (code >= 48 && code <= 57) {
          throw syntaxError(source, position, "Invalid number, unexpected digit after 0: ".concat(printCharCode(code), "."));
        }
      } else {
        position = readDigits(source, position, code);
        code = body.charCodeAt(position);
      }

      if (code === 46) {
        // .
        isFloat = true;
        code = body.charCodeAt(++position);
        position = readDigits(source, position, code);
        code = body.charCodeAt(position);
      }

      if (code === 69 || code === 101) {
        // E e
        isFloat = true;
        code = body.charCodeAt(++position);

        if (code === 43 || code === 45) {
          // + -
          code = body.charCodeAt(++position);
        }

        position = readDigits(source, position, code);
        code = body.charCodeAt(position);
      } // Numbers cannot be followed by . or e


      if (code === 46 || code === 69 || code === 101) {
        throw syntaxError(source, position, "Invalid number, expected digit but got: ".concat(printCharCode(code), "."));
      }

      return new Tok(isFloat ? TokenKind.FLOAT : TokenKind.INT, start, position, line, col, prev, body.slice(start, position));
    }
    /**
     * Returns the new position in the source after reading digits.
     */


    function readDigits(source, start, firstCode) {
      var body = source.body;
      var position = start;
      var code = firstCode;

      if (code >= 48 && code <= 57) {
        // 0 - 9
        do {
          code = body.charCodeAt(++position);
        } while (code >= 48 && code <= 57); // 0 - 9


        return position;
      }

      throw syntaxError(source, position, "Invalid number, expected digit but got: ".concat(printCharCode(code), "."));
    }
    /**
     * Reads a string token from the source file.
     *
     * "([^"\\\u000A\u000D]|(\\(u[0-9a-fA-F]{4}|["\\/bfnrt])))*"
     */


    function readString(source, start, line, col, prev) {
      var body = source.body;
      var position = start + 1;
      var chunkStart = position;
      var code = 0;
      var value = '';

      while (position < body.length && !isNaN(code = body.charCodeAt(position)) && // not LineTerminator
      code !== 0x000a && code !== 0x000d) {
        // Closing Quote (")
        if (code === 34) {
          value += body.slice(chunkStart, position);
          return new Tok(TokenKind.STRING, start, position + 1, line, col, prev, value);
        } // SourceCharacter


        if (code < 0x0020 && code !== 0x0009) {
          throw syntaxError(source, position, "Invalid character within String: ".concat(printCharCode(code), "."));
        }

        ++position;

        if (code === 92) {
          // \
          value += body.slice(chunkStart, position - 1);
          code = body.charCodeAt(position);

          switch (code) {
            case 34:
              value += '"';
              break;

            case 47:
              value += '/';
              break;

            case 92:
              value += '\\';
              break;

            case 98:
              value += '\b';
              break;

            case 102:
              value += '\f';
              break;

            case 110:
              value += '\n';
              break;

            case 114:
              value += '\r';
              break;

            case 116:
              value += '\t';
              break;

            case 117:
              {
                // uXXXX
                var charCode = uniCharCode(body.charCodeAt(position + 1), body.charCodeAt(position + 2), body.charCodeAt(position + 3), body.charCodeAt(position + 4));

                if (charCode < 0) {
                  var invalidSequence = body.slice(position + 1, position + 5);
                  throw syntaxError(source, position, "Invalid character escape sequence: \\u".concat(invalidSequence, "."));
                }

                value += String.fromCharCode(charCode);
                position += 4;
                break;
              }

            default:
              throw syntaxError(source, position, "Invalid character escape sequence: \\".concat(String.fromCharCode(code), "."));
          }

          ++position;
          chunkStart = position;
        }
      }

      throw syntaxError(source, position, 'Unterminated string.');
    }
    /**
     * Reads a block string token from the source file.
     *
     * """("?"?(\\"""|\\(?!=""")|[^"\\]))*"""
     */


    function readBlockString(source, start, line, col, prev, lexer) {
      var body = source.body;
      var position = start + 3;
      var chunkStart = position;
      var code = 0;
      var rawValue = '';

      while (position < body.length && !isNaN(code = body.charCodeAt(position))) {
        // Closing Triple-Quote (""")
        if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
          rawValue += body.slice(chunkStart, position);
          return new Tok(TokenKind.BLOCK_STRING, start, position + 3, line, col, prev, dedentBlockStringValue(rawValue));
        } // SourceCharacter


        if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {
          throw syntaxError(source, position, "Invalid character within String: ".concat(printCharCode(code), "."));
        }

        if (code === 10) {
          // new line
          ++position;
          ++lexer.line;
          lexer.lineStart = position;
        } else if (code === 13) {
          // carriage return
          if (body.charCodeAt(position + 1) === 10) {
            position += 2;
          } else {
            ++position;
          }

          ++lexer.line;
          lexer.lineStart = position;
        } else if ( // Escape Triple-Quote (\""")
        code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
          rawValue += body.slice(chunkStart, position) + '"""';
          position += 4;
          chunkStart = position;
        } else {
          ++position;
        }
      }

      throw syntaxError(source, position, 'Unterminated string.');
    }
    /**
     * Converts four hexadecimal chars to the integer that the
     * string represents. For example, uniCharCode('0','0','0','f')
     * will return 15, and uniCharCode('0','0','f','f') returns 255.
     *
     * Returns a negative number on error, if a char was invalid.
     *
     * This is implemented by noting that char2hex() returns -1 on error,
     * which means the result of ORing the char2hex() will also be negative.
     */


    function uniCharCode(a, b, c, d) {
      return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d);
    }
    /**
     * Converts a hex character to its integer value.
     * '0' becomes 0, '9' becomes 9
     * 'A' becomes 10, 'F' becomes 15
     * 'a' becomes 10, 'f' becomes 15
     *
     * Returns -1 on error.
     */


    function char2hex(a) {
      return a >= 48 && a <= 57 ? a - 48 // 0-9
      : a >= 65 && a <= 70 ? a - 55 // A-F
      : a >= 97 && a <= 102 ? a - 87 // a-f
      : -1;
    }
    /**
     * Reads an alphanumeric + underscore name from the source.
     *
     * [_A-Za-z][_0-9A-Za-z]*
     */


    function readName(source, start, line, col, prev) {
      var body = source.body;
      var bodyLength = body.length;
      var position = start + 1;
      var code = 0;

      while (position !== bodyLength && !isNaN(code = body.charCodeAt(position)) && (code === 95 || // _
      code >= 48 && code <= 57 || // 0-9
      code >= 65 && code <= 90 || // A-Z
      code >= 97 && code <= 122) // a-z
      ) {
        ++position;
      }

      return new Tok(TokenKind.NAME, start, position, line, col, prev, body.slice(start, position));
    }

    /**
     * The set of allowed directive location values.
     */
    var DirectiveLocation = Object.freeze({
      // Request Definitions
      QUERY: 'QUERY',
      MUTATION: 'MUTATION',
      SUBSCRIPTION: 'SUBSCRIPTION',
      FIELD: 'FIELD',
      FRAGMENT_DEFINITION: 'FRAGMENT_DEFINITION',
      FRAGMENT_SPREAD: 'FRAGMENT_SPREAD',
      INLINE_FRAGMENT: 'INLINE_FRAGMENT',
      VARIABLE_DEFINITION: 'VARIABLE_DEFINITION',
      // Type System Definitions
      SCHEMA: 'SCHEMA',
      SCALAR: 'SCALAR',
      OBJECT: 'OBJECT',
      FIELD_DEFINITION: 'FIELD_DEFINITION',
      ARGUMENT_DEFINITION: 'ARGUMENT_DEFINITION',
      INTERFACE: 'INTERFACE',
      UNION: 'UNION',
      ENUM: 'ENUM',
      ENUM_VALUE: 'ENUM_VALUE',
      INPUT_OBJECT: 'INPUT_OBJECT',
      INPUT_FIELD_DEFINITION: 'INPUT_FIELD_DEFINITION'
    });
    /**
     * The enum type representing the directive location values.
     */

    /**
     * Given a GraphQL source, parses it into a Document.
     * Throws GraphQLError if a syntax error is encountered.
     */
    function parse(source, options) {
      var parser = new Parser(source, options);
      return parser.parseDocument();
    }
    /**
     * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for
     * that value.
     * Throws GraphQLError if a syntax error is encountered.
     *
     * This is useful within tools that operate upon GraphQL Values directly and
     * in isolation of complete GraphQL documents.
     *
     * Consider providing the results to the utility function: valueFromAST().
     */

    function parseValue(source, options) {
      var parser = new Parser(source, options);
      parser.expectToken(TokenKind.SOF);
      var value = parser.parseValueLiteral(false);
      parser.expectToken(TokenKind.EOF);
      return value;
    }
    /**
     * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for
     * that type.
     * Throws GraphQLError if a syntax error is encountered.
     *
     * This is useful within tools that operate upon GraphQL Types directly and
     * in isolation of complete GraphQL documents.
     *
     * Consider providing the results to the utility function: typeFromAST().
     */

    function parseType(source, options) {
      var parser = new Parser(source, options);
      parser.expectToken(TokenKind.SOF);
      var type = parser.parseTypeReference();
      parser.expectToken(TokenKind.EOF);
      return type;
    }

    var Parser =
    /*#__PURE__*/
    function () {
      function Parser(source, options) {
        var sourceObj = typeof source === 'string' ? new Source(source) : source;
        sourceObj instanceof Source || devAssert(0, "Must provide Source. Received: ".concat(inspect(sourceObj)));
        this._lexer = createLexer(sourceObj);
        this._options = options || {};
      }
      /**
       * Converts a name lex token into a name parse node.
       */


      var _proto = Parser.prototype;

      _proto.parseName = function parseName() {
        var token = this.expectToken(TokenKind.NAME);
        return {
          kind: Kind.NAME,
          value: token.value,
          loc: this.loc(token)
        };
      } // Implements the parsing rules in the Document section.

      /**
       * Document : Definition+
       */
      ;

      _proto.parseDocument = function parseDocument() {
        var start = this._lexer.token;
        return {
          kind: Kind.DOCUMENT,
          definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF),
          loc: this.loc(start)
        };
      }
      /**
       * Definition :
       *   - ExecutableDefinition
       *   - TypeSystemDefinition
       *   - TypeSystemExtension
       *
       * ExecutableDefinition :
       *   - OperationDefinition
       *   - FragmentDefinition
       */
      ;

      _proto.parseDefinition = function parseDefinition() {
        if (this.peek(TokenKind.NAME)) {
          switch (this._lexer.token.value) {
            case 'query':
            case 'mutation':
            case 'subscription':
              return this.parseOperationDefinition();

            case 'fragment':
              return this.parseFragmentDefinition();

            case 'schema':
            case 'scalar':
            case 'type':
            case 'interface':
            case 'union':
            case 'enum':
            case 'input':
            case 'directive':
              return this.parseTypeSystemDefinition();

            case 'extend':
              return this.parseTypeSystemExtension();
          }
        } else if (this.peek(TokenKind.BRACE_L)) {
          return this.parseOperationDefinition();
        } else if (this.peekDescription()) {
          return this.parseTypeSystemDefinition();
        }

        throw this.unexpected();
      } // Implements the parsing rules in the Operations section.

      /**
       * OperationDefinition :
       *  - SelectionSet
       *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
       */
      ;

      _proto.parseOperationDefinition = function parseOperationDefinition() {
        var start = this._lexer.token;

        if (this.peek(TokenKind.BRACE_L)) {
          return {
            kind: Kind.OPERATION_DEFINITION,
            operation: 'query',
            name: undefined,
            variableDefinitions: [],
            directives: [],
            selectionSet: this.parseSelectionSet(),
            loc: this.loc(start)
          };
        }

        var operation = this.parseOperationType();
        var name;

        if (this.peek(TokenKind.NAME)) {
          name = this.parseName();
        }

        return {
          kind: Kind.OPERATION_DEFINITION,
          operation: operation,
          name: name,
          variableDefinitions: this.parseVariableDefinitions(),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet(),
          loc: this.loc(start)
        };
      }
      /**
       * OperationType : one of query mutation subscription
       */
      ;

      _proto.parseOperationType = function parseOperationType() {
        var operationToken = this.expectToken(TokenKind.NAME);

        switch (operationToken.value) {
          case 'query':
            return 'query';

          case 'mutation':
            return 'mutation';

          case 'subscription':
            return 'subscription';
        }

        throw this.unexpected(operationToken);
      }
      /**
       * VariableDefinitions : ( VariableDefinition+ )
       */
      ;

      _proto.parseVariableDefinitions = function parseVariableDefinitions() {
        return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);
      }
      /**
       * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
       */
      ;

      _proto.parseVariableDefinition = function parseVariableDefinition() {
        var start = this._lexer.token;
        return {
          kind: Kind.VARIABLE_DEFINITION,
          variable: this.parseVariable(),
          type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
          defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseValueLiteral(true) : undefined,
          directives: this.parseDirectives(true),
          loc: this.loc(start)
        };
      }
      /**
       * Variable : $ Name
       */
      ;

      _proto.parseVariable = function parseVariable() {
        var start = this._lexer.token;
        this.expectToken(TokenKind.DOLLAR);
        return {
          kind: Kind.VARIABLE,
          name: this.parseName(),
          loc: this.loc(start)
        };
      }
      /**
       * SelectionSet : { Selection+ }
       */
      ;

      _proto.parseSelectionSet = function parseSelectionSet() {
        var start = this._lexer.token;
        return {
          kind: Kind.SELECTION_SET,
          selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R),
          loc: this.loc(start)
        };
      }
      /**
       * Selection :
       *   - Field
       *   - FragmentSpread
       *   - InlineFragment
       */
      ;

      _proto.parseSelection = function parseSelection() {
        return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
      }
      /**
       * Field : Alias? Name Arguments? Directives? SelectionSet?
       *
       * Alias : Name :
       */
      ;

      _proto.parseField = function parseField() {
        var start = this._lexer.token;
        var nameOrAlias = this.parseName();
        var alias;
        var name;

        if (this.expectOptionalToken(TokenKind.COLON)) {
          alias = nameOrAlias;
          name = this.parseName();
        } else {
          name = nameOrAlias;
        }

        return {
          kind: Kind.FIELD,
          alias: alias,
          name: name,
          arguments: this.parseArguments(false),
          directives: this.parseDirectives(false),
          selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined,
          loc: this.loc(start)
        };
      }
      /**
       * Arguments[Const] : ( Argument[?Const]+ )
       */
      ;

      _proto.parseArguments = function parseArguments(isConst) {
        var item = isConst ? this.parseConstArgument : this.parseArgument;
        return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
      }
      /**
       * Argument[Const] : Name : Value[?Const]
       */
      ;

      _proto.parseArgument = function parseArgument() {
        var start = this._lexer.token;
        var name = this.parseName();
        this.expectToken(TokenKind.COLON);
        return {
          kind: Kind.ARGUMENT,
          name: name,
          value: this.parseValueLiteral(false),
          loc: this.loc(start)
        };
      };

      _proto.parseConstArgument = function parseConstArgument() {
        var start = this._lexer.token;
        return {
          kind: Kind.ARGUMENT,
          name: this.parseName(),
          value: (this.expectToken(TokenKind.COLON), this.parseValueLiteral(true)),
          loc: this.loc(start)
        };
      } // Implements the parsing rules in the Fragments section.

      /**
       * Corresponds to both FragmentSpread and InlineFragment in the spec.
       *
       * FragmentSpread : ... FragmentName Directives?
       *
       * InlineFragment : ... TypeCondition? Directives? SelectionSet
       */
      ;

      _proto.parseFragment = function parseFragment() {
        var start = this._lexer.token;
        this.expectToken(TokenKind.SPREAD);
        var hasTypeCondition = this.expectOptionalKeyword('on');

        if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
          return {
            kind: Kind.FRAGMENT_SPREAD,
            name: this.parseFragmentName(),
            directives: this.parseDirectives(false),
            loc: this.loc(start)
          };
        }

        return {
          kind: Kind.INLINE_FRAGMENT,
          typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet(),
          loc: this.loc(start)
        };
      }
      /**
       * FragmentDefinition :
       *   - fragment FragmentName on TypeCondition Directives? SelectionSet
       *
       * TypeCondition : NamedType
       */
      ;

      _proto.parseFragmentDefinition = function parseFragmentDefinition() {
        var start = this._lexer.token;
        this.expectKeyword('fragment'); // Experimental support for defining variables within fragments changes
        // the grammar of FragmentDefinition:
        //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet

        if (this._options.experimentalFragmentVariables) {
          return {
            kind: Kind.FRAGMENT_DEFINITION,
            name: this.parseFragmentName(),
            variableDefinitions: this.parseVariableDefinitions(),
            typeCondition: (this.expectKeyword('on'), this.parseNamedType()),
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet(),
            loc: this.loc(start)
          };
        }

        return {
          kind: Kind.FRAGMENT_DEFINITION,
          name: this.parseFragmentName(),
          typeCondition: (this.expectKeyword('on'), this.parseNamedType()),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet(),
          loc: this.loc(start)
        };
      }
      /**
       * FragmentName : Name but not `on`
       */
      ;

      _proto.parseFragmentName = function parseFragmentName() {
        if (this._lexer.token.value === 'on') {
          throw this.unexpected();
        }

        return this.parseName();
      } // Implements the parsing rules in the Values section.

      /**
       * Value[Const] :
       *   - [~Const] Variable
       *   - IntValue
       *   - FloatValue
       *   - StringValue
       *   - BooleanValue
       *   - NullValue
       *   - EnumValue
       *   - ListValue[?Const]
       *   - ObjectValue[?Const]
       *
       * BooleanValue : one of `true` `false`
       *
       * NullValue : `null`
       *
       * EnumValue : Name but not `true`, `false` or `null`
       */
      ;

      _proto.parseValueLiteral = function parseValueLiteral(isConst) {
        var token = this._lexer.token;

        switch (token.kind) {
          case TokenKind.BRACKET_L:
            return this.parseList(isConst);

          case TokenKind.BRACE_L:
            return this.parseObject(isConst);

          case TokenKind.INT:
            this._lexer.advance();

            return {
              kind: Kind.INT,
              value: token.value,
              loc: this.loc(token)
            };

          case TokenKind.FLOAT:
            this._lexer.advance();

            return {
              kind: Kind.FLOAT,
              value: token.value,
              loc: this.loc(token)
            };

          case TokenKind.STRING:
          case TokenKind.BLOCK_STRING:
            return this.parseStringLiteral();

          case TokenKind.NAME:
            if (token.value === 'true' || token.value === 'false') {
              this._lexer.advance();

              return {
                kind: Kind.BOOLEAN,
                value: token.value === 'true',
                loc: this.loc(token)
              };
            } else if (token.value === 'null') {
              this._lexer.advance();

              return {
                kind: Kind.NULL,
                loc: this.loc(token)
              };
            }

            this._lexer.advance();

            return {
              kind: Kind.ENUM,
              value: token.value,
              loc: this.loc(token)
            };

          case TokenKind.DOLLAR:
            if (!isConst) {
              return this.parseVariable();
            }

            break;
        }

        throw this.unexpected();
      };

      _proto.parseStringLiteral = function parseStringLiteral() {
        var token = this._lexer.token;

        this._lexer.advance();

        return {
          kind: Kind.STRING,
          value: token.value,
          block: token.kind === TokenKind.BLOCK_STRING,
          loc: this.loc(token)
        };
      }
      /**
       * ListValue[Const] :
       *   - [ ]
       *   - [ Value[?Const]+ ]
       */
      ;

      _proto.parseList = function parseList(isConst) {
        var _this = this;

        var start = this._lexer.token;

        var item = function item() {
          return _this.parseValueLiteral(isConst);
        };

        return {
          kind: Kind.LIST,
          values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),
          loc: this.loc(start)
        };
      }
      /**
       * ObjectValue[Const] :
       *   - { }
       *   - { ObjectField[?Const]+ }
       */
      ;

      _proto.parseObject = function parseObject(isConst) {
        var _this2 = this;

        var start = this._lexer.token;

        var item = function item() {
          return _this2.parseObjectField(isConst);
        };

        return {
          kind: Kind.OBJECT,
          fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),
          loc: this.loc(start)
        };
      }
      /**
       * ObjectField[Const] : Name : Value[?Const]
       */
      ;

      _proto.parseObjectField = function parseObjectField(isConst) {
        var start = this._lexer.token;
        var name = this.parseName();
        this.expectToken(TokenKind.COLON);
        return {
          kind: Kind.OBJECT_FIELD,
          name: name,
          value: this.parseValueLiteral(isConst),
          loc: this.loc(start)
        };
      } // Implements the parsing rules in the Directives section.

      /**
       * Directives[Const] : Directive[?Const]+
       */
      ;

      _proto.parseDirectives = function parseDirectives(isConst) {
        var directives = [];

        while (this.peek(TokenKind.AT)) {
          directives.push(this.parseDirective(isConst));
        }

        return directives;
      }
      /**
       * Directive[Const] : @ Name Arguments[?Const]?
       */
      ;

      _proto.parseDirective = function parseDirective(isConst) {
        var start = this._lexer.token;
        this.expectToken(TokenKind.AT);
        return {
          kind: Kind.DIRECTIVE,
          name: this.parseName(),
          arguments: this.parseArguments(isConst),
          loc: this.loc(start)
        };
      } // Implements the parsing rules in the Types section.

      /**
       * Type :
       *   - NamedType
       *   - ListType
       *   - NonNullType
       */
      ;

      _proto.parseTypeReference = function parseTypeReference() {
        var start = this._lexer.token;
        var type;

        if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
          type = this.parseTypeReference();
          this.expectToken(TokenKind.BRACKET_R);
          type = {
            kind: Kind.LIST_TYPE,
            type: type,
            loc: this.loc(start)
          };
        } else {
          type = this.parseNamedType();
        }

        if (this.expectOptionalToken(TokenKind.BANG)) {
          return {
            kind: Kind.NON_NULL_TYPE,
            type: type,
            loc: this.loc(start)
          };
        }

        return type;
      }
      /**
       * NamedType : Name
       */
      ;

      _proto.parseNamedType = function parseNamedType() {
        var start = this._lexer.token;
        return {
          kind: Kind.NAMED_TYPE,
          name: this.parseName(),
          loc: this.loc(start)
        };
      } // Implements the parsing rules in the Type Definition section.

      /**
       * TypeSystemDefinition :
       *   - SchemaDefinition
       *   - TypeDefinition
       *   - DirectiveDefinition
       *
       * TypeDefinition :
       *   - ScalarTypeDefinition
       *   - ObjectTypeDefinition
       *   - InterfaceTypeDefinition
       *   - UnionTypeDefinition
       *   - EnumTypeDefinition
       *   - InputObjectTypeDefinition
       */
      ;

      _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {
        // Many definitions begin with a description and require a lookahead.
        var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;

        if (keywordToken.kind === TokenKind.NAME) {
          switch (keywordToken.value) {
            case 'schema':
              return this.parseSchemaDefinition();

            case 'scalar':
              return this.parseScalarTypeDefinition();

            case 'type':
              return this.parseObjectTypeDefinition();

            case 'interface':
              return this.parseInterfaceTypeDefinition();

            case 'union':
              return this.parseUnionTypeDefinition();

            case 'enum':
              return this.parseEnumTypeDefinition();

            case 'input':
              return this.parseInputObjectTypeDefinition();

            case 'directive':
              return this.parseDirectiveDefinition();
          }
        }

        throw this.unexpected(keywordToken);
      };

      _proto.peekDescription = function peekDescription() {
        return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
      }
      /**
       * Description : StringValue
       */
      ;

      _proto.parseDescription = function parseDescription() {
        if (this.peekDescription()) {
          return this.parseStringLiteral();
        }
      }
      /**
       * SchemaDefinition : schema Directives[Const]? { OperationTypeDefinition+ }
       */
      ;

      _proto.parseSchemaDefinition = function parseSchemaDefinition() {
        var start = this._lexer.token;
        this.expectKeyword('schema');
        var directives = this.parseDirectives(true);
        var operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
        return {
          kind: Kind.SCHEMA_DEFINITION,
          directives: directives,
          operationTypes: operationTypes,
          loc: this.loc(start)
        };
      }
      /**
       * OperationTypeDefinition : OperationType : NamedType
       */
      ;

      _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {
        var start = this._lexer.token;
        var operation = this.parseOperationType();
        this.expectToken(TokenKind.COLON);
        var type = this.parseNamedType();
        return {
          kind: Kind.OPERATION_TYPE_DEFINITION,
          operation: operation,
          type: type,
          loc: this.loc(start)
        };
      }
      /**
       * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
       */
      ;

      _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword('scalar');
        var name = this.parseName();
        var directives = this.parseDirectives(true);
        return {
          kind: Kind.SCALAR_TYPE_DEFINITION,
          description: description,
          name: name,
          directives: directives,
          loc: this.loc(start)
        };
      }
      /**
       * ObjectTypeDefinition :
       *   Description?
       *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
       */
      ;

      _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword('type');
        var name = this.parseName();
        var interfaces = this.parseImplementsInterfaces();
        var directives = this.parseDirectives(true);
        var fields = this.parseFieldsDefinition();
        return {
          kind: Kind.OBJECT_TYPE_DEFINITION,
          description: description,
          name: name,
          interfaces: interfaces,
          directives: directives,
          fields: fields,
          loc: this.loc(start)
        };
      }
      /**
       * ImplementsInterfaces :
       *   - implements `&`? NamedType
       *   - ImplementsInterfaces & NamedType
       */
      ;

      _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {
        var types = [];

        if (this.expectOptionalKeyword('implements')) {
          // Optional leading ampersand
          this.expectOptionalToken(TokenKind.AMP);

          do {
            types.push(this.parseNamedType());
          } while (this.expectOptionalToken(TokenKind.AMP) || // Legacy support for the SDL?
          this._options.allowLegacySDLImplementsInterfaces && this.peek(TokenKind.NAME));
        }

        return types;
      }
      /**
       * FieldsDefinition : { FieldDefinition+ }
       */
      ;

      _proto.parseFieldsDefinition = function parseFieldsDefinition() {
        // Legacy support for the SDL?
        if (this._options.allowLegacySDLEmptyFields && this.peek(TokenKind.BRACE_L) && this._lexer.lookahead().kind === TokenKind.BRACE_R) {
          this._lexer.advance();

          this._lexer.advance();

          return [];
        }

        return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);
      }
      /**
       * FieldDefinition :
       *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
       */
      ;

      _proto.parseFieldDefinition = function parseFieldDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        var name = this.parseName();
        var args = this.parseArgumentDefs();
        this.expectToken(TokenKind.COLON);
        var type = this.parseTypeReference();
        var directives = this.parseDirectives(true);
        return {
          kind: Kind.FIELD_DEFINITION,
          description: description,
          name: name,
          arguments: args,
          type: type,
          directives: directives,
          loc: this.loc(start)
        };
      }
      /**
       * ArgumentsDefinition : ( InputValueDefinition+ )
       */
      ;

      _proto.parseArgumentDefs = function parseArgumentDefs() {
        return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);
      }
      /**
       * InputValueDefinition :
       *   - Description? Name : Type DefaultValue? Directives[Const]?
       */
      ;

      _proto.parseInputValueDef = function parseInputValueDef() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        var name = this.parseName();
        this.expectToken(TokenKind.COLON);
        var type = this.parseTypeReference();
        var defaultValue;

        if (this.expectOptionalToken(TokenKind.EQUALS)) {
          defaultValue = this.parseValueLiteral(true);
        }

        var directives = this.parseDirectives(true);
        return {
          kind: Kind.INPUT_VALUE_DEFINITION,
          description: description,
          name: name,
          type: type,
          defaultValue: defaultValue,
          directives: directives,
          loc: this.loc(start)
        };
      }
      /**
       * InterfaceTypeDefinition :
       *   - Description? interface Name Directives[Const]? FieldsDefinition?
       */
      ;

      _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword('interface');
        var name = this.parseName();
        var directives = this.parseDirectives(true);
        var fields = this.parseFieldsDefinition();
        return {
          kind: Kind.INTERFACE_TYPE_DEFINITION,
          description: description,
          name: name,
          directives: directives,
          fields: fields,
          loc: this.loc(start)
        };
      }
      /**
       * UnionTypeDefinition :
       *   - Description? union Name Directives[Const]? UnionMemberTypes?
       */
      ;

      _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword('union');
        var name = this.parseName();
        var directives = this.parseDirectives(true);
        var types = this.parseUnionMemberTypes();
        return {
          kind: Kind.UNION_TYPE_DEFINITION,
          description: description,
          name: name,
          directives: directives,
          types: types,
          loc: this.loc(start)
        };
      }
      /**
       * UnionMemberTypes :
       *   - = `|`? NamedType
       *   - UnionMemberTypes | NamedType
       */
      ;

      _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {
        var types = [];

        if (this.expectOptionalToken(TokenKind.EQUALS)) {
          // Optional leading pipe
          this.expectOptionalToken(TokenKind.PIPE);

          do {
            types.push(this.parseNamedType());
          } while (this.expectOptionalToken(TokenKind.PIPE));
        }

        return types;
      }
      /**
       * EnumTypeDefinition :
       *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
       */
      ;

      _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword('enum');
        var name = this.parseName();
        var directives = this.parseDirectives(true);
        var values = this.parseEnumValuesDefinition();
        return {
          kind: Kind.ENUM_TYPE_DEFINITION,
          description: description,
          name: name,
          directives: directives,
          values: values,
          loc: this.loc(start)
        };
      }
      /**
       * EnumValuesDefinition : { EnumValueDefinition+ }
       */
      ;

      _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {
        return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);
      }
      /**
       * EnumValueDefinition : Description? EnumValue Directives[Const]?
       *
       * EnumValue : Name
       */
      ;

      _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        var name = this.parseName();
        var directives = this.parseDirectives(true);
        return {
          kind: Kind.ENUM_VALUE_DEFINITION,
          description: description,
          name: name,
          directives: directives,
          loc: this.loc(start)
        };
      }
      /**
       * InputObjectTypeDefinition :
       *   - Description? input Name Directives[Const]? InputFieldsDefinition?
       */
      ;

      _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword('input');
        var name = this.parseName();
        var directives = this.parseDirectives(true);
        var fields = this.parseInputFieldsDefinition();
        return {
          kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
          description: description,
          name: name,
          directives: directives,
          fields: fields,
          loc: this.loc(start)
        };
      }
      /**
       * InputFieldsDefinition : { InputValueDefinition+ }
       */
      ;

      _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {
        return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);
      }
      /**
       * TypeSystemExtension :
       *   - SchemaExtension
       *   - TypeExtension
       *
       * TypeExtension :
       *   - ScalarTypeExtension
       *   - ObjectTypeExtension
       *   - InterfaceTypeExtension
       *   - UnionTypeExtension
       *   - EnumTypeExtension
       *   - InputObjectTypeDefinition
       */
      ;

      _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {
        var keywordToken = this._lexer.lookahead();

        if (keywordToken.kind === TokenKind.NAME) {
          switch (keywordToken.value) {
            case 'schema':
              return this.parseSchemaExtension();

            case 'scalar':
              return this.parseScalarTypeExtension();

            case 'type':
              return this.parseObjectTypeExtension();

            case 'interface':
              return this.parseInterfaceTypeExtension();

            case 'union':
              return this.parseUnionTypeExtension();

            case 'enum':
              return this.parseEnumTypeExtension();

            case 'input':
              return this.parseInputObjectTypeExtension();
          }
        }

        throw this.unexpected(keywordToken);
      }
      /**
       * SchemaExtension :
       *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
       *  - extend schema Directives[Const]
       */
      ;

      _proto.parseSchemaExtension = function parseSchemaExtension() {
        var start = this._lexer.token;
        this.expectKeyword('extend');
        this.expectKeyword('schema');
        var directives = this.parseDirectives(true);
        var operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);

        if (directives.length === 0 && operationTypes.length === 0) {
          throw this.unexpected();
        }

        return {
          kind: Kind.SCHEMA_EXTENSION,
          directives: directives,
          operationTypes: operationTypes,
          loc: this.loc(start)
        };
      }
      /**
       * ScalarTypeExtension :
       *   - extend scalar Name Directives[Const]
       */
      ;

      _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {
        var start = this._lexer.token;
        this.expectKeyword('extend');
        this.expectKeyword('scalar');
        var name = this.parseName();
        var directives = this.parseDirectives(true);

        if (directives.length === 0) {
          throw this.unexpected();
        }

        return {
          kind: Kind.SCALAR_TYPE_EXTENSION,
          name: name,
          directives: directives,
          loc: this.loc(start)
        };
      }
      /**
       * ObjectTypeExtension :
       *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
       *  - extend type Name ImplementsInterfaces? Directives[Const]
       *  - extend type Name ImplementsInterfaces
       */
      ;

      _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {
        var start = this._lexer.token;
        this.expectKeyword('extend');
        this.expectKeyword('type');
        var name = this.parseName();
        var interfaces = this.parseImplementsInterfaces();
        var directives = this.parseDirectives(true);
        var fields = this.parseFieldsDefinition();

        if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }

        return {
          kind: Kind.OBJECT_TYPE_EXTENSION,
          name: name,
          interfaces: interfaces,
          directives: directives,
          fields: fields,
          loc: this.loc(start)
        };
      }
      /**
       * InterfaceTypeExtension :
       *   - extend interface Name Directives[Const]? FieldsDefinition
       *   - extend interface Name Directives[Const]
       */
      ;

      _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {
        var start = this._lexer.token;
        this.expectKeyword('extend');
        this.expectKeyword('interface');
        var name = this.parseName();
        var directives = this.parseDirectives(true);
        var fields = this.parseFieldsDefinition();

        if (directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }

        return {
          kind: Kind.INTERFACE_TYPE_EXTENSION,
          name: name,
          directives: directives,
          fields: fields,
          loc: this.loc(start)
        };
      }
      /**
       * UnionTypeExtension :
       *   - extend union Name Directives[Const]? UnionMemberTypes
       *   - extend union Name Directives[Const]
       */
      ;

      _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {
        var start = this._lexer.token;
        this.expectKeyword('extend');
        this.expectKeyword('union');
        var name = this.parseName();
        var directives = this.parseDirectives(true);
        var types = this.parseUnionMemberTypes();

        if (directives.length === 0 && types.length === 0) {
          throw this.unexpected();
        }

        return {
          kind: Kind.UNION_TYPE_EXTENSION,
          name: name,
          directives: directives,
          types: types,
          loc: this.loc(start)
        };
      }
      /**
       * EnumTypeExtension :
       *   - extend enum Name Directives[Const]? EnumValuesDefinition
       *   - extend enum Name Directives[Const]
       */
      ;

      _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {
        var start = this._lexer.token;
        this.expectKeyword('extend');
        this.expectKeyword('enum');
        var name = this.parseName();
        var directives = this.parseDirectives(true);
        var values = this.parseEnumValuesDefinition();

        if (directives.length === 0 && values.length === 0) {
          throw this.unexpected();
        }

        return {
          kind: Kind.ENUM_TYPE_EXTENSION,
          name: name,
          directives: directives,
          values: values,
          loc: this.loc(start)
        };
      }
      /**
       * InputObjectTypeExtension :
       *   - extend input Name Directives[Const]? InputFieldsDefinition
       *   - extend input Name Directives[Const]
       */
      ;

      _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {
        var start = this._lexer.token;
        this.expectKeyword('extend');
        this.expectKeyword('input');
        var name = this.parseName();
        var directives = this.parseDirectives(true);
        var fields = this.parseInputFieldsDefinition();

        if (directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }

        return {
          kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
          name: name,
          directives: directives,
          fields: fields,
          loc: this.loc(start)
        };
      }
      /**
       * DirectiveDefinition :
       *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
       */
      ;

      _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword('directive');
        this.expectToken(TokenKind.AT);
        var name = this.parseName();
        var args = this.parseArgumentDefs();
        var repeatable = this.expectOptionalKeyword('repeatable');
        this.expectKeyword('on');
        var locations = this.parseDirectiveLocations();
        return {
          kind: Kind.DIRECTIVE_DEFINITION,
          description: description,
          name: name,
          arguments: args,
          repeatable: repeatable,
          locations: locations,
          loc: this.loc(start)
        };
      }
      /**
       * DirectiveLocations :
       *   - `|`? DirectiveLocation
       *   - DirectiveLocations | DirectiveLocation
       */
      ;

      _proto.parseDirectiveLocations = function parseDirectiveLocations() {
        // Optional leading pipe
        this.expectOptionalToken(TokenKind.PIPE);
        var locations = [];

        do {
          locations.push(this.parseDirectiveLocation());
        } while (this.expectOptionalToken(TokenKind.PIPE));

        return locations;
      }
      /*
       * DirectiveLocation :
       *   - ExecutableDirectiveLocation
       *   - TypeSystemDirectiveLocation
       *
       * ExecutableDirectiveLocation : one of
       *   `QUERY`
       *   `MUTATION`
       *   `SUBSCRIPTION`
       *   `FIELD`
       *   `FRAGMENT_DEFINITION`
       *   `FRAGMENT_SPREAD`
       *   `INLINE_FRAGMENT`
       *
       * TypeSystemDirectiveLocation : one of
       *   `SCHEMA`
       *   `SCALAR`
       *   `OBJECT`
       *   `FIELD_DEFINITION`
       *   `ARGUMENT_DEFINITION`
       *   `INTERFACE`
       *   `UNION`
       *   `ENUM`
       *   `ENUM_VALUE`
       *   `INPUT_OBJECT`
       *   `INPUT_FIELD_DEFINITION`
       */
      ;

      _proto.parseDirectiveLocation = function parseDirectiveLocation() {
        var start = this._lexer.token;
        var name = this.parseName();

        if (DirectiveLocation[name.value] !== undefined) {
          return name;
        }

        throw this.unexpected(start);
      } // Core parsing utility functions

      /**
       * Returns a location object, used to identify the place in
       * the source that created a given parsed object.
       */
      ;

      _proto.loc = function loc(startToken) {
        if (!this._options.noLocation) {
          return new Loc(startToken, this._lexer.lastToken, this._lexer.source);
        }
      }
      /**
       * Determines if the next token is of a given kind
       */
      ;

      _proto.peek = function peek(kind) {
        return this._lexer.token.kind === kind;
      }
      /**
       * If the next token is of the given kind, return that token after advancing
       * the lexer. Otherwise, do not change the parser state and throw an error.
       */
      ;

      _proto.expectToken = function expectToken(kind) {
        var token = this._lexer.token;

        if (token.kind === kind) {
          this._lexer.advance();

          return token;
        }

        throw syntaxError(this._lexer.source, token.start, "Expected ".concat(kind, ", found ").concat(getTokenDesc(token)));
      }
      /**
       * If the next token is of the given kind, return that token after advancing
       * the lexer. Otherwise, do not change the parser state and return undefined.
       */
      ;

      _proto.expectOptionalToken = function expectOptionalToken(kind) {
        var token = this._lexer.token;

        if (token.kind === kind) {
          this._lexer.advance();

          return token;
        }

        return undefined;
      }
      /**
       * If the next token is a given keyword, advance the lexer.
       * Otherwise, do not change the parser state and throw an error.
       */
      ;

      _proto.expectKeyword = function expectKeyword(value) {
        var token = this._lexer.token;

        if (token.kind === TokenKind.NAME && token.value === value) {
          this._lexer.advance();
        } else {
          throw syntaxError(this._lexer.source, token.start, "Expected \"".concat(value, "\", found ").concat(getTokenDesc(token)));
        }
      }
      /**
       * If the next token is a given keyword, return "true" after advancing
       * the lexer. Otherwise, do not change the parser state and return "false".
       */
      ;

      _proto.expectOptionalKeyword = function expectOptionalKeyword(value) {
        var token = this._lexer.token;

        if (token.kind === TokenKind.NAME && token.value === value) {
          this._lexer.advance();

          return true;
        }

        return false;
      }
      /**
       * Helper function for creating an error when an unexpected lexed token
       * is encountered.
       */
      ;

      _proto.unexpected = function unexpected(atToken) {
        var token = atToken || this._lexer.token;
        return syntaxError(this._lexer.source, token.start, "Unexpected ".concat(getTokenDesc(token)));
      }
      /**
       * Returns a possibly empty list of parse nodes, determined by
       * the parseFn. This list begins with a lex token of openKind
       * and ends with a lex token of closeKind. Advances the parser
       * to the next lex token after the closing token.
       */
      ;

      _proto.any = function any(openKind, parseFn, closeKind) {
        this.expectToken(openKind);
        var nodes = [];

        while (!this.expectOptionalToken(closeKind)) {
          nodes.push(parseFn.call(this));
        }

        return nodes;
      }
      /**
       * Returns a list of parse nodes, determined by the parseFn.
       * It can be empty only if open token is missing otherwise it will always
       * return non-empty list that begins with a lex token of openKind and ends
       * with a lex token of closeKind. Advances the parser to the next lex token
       * after the closing token.
       */
      ;

      _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {
        if (this.expectOptionalToken(openKind)) {
          var nodes = [];

          do {
            nodes.push(parseFn.call(this));
          } while (!this.expectOptionalToken(closeKind));

          return nodes;
        }

        return [];
      }
      /**
       * Returns a non-empty list of parse nodes, determined by
       * the parseFn. This list begins with a lex token of openKind
       * and ends with a lex token of closeKind. Advances the parser
       * to the next lex token after the closing token.
       */
      ;

      _proto.many = function many(openKind, parseFn, closeKind) {
        this.expectToken(openKind);
        var nodes = [];

        do {
          nodes.push(parseFn.call(this));
        } while (!this.expectOptionalToken(closeKind));

        return nodes;
      };

      return Parser;
    }();

    function Loc(startToken, endToken, source) {
      this.start = startToken.start;
      this.end = endToken.end;
      this.startToken = startToken;
      this.endToken = endToken;
      this.source = source;
    } // Print a simplified form when appearing in JSON/util.inspect.


    defineToJSON(Loc, function () {
      return {
        start: this.start,
        end: this.end
      };
    });
    /**
     * A helper function to describe a token as a string for debugging
     */

    function getTokenDesc(token) {
      var value = token.value;
      return value ? "".concat(token.kind, " \"").concat(value, "\"") : token.kind;
    }

    var parser = /*#__PURE__*/Object.freeze({
        __proto__: null,
        parse: parse,
        parseValue: parseValue,
        parseType: parseType
    });

    var parser$1 = getCjsExportFromNamespace(parser);

    var parse$1 = parser$1.parse;

    // Strip insignificant whitespace
    // Note that this could do a lot more, such as reorder fields etc.
    function normalize(string) {
      return string.replace(/[\s,]+/g, ' ').trim();
    }

    // A map docString -> graphql document
    var docCache = {};

    // A map fragmentName -> [normalized source]
    var fragmentSourceMap = {};

    function cacheKeyFromLoc(loc) {
      return normalize(loc.source.body.substring(loc.start, loc.end));
    }

    // For testing.
    function resetCaches() {
      docCache = {};
      fragmentSourceMap = {};
    }

    // Take a unstripped parsed document (query/mutation or even fragment), and
    // check all fragment definitions, checking for name->source uniqueness.
    // We also want to make sure only unique fragments exist in the document.
    var printFragmentWarnings = true;
    function processFragments(ast) {
      var astFragmentMap = {};
      var definitions = [];

      for (var i = 0; i < ast.definitions.length; i++) {
        var fragmentDefinition = ast.definitions[i];

        if (fragmentDefinition.kind === 'FragmentDefinition') {
          var fragmentName = fragmentDefinition.name.value;
          var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);

          // We know something about this fragment
          if (fragmentSourceMap.hasOwnProperty(fragmentName) && !fragmentSourceMap[fragmentName][sourceKey]) {

            // this is a problem because the app developer is trying to register another fragment with
            // the same name as one previously registered. So, we tell them about it.
            if (printFragmentWarnings) {
              console.warn("Warning: fragment with name " + fragmentName + " already exists.\n"
                + "graphql-tag enforces all fragment names across your application to be unique; read more about\n"
                + "this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
            }

            fragmentSourceMap[fragmentName][sourceKey] = true;

          } else if (!fragmentSourceMap.hasOwnProperty(fragmentName)) {
            fragmentSourceMap[fragmentName] = {};
            fragmentSourceMap[fragmentName][sourceKey] = true;
          }

          if (!astFragmentMap[sourceKey]) {
            astFragmentMap[sourceKey] = true;
            definitions.push(fragmentDefinition);
          }
        } else {
          definitions.push(fragmentDefinition);
        }
      }

      ast.definitions = definitions;
      return ast;
    }

    function disableFragmentWarnings() {
      printFragmentWarnings = false;
    }

    function stripLoc(doc, removeLocAtThisLevel) {
      var docType = Object.prototype.toString.call(doc);

      if (docType === '[object Array]') {
        return doc.map(function (d) {
          return stripLoc(d, removeLocAtThisLevel);
        });
      }

      if (docType !== '[object Object]') {
        throw new Error('Unexpected input.');
      }

      // We don't want to remove the root loc field so we can use it
      // for fragment substitution (see below)
      if (removeLocAtThisLevel && doc.loc) {
        delete doc.loc;
      }

      // https://github.com/apollographql/graphql-tag/issues/40
      if (doc.loc) {
        delete doc.loc.startToken;
        delete doc.loc.endToken;
      }

      var keys = Object.keys(doc);
      var key;
      var value;
      var valueType;

      for (key in keys) {
        if (keys.hasOwnProperty(key)) {
          value = doc[keys[key]];
          valueType = Object.prototype.toString.call(value);

          if (valueType === '[object Object]' || valueType === '[object Array]') {
            doc[keys[key]] = stripLoc(value, true);
          }
        }
      }

      return doc;
    }

    var experimentalFragmentVariables = false;
    function parseDocument(doc) {
      var cacheKey = normalize(doc);

      if (docCache[cacheKey]) {
        return docCache[cacheKey];
      }

      var parsed = parse$1(doc, { experimentalFragmentVariables: experimentalFragmentVariables });
      if (!parsed || parsed.kind !== 'Document') {
        throw new Error('Not a valid GraphQL document.');
      }

      // check that all "new" fragments inside the documents are consistent with
      // existing fragments of the same name
      parsed = processFragments(parsed);
      parsed = stripLoc(parsed, false);
      docCache[cacheKey] = parsed;

      return parsed;
    }

    function enableExperimentalFragmentVariables() {
      experimentalFragmentVariables = true;
    }

    function disableExperimentalFragmentVariables() {
      experimentalFragmentVariables = false;
    }

    // XXX This should eventually disallow arbitrary string interpolation, like Relay does
    function gql(/* arguments */) {
      var args = Array.prototype.slice.call(arguments);

      var literals = args[0];

      // We always get literals[0] and then matching post literals for each arg given
      var result = (typeof(literals) === "string") ? literals : literals[0];

      for (var i = 1; i < args.length; i++) {
        if (args[i] && args[i].kind && args[i].kind === 'Document') {
          result += args[i].loc.source.body;
        } else {
          result += args[i];
        }

        result += literals[i];
      }

      return parseDocument(result);
    }

    // Support typescript, which isn't as nice as Babel about default exports
    gql.default = gql;
    gql.resetCaches = resetCaches;
    gql.disableFragmentWarnings = disableFragmentWarnings;
    gql.enableExperimentalFragmentVariables = enableExperimentalFragmentVariables;
    gql.disableExperimentalFragmentVariables = disableExperimentalFragmentVariables;

    var src$1 = gql;

    const getProblems = src$1`
  query getAllProblems {
    allProblems {
      id
      problemName
      description
      problemTests
      tags
      timelimit
      datalimit
      solution
    }
  }
`;

    const problemsByAuthor = src$1`
  query problemsByAuthor($email: String) {
    problemsByAuthor(email: $email) {
      id
      problemName
      problemTests
      description
      difficultyLevel
      email
    }
  }
`;

    const getToken = src$1`
  query getToken($id: ID!) {
    getToken(id: $id) {
      token
    }
  }
`;

    const allTests = src$1`
  query getTest {
    allTests {
      id
      testName
      difficultyLevel
      email
      createdAt
      problems {
        id
      }
    }
  }
`;

    const testsByAuthor = src$1`
  query testsByAuthor($email: String) {
    testsByAuthor(email: $email) {
      id
      testName
      difficultyLevel
    }
  }
`;

    const testByToken = src$1`
  query getTest($token: String) {
    testByToken(token: $token) {
      id
      problems {
        id
        problemName
        description
      }
    }
  }
`;

    const sendMail = src$1`
  mutation mailSender($mailBody: String, $email: String) {
    sendMail(mailBody: $mailBody, email: $email) {
      success
      message
    }
  }
`;

    const addProblem = src$1`
  mutation addNewProblem(
    $problemName: String
    $description: String
    $problemTests: JSON
    $email: String
    $timelimit: String
    $datalimit: String
    $tags: String
    $solution: String
  ) {
    addProblem(
      data: {
        problemName: $problemName
        description: $description
        problemTests: $problemTests
        email: $email
        timelimit: $timelimit
        datalimit: $datalimit
        tags: $tags
        solution: $solution
      }
    ) {
      success
      message
      problems {
        id
        problemName
        problemTests
        description
        email
      }
    }
  }
`;

    const deleteProblem = src$1`
  mutation deleteProblem($id: ID) {
    deleteProblem(id: $id) {
      id
      problemName
      problemTests
      description
    }
  }
`;

    const updateProblem = src$1`
  mutation updateProblem(
    $id: ID!
    $problemName: String
    $description: String
    $problemTests: JSON
    $solution: String
    $timelimit: String
    $datalimit: String
    $tags: String
  ) {
    updateProblem(
      id: $id
      data: {
        problemName: $problemName
        description: $description
        problemTests: $problemTests
        solution: $solution
        datalimit: $datalimit
        timelimit: $timelimit
        tags: $tags
      }
    ) {
      success
      message
    }
  }
`;

    const addTest = src$1`
  mutation addNewTest(
    $testName: String
    $difficultyLevel: String
    $email: String
    $problems: JSON
    $tags: String
    $timelimit: String
  ) {
    addTest(
      data: {
        testName: $testName
        difficultyLevel: $difficultyLevel
        email: $email
        tags: $tags
        timelimit: $timelimit
        problems: $problems
      }
    ) {
      success
      message
    }
  }
`;

    const deleteTest = src$1`
  mutation deleteTest($id: ID) {
    deleteTest(id: $id) {
      id
      testName
      difficultyLevel
      problems {
        id
        problemName
        problemTests
        description
        difficultyLevel
        email
      }
    }
  }
`;
    const updateTest = src$1`
  mutation updateTest(
    $id: ID
    $testName: String
    $difficultyLevel: String
    $problems: [ID]
  ) {
    updateTest(
      id: $id
      data: {
        testName: $testName
        difficultyLevel: $difficultyLevel
        problems: $problems
      }
    ) {
      success
      message
    }
  }
`;

    const addUser = src$1`
  mutation addNewUser($name: String, $email: String, $collegeName: String) {
    addUser(data: { name: $name, email: $email, collegeName: $collegeName }) {
      success
      message
      user {
        name
        id
        collegeName
      }
    }
  }
`;
    const addTestProblem = src$1`
  mutation addTestProblem($t_id: Int, $p_id: Int) {
    addTestProblem(data: { t_id: $t_id, p_id: $p_id }) {
      success
      message
      test {
        id
        testName
        difficultyLevel
        problems {
          id
          problemName
          problemTests
          description
          difficultyLevel
          email
        }
      }
    }
  }
`;

    const getProblemById = src$1`
  query getProblemById($id: ID!) {
    problemById(id: $id) {
      id
      description
      createdAt
      tags
      timelimit
      datalimit
      problemName
      problemTests
      solution
    }
  }
`;

    const getTestById = src$1`
  query getTestById($id: ID!) {
    testById(id: $id) {
      id
      testName
      difficultyLevel
      problems {
        id
        problemName
        problemTests
        description
        email
      }
    }
  }
`;

    const getAttempts = src$1`
  query getAttempts($id: ID) {
    getAttempt(id: $id) {
      id
      user {
        id
        email
        name
        collegeName
      }
      solutions
      attemptTime
      score
    }
  }
`;
    const updateAttempt = src$1`
  mutation updateAttempt($id: ID, $u_id: ID, $solutions: JSON) {
    updateAttempt(data: { u_id: $u_id, id: $id, solutions: $solutions }) {
      success
      message
    }
  }
`;
    const addAttempt = src$1`
  mutation addAttempt($u_id: ID, $t_id: ID, $solutions: JSON) {
    addAttempt(data: { u_id: $u_id, t_id: $t_id, solutions: $solutions }) {
      success
      message
      id
    }
  }
`;

    const checkIfAvailable = src$1`
  mutation checkIfAvailable($problemName: String) {
    checkProblemIfExists(problemName: $problemName) {
      success
      message
    }
  }
`;
    const checkTestIfAvailable = src$1`
  mutation checkTestIfAvailable($testName: String) {
    checkTestIfExists(testName: $testName) {
      success
      message
    }
  }
`;
    const apolloClient = {
      checkTestIfAvailable,
      checkIfAvailable,
      getAttempts,
      updateAttempt,
      addAttempt,
      sendMail,
      getTestById,
      getProblems,
      getProblemById,
      testsByAuthor,
      deleteProblem,
      updateProblem,
      updateTest,
      allTests,
      problemsByAuthor,
      addProblem,
      addTest,
      addTestProblem,
      deleteTest,
      addUser,
      getToken,
      testByToken,
    };

    var QueryDocumentKeys = {
      Name: [],
      Document: ['definitions'],
      OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],
      VariableDefinition: ['variable', 'type', 'defaultValue', 'directives'],
      Variable: ['name'],
      SelectionSet: ['selections'],
      Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],
      Argument: ['name', 'value'],
      FragmentSpread: ['name', 'directives'],
      InlineFragment: ['typeCondition', 'directives', 'selectionSet'],
      FragmentDefinition: ['name', // Note: fragment variable definitions are experimental and may be changed
      // or removed in the future.
      'variableDefinitions', 'typeCondition', 'directives', 'selectionSet'],
      IntValue: [],
      FloatValue: [],
      StringValue: [],
      BooleanValue: [],
      NullValue: [],
      EnumValue: [],
      ListValue: ['values'],
      ObjectValue: ['fields'],
      ObjectField: ['name', 'value'],
      Directive: ['name', 'arguments'],
      NamedType: ['name'],
      ListType: ['type'],
      NonNullType: ['type'],
      SchemaDefinition: ['directives', 'operationTypes'],
      OperationTypeDefinition: ['type'],
      ScalarTypeDefinition: ['description', 'name', 'directives'],
      ObjectTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],
      FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],
      InputValueDefinition: ['description', 'name', 'type', 'defaultValue', 'directives'],
      InterfaceTypeDefinition: ['description', 'name', 'directives', 'fields'],
      UnionTypeDefinition: ['description', 'name', 'directives', 'types'],
      EnumTypeDefinition: ['description', 'name', 'directives', 'values'],
      EnumValueDefinition: ['description', 'name', 'directives'],
      InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],
      DirectiveDefinition: ['description', 'name', 'arguments', 'locations'],
      SchemaExtension: ['directives', 'operationTypes'],
      ScalarTypeExtension: ['name', 'directives'],
      ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],
      InterfaceTypeExtension: ['name', 'directives', 'fields'],
      UnionTypeExtension: ['name', 'directives', 'types'],
      EnumTypeExtension: ['name', 'directives', 'values'],
      InputObjectTypeExtension: ['name', 'directives', 'fields']
    };
    var BREAK = Object.freeze({});
    /**
     * visit() will walk through an AST using a depth first traversal, calling
     * the visitor's enter function at each node in the traversal, and calling the
     * leave function after visiting that node and all of its child nodes.
     *
     * By returning different values from the enter and leave functions, the
     * behavior of the visitor can be altered, including skipping over a sub-tree of
     * the AST (by returning false), editing the AST by returning a value or null
     * to remove the value, or to stop the whole traversal by returning BREAK.
     *
     * When using visit() to edit an AST, the original AST will not be modified, and
     * a new version of the AST with the changes applied will be returned from the
     * visit function.
     *
     *     const editedAST = visit(ast, {
     *       enter(node, key, parent, path, ancestors) {
     *         // @return
     *         //   undefined: no action
     *         //   false: skip visiting this node
     *         //   visitor.BREAK: stop visiting altogether
     *         //   null: delete this node
     *         //   any value: replace this node with the returned value
     *       },
     *       leave(node, key, parent, path, ancestors) {
     *         // @return
     *         //   undefined: no action
     *         //   false: no action
     *         //   visitor.BREAK: stop visiting altogether
     *         //   null: delete this node
     *         //   any value: replace this node with the returned value
     *       }
     *     });
     *
     * Alternatively to providing enter() and leave() functions, a visitor can
     * instead provide functions named the same as the kinds of AST nodes, or
     * enter/leave visitors at a named key, leading to four permutations of
     * visitor API:
     *
     * 1) Named visitors triggered when entering a node a specific kind.
     *
     *     visit(ast, {
     *       Kind(node) {
     *         // enter the "Kind" node
     *       }
     *     })
     *
     * 2) Named visitors that trigger upon entering and leaving a node of
     *    a specific kind.
     *
     *     visit(ast, {
     *       Kind: {
     *         enter(node) {
     *           // enter the "Kind" node
     *         }
     *         leave(node) {
     *           // leave the "Kind" node
     *         }
     *       }
     *     })
     *
     * 3) Generic visitors that trigger upon entering and leaving any node.
     *
     *     visit(ast, {
     *       enter(node) {
     *         // enter any node
     *       },
     *       leave(node) {
     *         // leave any node
     *       }
     *     })
     *
     * 4) Parallel visitors for entering and leaving nodes of a specific kind.
     *
     *     visit(ast, {
     *       enter: {
     *         Kind(node) {
     *           // enter the "Kind" node
     *         }
     *       },
     *       leave: {
     *         Kind(node) {
     *           // leave the "Kind" node
     *         }
     *       }
     *     })
     */

    function visit(root, visitor) {
      var visitorKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : QueryDocumentKeys;

      /* eslint-disable no-undef-init */
      var stack = undefined;
      var inArray = Array.isArray(root);
      var keys = [root];
      var index = -1;
      var edits = [];
      var node = undefined;
      var key = undefined;
      var parent = undefined;
      var path = [];
      var ancestors = [];
      var newRoot = root;
      /* eslint-enable no-undef-init */

      do {
        index++;
        var isLeaving = index === keys.length;
        var isEdited = isLeaving && edits.length !== 0;

        if (isLeaving) {
          key = ancestors.length === 0 ? undefined : path[path.length - 1];
          node = parent;
          parent = ancestors.pop();

          if (isEdited) {
            if (inArray) {
              node = node.slice();
            } else {
              var clone = {};

              for (var _i2 = 0, _Object$keys2 = Object.keys(node); _i2 < _Object$keys2.length; _i2++) {
                var k = _Object$keys2[_i2];
                clone[k] = node[k];
              }

              node = clone;
            }

            var editOffset = 0;

            for (var ii = 0; ii < edits.length; ii++) {
              var editKey = edits[ii][0];
              var editValue = edits[ii][1];

              if (inArray) {
                editKey -= editOffset;
              }

              if (inArray && editValue === null) {
                node.splice(editKey, 1);
                editOffset++;
              } else {
                node[editKey] = editValue;
              }
            }
          }

          index = stack.index;
          keys = stack.keys;
          edits = stack.edits;
          inArray = stack.inArray;
          stack = stack.prev;
        } else {
          key = parent ? inArray ? index : keys[index] : undefined;
          node = parent ? parent[key] : newRoot;

          if (node === null || node === undefined) {
            continue;
          }

          if (parent) {
            path.push(key);
          }
        }

        var result = void 0;

        if (!Array.isArray(node)) {
          if (!isNode(node)) {
            throw new Error('Invalid AST Node: ' + inspect(node));
          }

          var visitFn = getVisitFn(visitor, node.kind, isLeaving);

          if (visitFn) {
            result = visitFn.call(visitor, node, key, parent, path, ancestors);

            if (result === BREAK) {
              break;
            }

            if (result === false) {
              if (!isLeaving) {
                path.pop();
                continue;
              }
            } else if (result !== undefined) {
              edits.push([key, result]);

              if (!isLeaving) {
                if (isNode(result)) {
                  node = result;
                } else {
                  path.pop();
                  continue;
                }
              }
            }
          }
        }

        if (result === undefined && isEdited) {
          edits.push([key, node]);
        }

        if (isLeaving) {
          path.pop();
        } else {
          stack = {
            inArray: inArray,
            index: index,
            keys: keys,
            edits: edits,
            prev: stack
          };
          inArray = Array.isArray(node);
          keys = inArray ? node : visitorKeys[node.kind] || [];
          index = -1;
          edits = [];

          if (parent) {
            ancestors.push(parent);
          }

          parent = node;
        }
      } while (stack !== undefined);

      if (edits.length !== 0) {
        newRoot = edits[edits.length - 1][1];
      }

      return newRoot;
    }

    function isNode(maybeNode) {
      return Boolean(maybeNode && typeof maybeNode.kind === 'string');
    }
    /**
     * Given a visitor instance, if it is leaving or not, and a node kind, return
     * the function the visitor runtime should call.
     */

    function getVisitFn(visitor, kind, isLeaving) {
      var kindVisitor = visitor[kind];

      if (kindVisitor) {
        if (!isLeaving && typeof kindVisitor === 'function') {
          // { Kind() {} }
          return kindVisitor;
        }

        var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;

        if (typeof kindSpecificVisitor === 'function') {
          // { Kind: { enter() {}, leave() {} } }
          return kindSpecificVisitor;
        }
      } else {
        var specificVisitor = isLeaving ? visitor.leave : visitor.enter;

        if (specificVisitor) {
          if (typeof specificVisitor === 'function') {
            // { enter() {}, leave() {} }
            return specificVisitor;
          }

          var specificKindVisitor = specificVisitor[kind];

          if (typeof specificKindVisitor === 'function') {
            // { enter: { Kind() {} }, leave: { Kind() {} } }
            return specificKindVisitor;
          }
        }
      }
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }

    var genericMessage = "Invariant Violation";
    var _a = Object.setPrototypeOf, setPrototypeOf = _a === void 0 ? function (obj, proto) {
        obj.__proto__ = proto;
        return obj;
    } : _a;
    var InvariantError = /** @class */ (function (_super) {
        __extends(InvariantError, _super);
        function InvariantError(message) {
            if (message === void 0) { message = genericMessage; }
            var _this = _super.call(this, typeof message === "number"
                ? genericMessage + ": " + message + " (see https://github.com/apollographql/invariant-packages)"
                : message) || this;
            _this.framesToPop = 1;
            _this.name = genericMessage;
            setPrototypeOf(_this, InvariantError.prototype);
            return _this;
        }
        return InvariantError;
    }(Error));
    function invariant(condition, message) {
        if (!condition) {
            throw new InvariantError(message);
        }
    }
    function wrapConsoleMethod(method) {
        return function () {
            return console[method].apply(console, arguments);
        };
    }
    (function (invariant) {
        invariant.warn = wrapConsoleMethod("warn");
        invariant.error = wrapConsoleMethod("error");
    })(invariant || (invariant = {}));
    // Code that uses ts-invariant with rollup-plugin-invariant may want to
    // import this process stub to avoid errors evaluating process.env.NODE_ENV.
    // However, because most ESM-to-CJS compilers will rewrite the process import
    // as tsInvariant.process, which prevents proper replacement by minifiers, we
    // also attempt to define the stub globally when it is not already defined.
    var processStub = { env: {} };
    if (typeof process === "object") {
        processStub = process;
    }
    else
        try {
            // Using Function to evaluate this assignment in global scope also escapes
            // the strict mode of the current module, thereby allowing the assignment.
            // Inspired by https://github.com/facebook/regenerator/pull/369.
            Function("stub", "process = stub")(processStub);
        }
        catch (atLeastWeTried) {
            // The assignment can fail if a Content Security Policy heavy-handedly
            // forbids Function usage. In those environments, developers should take
            // extra care to replace process.env.NODE_ENV in their production builds,
            // or define an appropriate global.process polyfill.
        }
    //# sourceMappingURL=invariant.esm.js.map

    var fastJsonStableStringify = function (data, opts) {
        if (!opts) opts = {};
        if (typeof opts === 'function') opts = { cmp: opts };
        var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;

        var cmp = opts.cmp && (function (f) {
            return function (node) {
                return function (a, b) {
                    var aobj = { key: a, value: node[a] };
                    var bobj = { key: b, value: node[b] };
                    return f(aobj, bobj);
                };
            };
        })(opts.cmp);

        var seen = [];
        return (function stringify (node) {
            if (node && node.toJSON && typeof node.toJSON === 'function') {
                node = node.toJSON();
            }

            if (node === undefined) return;
            if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';
            if (typeof node !== 'object') return JSON.stringify(node);

            var i, out;
            if (Array.isArray(node)) {
                out = '[';
                for (i = 0; i < node.length; i++) {
                    if (i) out += ',';
                    out += stringify(node[i]) || 'null';
                }
                return out + ']';
            }

            if (node === null) return 'null';

            if (seen.indexOf(node) !== -1) {
                if (cycles) return JSON.stringify('__cycle__');
                throw new TypeError('Converting circular structure to JSON');
            }

            var seenIndex = seen.push(node) - 1;
            var keys = Object.keys(node).sort(cmp && cmp(node));
            out = '';
            for (i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = stringify(node[key]);

                if (!value) continue;
                if (out) out += ',';
                out += JSON.stringify(key) + ':' + value;
            }
            seen.splice(seenIndex, 1);
            return '{' + out + '}';
        })(data);
    };

    var _a$1 = Object.prototype, toString = _a$1.toString, hasOwnProperty = _a$1.hasOwnProperty;
    var previousComparisons = new Map();
    /**
     * Performs a deep equality check on two JavaScript values, tolerating cycles.
     */
    function equal(a, b) {
        try {
            return check(a, b);
        }
        finally {
            previousComparisons.clear();
        }
    }
    function check(a, b) {
        // If the two values are strictly equal, our job is easy.
        if (a === b) {
            return true;
        }
        // Object.prototype.toString returns a representation of the runtime type of
        // the given value that is considerably more precise than typeof.
        var aTag = toString.call(a);
        var bTag = toString.call(b);
        // If the runtime types of a and b are different, they could maybe be equal
        // under some interpretation of equality, but for simplicity and performance
        // we just return false instead.
        if (aTag !== bTag) {
            return false;
        }
        switch (aTag) {
            case '[object Array]':
                // Arrays are a lot like other objects, but we can cheaply compare their
                // lengths as a short-cut before comparing their elements.
                if (a.length !== b.length)
                    return false;
            // Fall through to object case...
            case '[object Object]': {
                if (previouslyCompared(a, b))
                    return true;
                var aKeys = Object.keys(a);
                var bKeys = Object.keys(b);
                // If `a` and `b` have a different number of enumerable keys, they
                // must be different.
                var keyCount = aKeys.length;
                if (keyCount !== bKeys.length)
                    return false;
                // Now make sure they have the same keys.
                for (var k = 0; k < keyCount; ++k) {
                    if (!hasOwnProperty.call(b, aKeys[k])) {
                        return false;
                    }
                }
                // Finally, check deep equality of all child properties.
                for (var k = 0; k < keyCount; ++k) {
                    var key = aKeys[k];
                    if (!check(a[key], b[key])) {
                        return false;
                    }
                }
                return true;
            }
            case '[object Error]':
                return a.name === b.name && a.message === b.message;
            case '[object Number]':
                // Handle NaN, which is !== itself.
                if (a !== a)
                    return b !== b;
            // Fall through to shared +a === +b case...
            case '[object Boolean]':
            case '[object Date]':
                return +a === +b;
            case '[object RegExp]':
            case '[object String]':
                return a == "" + b;
            case '[object Map]':
            case '[object Set]': {
                if (a.size !== b.size)
                    return false;
                if (previouslyCompared(a, b))
                    return true;
                var aIterator = a.entries();
                var isMap = aTag === '[object Map]';
                while (true) {
                    var info = aIterator.next();
                    if (info.done)
                        break;
                    // If a instanceof Set, aValue === aKey.
                    var _a = info.value, aKey = _a[0], aValue = _a[1];
                    // So this works the same way for both Set and Map.
                    if (!b.has(aKey)) {
                        return false;
                    }
                    // However, we care about deep equality of values only when dealing
                    // with Map structures.
                    if (isMap && !check(aValue, b.get(aKey))) {
                        return false;
                    }
                }
                return true;
            }
        }
        // Otherwise the values are not equal.
        return false;
    }
    function previouslyCompared(a, b) {
        // Though cyclic references can make an object graph appear infinite from the
        // perspective of a depth-first traversal, the graph still contains a finite
        // number of distinct object references. We use the previousComparisons cache
        // to avoid comparing the same pair of object references more than once, which
        // guarantees termination (even if we end up comparing every object in one
        // graph to every object in the other graph, which is extremely unlikely),
        // while still allowing weird isomorphic structures (like rings with different
        // lengths) a chance to pass the equality test.
        var bSet = previousComparisons.get(a);
        if (bSet) {
            // Return true here because we can be sure false will be returned somewhere
            // else if the objects are not equivalent.
            if (bSet.has(b))
                return true;
        }
        else {
            previousComparisons.set(a, bSet = new Set);
        }
        bSet.add(b);
        return false;
    }
    //# sourceMappingURL=equality.esm.js.map

    function isStringValue(value) {
        return value.kind === 'StringValue';
    }
    function isBooleanValue(value) {
        return value.kind === 'BooleanValue';
    }
    function isIntValue(value) {
        return value.kind === 'IntValue';
    }
    function isFloatValue(value) {
        return value.kind === 'FloatValue';
    }
    function isVariable(value) {
        return value.kind === 'Variable';
    }
    function isObjectValue(value) {
        return value.kind === 'ObjectValue';
    }
    function isListValue(value) {
        return value.kind === 'ListValue';
    }
    function isEnumValue(value) {
        return value.kind === 'EnumValue';
    }
    function isNullValue(value) {
        return value.kind === 'NullValue';
    }
    function valueToObjectRepresentation(argObj, name, value, variables) {
        if (isIntValue(value) || isFloatValue(value)) {
            argObj[name.value] = Number(value.value);
        }
        else if (isBooleanValue(value) || isStringValue(value)) {
            argObj[name.value] = value.value;
        }
        else if (isObjectValue(value)) {
            var nestedArgObj_1 = {};
            value.fields.map(function (obj) {
                return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);
            });
            argObj[name.value] = nestedArgObj_1;
        }
        else if (isVariable(value)) {
            var variableValue = (variables || {})[value.name.value];
            argObj[name.value] = variableValue;
        }
        else if (isListValue(value)) {
            argObj[name.value] = value.values.map(function (listValue) {
                var nestedArgArrayObj = {};
                valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);
                return nestedArgArrayObj[name.value];
            });
        }
        else if (isEnumValue(value)) {
            argObj[name.value] = value.value;
        }
        else if (isNullValue(value)) {
            argObj[name.value] = null;
        }
        else {
            throw process.env.NODE_ENV === "production" ? new InvariantError(17) : new InvariantError("The inline argument \"" + name.value + "\" of kind \"" + value.kind + "\"" +
                'is not supported. Use variables instead of inline arguments to ' +
                'overcome this limitation.');
        }
    }
    function storeKeyNameFromField(field, variables) {
        var directivesObj = null;
        if (field.directives) {
            directivesObj = {};
            field.directives.forEach(function (directive) {
                directivesObj[directive.name.value] = {};
                if (directive.arguments) {
                    directive.arguments.forEach(function (_a) {
                        var name = _a.name, value = _a.value;
                        return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);
                    });
                }
            });
        }
        var argObj = null;
        if (field.arguments && field.arguments.length) {
            argObj = {};
            field.arguments.forEach(function (_a) {
                var name = _a.name, value = _a.value;
                return valueToObjectRepresentation(argObj, name, value, variables);
            });
        }
        return getStoreKeyName(field.name.value, argObj, directivesObj);
    }
    var KNOWN_DIRECTIVES = [
        'connection',
        'include',
        'skip',
        'client',
        'rest',
        'export',
    ];
    function getStoreKeyName(fieldName, args, directives) {
        if (directives &&
            directives['connection'] &&
            directives['connection']['key']) {
            if (directives['connection']['filter'] &&
                directives['connection']['filter'].length > 0) {
                var filterKeys = directives['connection']['filter']
                    ? directives['connection']['filter']
                    : [];
                filterKeys.sort();
                var queryArgs_1 = args;
                var filteredArgs_1 = {};
                filterKeys.forEach(function (key) {
                    filteredArgs_1[key] = queryArgs_1[key];
                });
                return directives['connection']['key'] + "(" + JSON.stringify(filteredArgs_1) + ")";
            }
            else {
                return directives['connection']['key'];
            }
        }
        var completeFieldName = fieldName;
        if (args) {
            var stringifiedArgs = fastJsonStableStringify(args);
            completeFieldName += "(" + stringifiedArgs + ")";
        }
        if (directives) {
            Object.keys(directives).forEach(function (key) {
                if (KNOWN_DIRECTIVES.indexOf(key) !== -1)
                    return;
                if (directives[key] && Object.keys(directives[key]).length) {
                    completeFieldName += "@" + key + "(" + JSON.stringify(directives[key]) + ")";
                }
                else {
                    completeFieldName += "@" + key;
                }
            });
        }
        return completeFieldName;
    }
    function argumentsObjectFromField(field, variables) {
        if (field.arguments && field.arguments.length) {
            var argObj_1 = {};
            field.arguments.forEach(function (_a) {
                var name = _a.name, value = _a.value;
                return valueToObjectRepresentation(argObj_1, name, value, variables);
            });
            return argObj_1;
        }
        return null;
    }
    function resultKeyNameFromField(field) {
        return field.alias ? field.alias.value : field.name.value;
    }
    function isField(selection) {
        return selection.kind === 'Field';
    }
    function isInlineFragment(selection) {
        return selection.kind === 'InlineFragment';
    }
    function isIdValue(idObject) {
        return idObject &&
            idObject.type === 'id' &&
            typeof idObject.generated === 'boolean';
    }
    function toIdValue(idConfig, generated) {
        if (generated === void 0) { generated = false; }
        return __assign({ type: 'id', generated: generated }, (typeof idConfig === 'string'
            ? { id: idConfig, typename: undefined }
            : idConfig));
    }
    function isJsonValue(jsonObject) {
        return (jsonObject != null &&
            typeof jsonObject === 'object' &&
            jsonObject.type === 'json');
    }

    function getDirectiveInfoFromField(field, variables) {
        if (field.directives && field.directives.length) {
            var directiveObj_1 = {};
            field.directives.forEach(function (directive) {
                directiveObj_1[directive.name.value] = argumentsObjectFromField(directive, variables);
            });
            return directiveObj_1;
        }
        return null;
    }
    function shouldInclude(selection, variables) {
        if (variables === void 0) { variables = {}; }
        return getInclusionDirectives(selection.directives).every(function (_a) {
            var directive = _a.directive, ifArgument = _a.ifArgument;
            var evaledValue = false;
            if (ifArgument.value.kind === 'Variable') {
                evaledValue = variables[ifArgument.value.name.value];
                process.env.NODE_ENV === "production" ? invariant(evaledValue !== void 0, 1) : invariant(evaledValue !== void 0, "Invalid variable referenced in @" + directive.name.value + " directive.");
            }
            else {
                evaledValue = ifArgument.value.value;
            }
            return directive.name.value === 'skip' ? !evaledValue : evaledValue;
        });
    }
    function getDirectiveNames(doc) {
        var names = [];
        visit(doc, {
            Directive: function (node) {
                names.push(node.name.value);
            },
        });
        return names;
    }
    function hasDirectives(names, doc) {
        return getDirectiveNames(doc).some(function (name) { return names.indexOf(name) > -1; });
    }
    function hasClientExports(document) {
        return (document &&
            hasDirectives(['client'], document) &&
            hasDirectives(['export'], document));
    }
    function isInclusionDirective(_a) {
        var value = _a.name.value;
        return value === 'skip' || value === 'include';
    }
    function getInclusionDirectives(directives) {
        return directives ? directives.filter(isInclusionDirective).map(function (directive) {
            var directiveArguments = directive.arguments;
            var directiveName = directive.name.value;
            process.env.NODE_ENV === "production" ? invariant(directiveArguments && directiveArguments.length === 1, 2) : invariant(directiveArguments && directiveArguments.length === 1, "Incorrect number of arguments for the @" + directiveName + " directive.");
            var ifArgument = directiveArguments[0];
            process.env.NODE_ENV === "production" ? invariant(ifArgument.name && ifArgument.name.value === 'if', 3) : invariant(ifArgument.name && ifArgument.name.value === 'if', "Invalid argument for the @" + directiveName + " directive.");
            var ifValue = ifArgument.value;
            process.env.NODE_ENV === "production" ? invariant(ifValue &&
                (ifValue.kind === 'Variable' || ifValue.kind === 'BooleanValue'), 4) : invariant(ifValue &&
                (ifValue.kind === 'Variable' || ifValue.kind === 'BooleanValue'), "Argument for the @" + directiveName + " directive must be a variable or a boolean value.");
            return { directive: directive, ifArgument: ifArgument };
        }) : [];
    }

    function getFragmentQueryDocument(document, fragmentName) {
        var actualFragmentName = fragmentName;
        var fragments = [];
        document.definitions.forEach(function (definition) {
            if (definition.kind === 'OperationDefinition') {
                throw process.env.NODE_ENV === "production" ? new InvariantError(5) : new InvariantError("Found a " + definition.operation + " operation" + (definition.name ? " named '" + definition.name.value + "'" : '') + ". " +
                    'No operations are allowed when using a fragment as a query. Only fragments are allowed.');
            }
            if (definition.kind === 'FragmentDefinition') {
                fragments.push(definition);
            }
        });
        if (typeof actualFragmentName === 'undefined') {
            process.env.NODE_ENV === "production" ? invariant(fragments.length === 1, 6) : invariant(fragments.length === 1, "Found " + fragments.length + " fragments. `fragmentName` must be provided when there is not exactly 1 fragment.");
            actualFragmentName = fragments[0].name.value;
        }
        var query = __assign(__assign({}, document), { definitions: __spreadArrays([
                {
                    kind: 'OperationDefinition',
                    operation: 'query',
                    selectionSet: {
                        kind: 'SelectionSet',
                        selections: [
                            {
                                kind: 'FragmentSpread',
                                name: {
                                    kind: 'Name',
                                    value: actualFragmentName,
                                },
                            },
                        ],
                    },
                }
            ], document.definitions) });
        return query;
    }

    function assign$1(target) {
        var sources = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            sources[_i - 1] = arguments[_i];
        }
        sources.forEach(function (source) {
            if (typeof source === 'undefined' || source === null) {
                return;
            }
            Object.keys(source).forEach(function (key) {
                target[key] = source[key];
            });
        });
        return target;
    }
    function checkDocument(doc) {
        process.env.NODE_ENV === "production" ? invariant(doc && doc.kind === 'Document', 8) : invariant(doc && doc.kind === 'Document', "Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql");
        var operations = doc.definitions
            .filter(function (d) { return d.kind !== 'FragmentDefinition'; })
            .map(function (definition) {
            if (definition.kind !== 'OperationDefinition') {
                throw process.env.NODE_ENV === "production" ? new InvariantError(9) : new InvariantError("Schema type definitions not allowed in queries. Found: \"" + definition.kind + "\"");
            }
            return definition;
        });
        process.env.NODE_ENV === "production" ? invariant(operations.length <= 1, 10) : invariant(operations.length <= 1, "Ambiguous GraphQL document: contains " + operations.length + " operations");
        return doc;
    }
    function getOperationDefinition(doc) {
        checkDocument(doc);
        return doc.definitions.filter(function (definition) { return definition.kind === 'OperationDefinition'; })[0];
    }
    function getOperationName(doc) {
        return (doc.definitions
            .filter(function (definition) {
            return definition.kind === 'OperationDefinition' && definition.name;
        })
            .map(function (x) { return x.name.value; })[0] || null);
    }
    function getFragmentDefinitions(doc) {
        return doc.definitions.filter(function (definition) { return definition.kind === 'FragmentDefinition'; });
    }
    function getQueryDefinition(doc) {
        var queryDef = getOperationDefinition(doc);
        process.env.NODE_ENV === "production" ? invariant(queryDef && queryDef.operation === 'query', 12) : invariant(queryDef && queryDef.operation === 'query', 'Must contain a query definition.');
        return queryDef;
    }
    function getFragmentDefinition(doc) {
        process.env.NODE_ENV === "production" ? invariant(doc.kind === 'Document', 13) : invariant(doc.kind === 'Document', "Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql");
        process.env.NODE_ENV === "production" ? invariant(doc.definitions.length <= 1, 14) : invariant(doc.definitions.length <= 1, 'Fragment must have exactly one definition.');
        var fragmentDef = doc.definitions[0];
        process.env.NODE_ENV === "production" ? invariant(fragmentDef.kind === 'FragmentDefinition', 15) : invariant(fragmentDef.kind === 'FragmentDefinition', 'Must be a fragment definition.');
        return fragmentDef;
    }
    function getMainDefinition(queryDoc) {
        checkDocument(queryDoc);
        var fragmentDefinition;
        for (var _i = 0, _a = queryDoc.definitions; _i < _a.length; _i++) {
            var definition = _a[_i];
            if (definition.kind === 'OperationDefinition') {
                var operation = definition.operation;
                if (operation === 'query' ||
                    operation === 'mutation' ||
                    operation === 'subscription') {
                    return definition;
                }
            }
            if (definition.kind === 'FragmentDefinition' && !fragmentDefinition) {
                fragmentDefinition = definition;
            }
        }
        if (fragmentDefinition) {
            return fragmentDefinition;
        }
        throw process.env.NODE_ENV === "production" ? new InvariantError(16) : new InvariantError('Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.');
    }
    function createFragmentMap(fragments) {
        if (fragments === void 0) { fragments = []; }
        var symTable = {};
        fragments.forEach(function (fragment) {
            symTable[fragment.name.value] = fragment;
        });
        return symTable;
    }
    function getDefaultValues(definition) {
        if (definition &&
            definition.variableDefinitions &&
            definition.variableDefinitions.length) {
            var defaultValues = definition.variableDefinitions
                .filter(function (_a) {
                var defaultValue = _a.defaultValue;
                return defaultValue;
            })
                .map(function (_a) {
                var variable = _a.variable, defaultValue = _a.defaultValue;
                var defaultValueObj = {};
                valueToObjectRepresentation(defaultValueObj, variable.name, defaultValue);
                return defaultValueObj;
            });
            return assign$1.apply(void 0, __spreadArrays([{}], defaultValues));
        }
        return {};
    }

    function filterInPlace(array, test, context) {
        var target = 0;
        array.forEach(function (elem, i) {
            if (test.call(this, elem, i, array)) {
                array[target++] = elem;
            }
        }, context);
        array.length = target;
        return array;
    }

    var TYPENAME_FIELD = {
        kind: 'Field',
        name: {
            kind: 'Name',
            value: '__typename',
        },
    };
    function isEmpty(op, fragments) {
        return op.selectionSet.selections.every(function (selection) {
            return selection.kind === 'FragmentSpread' &&
                isEmpty(fragments[selection.name.value], fragments);
        });
    }
    function nullIfDocIsEmpty(doc) {
        return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc)))
            ? null
            : doc;
    }
    function getDirectiveMatcher(directives) {
        return function directiveMatcher(directive) {
            return directives.some(function (dir) {
                return (dir.name && dir.name === directive.name.value) ||
                    (dir.test && dir.test(directive));
            });
        };
    }
    function removeDirectivesFromDocument(directives, doc) {
        var variablesInUse = Object.create(null);
        var variablesToRemove = [];
        var fragmentSpreadsInUse = Object.create(null);
        var fragmentSpreadsToRemove = [];
        var modifiedDoc = nullIfDocIsEmpty(visit(doc, {
            Variable: {
                enter: function (node, _key, parent) {
                    if (parent.kind !== 'VariableDefinition') {
                        variablesInUse[node.name.value] = true;
                    }
                },
            },
            Field: {
                enter: function (node) {
                    if (directives && node.directives) {
                        var shouldRemoveField = directives.some(function (directive) { return directive.remove; });
                        if (shouldRemoveField &&
                            node.directives &&
                            node.directives.some(getDirectiveMatcher(directives))) {
                            if (node.arguments) {
                                node.arguments.forEach(function (arg) {
                                    if (arg.value.kind === 'Variable') {
                                        variablesToRemove.push({
                                            name: arg.value.name.value,
                                        });
                                    }
                                });
                            }
                            if (node.selectionSet) {
                                getAllFragmentSpreadsFromSelectionSet(node.selectionSet).forEach(function (frag) {
                                    fragmentSpreadsToRemove.push({
                                        name: frag.name.value,
                                    });
                                });
                            }
                            return null;
                        }
                    }
                },
            },
            FragmentSpread: {
                enter: function (node) {
                    fragmentSpreadsInUse[node.name.value] = true;
                },
            },
            Directive: {
                enter: function (node) {
                    if (getDirectiveMatcher(directives)(node)) {
                        return null;
                    }
                },
            },
        }));
        if (modifiedDoc &&
            filterInPlace(variablesToRemove, function (v) { return !variablesInUse[v.name]; }).length) {
            modifiedDoc = removeArgumentsFromDocument(variablesToRemove, modifiedDoc);
        }
        if (modifiedDoc &&
            filterInPlace(fragmentSpreadsToRemove, function (fs) { return !fragmentSpreadsInUse[fs.name]; })
                .length) {
            modifiedDoc = removeFragmentSpreadFromDocument(fragmentSpreadsToRemove, modifiedDoc);
        }
        return modifiedDoc;
    }
    function addTypenameToDocument(doc) {
        return visit(checkDocument(doc), {
            SelectionSet: {
                enter: function (node, _key, parent) {
                    if (parent &&
                        parent.kind === 'OperationDefinition') {
                        return;
                    }
                    var selections = node.selections;
                    if (!selections) {
                        return;
                    }
                    var skip = selections.some(function (selection) {
                        return (isField(selection) &&
                            (selection.name.value === '__typename' ||
                                selection.name.value.lastIndexOf('__', 0) === 0));
                    });
                    if (skip) {
                        return;
                    }
                    var field = parent;
                    if (isField(field) &&
                        field.directives &&
                        field.directives.some(function (d) { return d.name.value === 'export'; })) {
                        return;
                    }
                    return __assign(__assign({}, node), { selections: __spreadArrays(selections, [TYPENAME_FIELD]) });
                },
            },
        });
    }
    var connectionRemoveConfig = {
        test: function (directive) {
            var willRemove = directive.name.value === 'connection';
            if (willRemove) {
                if (!directive.arguments ||
                    !directive.arguments.some(function (arg) { return arg.name.value === 'key'; })) {
                    process.env.NODE_ENV === "production" || invariant.warn('Removing an @connection directive even though it does not have a key. ' +
                        'You may want to use the key parameter to specify a store key.');
                }
            }
            return willRemove;
        },
    };
    function removeConnectionDirectiveFromDocument(doc) {
        return removeDirectivesFromDocument([connectionRemoveConfig], checkDocument(doc));
    }
    function getArgumentMatcher(config) {
        return function argumentMatcher(argument) {
            return config.some(function (aConfig) {
                return argument.value &&
                    argument.value.kind === 'Variable' &&
                    argument.value.name &&
                    (aConfig.name === argument.value.name.value ||
                        (aConfig.test && aConfig.test(argument)));
            });
        };
    }
    function removeArgumentsFromDocument(config, doc) {
        var argMatcher = getArgumentMatcher(config);
        return nullIfDocIsEmpty(visit(doc, {
            OperationDefinition: {
                enter: function (node) {
                    return __assign(__assign({}, node), { variableDefinitions: node.variableDefinitions.filter(function (varDef) {
                            return !config.some(function (arg) { return arg.name === varDef.variable.name.value; });
                        }) });
                },
            },
            Field: {
                enter: function (node) {
                    var shouldRemoveField = config.some(function (argConfig) { return argConfig.remove; });
                    if (shouldRemoveField) {
                        var argMatchCount_1 = 0;
                        node.arguments.forEach(function (arg) {
                            if (argMatcher(arg)) {
                                argMatchCount_1 += 1;
                            }
                        });
                        if (argMatchCount_1 === 1) {
                            return null;
                        }
                    }
                },
            },
            Argument: {
                enter: function (node) {
                    if (argMatcher(node)) {
                        return null;
                    }
                },
            },
        }));
    }
    function removeFragmentSpreadFromDocument(config, doc) {
        function enter(node) {
            if (config.some(function (def) { return def.name === node.name.value; })) {
                return null;
            }
        }
        return nullIfDocIsEmpty(visit(doc, {
            FragmentSpread: { enter: enter },
            FragmentDefinition: { enter: enter },
        }));
    }
    function getAllFragmentSpreadsFromSelectionSet(selectionSet) {
        var allFragments = [];
        selectionSet.selections.forEach(function (selection) {
            if ((isField(selection) || isInlineFragment(selection)) &&
                selection.selectionSet) {
                getAllFragmentSpreadsFromSelectionSet(selection.selectionSet).forEach(function (frag) { return allFragments.push(frag); });
            }
            else if (selection.kind === 'FragmentSpread') {
                allFragments.push(selection);
            }
        });
        return allFragments;
    }
    function buildQueryFromSelectionSet(document) {
        var definition = getMainDefinition(document);
        var definitionOperation = definition.operation;
        if (definitionOperation === 'query') {
            return document;
        }
        var modifiedDoc = visit(document, {
            OperationDefinition: {
                enter: function (node) {
                    return __assign(__assign({}, node), { operation: 'query' });
                },
            },
        });
        return modifiedDoc;
    }
    function removeClientSetsFromDocument(document) {
        checkDocument(document);
        var modifiedDoc = removeDirectivesFromDocument([
            {
                test: function (directive) { return directive.name.value === 'client'; },
                remove: true,
            },
        ], document);
        if (modifiedDoc) {
            modifiedDoc = visit(modifiedDoc, {
                FragmentDefinition: {
                    enter: function (node) {
                        if (node.selectionSet) {
                            var isTypenameOnly = node.selectionSet.selections.every(function (selection) {
                                return isField(selection) && selection.name.value === '__typename';
                            });
                            if (isTypenameOnly) {
                                return null;
                            }
                        }
                    },
                },
            });
        }
        return modifiedDoc;
    }

    var canUseWeakMap = typeof WeakMap === 'function' && !(typeof navigator === 'object' &&
        navigator.product === 'ReactNative');

    var toString$1 = Object.prototype.toString;
    function cloneDeep(value) {
        return cloneDeepHelper(value, new Map());
    }
    function cloneDeepHelper(val, seen) {
        switch (toString$1.call(val)) {
            case "[object Array]": {
                if (seen.has(val))
                    return seen.get(val);
                var copy_1 = val.slice(0);
                seen.set(val, copy_1);
                copy_1.forEach(function (child, i) {
                    copy_1[i] = cloneDeepHelper(child, seen);
                });
                return copy_1;
            }
            case "[object Object]": {
                if (seen.has(val))
                    return seen.get(val);
                var copy_2 = Object.create(Object.getPrototypeOf(val));
                seen.set(val, copy_2);
                Object.keys(val).forEach(function (key) {
                    copy_2[key] = cloneDeepHelper(val[key], seen);
                });
                return copy_2;
            }
            default:
                return val;
        }
    }

    function getEnv() {
        if (typeof process !== 'undefined' && process.env.NODE_ENV) {
            return process.env.NODE_ENV;
        }
        return 'development';
    }
    function isEnv(env) {
        return getEnv() === env;
    }
    function isProduction() {
        return isEnv('production') === true;
    }
    function isDevelopment() {
        return isEnv('development') === true;
    }
    function isTest() {
        return isEnv('test') === true;
    }

    function tryFunctionOrLogError(f) {
        try {
            return f();
        }
        catch (e) {
            if (console.error) {
                console.error(e);
            }
        }
    }
    function graphQLResultHasError(result) {
        return result.errors && result.errors.length;
    }

    function deepFreeze(o) {
        Object.freeze(o);
        Object.getOwnPropertyNames(o).forEach(function (prop) {
            if (o[prop] !== null &&
                (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&
                !Object.isFrozen(o[prop])) {
                deepFreeze(o[prop]);
            }
        });
        return o;
    }
    function maybeDeepFreeze(obj) {
        if (isDevelopment() || isTest()) {
            var symbolIsPolyfilled = typeof Symbol === 'function' && typeof Symbol('') === 'string';
            if (!symbolIsPolyfilled) {
                return deepFreeze(obj);
            }
        }
        return obj;
    }

    var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
    function mergeDeep() {
        var sources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            sources[_i] = arguments[_i];
        }
        return mergeDeepArray(sources);
    }
    function mergeDeepArray(sources) {
        var target = sources[0] || {};
        var count = sources.length;
        if (count > 1) {
            var pastCopies = [];
            target = shallowCopyForMerge(target, pastCopies);
            for (var i = 1; i < count; ++i) {
                target = mergeHelper(target, sources[i], pastCopies);
            }
        }
        return target;
    }
    function isObject(obj) {
        return obj !== null && typeof obj === 'object';
    }
    function mergeHelper(target, source, pastCopies) {
        if (isObject(source) && isObject(target)) {
            if (Object.isExtensible && !Object.isExtensible(target)) {
                target = shallowCopyForMerge(target, pastCopies);
            }
            Object.keys(source).forEach(function (sourceKey) {
                var sourceValue = source[sourceKey];
                if (hasOwnProperty$1.call(target, sourceKey)) {
                    var targetValue = target[sourceKey];
                    if (sourceValue !== targetValue) {
                        target[sourceKey] = mergeHelper(shallowCopyForMerge(targetValue, pastCopies), sourceValue, pastCopies);
                    }
                }
                else {
                    target[sourceKey] = sourceValue;
                }
            });
            return target;
        }
        return source;
    }
    function shallowCopyForMerge(value, pastCopies) {
        if (value !== null &&
            typeof value === 'object' &&
            pastCopies.indexOf(value) < 0) {
            if (Array.isArray(value)) {
                value = value.slice(0);
            }
            else {
                value = __assign({ __proto__: Object.getPrototypeOf(value) }, value);
            }
            pastCopies.push(value);
        }
        return value;
    }
    //# sourceMappingURL=bundle.esm.js.map

    var OBSERVABLE;
    function isObservable(value) {
        // Lazy-load Symbol to give polyfills a chance to run
        if (!OBSERVABLE) {
            OBSERVABLE =
                (typeof Symbol === 'function' && Symbol.observable) || '@@observable';
        }
        return value && value[OBSERVABLE] && value[OBSERVABLE]() === value;
    }
    function deferred(set, initial) {
        var initialized = initial !== undefined;
        var resolve;
        var reject;
        // Set initial value
        set(initialized
            ? initial
            : new Promise(function (_resolve, _reject) {
                resolve = _resolve;
                reject = _reject;
            }));
        return {
            fulfill: function (value) {
                if (initialized)
                    return set(Promise.resolve(value));
                initialized = true;
                resolve(value);
            },
            reject: function (error) {
                if (initialized)
                    return set(Promise.reject(error));
                initialized = true;
                reject(error);
            }
        };
    }

    var noop$1 = function () { };
    function observe(observable, initial) {
        if (!isObservable(observable)) {
            return readable(observable, noop$1);
        }
        return readable(undefined, function (set) {
            var _a = deferred(set, initial), fulfill = _a.fulfill, reject = _a.reject;
            var subscription = observable.subscribe({
                next: function (value) {
                    fulfill(value);
                },
                error: function (err) {
                    reject(err);
                }
            });
            return function () { return subscription.unsubscribe(); };
        });
    }
    //# sourceMappingURL=svelte-observable.es.js.map

    var CLIENT = typeof Symbol !== 'undefined' ? Symbol('client') : '@@client';
    function getClient() {
        return getContext(CLIENT);
    }
    function setClient(client) {
        setContext(CLIENT, client);
    }

    var restoring = typeof WeakSet !== 'undefined' ? new WeakSet() : new Set();

    function query(client, options) {
        var subscribed = false;
        var initial_value;
        // If client is restoring (e.g. from SSR)
        // attempt synchronous readQuery first (to prevent loading in {#await})
        if (restoring.has(client)) {
            try {
                // undefined = skip initial value (not in cache)
                initial_value = client.readQuery(options) || undefined;
                initial_value = { data: initial_value };
            }
            catch (err) {
                // Ignore preload errors
            }
        }
        // Create query and observe,
        // but don't subscribe directly to avoid firing duplicate value if initialized
        var observable_query = client.watchQuery(options);
        var subscribe_to_query = observe(observable_query, initial_value).subscribe;
        // Wrap the query subscription with a readable to prevent duplicate values
        var subscribe = readable(initial_value, function (set) {
            subscribed = true;
            var skip_duplicate = initial_value !== undefined;
            var initialized = false;
            var skipped = false;
            var unsubscribe = subscribe_to_query(function (value) {
                if (skip_duplicate && initialized && !skipped) {
                    skipped = true;
                }
                else {
                    if (!initialized)
                        initialized = true;
                    set(value);
                }
            });
            return unsubscribe;
        }).subscribe;
        return {
            subscribe: subscribe,
            refetch: function (variables) {
                // If variables have not changed and not subscribed, skip refetch
                if (!subscribed && equal(variables, observable_query.variables))
                    return observable_query.result();
                return observable_query.refetch(variables);
            },
            result: function () { return observable_query.result(); },
            fetchMore: function (options) { return observable_query.fetchMore(options); },
            setOptions: function (options) { return observable_query.setOptions(options); },
            updateQuery: function (map) { return observable_query.updateQuery(map); },
            startPolling: function (interval) { return observable_query.startPolling(interval); },
            stopPolling: function () { return observable_query.stopPolling(); },
            subscribeToMore: function (options) { return observable_query.subscribeToMore(options); }
        };
    }

    function mutate(client, options) {
        return client.mutate(options);
    }

    function subscribe$2(client, options) {
        var observable = client.subscribe(options);
        return observe(observable);
    }
    //# sourceMappingURL=svelte-apollo.es.js.map

    /* src/EditorArea.svelte generated by Svelte v3.18.1 */

    const file$2 = "src/EditorArea.svelte";

    function create_fragment$4(ctx) {
    	let div4;
    	let h1;
    	let t0_value = /*$currentTab*/ ctx[2].description + "";
    	let t0;
    	let t1;
    	let t2;
    	let div0;
    	let t3;
    	let div3;
    	let button;
    	let t5;
    	let h2;
    	let t7;
    	let div1;
    	let t9;
    	let div2;
    	let current;
    	let dispose;
    	const editorwindow = new EditorWindow({ $$inline: true });

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			h1 = element("h1");
    			t0 = text(t0_value);
    			t1 = space();
    			create_component(editorwindow.$$.fragment);
    			t2 = space();
    			div0 = element("div");
    			t3 = space();
    			div3 = element("div");
    			button = element("button");
    			button.textContent = "Submit";
    			t5 = space();
    			h2 = element("h2");
    			h2.textContent = "Output";
    			t7 = space();
    			div1 = element("div");
    			div1.textContent = `${/*outputData*/ ctx[4]}`;
    			t9 = space();
    			div2 = element("div");
    			div2.textContent = `${/*outputCheck*/ ctx[5]}`;
    			attr_dev(h1, "class", "question px-3 py-3 svelte-104b6dp");
    			add_location(h1, file$2, 113, 2, 3753);
    			attr_dev(div0, "class", "w-full bg-gray-800 sizechanger cursor-move text-bg-600 flex\n    justify-center text-3xl h-3 svelte-104b6dp");
    			set_style(div0, "line-height", "1px");
    			set_style(div0, "cursor", "ns-resize");
    			add_location(div0, file$2, 115, 2, 3836);
    			attr_dev(button, "class", "runButton svelte-104b6dp");
    			add_location(button, file$2, 123, 4, 4119);
    			attr_dev(h2, "class", "text-3xl text-center title svelte-104b6dp");
    			add_location(h2, file$2, 126, 4, 4219);
    			attr_dev(div1, "class", "flex-1 text-gray-700 text-center px-4 py-2 outputValue svelte-104b6dp");
    			add_location(div1, file$2, 127, 4, 4274);
    			attr_dev(div2, "class", "flex-1 text-gray-700 text-center px-4 py-2 outputValue svelte-104b6dp");
    			add_location(div2, file$2, 130, 4, 4377);
    			attr_dev(div3, "class", "output svelte-104b6dp");
    			attr_dev(div3, "id", "outputid");
    			set_style(div3, "height", /*height*/ ctx[1]);
    			add_location(div3, file$2, 122, 2, 4056);
    			attr_dev(div4, "class", "mainDiv flex flex-col svelte-104b6dp");
    			add_location(div4, file$2, 99, 0, 3428);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, h1);
    			append_dev(h1, t0);
    			append_dev(div4, t1);
    			mount_component(editorwindow, div4, null);
    			append_dev(div4, t2);
    			append_dev(div4, div0);
    			append_dev(div4, t3);
    			append_dev(div4, div3);
    			append_dev(div3, button);
    			append_dev(div3, t5);
    			append_dev(div3, h2);
    			append_dev(div3, t7);
    			append_dev(div3, div1);
    			append_dev(div3, t9);
    			append_dev(div3, div2);
    			current = true;

    			dispose = [
    				listen_dev(window, "keydown", /*keydown_handler*/ ctx[8], false, false, false),
    				listen_dev(div0, "mousedown", /*mousedown_handler*/ ctx[9], false, false, false),
    				listen_dev(button, "click", /*click_handler*/ ctx[10], false, false, false),
    				listen_dev(div4, "mousemove", /*mousemove_handler*/ ctx[11], false, false, false),
    				listen_dev(div4, "mouseup", /*mouseup_handler*/ ctx[12], false, false, false)
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$currentTab*/ 4) && t0_value !== (t0_value = /*$currentTab*/ ctx[2].description + "")) set_data_dev(t0, t0_value);

    			if (!current || dirty & /*height*/ 2) {
    				set_style(div3, "height", /*height*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(editorwindow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(editorwindow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			destroy_component(editorwindow);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }
    //   method:"GET"

    function instance$4($$self, $$props, $$invalidate) {
    	let $currentTab;
    	let $dataStore;
    	validate_store(currentTab, "currentTab");
    	component_subscribe($$self, currentTab, $$value => $$invalidate(2, $currentTab = $$value));
    	validate_store(dataStore, "dataStore");
    	component_subscribe($$self, dataStore, $$value => $$invalidate(3, $dataStore = $$value));
    	let outputData = "";
    	let outputCheck = "";
    	let dragging = false;
    	const client = getClient();

    	// })
    	// .then(res=>{
    	//   return res.json();
    	// })
    	// .then(data=>{
    	//   outputData=data.output;
    	//   outputCheck=data.answer;
    	// })
    	async function sendSolution(data) {
    		let solutions = {
    			id: parseInt(cookieHandler.getCookie("attemptId")),
    			u_id: parseInt(cookieHandler.getCookie("user_id")),
    			solutions: JSON.stringify(data)
    		};

    		console.log(solutions);

    		try {
    			await mutate(client, {
    				mutation: apolloClient.updateAttempt,
    				variables: solutions
    			});
    		} catch(err) {
    			console.log(err); // location.replace("http://localhost:5000/thankyou");
    		}
    	}

    	const keydown_handler = e => {
    		if (!e.altKey || e.key !== "r") {
    			return;
    		}

    		e.preventDefault();
    	};

    	const mousedown_handler = evt => {
    		$$invalidate(0, dragging = true);
    	};

    	const click_handler = () => sendSolution($dataStore);

    	const mousemove_handler = evt => {
    		if (dragging) {
    			$$invalidate(1, height = `${100 * ((document.body.clientHeight - evt.clientY) / document.body.clientHeight)}vh`);
    		}
    	};

    	const mouseup_handler = () => {
    		$$invalidate(0, dragging = false);
    	};

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("outputData" in $$props) $$invalidate(4, outputData = $$props.outputData);
    		if ("outputCheck" in $$props) $$invalidate(5, outputCheck = $$props.outputCheck);
    		if ("dragging" in $$props) $$invalidate(0, dragging = $$props.dragging);
    		if ("height" in $$props) $$invalidate(1, height = $$props.height);
    		if ("$currentTab" in $$props) currentTab.set($currentTab = $$props.$currentTab);
    		if ("$dataStore" in $$props) dataStore.set($dataStore = $$props.$dataStore);
    	};

    	let height;
    	 $$invalidate(1, height = "40vh");

    	return [
    		dragging,
    		height,
    		$currentTab,
    		$dataStore,
    		outputData,
    		outputCheck,
    		sendSolution,
    		client,
    		keydown_handler,
    		mousedown_handler,
    		click_handler,
    		mousemove_handler,
    		mouseup_handler
    	];
    }

    class EditorArea extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EditorArea",
    			options,
    			id: create_fragment$4.name
    		});
    	}
    }

    /* src/Tabs.svelte generated by Svelte v3.18.1 */
    const file$3 = "src/Tabs.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[2] = list[i];
    	child_ctx[4] = i;
    	return child_ctx;
    }

    // (78:2) {#each $dataStore as tab, index}
    function create_each_block(ctx) {
    	let div;
    	let li;
    	let t0;
    	let t1_value = /*tab*/ ctx[2].id + "";
    	let t1;
    	let t2;
    	let dispose;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[1](/*tab*/ ctx[2], ...args);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			li = element("li");
    			t0 = text("Problem ");
    			t1 = text(t1_value);
    			t2 = space();
    			attr_dev(li, "class", "tab flex-grow svelte-1ph5tii");
    			toggle_class(li, "active", /*tab*/ ctx[2].active);
    			add_location(li, file$3, 79, 6, 3596);
    			attr_dev(div, "class", "flex-grow flex parentDiv svelte-1ph5tii");
    			add_location(div, file$3, 78, 4, 3551);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, li);
    			append_dev(li, t0);
    			append_dev(li, t1);
    			append_dev(div, t2);
    			dispose = listen_dev(li, "click", click_handler, false, false, false);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*$dataStore*/ 1 && t1_value !== (t1_value = /*tab*/ ctx[2].id + "")) set_data_dev(t1, t1_value);

    			if (dirty & /*$dataStore*/ 1) {
    				toggle_class(li, "active", /*tab*/ ctx[2].active);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(78:2) {#each $dataStore as tab, index}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let ul;
    	let each_value = /*$dataStore*/ ctx[0];
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ul, "class", "tabs flex svelte-1ph5tii");
    			add_location(ul, file$3, 76, 0, 3489);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$dataStore, dataStore*/ 1) {
    				each_value = /*$dataStore*/ ctx[0];
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let $dataStore;
    	validate_store(dataStore, "dataStore");
    	component_subscribe($$self, dataStore, $$value => $$invalidate(0, $dataStore = $$value));
    	const click_handler = tab => dataStore.activate(tab.id);

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("$dataStore" in $$props) dataStore.set($dataStore = $$props.$dataStore);
    	};

    	return [$dataStore, click_handler];
    }

    class Tabs extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tabs",
    			options,
    			id: create_fragment$5.name
    		});
    	}
    }

    var bind = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };

    /*global toString:true*/

    // utils is a library of generic helper functions non-specific to axios

    var toString$2 = Object.prototype.toString;

    /**
     * Determine if a value is an Array
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Array, otherwise false
     */
    function isArray(val) {
      return toString$2.call(val) === '[object Array]';
    }

    /**
     * Determine if a value is undefined
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if the value is undefined, otherwise false
     */
    function isUndefined(val) {
      return typeof val === 'undefined';
    }

    /**
     * Determine if a value is a Buffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Buffer, otherwise false
     */
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
        && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
    }

    /**
     * Determine if a value is an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an ArrayBuffer, otherwise false
     */
    function isArrayBuffer(val) {
      return toString$2.call(val) === '[object ArrayBuffer]';
    }

    /**
     * Determine if a value is a FormData
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an FormData, otherwise false
     */
    function isFormData(val) {
      return (typeof FormData !== 'undefined') && (val instanceof FormData);
    }

    /**
     * Determine if a value is a view on an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
     */
    function isArrayBufferView(val) {
      var result;
      if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
        result = ArrayBuffer.isView(val);
      } else {
        result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
      }
      return result;
    }

    /**
     * Determine if a value is a String
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a String, otherwise false
     */
    function isString(val) {
      return typeof val === 'string';
    }

    /**
     * Determine if a value is a Number
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Number, otherwise false
     */
    function isNumber(val) {
      return typeof val === 'number';
    }

    /**
     * Determine if a value is an Object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Object, otherwise false
     */
    function isObject$1(val) {
      return val !== null && typeof val === 'object';
    }

    /**
     * Determine if a value is a Date
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Date, otherwise false
     */
    function isDate(val) {
      return toString$2.call(val) === '[object Date]';
    }

    /**
     * Determine if a value is a File
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a File, otherwise false
     */
    function isFile(val) {
      return toString$2.call(val) === '[object File]';
    }

    /**
     * Determine if a value is a Blob
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Blob, otherwise false
     */
    function isBlob(val) {
      return toString$2.call(val) === '[object Blob]';
    }

    /**
     * Determine if a value is a Function
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Function, otherwise false
     */
    function isFunction(val) {
      return toString$2.call(val) === '[object Function]';
    }

    /**
     * Determine if a value is a Stream
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Stream, otherwise false
     */
    function isStream(val) {
      return isObject$1(val) && isFunction(val.pipe);
    }

    /**
     * Determine if a value is a URLSearchParams object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a URLSearchParams object, otherwise false
     */
    function isURLSearchParams(val) {
      return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
    }

    /**
     * Trim excess whitespace off the beginning and end of a string
     *
     * @param {String} str The String to trim
     * @returns {String} The String freed of excess whitespace
     */
    function trim(str) {
      return str.replace(/^\s*/, '').replace(/\s*$/, '');
    }

    /**
     * Determine if we're running in a standard browser environment
     *
     * This allows axios to run in a web worker, and react-native.
     * Both environments support XMLHttpRequest, but not fully standard globals.
     *
     * web workers:
     *  typeof window -> undefined
     *  typeof document -> undefined
     *
     * react-native:
     *  navigator.product -> 'ReactNative'
     * nativescript
     *  navigator.product -> 'NativeScript' or 'NS'
     */
    function isStandardBrowserEnv() {
      if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                               navigator.product === 'NativeScript' ||
                                               navigator.product === 'NS')) {
        return false;
      }
      return (
        typeof window !== 'undefined' &&
        typeof document !== 'undefined'
      );
    }

    /**
     * Iterate over an Array or an Object invoking a function for each item.
     *
     * If `obj` is an Array callback will be called passing
     * the value, index, and complete array for each item.
     *
     * If 'obj' is an Object callback will be called passing
     * the value, key, and complete object for each property.
     *
     * @param {Object|Array} obj The object to iterate
     * @param {Function} fn The callback to invoke for each item
     */
    function forEach(obj, fn) {
      // Don't bother if no value provided
      if (obj === null || typeof obj === 'undefined') {
        return;
      }

      // Force an array if not already something iterable
      if (typeof obj !== 'object') {
        /*eslint no-param-reassign:0*/
        obj = [obj];
      }

      if (isArray(obj)) {
        // Iterate over array values
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        // Iterate over object keys
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }

    /**
     * Accepts varargs expecting each argument to be an object, then
     * immutably merges the properties of each object and returns result.
     *
     * When multiple objects contain the same key the later object in
     * the arguments list will take precedence.
     *
     * Example:
     *
     * ```js
     * var result = merge({foo: 123}, {foo: 456});
     * console.log(result.foo); // outputs 456
     * ```
     *
     * @param {Object} obj1 Object to merge
     * @returns {Object} Result of all merge properties
     */
    function merge(/* obj1, obj2, obj3, ... */) {
      var result = {};
      function assignValue(val, key) {
        if (typeof result[key] === 'object' && typeof val === 'object') {
          result[key] = merge(result[key], val);
        } else {
          result[key] = val;
        }
      }

      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }

    /**
     * Function equal to merge with the difference being that no reference
     * to original objects is kept.
     *
     * @see merge
     * @param {Object} obj1 Object to merge
     * @returns {Object} Result of all merge properties
     */
    function deepMerge(/* obj1, obj2, obj3, ... */) {
      var result = {};
      function assignValue(val, key) {
        if (typeof result[key] === 'object' && typeof val === 'object') {
          result[key] = deepMerge(result[key], val);
        } else if (typeof val === 'object') {
          result[key] = deepMerge({}, val);
        } else {
          result[key] = val;
        }
      }

      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }

    /**
     * Extends object a by mutably adding to it the properties of object b.
     *
     * @param {Object} a The object to be extended
     * @param {Object} b The object to copy properties from
     * @param {Object} thisArg The object to bind function to
     * @return {Object} The resulting value of object a
     */
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === 'function') {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }

    var utils$1 = {
      isArray: isArray,
      isArrayBuffer: isArrayBuffer,
      isBuffer: isBuffer,
      isFormData: isFormData,
      isArrayBufferView: isArrayBufferView,
      isString: isString,
      isNumber: isNumber,
      isObject: isObject$1,
      isUndefined: isUndefined,
      isDate: isDate,
      isFile: isFile,
      isBlob: isBlob,
      isFunction: isFunction,
      isStream: isStream,
      isURLSearchParams: isURLSearchParams,
      isStandardBrowserEnv: isStandardBrowserEnv,
      forEach: forEach,
      merge: merge,
      deepMerge: deepMerge,
      extend: extend,
      trim: trim
    };

    function encode(val) {
      return encodeURIComponent(val).
        replace(/%40/gi, '@').
        replace(/%3A/gi, ':').
        replace(/%24/g, '$').
        replace(/%2C/gi, ',').
        replace(/%20/g, '+').
        replace(/%5B/gi, '[').
        replace(/%5D/gi, ']');
    }

    /**
     * Build a URL by appending params to the end
     *
     * @param {string} url The base of the url (e.g., http://www.google.com)
     * @param {object} [params] The params to be appended
     * @returns {string} The formatted url
     */
    var buildURL = function buildURL(url, params, paramsSerializer) {
      /*eslint no-param-reassign:0*/
      if (!params) {
        return url;
      }

      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils$1.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];

        utils$1.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === 'undefined') {
            return;
          }

          if (utils$1.isArray(val)) {
            key = key + '[]';
          } else {
            val = [val];
          }

          utils$1.forEach(val, function parseValue(v) {
            if (utils$1.isDate(v)) {
              v = v.toISOString();
            } else if (utils$1.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + '=' + encode(v));
          });
        });

        serializedParams = parts.join('&');
      }

      if (serializedParams) {
        var hashmarkIndex = url.indexOf('#');
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }

        url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
      }

      return url;
    };

    function InterceptorManager() {
      this.handlers = [];
    }

    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    InterceptorManager.prototype.use = function use(fulfilled, rejected) {
      this.handlers.push({
        fulfilled: fulfilled,
        rejected: rejected
      });
      return this.handlers.length - 1;
    };

    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     */
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };

    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     */
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils$1.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };

    var InterceptorManager_1 = InterceptorManager;

    /**
     * Transform the data for a request or a response
     *
     * @param {Object|String} data The data to be transformed
     * @param {Array} headers The headers for the request or response
     * @param {Array|Function} fns A single function or Array of functions
     * @returns {*} The resulting transformed data
     */
    var transformData = function transformData(data, headers, fns) {
      /*eslint no-param-reassign:0*/
      utils$1.forEach(fns, function transform(fn) {
        data = fn(data, headers);
      });

      return data;
    };

    var isCancel = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };

    var normalizeHeaderName = function normalizeHeaderName(headers, normalizedName) {
      utils$1.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };

    /**
     * Update an Error with the specified config, error code, and response.
     *
     * @param {Error} error The error to update.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The error.
     */
    var enhanceError = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }

      error.request = request;
      error.response = response;
      error.isAxiosError = true;

      error.toJSON = function() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code
        };
      };
      return error;
    };

    /**
     * Create an Error with the specified message, config, error code, request and response.
     *
     * @param {string} message The error message.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The created error.
     */
    var createError = function createError(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };

    /**
     * Resolve or reject a Promise based on response status.
     *
     * @param {Function} resolve A function that resolves the promise.
     * @param {Function} reject A function that rejects the promise.
     * @param {object} response The response.
     */
    var settle = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError(
          'Request failed with status code ' + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };

    /**
     * Determines whether the specified URL is absolute
     *
     * @param {string} url The URL to test
     * @returns {boolean} True if the specified URL is absolute, otherwise false
     */
    var isAbsoluteURL = function isAbsoluteURL(url) {
      // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
      // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
      // by any combination of letters, digits, plus, period, or hyphen.
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };

    /**
     * Creates a new URL by combining the specified URLs
     *
     * @param {string} baseURL The base URL
     * @param {string} relativeURL The relative URL
     * @returns {string} The combined URL
     */
    var combineURLs = function combineURLs(baseURL, relativeURL) {
      return relativeURL
        ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
        : baseURL;
    };

    /**
     * Creates a new URL by combining the baseURL with the requestedURL,
     * only when the requestedURL is not already an absolute URL.
     * If the requestURL is absolute, this function returns the requestedURL untouched.
     *
     * @param {string} baseURL The base URL
     * @param {string} requestedURL Absolute or relative URL to combine
     * @returns {string} The combined full path
     */
    var buildFullPath = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };

    // Headers whose duplicates are ignored by node
    // c.f. https://nodejs.org/api/http.html#http_message_headers
    var ignoreDuplicateOf = [
      'age', 'authorization', 'content-length', 'content-type', 'etag',
      'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
      'last-modified', 'location', 'max-forwards', 'proxy-authorization',
      'referer', 'retry-after', 'user-agent'
    ];

    /**
     * Parse headers into an object
     *
     * ```
     * Date: Wed, 27 Aug 2014 08:58:49 GMT
     * Content-Type: application/json
     * Connection: keep-alive
     * Transfer-Encoding: chunked
     * ```
     *
     * @param {String} headers Headers needing to be parsed
     * @returns {Object} Headers parsed into an object
     */
    var parseHeaders = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;

      if (!headers) { return parsed; }

      utils$1.forEach(headers.split('\n'), function parser(line) {
        i = line.indexOf(':');
        key = utils$1.trim(line.substr(0, i)).toLowerCase();
        val = utils$1.trim(line.substr(i + 1));

        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === 'set-cookie') {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
          }
        }
      });

      return parsed;
    };

    var isURLSameOrigin = (
      utils$1.isStandardBrowserEnv() ?

      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
        (function standardBrowserEnv() {
          var msie = /(msie|trident)/i.test(navigator.userAgent);
          var urlParsingNode = document.createElement('a');
          var originURL;

          /**
        * Parse a URL to discover it's components
        *
        * @param {String} url The URL to be parsed
        * @returns {Object}
        */
          function resolveURL(url) {
            var href = url;

            if (msie) {
            // IE needs attribute set twice to normalize properties
              urlParsingNode.setAttribute('href', href);
              href = urlParsingNode.href;
            }

            urlParsingNode.setAttribute('href', href);

            // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
            return {
              href: urlParsingNode.href,
              protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
              host: urlParsingNode.host,
              search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
              hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
              hostname: urlParsingNode.hostname,
              port: urlParsingNode.port,
              pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                urlParsingNode.pathname :
                '/' + urlParsingNode.pathname
            };
          }

          originURL = resolveURL(window.location.href);

          /**
        * Determine if a URL shares the same origin as the current location
        *
        * @param {String} requestURL The URL to test
        * @returns {boolean} True if URL shares the same origin, otherwise false
        */
          return function isURLSameOrigin(requestURL) {
            var parsed = (utils$1.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
            return (parsed.protocol === originURL.protocol &&
                parsed.host === originURL.host);
          };
        })() :

      // Non standard browser envs (web workers, react-native) lack needed support.
        (function nonStandardBrowserEnv() {
          return function isURLSameOrigin() {
            return true;
          };
        })()
    );

    var cookies = (
      utils$1.isStandardBrowserEnv() ?

      // Standard browser envs support document.cookie
        (function standardBrowserEnv() {
          return {
            write: function write(name, value, expires, path, domain, secure) {
              var cookie = [];
              cookie.push(name + '=' + encodeURIComponent(value));

              if (utils$1.isNumber(expires)) {
                cookie.push('expires=' + new Date(expires).toGMTString());
              }

              if (utils$1.isString(path)) {
                cookie.push('path=' + path);
              }

              if (utils$1.isString(domain)) {
                cookie.push('domain=' + domain);
              }

              if (secure === true) {
                cookie.push('secure');
              }

              document.cookie = cookie.join('; ');
            },

            read: function read(name) {
              var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
              return (match ? decodeURIComponent(match[3]) : null);
            },

            remove: function remove(name) {
              this.write(name, '', Date.now() - 86400000);
            }
          };
        })() :

      // Non standard browser env (web workers, react-native) lack needed support.
        (function nonStandardBrowserEnv() {
          return {
            write: function write() {},
            read: function read() { return null; },
            remove: function remove() {}
          };
        })()
    );

    var xhr = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;

        if (utils$1.isFormData(requestData)) {
          delete requestHeaders['Content-Type']; // Let the browser set it
        }

        var request = new XMLHttpRequest();

        // HTTP basic authentication
        if (config.auth) {
          var username = config.auth.username || '';
          var password = config.auth.password || '';
          requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
        }

        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

        // Set the request timeout in MS
        request.timeout = config.timeout;

        // Listen for ready state
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }

          // The request errored out and we didn't get a response, this will be
          // handled by onerror instead
          // With one exception: request that using file: protocol, most browsers
          // will return status as 0 even though it's a successful request
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
            return;
          }

          // Prepare the response
          var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config: config,
            request: request
          };

          settle(resolve, reject, response);

          // Clean up request
          request = null;
        };

        // Handle browser request cancellation (as opposed to a manual cancellation)
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }

          reject(createError('Request aborted', config, 'ECONNABORTED', request));

          // Clean up request
          request = null;
        };

        // Handle low level network errors
        request.onerror = function handleError() {
          // Real errors are hidden from us by the browser
          // onerror should only fire if it's a network error
          reject(createError('Network Error', config, null, request));

          // Clean up request
          request = null;
        };

        // Handle timeout
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',
            request));

          // Clean up request
          request = null;
        };

        // Add xsrf header
        // This is only done if running in a standard browser environment.
        // Specifically not if we're in a web worker, or react-native.
        if (utils$1.isStandardBrowserEnv()) {
          var cookies$1 = cookies;

          // Add xsrf header
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
            cookies$1.read(config.xsrfCookieName) :
            undefined;

          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }

        // Add headers to the request
        if ('setRequestHeader' in request) {
          utils$1.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
              // Remove Content-Type if data is undefined
              delete requestHeaders[key];
            } else {
              // Otherwise add header to the request
              request.setRequestHeader(key, val);
            }
          });
        }

        // Add withCredentials to request if needed
        if (!utils$1.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }

        // Add responseType to request if needed
        if (config.responseType) {
          try {
            request.responseType = config.responseType;
          } catch (e) {
            // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
            // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
            if (config.responseType !== 'json') {
              throw e;
            }
          }
        }

        // Handle progress if needed
        if (typeof config.onDownloadProgress === 'function') {
          request.addEventListener('progress', config.onDownloadProgress);
        }

        // Not all browsers support upload events
        if (typeof config.onUploadProgress === 'function' && request.upload) {
          request.upload.addEventListener('progress', config.onUploadProgress);
        }

        if (config.cancelToken) {
          // Handle cancellation
          config.cancelToken.promise.then(function onCanceled(cancel) {
            if (!request) {
              return;
            }

            request.abort();
            reject(cancel);
            // Clean up request
            request = null;
          });
        }

        if (requestData === undefined) {
          requestData = null;
        }

        // Send the request
        request.send(requestData);
      });
    };

    var DEFAULT_CONTENT_TYPE = {
      'Content-Type': 'application/x-www-form-urlencoded'
    };

    function setContentTypeIfUnset(headers, value) {
      if (!utils$1.isUndefined(headers) && utils$1.isUndefined(headers['Content-Type'])) {
        headers['Content-Type'] = value;
      }
    }

    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== 'undefined') {
        // For browsers use XHR adapter
        adapter = xhr;
      } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
        // For node use HTTP adapter
        adapter = xhr;
      }
      return adapter;
    }

    var defaults = {
      adapter: getDefaultAdapter(),

      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, 'Accept');
        normalizeHeaderName(headers, 'Content-Type');
        if (utils$1.isFormData(data) ||
          utils$1.isArrayBuffer(data) ||
          utils$1.isBuffer(data) ||
          utils$1.isStream(data) ||
          utils$1.isFile(data) ||
          utils$1.isBlob(data)
        ) {
          return data;
        }
        if (utils$1.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils$1.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
          return data.toString();
        }
        if (utils$1.isObject(data)) {
          setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
          return JSON.stringify(data);
        }
        return data;
      }],

      transformResponse: [function transformResponse(data) {
        /*eslint no-param-reassign:0*/
        if (typeof data === 'string') {
          try {
            data = JSON.parse(data);
          } catch (e) { /* Ignore */ }
        }
        return data;
      }],

      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,

      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',

      maxContentLength: -1,

      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      }
    };

    defaults.headers = {
      common: {
        'Accept': 'application/json, text/plain, */*'
      }
    };

    utils$1.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });

    utils$1.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      defaults.headers[method] = utils$1.merge(DEFAULT_CONTENT_TYPE);
    });

    var defaults_1 = defaults;

    /**
     * Throws a `Cancel` if cancellation has been requested.
     */
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
    }

    /**
     * Dispatch a request to the server using the configured adapter.
     *
     * @param {object} config The config that is to be used for the request
     * @returns {Promise} The Promise to be fulfilled
     */
    var dispatchRequest = function dispatchRequest(config) {
      throwIfCancellationRequested(config);

      // Ensure headers exist
      config.headers = config.headers || {};

      // Transform request data
      config.data = transformData(
        config.data,
        config.headers,
        config.transformRequest
      );

      // Flatten headers
      config.headers = utils$1.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );

      utils$1.forEach(
        ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );

      var adapter = config.adapter || defaults_1.adapter;

      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);

        // Transform response data
        response.data = transformData(
          response.data,
          response.headers,
          config.transformResponse
        );

        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);

          // Transform response data
          if (reason && reason.response) {
            reason.response.data = transformData(
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }

        return Promise.reject(reason);
      });
    };

    /**
     * Config-specific merge-function which creates a new config-object
     * by merging two configuration objects together.
     *
     * @param {Object} config1
     * @param {Object} config2
     * @returns {Object} New object resulting from merging config2 to config1
     */
    var mergeConfig = function mergeConfig(config1, config2) {
      // eslint-disable-next-line no-param-reassign
      config2 = config2 || {};
      var config = {};

      var valueFromConfig2Keys = ['url', 'method', 'params', 'data'];
      var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy'];
      var defaultToConfig2Keys = [
        'baseURL', 'url', 'transformRequest', 'transformResponse', 'paramsSerializer',
        'timeout', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
        'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress',
        'maxContentLength', 'validateStatus', 'maxRedirects', 'httpAgent',
        'httpsAgent', 'cancelToken', 'socketPath'
      ];

      utils$1.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
        if (typeof config2[prop] !== 'undefined') {
          config[prop] = config2[prop];
        }
      });

      utils$1.forEach(mergeDeepPropertiesKeys, function mergeDeepProperties(prop) {
        if (utils$1.isObject(config2[prop])) {
          config[prop] = utils$1.deepMerge(config1[prop], config2[prop]);
        } else if (typeof config2[prop] !== 'undefined') {
          config[prop] = config2[prop];
        } else if (utils$1.isObject(config1[prop])) {
          config[prop] = utils$1.deepMerge(config1[prop]);
        } else if (typeof config1[prop] !== 'undefined') {
          config[prop] = config1[prop];
        }
      });

      utils$1.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
        if (typeof config2[prop] !== 'undefined') {
          config[prop] = config2[prop];
        } else if (typeof config1[prop] !== 'undefined') {
          config[prop] = config1[prop];
        }
      });

      var axiosKeys = valueFromConfig2Keys
        .concat(mergeDeepPropertiesKeys)
        .concat(defaultToConfig2Keys);

      var otherKeys = Object
        .keys(config2)
        .filter(function filterAxiosKeys(key) {
          return axiosKeys.indexOf(key) === -1;
        });

      utils$1.forEach(otherKeys, function otherKeysDefaultToConfig2(prop) {
        if (typeof config2[prop] !== 'undefined') {
          config[prop] = config2[prop];
        } else if (typeof config1[prop] !== 'undefined') {
          config[prop] = config1[prop];
        }
      });

      return config;
    };

    /**
     * Create a new instance of Axios
     *
     * @param {Object} instanceConfig The default config for the instance
     */
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager_1(),
        response: new InterceptorManager_1()
      };
    }

    /**
     * Dispatch a request
     *
     * @param {Object} config The config specific for this request (merged with this.defaults)
     */
    Axios.prototype.request = function request(config) {
      /*eslint no-param-reassign:0*/
      // Allow for axios('example/url'[, config]) a la fetch API
      if (typeof config === 'string') {
        config = arguments[1] || {};
        config.url = arguments[0];
      } else {
        config = config || {};
      }

      config = mergeConfig(this.defaults, config);

      // Set config.method
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = 'get';
      }

      // Hook up interceptors middleware
      var chain = [dispatchRequest, undefined];
      var promise = Promise.resolve(config);

      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        chain.unshift(interceptor.fulfilled, interceptor.rejected);
      });

      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        chain.push(interceptor.fulfilled, interceptor.rejected);
      });

      while (chain.length) {
        promise = promise.then(chain.shift(), chain.shift());
      }

      return promise;
    };

    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
    };

    // Provide aliases for supported request methods
    utils$1.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
      /*eslint func-names:0*/
      Axios.prototype[method] = function(url, config) {
        return this.request(utils$1.merge(config || {}, {
          method: method,
          url: url
        }));
      };
    });

    utils$1.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      /*eslint func-names:0*/
      Axios.prototype[method] = function(url, data, config) {
        return this.request(utils$1.merge(config || {}, {
          method: method,
          url: url,
          data: data
        }));
      };
    });

    var Axios_1 = Axios;

    /**
     * A `Cancel` is an object that is thrown when an operation is canceled.
     *
     * @class
     * @param {string=} message The message.
     */
    function Cancel(message) {
      this.message = message;
    }

    Cancel.prototype.toString = function toString() {
      return 'Cancel' + (this.message ? ': ' + this.message : '');
    };

    Cancel.prototype.__CANCEL__ = true;

    var Cancel_1 = Cancel;

    /**
     * A `CancelToken` is an object that can be used to request cancellation of an operation.
     *
     * @class
     * @param {Function} executor The executor function.
     */
    function CancelToken(executor) {
      if (typeof executor !== 'function') {
        throw new TypeError('executor must be a function.');
      }

      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });

      var token = this;
      executor(function cancel(message) {
        if (token.reason) {
          // Cancellation has already been requested
          return;
        }

        token.reason = new Cancel_1(message);
        resolvePromise(token.reason);
      });
    }

    /**
     * Throws a `Cancel` if cancellation has been requested.
     */
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };

    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token: token,
        cancel: cancel
      };
    };

    var CancelToken_1 = CancelToken;

    /**
     * Syntactic sugar for invoking a function and expanding an array for arguments.
     *
     * Common use case would be to use `Function.prototype.apply`.
     *
     *  ```js
     *  function f(x, y, z) {}
     *  var args = [1, 2, 3];
     *  f.apply(null, args);
     *  ```
     *
     * With `spread` this example can be re-written.
     *
     *  ```js
     *  spread(function(x, y, z) {})([1, 2, 3]);
     *  ```
     *
     * @param {Function} callback
     * @returns {Function}
     */
    var spread = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };

    /**
     * Create an instance of Axios
     *
     * @param {Object} defaultConfig The default config for the instance
     * @return {Axios} A new instance of Axios
     */
    function createInstance(defaultConfig) {
      var context = new Axios_1(defaultConfig);
      var instance = bind(Axios_1.prototype.request, context);

      // Copy axios.prototype to instance
      utils$1.extend(instance, Axios_1.prototype, context);

      // Copy context to instance
      utils$1.extend(instance, context);

      return instance;
    }

    // Create the default instance to be exported
    var axios = createInstance(defaults_1);

    // Expose Axios class to allow class inheritance
    axios.Axios = Axios_1;

    // Factory for creating new instances
    axios.create = function create(instanceConfig) {
      return createInstance(mergeConfig(axios.defaults, instanceConfig));
    };

    // Expose Cancel & CancelToken
    axios.Cancel = Cancel_1;
    axios.CancelToken = CancelToken_1;
    axios.isCancel = isCancel;

    // Expose all/spread
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;

    var axios_1 = axios;

    // Allow use of default import syntax in TypeScript
    var default_1 = axios;
    axios_1.default = default_1;

    var axios$1 = axios_1;

    var pubnub_min = createCommonjsModule(function (module, exports) {
    !function(e,t){module.exports=t();}(window,function(){return r={},i.m=n=[function(e,t,n){e.exports={};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;t.default={PNTimeOperation:"PNTimeOperation",PNHistoryOperation:"PNHistoryOperation",PNDeleteMessagesOperation:"PNDeleteMessagesOperation",PNFetchMessagesOperation:"PNFetchMessagesOperation",PNMessageCounts:"PNMessageCountsOperation",PNSubscribeOperation:"PNSubscribeOperation",PNUnsubscribeOperation:"PNUnsubscribeOperation",PNPublishOperation:"PNPublishOperation",PNSignalOperation:"PNSignalOperation",PNAddMessageActionOperation:"PNAddActionOperation",PNRemoveMessageActionOperation:"PNRemoveMessageActionOperation",PNGetMessageActionsOperation:"PNGetMessageActionsOperation",PNCreateUserOperation:"PNCreateUserOperation",PNUpdateUserOperation:"PNUpdateUserOperation",PNDeleteUserOperation:"PNDeleteUserOperation",PNGetUserOperation:"PNGetUsersOperation",PNGetUsersOperation:"PNGetUsersOperation",PNCreateSpaceOperation:"PNCreateSpaceOperation",PNUpdateSpaceOperation:"PNUpdateSpaceOperation",PNDeleteSpaceOperation:"PNDeleteSpaceOperation",PNGetSpaceOperation:"PNGetSpacesOperation",PNGetSpacesOperation:"PNGetSpacesOperation",PNGetMembersOperation:"PNGetMembersOperation",PNUpdateMembersOperation:"PNUpdateMembersOperation",PNGetMembershipsOperation:"PNGetMembershipsOperation",PNUpdateMembershipsOperation:"PNUpdateMembershipsOperation",PNPushNotificationEnabledChannelsOperation:"PNPushNotificationEnabledChannelsOperation",PNRemoveAllPushNotificationsOperation:"PNRemoveAllPushNotificationsOperation",PNWhereNowOperation:"PNWhereNowOperation",PNSetStateOperation:"PNSetStateOperation",PNHereNowOperation:"PNHereNowOperation",PNGetStateOperation:"PNGetStateOperation",PNHeartbeatOperation:"PNHeartbeatOperation",PNChannelGroupsOperation:"PNChannelGroupsOperation",PNRemoveGroupOperation:"PNRemoveGroupOperation",PNChannelsForGroupOperation:"PNChannelsForGroupOperation",PNAddChannelsToGroupOperation:"PNAddChannelsToGroupOperation",PNRemoveChannelsFromGroupOperation:"PNRemoveChannelsFromGroupOperation",PNAccessManagerGrant:"PNAccessManagerGrant",PNAccessManagerGrantToken:"PNAccessManagerGrantToken",PNAccessManagerAudit:"PNAccessManagerAudit"},e.exports=t.default;},function(e,t,n){function r(e){return encodeURIComponent(e).replace(/[!~*'()]/g,function(e){return "%".concat(e.charCodeAt(0).toString(16).toUpperCase())})}function i(e){return function(e){var t=[];return Object.keys(e).forEach(function(e){return t.push(e)}),t}(e).sort()}e.exports={signPamFromParams:function(t){return i(t).map(function(e){return "".concat(e,"=").concat(r(t[e]))}).join("&")},endsWith:function(e,t){return -1!==e.indexOf(t,this.length-t.length)},createPromise:function(){var n,r;return {promise:new Promise(function(e,t){n=e,r=t;}),reject:r,fulfill:n}},encodeString:r};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var r,i=(r=n(5))&&r.__esModule?r:{default:r};n(0);function o(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r);}}function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var a,u,f=(a=l,(u=[{key:"getAuthKey",value:function(){return this.authKey}},{key:"setAuthKey",value:function(e){return this.authKey=e,this}},{key:"setCipherKey",value:function(e){return this.cipherKey=e,this}},{key:"getUUID",value:function(){return this.UUID}},{key:"setUUID",value:function(e){return this._db&&this._db.set&&this._db.set("".concat(this.subscribeKey,"uuid"),e),this.UUID=e,this}},{key:"getFilterExpression",value:function(){return this.filterExpression}},{key:"setFilterExpression",value:function(e){return this.filterExpression=e,this}},{key:"getPresenceTimeout",value:function(){return this._presenceTimeout}},{key:"setPresenceTimeout",value:function(e){return 20<=e?this._presenceTimeout=e:(this._presenceTimeout=20,console.log("WARNING: Presence timeout is less than the minimum. Using minimum value: ",this._presenceTimeout)),this.setHeartbeatInterval(this._presenceTimeout/2-1),this}},{key:"setProxy",value:function(e){this.proxy=e;}},{key:"getHeartbeatInterval",value:function(){return this._heartbeatInterval}},{key:"setHeartbeatInterval",value:function(e){return this._heartbeatInterval=e,this}},{key:"getSubscribeTimeout",value:function(){return this._subscribeRequestTimeout}},{key:"setSubscribeTimeout",value:function(e){return this._subscribeRequestTimeout=e,this}},{key:"getTransactionTimeout",value:function(){return this._transactionalRequestTimeout}},{key:"setTransactionTimeout",value:function(e){return this._transactionalRequestTimeout=e,this}},{key:"isSendBeaconEnabled",value:function(){return this._useSendBeacon}},{key:"setSendBeaconConfig",value:function(e){return this._useSendBeacon=e,this}},{key:"getVersion",value:function(){return "4.27.3"}},{key:"_addPnsdkSuffix",value:function(e,t){this._PNSDKSuffix[e]=t;}},{key:"_getPnsdkSuffix",value:function(n){var r=this;return Object.keys(this._PNSDKSuffix).reduce(function(e,t){return e+n+r._PNSDKSuffix[t]},"")}},{key:"_decideUUID",value:function(e){return e||(this._db&&this._db.get&&this._db.get("".concat(this.subscribeKey,"uuid"))?this._db.get("".concat(this.subscribeKey,"uuid")):"pn-".concat(i.default.createUUID()))}}])&&o(a.prototype,u),l);function l(e){var t=e.setup,n=e.db;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,l),s(this,"_db",void 0),s(this,"subscribeKey",void 0),s(this,"publishKey",void 0),s(this,"secretKey",void 0),s(this,"cipherKey",void 0),s(this,"authKey",void 0),s(this,"UUID",void 0),s(this,"proxy",void 0),s(this,"instanceId",void 0),s(this,"sdkName",void 0),s(this,"sdkFamily",void 0),s(this,"partnerId",void 0),s(this,"filterExpression",void 0),s(this,"suppressLeaveEvents",void 0),s(this,"secure",void 0),s(this,"origin",void 0),s(this,"logVerbosity",void 0),s(this,"useInstanceId",void 0),s(this,"useRequestId",void 0),s(this,"keepAlive",void 0),s(this,"keepAliveSettings",void 0),s(this,"autoNetworkDetection",void 0),s(this,"announceSuccessfulHeartbeats",void 0),s(this,"announceFailedHeartbeats",void 0),s(this,"_presenceTimeout",void 0),s(this,"_heartbeatInterval",void 0),s(this,"_subscribeRequestTimeout",void 0),s(this,"_transactionalRequestTimeout",void 0),s(this,"_useSendBeacon",void 0),s(this,"_PNSDKSuffix",void 0),s(this,"requestMessageCountThreshold",void 0),s(this,"restore",void 0),s(this,"dedupeOnSubscribe",void 0),s(this,"maximumCacheSize",void 0),s(this,"customEncrypt",void 0),s(this,"customDecrypt",void 0),this._PNSDKSuffix={},this._db=n,this.instanceId="pn-".concat(i.default.createUUID()),this.secretKey=t.secretKey||t.secret_key,this.subscribeKey=t.subscribeKey||t.subscribe_key,this.publishKey=t.publishKey||t.publish_key,this.sdkName=t.sdkName,this.sdkFamily=t.sdkFamily,this.partnerId=t.partnerId,this.setAuthKey(t.authKey),this.setCipherKey(t.cipherKey),this.setFilterExpression(t.filterExpression),this.origin=t.origin||"ps.pndsn.com",this.secure=t.ssl||!1,this.restore=t.restore||!1,this.proxy=t.proxy,this.keepAlive=t.keepAlive,this.keepAliveSettings=t.keepAliveSettings,this.autoNetworkDetection=t.autoNetworkDetection||!1,this.dedupeOnSubscribe=t.dedupeOnSubscribe||!1,this.maximumCacheSize=t.maximumCacheSize||100,this.customEncrypt=t.customEncrypt,this.customDecrypt=t.customDecrypt,"undefined"!=typeof location&&"https:"===location.protocol&&(this.secure=!0),this.logVerbosity=t.logVerbosity||!1,this.suppressLeaveEvents=t.suppressLeaveEvents||!1,this.announceFailedHeartbeats=t.announceFailedHeartbeats||!0,this.announceSuccessfulHeartbeats=t.announceSuccessfulHeartbeats||!1,this.useInstanceId=t.useInstanceId||!1,this.useRequestId=t.useRequestId||!1,this.requestMessageCountThreshold=t.requestMessageCountThreshold,this.setTransactionTimeout(t.transactionalRequestTimeout||15e3),this.setSubscribeTimeout(t.subscribeRequestTimeout||31e4),this.setSendBeaconConfig(t.useSendBeacon||!0),t.presenceTimeout?this.setPresenceTimeout(t.presenceTimeout):this._presenceTimeout=300,null!=t.heartbeatInterval&&this.setHeartbeatInterval(t.heartbeatInterval),this.setUUID(this._decideUUID(t.uuid));}t.default=f,e.exports=t.default;},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;t.default={PNNetworkUpCategory:"PNNetworkUpCategory",PNNetworkDownCategory:"PNNetworkDownCategory",PNNetworkIssuesCategory:"PNNetworkIssuesCategory",PNTimeoutCategory:"PNTimeoutCategory",PNBadRequestCategory:"PNBadRequestCategory",PNAccessDeniedCategory:"PNAccessDeniedCategory",PNUnknownCategory:"PNUnknownCategory",PNReconnectedCategory:"PNReconnectedCategory",PNConnectedCategory:"PNConnectedCategory",PNRequestMessageCountExceededCategory:"PNRequestMessageCountExceededCategory"},e.exports=t.default;},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var r,i=(r=n(13))&&r.__esModule?r:{default:r};var o={createUUID:function(){return i.default.uuid?i.default.uuid():(0, i.default)()}};t.default=o,e.exports=t.default;},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;r(n(3));var u=r(n(14));function r(e){return e&&e.__esModule?e:{default:e}}function i(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r);}}function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var s,a,f=(s=l,(a=[{key:"HMACSHA256",value:function(e){return u.default.HmacSHA256(e,this._config.secretKey).toString(u.default.enc.Base64)}},{key:"SHA256",value:function(e){return u.default.SHA256(e).toString(u.default.enc.Hex)}},{key:"_parseOptions",value:function(e){var t=e||{};return t.hasOwnProperty("encryptKey")||(t.encryptKey=this._defaultOptions.encryptKey),t.hasOwnProperty("keyEncoding")||(t.keyEncoding=this._defaultOptions.keyEncoding),t.hasOwnProperty("keyLength")||(t.keyLength=this._defaultOptions.keyLength),t.hasOwnProperty("mode")||(t.mode=this._defaultOptions.mode),-1===this._allowedKeyEncodings.indexOf(t.keyEncoding.toLowerCase())&&(t.keyEncoding=this._defaultOptions.keyEncoding),-1===this._allowedKeyLengths.indexOf(parseInt(t.keyLength,10))&&(t.keyLength=this._defaultOptions.keyLength),-1===this._allowedModes.indexOf(t.mode.toLowerCase())&&(t.mode=this._defaultOptions.mode),t}},{key:"_decodeKey",value:function(e,t){return "base64"===t.keyEncoding?u.default.enc.Base64.parse(e):"hex"===t.keyEncoding?u.default.enc.Hex.parse(e):e}},{key:"_getPaddedKey",value:function(e,t){return e=this._decodeKey(e,t),t.encryptKey?u.default.enc.Utf8.parse(this.SHA256(e).slice(0,32)):e}},{key:"_getMode",value:function(e){return "ecb"===e.mode?u.default.mode.ECB:u.default.mode.CBC}},{key:"_getIV",value:function(e){return "cbc"===e.mode?u.default.enc.Utf8.parse(this._iv):null}},{key:"encrypt",value:function(e,t,n){return this._config.customEncrypt?this._config.customEncrypt(e):this.pnEncrypt(e,t,n)}},{key:"decrypt",value:function(e,t,n){return this._config.customDecrypt?this._config.customDecrypt(e):this.pnDecrypt(e,t,n)}},{key:"pnEncrypt",value:function(e,t,n){if(!t&&!this._config.cipherKey)return e;n=this._parseOptions(n);var r=this._getIV(n),i=this._getMode(n),o=this._getPaddedKey(t||this._config.cipherKey,n);return u.default.AES.encrypt(e,o,{iv:r,mode:i}).ciphertext.toString(u.default.enc.Base64)||e}},{key:"pnDecrypt",value:function(e,t,n){if(!t&&!this._config.cipherKey)return e;n=this._parseOptions(n);var r=this._getIV(n),i=this._getMode(n),o=this._getPaddedKey(t||this._config.cipherKey,n);try{var s=u.default.enc.Base64.parse(e),a=u.default.AES.decrypt({ciphertext:s},o,{iv:r,mode:i}).toString(u.default.enc.Utf8);return JSON.parse(a)}catch(e){return null}}}])&&i(s.prototype,a),l);function l(e){var t=e.config;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,l),o(this,"_config",void 0),o(this,"_iv",void 0),o(this,"_allowedKeyEncodings",void 0),o(this,"_allowedKeyLengths",void 0),o(this,"_allowedModes",void 0),o(this,"_defaultOptions",void 0),this._config=t,this._iv="0123456789012345",this._allowedKeyEncodings=["hex","utf8","base64","binary"],this._allowedKeyLengths=[128,256],this._allowedModes=["ecb","cbc"],this._defaultOptions={encryptKey:!0,keyEncoding:"utf8",keyLength:256,mode:"cbc"};}t.default=f,e.exports=t.default;},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;n(0);var r,i=(r=n(4))&&r.__esModule?r:{default:r};function o(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r);}}var s,a,c=(s=f,(a=[{key:"addListener",value:function(e){this._listeners.push(e);}},{key:"removeListener",value:function(t){var n=[];this._listeners.forEach(function(e){e!==t&&n.push(e);}),this._listeners=n;}},{key:"removeAllListeners",value:function(){this._listeners=[];}},{key:"announcePresence",value:function(t){this._listeners.forEach(function(e){e.presence&&e.presence(t);});}},{key:"announceStatus",value:function(t){this._listeners.forEach(function(e){e.status&&e.status(t);});}},{key:"announceMessage",value:function(t){this._listeners.forEach(function(e){e.message&&e.message(t);});}},{key:"announceSignal",value:function(t){this._listeners.forEach(function(e){e.signal&&e.signal(t);});}},{key:"announceMessageAction",value:function(t){this._listeners.forEach(function(e){e.messageAction&&e.messageAction(t);});}},{key:"announceUser",value:function(t){this._listeners.forEach(function(e){e.user&&e.user(t);});}},{key:"announceSpace",value:function(t){this._listeners.forEach(function(e){e.space&&e.space(t);});}},{key:"announceMembership",value:function(t){this._listeners.forEach(function(e){e.membership&&e.membership(t);});}},{key:"announceNetworkUp",value:function(){var e={};e.category=i.default.PNNetworkUpCategory,this.announceStatus(e);}},{key:"announceNetworkDown",value:function(){var e={};e.category=i.default.PNNetworkDownCategory,this.announceStatus(e);}}])&&o(s.prototype,a),f);function f(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,f),function(e,t,n){t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n;}(this,"_listeners",void 0),this._listeners=[];}t.default=c,e.exports=t.default;},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNTimeOperation},t.getURL=function(){return "/time/0"},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.prepareParams=function(){return {}},t.isAuthSupported=function(){return !1},t.handleResponse=function(e,t){return {timetoken:t[0]}},t.validateParams=function(){};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r};},function(e,I,D){(function(e){var r=D(71),o=D(72),s=D(73);function n(){return l.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function a(e,t){if(n()<t)throw new RangeError("Invalid typed array length");return l.TYPED_ARRAY_SUPPORT?(e=new Uint8Array(t)).__proto__=l.prototype:(null===e&&(e=new l(t)),e.length=t),e}function l(e,t,n){if(!(l.TYPED_ARRAY_SUPPORT||this instanceof l))return new l(e,t,n);if("number"!=typeof e)return i(this,e,t,n);if("string"==typeof t)throw new Error("If encoding is specified then the first argument must be a string");return c(this,e)}function i(e,t,n,r){if("number"==typeof t)throw new TypeError('"value" argument must not be a number');return "undefined"!=typeof ArrayBuffer&&t instanceof ArrayBuffer?function(e,t,n,r){if(t.byteLength,n<0||t.byteLength<n)throw new RangeError("'offset' is out of bounds");if(t.byteLength<n+(r||0))throw new RangeError("'length' is out of bounds");t=void 0===n&&void 0===r?new Uint8Array(t):void 0===r?new Uint8Array(t,n):new Uint8Array(t,n,r);l.TYPED_ARRAY_SUPPORT?(e=t).__proto__=l.prototype:e=f(e,t);return e}(e,t,n,r):"string"==typeof t?function(e,t,n){"string"==typeof n&&""!==n||(n="utf8");if(!l.isEncoding(n))throw new TypeError('"encoding" must be a valid string encoding');var r=0|p(t,n),i=(e=a(e,r)).write(t,n);i!==r&&(e=e.slice(0,i));return e}(e,t,n):function(e,t){if(l.isBuffer(t)){var n=0|h(t.length);return 0===(e=a(e,n)).length||t.copy(e,0,0,n),e}if(t){if("undefined"!=typeof ArrayBuffer&&t.buffer instanceof ArrayBuffer||"length"in t)return "number"!=typeof t.length||function(e){return e!=e}(t.length)?a(e,0):f(e,t);if("Buffer"===t.type&&s(t.data))return f(e,t.data)}throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(e,t)}function u(e){if("number"!=typeof e)throw new TypeError('"size" argument must be a number');if(e<0)throw new RangeError('"size" argument must not be negative')}function c(e,t){if(u(t),e=a(e,t<0?0:0|h(t)),!l.TYPED_ARRAY_SUPPORT)for(var n=0;n<t;++n)e[n]=0;return e}function f(e,t){var n=t.length<0?0:0|h(t.length);e=a(e,n);for(var r=0;r<n;r+=1)e[r]=255&t[r];return e}function h(e){if(e>=n())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+n().toString(16)+" bytes");return 0|e}function p(e,t){if(l.isBuffer(e))return e.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(e)||e instanceof ArrayBuffer))return e.byteLength;"string"!=typeof e&&(e=""+e);var n=e.length;if(0===n)return 0;for(var r=!1;;)switch(t){case"ascii":case"latin1":case"binary":return n;case"utf8":case"utf-8":case void 0:return x(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*n;case"hex":return n>>>1;case"base64":return U(e).length;default:if(r)return x(e).length;t=(""+t).toLowerCase(),r=!0;}}function d(e,t,n){var r=e[t];e[t]=e[n],e[n]=r;}function g(e,t,n,r,i){if(0===e.length)return -1;if("string"==typeof n?(r=n,n=0):2147483647<n?n=2147483647:n<-2147483648&&(n=-2147483648),n=+n,isNaN(n)&&(n=i?0:e.length-1),n<0&&(n=e.length+n),n>=e.length){if(i)return -1;n=e.length-1;}else if(n<0){if(!i)return -1;n=0;}if("string"==typeof t&&(t=l.from(t,r)),l.isBuffer(t))return 0===t.length?-1:y(e,t,n,r,i);if("number"==typeof t)return t&=255,l.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?i?Uint8Array.prototype.indexOf.call(e,t,n):Uint8Array.prototype.lastIndexOf.call(e,t,n):y(e,[t],n,r,i);throw new TypeError("val must be string, number or Buffer")}function y(e,t,n,r,i){var o,s=1,a=e.length,u=t.length;if(void 0!==r&&("ucs2"===(r=String(r).toLowerCase())||"ucs-2"===r||"utf16le"===r||"utf-16le"===r)){if(e.length<2||t.length<2)return -1;a/=s=2,u/=2,n/=2;}function c(e,t){return 1===s?e[t]:e.readUInt16BE(t*s)}if(i){var f=-1;for(o=n;o<a;o++)if(c(e,o)===c(t,-1===f?0:o-f)){if(-1===f&&(f=o),o-f+1===u)return f*s}else-1!==f&&(o-=o-f),f=-1;}else for(a<n+u&&(n=a-u),o=n;0<=o;o--){for(var l=!0,h=0;h<u;h++)if(c(e,o+h)!==c(t,h)){l=!1;break}if(l)return o}return -1}function v(e,t,n,r){n=Number(n)||0;var i=e.length-n;r?i<(r=Number(r))&&(r=i):r=i;var o=t.length;if(o%2!=0)throw new TypeError("Invalid hex string");o/2<r&&(r=o/2);for(var s=0;s<r;++s){var a=parseInt(t.substr(2*s,2),16);if(isNaN(a))return s;e[n+s]=a;}return s}function b(e,t,n,r){return B(function(e){for(var t=[],n=0;n<e.length;++n)t.push(255&e.charCodeAt(n));return t}(t),e,n,r)}function m(e,t,n){return 0===t&&n===e.length?r.fromByteArray(e):r.fromByteArray(e.slice(t,n))}function _(e,t,n){n=Math.min(e.length,n);for(var r=[],i=t;i<n;){var o,s,a,u,c=e[i],f=null,l=239<c?4:223<c?3:191<c?2:1;if(i+l<=n)switch(l){case 1:c<128&&(f=c);break;case 2:128==(192&(o=e[i+1]))&&127<(u=(31&c)<<6|63&o)&&(f=u);break;case 3:o=e[i+1],s=e[i+2],128==(192&o)&&128==(192&s)&&2047<(u=(15&c)<<12|(63&o)<<6|63&s)&&(u<55296||57343<u)&&(f=u);break;case 4:o=e[i+1],s=e[i+2],a=e[i+3],128==(192&o)&&128==(192&s)&&128==(192&a)&&65535<(u=(15&c)<<18|(63&o)<<12|(63&s)<<6|63&a)&&u<1114112&&(f=u);}null===f?(f=65533,l=1):65535<f&&(f-=65536,r.push(f>>>10&1023|55296),f=56320|1023&f),r.push(f),i+=l;}return function(e){var t=e.length;if(t<=k)return String.fromCharCode.apply(String,e);var n="",r=0;for(;r<t;)n+=String.fromCharCode.apply(String,e.slice(r,r+=k));return n}(r)}I.Buffer=l,I.SlowBuffer=function(e){+e!=e&&(e=0);return l.alloc(+e)},I.INSPECT_MAX_BYTES=50,l.TYPED_ARRAY_SUPPORT=void 0!==e.TYPED_ARRAY_SUPPORT?e.TYPED_ARRAY_SUPPORT:function(){try{var e=new Uint8Array(1);return e.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===e.foo()&&"function"==typeof e.subarray&&0===e.subarray(1,1).byteLength}catch(e){return !1}}(),I.kMaxLength=n(),l.poolSize=8192,l._augment=function(e){return e.__proto__=l.prototype,e},l.from=function(e,t,n){return i(null,e,t,n)},l.TYPED_ARRAY_SUPPORT&&(l.prototype.__proto__=Uint8Array.prototype,l.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&l[Symbol.species]===l&&Object.defineProperty(l,Symbol.species,{value:null,configurable:!0})),l.alloc=function(e,t,n){return function(e,t,n,r){return u(t),t<=0?a(e,t):void 0!==n?"string"==typeof r?a(e,t).fill(n,r):a(e,t).fill(n):a(e,t)}(null,e,t,n)},l.allocUnsafe=function(e){return c(null,e)},l.allocUnsafeSlow=function(e){return c(null,e)},l.isBuffer=function(e){return !(null==e||!e._isBuffer)},l.compare=function(e,t){if(!l.isBuffer(e)||!l.isBuffer(t))throw new TypeError("Arguments must be Buffers");if(e===t)return 0;for(var n=e.length,r=t.length,i=0,o=Math.min(n,r);i<o;++i)if(e[i]!==t[i]){n=e[i],r=t[i];break}return n<r?-1:r<n?1:0},l.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return !0;default:return !1}},l.concat=function(e,t){if(!s(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return l.alloc(0);var n;if(void 0===t)for(n=t=0;n<e.length;++n)t+=e[n].length;var r=l.allocUnsafe(t),i=0;for(n=0;n<e.length;++n){var o=e[n];if(!l.isBuffer(o))throw new TypeError('"list" argument must be an Array of Buffers');o.copy(r,i),i+=o.length;}return r},l.byteLength=p,l.prototype._isBuffer=!0,l.prototype.swap16=function(){var e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var t=0;t<e;t+=2)d(this,t,t+1);return this},l.prototype.swap32=function(){var e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var t=0;t<e;t+=4)d(this,t,t+3),d(this,t+1,t+2);return this},l.prototype.swap64=function(){var e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var t=0;t<e;t+=8)d(this,t,t+7),d(this,t+1,t+6),d(this,t+2,t+5),d(this,t+3,t+4);return this},l.prototype.toString=function(){var e=0|this.length;return 0==e?"":0===arguments.length?_(this,0,e):function(e,t,n){var r=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return "";if((void 0===n||n>this.length)&&(n=this.length),n<=0)return "";if((n>>>=0)<=(t>>>=0))return "";for(e=e||"utf8";;)switch(e){case"hex":return T(this,t,n);case"utf8":case"utf-8":return _(this,t,n);case"ascii":return P(this,t,n);case"latin1":case"binary":return w(this,t,n);case"base64":return m(this,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return O(this,t,n);default:if(r)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),r=!0;}}.apply(this,arguments)},l.prototype.equals=function(e){if(!l.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e||0===l.compare(this,e)},l.prototype.inspect=function(){var e="",t=I.INSPECT_MAX_BYTES;return 0<this.length&&(e=this.toString("hex",0,t).match(/.{2}/g).join(" "),this.length>t&&(e+=" ... ")),"<Buffer "+e+">"},l.prototype.compare=function(e,t,n,r,i){if(!l.isBuffer(e))throw new TypeError("Argument must be a Buffer");if(void 0===t&&(t=0),void 0===n&&(n=e?e.length:0),void 0===r&&(r=0),void 0===i&&(i=this.length),t<0||n>e.length||r<0||i>this.length)throw new RangeError("out of range index");if(i<=r&&n<=t)return 0;if(i<=r)return -1;if(n<=t)return 1;if(this===e)return 0;for(var o=(i>>>=0)-(r>>>=0),s=(n>>>=0)-(t>>>=0),a=Math.min(o,s),u=this.slice(r,i),c=e.slice(t,n),f=0;f<a;++f)if(u[f]!==c[f]){o=u[f],s=c[f];break}return o<s?-1:s<o?1:0},l.prototype.includes=function(e,t,n){return -1!==this.indexOf(e,t,n)},l.prototype.indexOf=function(e,t,n){return g(this,e,t,n,!0)},l.prototype.lastIndexOf=function(e,t,n){return g(this,e,t,n,!1)},l.prototype.write=function(e,t,n,r){if(void 0===t)r="utf8",n=this.length,t=0;else if(void 0===n&&"string"==typeof t)r=t,n=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t|=0,isFinite(n)?(n|=0,void 0===r&&(r="utf8")):(r=n,n=void 0);}var i=this.length-t;if((void 0===n||i<n)&&(n=i),0<e.length&&(n<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");r=r||"utf8";for(var o,s,a,u,c,f,l,h,p,d=!1;;)switch(r){case"hex":return v(this,e,t,n);case"utf8":case"utf-8":return h=t,p=n,B(x(e,(l=this).length-h),l,h,p);case"ascii":return b(this,e,t,n);case"latin1":case"binary":return b(this,e,t,n);case"base64":return u=this,c=t,f=n,B(U(e),u,c,f);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return s=t,a=n,B(function(e,t){for(var n,r,i,o=[],s=0;s<e.length&&!((t-=2)<0);++s)n=e.charCodeAt(s),r=n>>8,i=n%256,o.push(i),o.push(r);return o}(e,(o=this).length-s),o,s,a);default:if(d)throw new TypeError("Unknown encoding: "+r);r=(""+r).toLowerCase(),d=!0;}},l.prototype.toJSON=function(){return {type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var k=4096;function P(e,t,n){var r="";n=Math.min(e.length,n);for(var i=t;i<n;++i)r+=String.fromCharCode(127&e[i]);return r}function w(e,t,n){var r="";n=Math.min(e.length,n);for(var i=t;i<n;++i)r+=String.fromCharCode(e[i]);return r}function T(e,t,n){var r=e.length;(!t||t<0)&&(t=0),(!n||n<0||r<n)&&(n=r);for(var i="",o=t;o<n;++o)i+=N(e[o]);return i}function O(e,t,n){for(var r=e.slice(t,n),i="",o=0;o<r.length;o+=2)i+=String.fromCharCode(r[o]+256*r[o+1]);return i}function S(e,t,n){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(n<e+t)throw new RangeError("Trying to access beyond buffer length")}function M(e,t,n,r,i,o){if(!l.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(i<t||t<o)throw new RangeError('"value" argument is out of bounds');if(n+r>e.length)throw new RangeError("Index out of range")}function E(e,t,n,r){t<0&&(t=65535+t+1);for(var i=0,o=Math.min(e.length-n,2);i<o;++i)e[n+i]=(t&255<<8*(r?i:1-i))>>>8*(r?i:1-i);}function A(e,t,n,r){t<0&&(t=4294967295+t+1);for(var i=0,o=Math.min(e.length-n,4);i<o;++i)e[n+i]=t>>>8*(r?i:3-i)&255;}function C(e,t,n,r){if(n+r>e.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("Index out of range")}function R(e,t,n,r,i){return i||C(e,0,n,4),o.write(e,t,n,r,23,4),n+4}function j(e,t,n,r,i){return i||C(e,0,n,8),o.write(e,t,n,r,52,8),n+8}l.prototype.slice=function(e,t){var n,r=this.length;if((e=~~e)<0?(e+=r)<0&&(e=0):r<e&&(e=r),(t=void 0===t?r:~~t)<0?(t+=r)<0&&(t=0):r<t&&(t=r),t<e&&(t=e),l.TYPED_ARRAY_SUPPORT)(n=this.subarray(e,t)).__proto__=l.prototype;else{var i=t-e;n=new l(i,void 0);for(var o=0;o<i;++o)n[o]=this[o+e];}return n},l.prototype.readUIntLE=function(e,t,n){e|=0,t|=0,n||S(e,t,this.length);for(var r=this[e],i=1,o=0;++o<t&&(i*=256);)r+=this[e+o]*i;return r},l.prototype.readUIntBE=function(e,t,n){e|=0,t|=0,n||S(e,t,this.length);for(var r=this[e+--t],i=1;0<t&&(i*=256);)r+=this[e+--t]*i;return r},l.prototype.readUInt8=function(e,t){return t||S(e,1,this.length),this[e]},l.prototype.readUInt16LE=function(e,t){return t||S(e,2,this.length),this[e]|this[e+1]<<8},l.prototype.readUInt16BE=function(e,t){return t||S(e,2,this.length),this[e]<<8|this[e+1]},l.prototype.readUInt32LE=function(e,t){return t||S(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},l.prototype.readUInt32BE=function(e,t){return t||S(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},l.prototype.readIntLE=function(e,t,n){e|=0,t|=0,n||S(e,t,this.length);for(var r=this[e],i=1,o=0;++o<t&&(i*=256);)r+=this[e+o]*i;return (i*=128)<=r&&(r-=Math.pow(2,8*t)),r},l.prototype.readIntBE=function(e,t,n){e|=0,t|=0,n||S(e,t,this.length);for(var r=t,i=1,o=this[e+--r];0<r&&(i*=256);)o+=this[e+--r]*i;return (i*=128)<=o&&(o-=Math.pow(2,8*t)),o},l.prototype.readInt8=function(e,t){return t||S(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},l.prototype.readInt16LE=function(e,t){t||S(e,2,this.length);var n=this[e]|this[e+1]<<8;return 32768&n?4294901760|n:n},l.prototype.readInt16BE=function(e,t){t||S(e,2,this.length);var n=this[e+1]|this[e]<<8;return 32768&n?4294901760|n:n},l.prototype.readInt32LE=function(e,t){return t||S(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},l.prototype.readInt32BE=function(e,t){return t||S(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},l.prototype.readFloatLE=function(e,t){return t||S(e,4,this.length),o.read(this,e,!0,23,4)},l.prototype.readFloatBE=function(e,t){return t||S(e,4,this.length),o.read(this,e,!1,23,4)},l.prototype.readDoubleLE=function(e,t){return t||S(e,8,this.length),o.read(this,e,!0,52,8)},l.prototype.readDoubleBE=function(e,t){return t||S(e,8,this.length),o.read(this,e,!1,52,8)},l.prototype.writeUIntLE=function(e,t,n,r){e=+e,t|=0,n|=0,r||M(this,e,t,n,Math.pow(2,8*n)-1,0);var i=1,o=0;for(this[t]=255&e;++o<n&&(i*=256);)this[t+o]=e/i&255;return t+n},l.prototype.writeUIntBE=function(e,t,n,r){e=+e,t|=0,n|=0,r||M(this,e,t,n,Math.pow(2,8*n)-1,0);var i=n-1,o=1;for(this[t+i]=255&e;0<=--i&&(o*=256);)this[t+i]=e/o&255;return t+n},l.prototype.writeUInt8=function(e,t,n){return e=+e,t|=0,n||M(this,e,t,1,255,0),l.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),this[t]=255&e,t+1},l.prototype.writeUInt16LE=function(e,t,n){return e=+e,t|=0,n||M(this,e,t,2,65535,0),l.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):E(this,e,t,!0),t+2},l.prototype.writeUInt16BE=function(e,t,n){return e=+e,t|=0,n||M(this,e,t,2,65535,0),l.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):E(this,e,t,!1),t+2},l.prototype.writeUInt32LE=function(e,t,n){return e=+e,t|=0,n||M(this,e,t,4,4294967295,0),l.TYPED_ARRAY_SUPPORT?(this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e):A(this,e,t,!0),t+4},l.prototype.writeUInt32BE=function(e,t,n){return e=+e,t|=0,n||M(this,e,t,4,4294967295,0),l.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):A(this,e,t,!1),t+4},l.prototype.writeIntLE=function(e,t,n,r){if(e=+e,t|=0,!r){var i=Math.pow(2,8*n-1);M(this,e,t,n,i-1,-i);}var o=0,s=1,a=0;for(this[t]=255&e;++o<n&&(s*=256);)e<0&&0===a&&0!==this[t+o-1]&&(a=1),this[t+o]=(e/s>>0)-a&255;return t+n},l.prototype.writeIntBE=function(e,t,n,r){if(e=+e,t|=0,!r){var i=Math.pow(2,8*n-1);M(this,e,t,n,i-1,-i);}var o=n-1,s=1,a=0;for(this[t+o]=255&e;0<=--o&&(s*=256);)e<0&&0===a&&0!==this[t+o+1]&&(a=1),this[t+o]=(e/s>>0)-a&255;return t+n},l.prototype.writeInt8=function(e,t,n){return e=+e,t|=0,n||M(this,e,t,1,127,-128),l.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),e<0&&(e=255+e+1),this[t]=255&e,t+1},l.prototype.writeInt16LE=function(e,t,n){return e=+e,t|=0,n||M(this,e,t,2,32767,-32768),l.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):E(this,e,t,!0),t+2},l.prototype.writeInt16BE=function(e,t,n){return e=+e,t|=0,n||M(this,e,t,2,32767,-32768),l.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):E(this,e,t,!1),t+2},l.prototype.writeInt32LE=function(e,t,n){return e=+e,t|=0,n||M(this,e,t,4,2147483647,-2147483648),l.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24):A(this,e,t,!0),t+4},l.prototype.writeInt32BE=function(e,t,n){return e=+e,t|=0,n||M(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),l.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):A(this,e,t,!1),t+4},l.prototype.writeFloatLE=function(e,t,n){return R(this,e,t,!0,n)},l.prototype.writeFloatBE=function(e,t,n){return R(this,e,t,!1,n)},l.prototype.writeDoubleLE=function(e,t,n){return j(this,e,t,!0,n)},l.prototype.writeDoubleBE=function(e,t,n){return j(this,e,t,!1,n)},l.prototype.copy=function(e,t,n,r){if(n=n||0,r||0===r||(r=this.length),t>=e.length&&(t=e.length),t=t||0,0<r&&r<n&&(r=n),r===n)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(n<0||n>=this.length)throw new RangeError("sourceStart out of bounds");if(r<0)throw new RangeError("sourceEnd out of bounds");r>this.length&&(r=this.length),e.length-t<r-n&&(r=e.length-t+n);var i,o=r-n;if(this===e&&n<t&&t<r)for(i=o-1;0<=i;--i)e[i+t]=this[i+n];else if(o<1e3||!l.TYPED_ARRAY_SUPPORT)for(i=0;i<o;++i)e[i+t]=this[i+n];else Uint8Array.prototype.set.call(e,this.subarray(n,n+o),t);return o},l.prototype.fill=function(e,t,n,r){if("string"==typeof e){if("string"==typeof t?(r=t,t=0,n=this.length):"string"==typeof n&&(r=n,n=this.length),1===e.length){var i=e.charCodeAt(0);i<256&&(e=i);}if(void 0!==r&&"string"!=typeof r)throw new TypeError("encoding must be a string");if("string"==typeof r&&!l.isEncoding(r))throw new TypeError("Unknown encoding: "+r)}else"number"==typeof e&&(e&=255);if(t<0||this.length<t||this.length<n)throw new RangeError("Out of range index");if(n<=t)return this;var o;if(t>>>=0,n=void 0===n?this.length:n>>>0,"number"==typeof(e=e||0))for(o=t;o<n;++o)this[o]=e;else{var s=l.isBuffer(e)?e:x(new l(e,r).toString()),a=s.length;for(o=0;o<n-t;++o)this[o+t]=s[o%a];}return this};var t=/[^+\/0-9A-Za-z-_]/g;function N(e){return e<16?"0"+e.toString(16):e.toString(16)}function x(e,t){var n;t=t||1/0;for(var r=e.length,i=null,o=[],s=0;s<r;++s){if(55295<(n=e.charCodeAt(s))&&n<57344){if(!i){if(56319<n){-1<(t-=3)&&o.push(239,191,189);continue}if(s+1===r){-1<(t-=3)&&o.push(239,191,189);continue}i=n;continue}if(n<56320){-1<(t-=3)&&o.push(239,191,189),i=n;continue}n=65536+(i-55296<<10|n-56320);}else i&&-1<(t-=3)&&o.push(239,191,189);if(i=null,n<128){if((t-=1)<0)break;o.push(n);}else if(n<2048){if((t-=2)<0)break;o.push(n>>6|192,63&n|128);}else if(n<65536){if((t-=3)<0)break;o.push(n>>12|224,n>>6&63|128,63&n|128);}else{if(!(n<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;o.push(n>>18|240,n>>12&63|128,n>>6&63|128,63&n|128);}}return o}function U(e){return r.toByteArray(function(e){if((e=function(e){return e.trim?e.trim():e.replace(/^\s+|\s+$/g,"")}(e).replace(t,"")).length<2)return "";for(;e.length%4!=0;)e+="=";return e}(e))}function B(e,t,n,r){for(var i=0;i<r&&!(i+n>=t.length||i>=e.length);++i)t[i+n]=e[i];return i}}).call(this,D(70));},function(e,t,n){e.exports=function(e){return null!==e&&"object"==typeof e};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var r=u(n(12)),i=u(n(67)),o=u(n(68)),s=u(n(69)),a=n(75);n(0);function u(e){return e&&e.__esModule?e:{default:e}}function c(e){return (c="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function f(e,t){return !t||"object"!==c(t)&&"function"!=typeof t?function(e){if(void 0!==e)return e;throw new ReferenceError("this hasn't been initialised - super() hasn't been called")}(e):t}function l(e){return (l=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function h(e,t){return (h=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function p(e){if(!navigator||!navigator.sendBeacon)return !1;navigator.sendBeacon(e);}var d=(function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&h(e,t);}(g,r.default),g);function g(e){var t;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,g);var n=e.listenToBrowserNetworkEvents,r=void 0===n||n;return e.db=o.default,e.cbor=new s.default,e.sdkFamily="Web",e.networking=new i.default({del:a.del,get:a.get,post:a.post,patch:a.patch,sendBeacon:p}),t=f(this,l(g).call(this,e)),r&&(window.addEventListener("offline",function(){t.networkDownDetected();}),window.addEventListener("online",function(){t.networkUpDetected();})),t}t.default=d,e.exports=t.default;},function(e,t,n){function s(e){return (s="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var y=f(n(3)),v=f(n(6)),b=f(n(15)),r=f(n(18)),m=f(n(7)),_=f(n(19)),k=f(n(20)),P=c(n(21)),w=c(n(22)),T=c(n(23)),O=c(n(24)),S=c(n(25)),M=c(n(26)),E=c(n(27)),A=c(n(28)),C=c(n(29)),R=c(n(30)),j=c(n(31)),N=c(n(32)),x=c(n(33)),U=c(n(34)),B=c(n(35)),I=c(n(36)),D=c(n(37)),K=c(n(38)),L=c(n(39)),F=c(n(40)),G=c(n(41)),H=c(n(42)),q=c(n(43)),z=c(n(44)),Y=c(n(45)),$=c(n(46)),W=c(n(47)),J=c(n(48)),X=c(n(49)),V=c(n(50)),Q=c(n(51)),Z=c(n(52)),ee=c(n(53)),te=c(n(54)),ne=c(n(55)),re=c(n(56)),ie=c(n(57)),oe=c(n(58)),se=c(n(59)),ae=c(n(60)),ue=c(n(61)),ce=c(n(62)),fe=c(n(63)),le=c(n(64)),he=c(n(65)),pe=c(n(8)),de=c(n(66)),i=f(n(1)),o=f(n(4)),a=(n(0),f(n(5)));function u(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return u=function(){return e},e}function c(e){if(e&&e.__esModule)return e;if(null===e||"object"!==s(e)&&"function"!=typeof e)return {default:e};var t=u();if(t&&t.has(e))return t.get(e);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var o=r?Object.getOwnPropertyDescriptor(e,i):null;o&&(o.get||o.set)?Object.defineProperty(n,i,o):n[i]=e[i];}return n.default=e,t&&t.set(e,n),n}function f(e){return e&&e.__esModule?e:{default:e}}function l(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r);}}function ge(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var h,p,d,g=(h=ye,d=[{key:"notificationPayload",value:function(e,t){return new r.default(e,t)}},{key:"generateUUID",value:function(){return a.default.createUUID()}}],(p=[{key:"getVersion",value:function(){return this._config.getVersion()}},{key:"_addPnsdkSuffix",value:function(e,t){this._config._addPnsdkSuffix(e,t);}},{key:"networkDownDetected",value:function(){this._listenerManager.announceNetworkDown(),this._config.restore?this.disconnect():this.destroy(!0);}},{key:"networkUpDetected",value:function(){this._listenerManager.announceNetworkUp(),this.reconnect();}}])&&l(h.prototype,p),void(d&&l(h,d)),ye);function ye(e){var n=this;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,ye),ge(this,"_config",void 0),ge(this,"_listenerManager",void 0),ge(this,"_tokenManager",void 0),ge(this,"time",void 0),ge(this,"publish",void 0),ge(this,"fire",void 0),ge(this,"history",void 0),ge(this,"deleteMessages",void 0),ge(this,"messageCounts",void 0),ge(this,"fetchMessages",void 0),ge(this,"channelGroups",void 0),ge(this,"push",void 0),ge(this,"hereNow",void 0),ge(this,"whereNow",void 0),ge(this,"getState",void 0),ge(this,"setState",void 0),ge(this,"grant",void 0),ge(this,"grantToken",void 0),ge(this,"audit",void 0),ge(this,"subscribe",void 0),ge(this,"signal",void 0),ge(this,"presence",void 0),ge(this,"unsubscribe",void 0),ge(this,"unsubscribeAll",void 0),ge(this,"addMessageAction",void 0),ge(this,"removeMessageAction",void 0),ge(this,"getMessageActions",void 0),ge(this,"createUser",void 0),ge(this,"updateUser",void 0),ge(this,"deleteUser",void 0),ge(this,"getUser",void 0),ge(this,"getUsers",void 0),ge(this,"createSpace",void 0),ge(this,"updateSpace",void 0),ge(this,"deleteSpace",void 0),ge(this,"getSpaces",void 0),ge(this,"getSpace",void 0),ge(this,"getMembers",void 0),ge(this,"addMembers",void 0),ge(this,"updateMembers",void 0),ge(this,"removeMembers",void 0),ge(this,"getMemberships",void 0),ge(this,"joinSpaces",void 0),ge(this,"updateMemberships",void 0),ge(this,"leaveSpaces",void 0),ge(this,"disconnect",void 0),ge(this,"reconnect",void 0),ge(this,"destroy",void 0),ge(this,"stop",void 0),ge(this,"getSubscribedChannels",void 0),ge(this,"getSubscribedChannelGroups",void 0),ge(this,"addListener",void 0),ge(this,"removeListener",void 0),ge(this,"removeAllListeners",void 0),ge(this,"parseToken",void 0),ge(this,"setToken",void 0),ge(this,"setTokens",void 0),ge(this,"getToken",void 0),ge(this,"getTokens",void 0),ge(this,"clearTokens",void 0),ge(this,"getAuthKey",void 0),ge(this,"setAuthKey",void 0),ge(this,"setCipherKey",void 0),ge(this,"setUUID",void 0),ge(this,"getUUID",void 0),ge(this,"getFilterExpression",void 0),ge(this,"setFilterExpression",void 0),ge(this,"setHeartbeatInterval",void 0),ge(this,"setProxy",void 0),ge(this,"encrypt",void 0),ge(this,"decrypt",void 0);var t=e.db,r=e.networking,i=e.cbor,o=this._config=new y.default({setup:e,db:t}),s=new v.default({config:o});r.init(o);var a=this._tokenManager=new _.default(o,i),u={config:o,networking:r,crypto:s,tokenManager:a},c=k.default.bind(this,u,pe),f=k.default.bind(this,u,R),l=k.default.bind(this,u,N),h=k.default.bind(this,u,U),p=k.default.bind(this,u,de),d=this._listenerManager=new m.default,g=new b.default({timeEndpoint:c,leaveEndpoint:f,heartbeatEndpoint:l,setStateEndpoint:h,subscribeEndpoint:p,crypto:u.crypto,config:u.config,listenerManager:d});this.addListener=d.addListener.bind(d),this.removeListener=d.removeListener.bind(d),this.removeAllListeners=d.removeAllListeners.bind(d),this.parseToken=a.parseToken.bind(a),this.setToken=a.setToken.bind(a),this.setTokens=a.setTokens.bind(a),this.getToken=a.getToken.bind(a),this.getTokens=a.getTokens.bind(a),this.clearTokens=a.clearTokens.bind(a),this.channelGroups={listGroups:k.default.bind(this,u,O),listChannels:k.default.bind(this,u,S),addChannels:k.default.bind(this,u,P),removeChannels:k.default.bind(this,u,w),deleteGroup:k.default.bind(this,u,T)},this.push={addChannels:k.default.bind(this,u,M),removeChannels:k.default.bind(this,u,E),deleteDevice:k.default.bind(this,u,C),listChannels:k.default.bind(this,u,A)},this.hereNow=k.default.bind(this,u,B),this.whereNow=k.default.bind(this,u,j),this.getState=k.default.bind(this,u,x),this.setState=g.adaptStateChange.bind(g),this.grant=k.default.bind(this,u,oe),this.grantToken=k.default.bind(this,u,se),this.audit=k.default.bind(this,u,ie),this.publish=k.default.bind(this,u,ae),this.fire=function(e,t){return e.replicate=!1,e.storeInHistory=!1,n.publish(e,t)},this.signal=k.default.bind(this,u,ue),this.history=k.default.bind(this,u,ce),this.deleteMessages=k.default.bind(this,u,fe),this.messageCounts=k.default.bind(this,u,le),this.fetchMessages=k.default.bind(this,u,he),this.addMessageAction=k.default.bind(this,u,I),this.removeMessageAction=k.default.bind(this,u,D),this.getMessageActions=k.default.bind(this,u,K),this.createUser=k.default.bind(this,u,L),this.updateUser=k.default.bind(this,u,F),this.deleteUser=k.default.bind(this,u,G),this.getUser=k.default.bind(this,u,H),this.getUsers=k.default.bind(this,u,q),this.createSpace=k.default.bind(this,u,z),this.updateSpace=k.default.bind(this,u,Y),this.deleteSpace=k.default.bind(this,u,$),this.getSpaces=k.default.bind(this,u,W),this.getSpace=k.default.bind(this,u,J),this.addMembers=k.default.bind(this,u,V),this.updateMembers=k.default.bind(this,u,Q),this.removeMembers=k.default.bind(this,u,Z),this.getMembers=k.default.bind(this,u,X),this.getMemberships=k.default.bind(this,u,ee),this.joinSpaces=k.default.bind(this,u,ne),this.updateMemberships=k.default.bind(this,u,te),this.leaveSpaces=k.default.bind(this,u,re),this.time=c,this.subscribe=g.adaptSubscribeChange.bind(g),this.presence=g.adaptPresenceChange.bind(g),this.unsubscribe=g.adaptUnsubscribeChange.bind(g),this.disconnect=g.disconnect.bind(g),this.reconnect=g.reconnect.bind(g),this.destroy=function(e){g.unsubscribeAll(e),g.disconnect();},this.stop=this.destroy,this.unsubscribeAll=g.unsubscribeAll.bind(g),this.getSubscribedChannels=g.getSubscribedChannels.bind(g),this.getSubscribedChannelGroups=g.getSubscribedChannelGroups.bind(g),this.encrypt=s.encrypt.bind(s),this.decrypt=s.decrypt.bind(s),this.getAuthKey=u.config.getAuthKey.bind(u.config),this.setAuthKey=u.config.setAuthKey.bind(u.config),this.setCipherKey=u.config.setCipherKey.bind(u.config),this.getUUID=u.config.getUUID.bind(u.config),this.setUUID=u.config.setUUID.bind(u.config),this.getFilterExpression=u.config.getFilterExpression.bind(u.config),this.setFilterExpression=u.config.setFilterExpression.bind(u.config),this.setHeartbeatInterval=u.config.setHeartbeatInterval.bind(u.config),r.hasModule("proxy")&&(this.setProxy=function(e){u.config.setProxy(e),n.reconnect();});}ge(t.default=g,"OPERATIONS",i.default),ge(g,"CATEGORIES",o.default),e.exports=t.default;},function(e,t,n){var r,i,o;i=[t],void 0===(o="function"==typeof(r=function(e){var r={3:/^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,4:/^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,5:/^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,all:/^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i};function t(){var e,t,n="";for(e=0;e<32;e++)t=16*Math.random()|0,8!==e&&12!==e&&16!==e&&20!==e||(n+="-"),n+=(12===e?4:16===e?3&t|8:t).toString(16);return n}function n(e,t){var n=r[t||"all"];return n&&n.test(e)||!1}t.isUUID=n,t.VERSION="0.1.0",e.uuid=t,e.isUUID=n;})?r.apply(t,i):r)||(e.exports=o);},function(e,t,n){var r,c,i,u,o,s,a,f,l,h,E=E||function(a){function n(){}var e={},t=e.lib={},r=t.Base={extend:function(e){n.prototype=this;var t=new n;return e&&t.mixIn(e),t.hasOwnProperty("init")||(t.init=function(){t.$super.init.apply(this,arguments);}),(t.init.prototype=t).$super=this,t},create:function(){var e=this.extend();return e.init.apply(e,arguments),e},init:function(){},mixIn:function(e){for(var t in e)e.hasOwnProperty(t)&&(this[t]=e[t]);e.hasOwnProperty("toString")&&(this.toString=e.toString);},clone:function(){return this.init.prototype.extend(this)}},u=t.WordArray=r.extend({init:function(e,t){e=this.words=e||[],this.sigBytes=null!=t?t:4*e.length;},toString:function(e){return (e||o).stringify(this)},concat:function(e){var t=this.words,n=e.words,r=this.sigBytes;if(e=e.sigBytes,this.clamp(),r%4)for(var i=0;i<e;i++)t[r+i>>>2]|=(n[i>>>2]>>>24-i%4*8&255)<<24-(r+i)%4*8;else if(65535<n.length)for(i=0;i<e;i+=4)t[r+i>>>2]=n[i>>>2];else t.push.apply(t,n);return this.sigBytes+=e,this},clamp:function(){var e=this.words,t=this.sigBytes;e[t>>>2]&=4294967295<<32-t%4*8,e.length=a.ceil(t/4);},clone:function(){var e=r.clone.call(this);return e.words=this.words.slice(0),e},random:function(e){for(var t=[],n=0;n<e;n+=4)t.push(4294967296*a.random()|0);return new u.init(t,e)}}),i=e.enc={},o=i.Hex={stringify:function(e){var t=e.words;e=e.sigBytes;for(var n=[],r=0;r<e;r++){var i=t[r>>>2]>>>24-r%4*8&255;n.push((i>>>4).toString(16)),n.push((15&i).toString(16));}return n.join("")},parse:function(e){for(var t=e.length,n=[],r=0;r<t;r+=2)n[r>>>3]|=parseInt(e.substr(r,2),16)<<24-r%8*4;return new u.init(n,t/2)}},s=i.Latin1={stringify:function(e){var t=e.words;e=e.sigBytes;for(var n=[],r=0;r<e;r++)n.push(String.fromCharCode(t[r>>>2]>>>24-r%4*8&255));return n.join("")},parse:function(e){for(var t=e.length,n=[],r=0;r<t;r++)n[r>>>2]|=(255&e.charCodeAt(r))<<24-r%4*8;return new u.init(n,t)}},c=i.Utf8={stringify:function(e){try{return decodeURIComponent(escape(s.stringify(e)))}catch(e){throw Error("Malformed UTF-8 data")}},parse:function(e){return s.parse(unescape(encodeURIComponent(e)))}},f=t.BufferedBlockAlgorithm=r.extend({reset:function(){this._data=new u.init,this._nDataBytes=0;},_append:function(e){"string"==typeof e&&(e=c.parse(e)),this._data.concat(e),this._nDataBytes+=e.sigBytes;},_process:function(e){var t=this._data,n=t.words,r=t.sigBytes,i=this.blockSize,o=r/(4*i);if(e=(o=e?a.ceil(o):a.max((0|o)-this._minBufferSize,0))*i,r=a.min(4*e,r),e){for(var s=0;s<e;s+=i)this._doProcessBlock(n,s);s=n.splice(0,e),t.sigBytes-=r;}return new u.init(s,r)},clone:function(){var e=r.clone.call(this);return e._data=this._data.clone(),e},_minBufferSize:0});t.Hasher=f.extend({cfg:r.extend(),init:function(e){this.cfg=this.cfg.extend(e),this.reset();},reset:function(){f.reset.call(this),this._doReset();},update:function(e){return this._append(e),this._process(),this},finalize:function(e){return e&&this._append(e),this._doFinalize()},blockSize:16,_createHelper:function(n){return function(e,t){return new n.init(t).finalize(e)}},_createHmacHelper:function(n){return function(e,t){return new l.HMAC.init(n,t).finalize(e)}}});var l=e.algo={};return e}(Math);!function(i){for(var e=E,t=(r=e.lib).WordArray,n=r.Hasher,r=e.algo,o=[],d=[],s=function(e){return 4294967296*(e-(0|e))|0},a=2,u=0;u<64;){var c;e:{c=a;for(var f=i.sqrt(c),l=2;l<=f;l++)if(!(c%l)){c=!1;break e}c=!0;}c&&(u<8&&(o[u]=s(i.pow(a,.5))),d[u]=s(i.pow(a,1/3)),u++),a++;}var g=[];r=r.SHA256=n.extend({_doReset:function(){this._hash=new t.init(o.slice(0));},_doProcessBlock:function(e,t){for(var n=this._hash.words,r=n[0],i=n[1],o=n[2],s=n[3],a=n[4],u=n[5],c=n[6],f=n[7],l=0;l<64;l++){if(l<16)g[l]=0|e[t+l];else{var h=g[l-15],p=g[l-2];g[l]=((h<<25|h>>>7)^(h<<14|h>>>18)^h>>>3)+g[l-7]+((p<<15|p>>>17)^(p<<13|p>>>19)^p>>>10)+g[l-16];}h=f+((a<<26|a>>>6)^(a<<21|a>>>11)^(a<<7|a>>>25))+(a&u^~a&c)+d[l]+g[l],p=((r<<30|r>>>2)^(r<<19|r>>>13)^(r<<10|r>>>22))+(r&i^r&o^i&o),f=c,c=u,u=a,a=s+h|0,s=o,o=i,i=r,r=h+p|0;}n[0]=n[0]+r|0,n[1]=n[1]+i|0,n[2]=n[2]+o|0,n[3]=n[3]+s|0,n[4]=n[4]+a|0,n[5]=n[5]+u|0,n[6]=n[6]+c|0,n[7]=n[7]+f|0;},_doFinalize:function(){var e=this._data,t=e.words,n=8*this._nDataBytes,r=8*e.sigBytes;return t[r>>>5]|=128<<24-r%32,t[14+(64+r>>>9<<4)]=i.floor(n/4294967296),t[15+(64+r>>>9<<4)]=n,e.sigBytes=4*t.length,this._process(),this._hash},clone:function(){var e=n.clone.call(this);return e._hash=this._hash.clone(),e}});e.SHA256=n._createHelper(r),e.HmacSHA256=n._createHmacHelper(r);}(Math),c=(r=E).enc.Utf8,r.algo.HMAC=r.lib.Base.extend({init:function(e,t){e=this._hasher=new e.init,"string"==typeof t&&(t=c.parse(t));var n=e.blockSize,r=4*n;t.sigBytes>r&&(t=e.finalize(t)),t.clamp();for(var i=this._oKey=t.clone(),o=this._iKey=t.clone(),s=i.words,a=o.words,u=0;u<n;u++)s[u]^=1549556828,a[u]^=909522486;i.sigBytes=o.sigBytes=r,this.reset();},reset:function(){var e=this._hasher;e.reset(),e.update(this._iKey);},update:function(e){return this._hasher.update(e),this},finalize:function(e){var t=this._hasher;return e=t.finalize(e),t.reset(),t.finalize(this._oKey.clone().concat(e))}}),u=(i=E).lib.WordArray,i.enc.Base64={stringify:function(e){var t=e.words,n=e.sigBytes,r=this._map;e.clamp(),e=[];for(var i=0;i<n;i+=3)for(var o=(t[i>>>2]>>>24-i%4*8&255)<<16|(t[i+1>>>2]>>>24-(i+1)%4*8&255)<<8|t[i+2>>>2]>>>24-(i+2)%4*8&255,s=0;s<4&&i+.75*s<n;s++)e.push(r.charAt(o>>>6*(3-s)&63));if(t=r.charAt(64))for(;e.length%4;)e.push(t);return e.join("")},parse:function(e){var t=e.length,n=this._map;!(r=n.charAt(64))||-1!=(r=e.indexOf(r))&&(t=r);for(var r=[],i=0,o=0;o<t;o++)if(o%4){var s=n.indexOf(e.charAt(o-1))<<o%4*2,a=n.indexOf(e.charAt(o))>>>6-o%4*2;r[i>>>2]|=(s|a)<<24-i%4*8,i++;}return u.create(r,i)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="},function(o){function w(e,t,n,r,i,o,s){return ((e=e+(t&n|~t&r)+i+s)<<o|e>>>32-o)+t}function T(e,t,n,r,i,o,s){return ((e=e+(t&r|n&~r)+i+s)<<o|e>>>32-o)+t}function O(e,t,n,r,i,o,s){return ((e=e+(t^n^r)+i+s)<<o|e>>>32-o)+t}function S(e,t,n,r,i,o,s){return ((e=e+(n^(t|~r))+i+s)<<o|e>>>32-o)+t}for(var e=E,t=(r=e.lib).WordArray,n=r.Hasher,r=e.algo,M=[],i=0;i<64;i++)M[i]=4294967296*o.abs(o.sin(i+1))|0;r=r.MD5=n.extend({_doReset:function(){this._hash=new t.init([1732584193,4023233417,2562383102,271733878]);},_doProcessBlock:function(e,t){for(var n=0;n<16;n++){var r=e[s=t+n];e[s]=16711935&(r<<8|r>>>24)|4278255360&(r<<24|r>>>8);}n=this._hash.words;var i,o,s=e[t+0],a=(r=e[t+1],e[t+2]),u=e[t+3],c=e[t+4],f=e[t+5],l=e[t+6],h=e[t+7],p=e[t+8],d=e[t+9],g=e[t+10],y=e[t+11],v=e[t+12],b=e[t+13],m=e[t+14],_=e[t+15],k=n[0],P=S(P=S(P=S(P=S(P=O(P=O(P=O(P=O(P=T(P=T(P=T(P=T(P=w(P=w(P=w(P=w(P=n[1],o=w(o=n[2],i=w(i=n[3],k=w(k,P,o,i,s,7,M[0]),P,o,r,12,M[1]),k,P,a,17,M[2]),i,k,u,22,M[3]),o=w(o,i=w(i,k=w(k,P,o,i,c,7,M[4]),P,o,f,12,M[5]),k,P,l,17,M[6]),i,k,h,22,M[7]),o=w(o,i=w(i,k=w(k,P,o,i,p,7,M[8]),P,o,d,12,M[9]),k,P,g,17,M[10]),i,k,y,22,M[11]),o=w(o,i=w(i,k=w(k,P,o,i,v,7,M[12]),P,o,b,12,M[13]),k,P,m,17,M[14]),i,k,_,22,M[15]),o=T(o,i=T(i,k=T(k,P,o,i,r,5,M[16]),P,o,l,9,M[17]),k,P,y,14,M[18]),i,k,s,20,M[19]),o=T(o,i=T(i,k=T(k,P,o,i,f,5,M[20]),P,o,g,9,M[21]),k,P,_,14,M[22]),i,k,c,20,M[23]),o=T(o,i=T(i,k=T(k,P,o,i,d,5,M[24]),P,o,m,9,M[25]),k,P,u,14,M[26]),i,k,p,20,M[27]),o=T(o,i=T(i,k=T(k,P,o,i,b,5,M[28]),P,o,a,9,M[29]),k,P,h,14,M[30]),i,k,v,20,M[31]),o=O(o,i=O(i,k=O(k,P,o,i,f,4,M[32]),P,o,p,11,M[33]),k,P,y,16,M[34]),i,k,m,23,M[35]),o=O(o,i=O(i,k=O(k,P,o,i,r,4,M[36]),P,o,c,11,M[37]),k,P,h,16,M[38]),i,k,g,23,M[39]),o=O(o,i=O(i,k=O(k,P,o,i,b,4,M[40]),P,o,s,11,M[41]),k,P,u,16,M[42]),i,k,l,23,M[43]),o=O(o,i=O(i,k=O(k,P,o,i,d,4,M[44]),P,o,v,11,M[45]),k,P,_,16,M[46]),i,k,a,23,M[47]),o=S(o,i=S(i,k=S(k,P,o,i,s,6,M[48]),P,o,h,10,M[49]),k,P,m,15,M[50]),i,k,f,21,M[51]),o=S(o,i=S(i,k=S(k,P,o,i,v,6,M[52]),P,o,u,10,M[53]),k,P,g,15,M[54]),i,k,r,21,M[55]),o=S(o,i=S(i,k=S(k,P,o,i,p,6,M[56]),P,o,_,10,M[57]),k,P,l,15,M[58]),i,k,b,21,M[59]),o=S(o,i=S(i,k=S(k,P,o,i,c,6,M[60]),P,o,y,10,M[61]),k,P,a,15,M[62]),i,k,d,21,M[63]);n[0]=n[0]+k|0,n[1]=n[1]+P|0,n[2]=n[2]+o|0,n[3]=n[3]+i|0;},_doFinalize:function(){var e=this._data,t=e.words,n=8*this._nDataBytes,r=8*e.sigBytes;t[r>>>5]|=128<<24-r%32;var i=o.floor(n/4294967296);for(t[15+(r+64>>>9<<4)]=16711935&(i<<8|i>>>24)|4278255360&(i<<24|i>>>8),t[14+(r+64>>>9<<4)]=16711935&(n<<8|n>>>24)|4278255360&(n<<24|n>>>8),e.sigBytes=4*(t.length+1),this._process(),t=(e=this._hash).words,n=0;n<4;n++)r=t[n],t[n]=16711935&(r<<8|r>>>24)|4278255360&(r<<24|r>>>8);return e},clone:function(){var e=n.clone.call(this);return e._hash=this._hash.clone(),e}}),e.MD5=n._createHelper(r),e.HmacMD5=n._createHmacHelper(r);}(Math),a=(o=(s=E).lib).Base,f=o.WordArray,l=(o=s.algo).EvpKDF=a.extend({cfg:a.extend({keySize:4,hasher:o.MD5,iterations:1}),init:function(e){this.cfg=this.cfg.extend(e);},compute:function(e,t){for(var n=(s=this.cfg).hasher.create(),r=f.create(),i=r.words,o=s.keySize,s=s.iterations;i.length<o;){a&&n.update(a);var a=n.update(e).finalize(t);n.reset();for(var u=1;u<s;u++)a=n.finalize(a),n.reset();r.concat(a);}return r.sigBytes=4*o,r}}),s.EvpKDF=function(e,t,n){return l.create(n).compute(e,t)},E.lib.Cipher||function(){var e=(h=E).lib,t=e.Base,s=e.WordArray,n=e.BufferedBlockAlgorithm,r=h.enc.Base64,i=h.algo.EvpKDF,o=e.Cipher=n.extend({cfg:t.extend(),createEncryptor:function(e,t){return this.create(this._ENC_XFORM_MODE,e,t)},createDecryptor:function(e,t){return this.create(this._DEC_XFORM_MODE,e,t)},init:function(e,t,n){this.cfg=this.cfg.extend(n),this._xformMode=e,this._key=t,this.reset();},reset:function(){n.reset.call(this),this._doReset();},process:function(e){return this._append(e),this._process()},finalize:function(e){return e&&this._append(e),this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(r){return {encrypt:function(e,t,n){return ("string"==typeof t?p:l).encrypt(r,e,t,n)},decrypt:function(e,t,n){return ("string"==typeof t?p:l).decrypt(r,e,t,n)}}}});e.StreamCipher=o.extend({_doFinalize:function(){return this._process(!0)},blockSize:1});function a(e,t,n){var r=this._iv;r?this._iv=void 0:r=this._prevBlock;for(var i=0;i<n;i++)e[t+i]^=r[i];}var u=h.mode={},c=(e.BlockCipherMode=t.extend({createEncryptor:function(e,t){return this.Encryptor.create(e,t)},createDecryptor:function(e,t){return this.Decryptor.create(e,t)},init:function(e,t){this._cipher=e,this._iv=t;}})).extend();c.Encryptor=c.extend({processBlock:function(e,t){var n=this._cipher,r=n.blockSize;a.call(this,e,t,r),n.encryptBlock(e,t),this._prevBlock=e.slice(t,t+r);}}),c.Decryptor=c.extend({processBlock:function(e,t){var n=this._cipher,r=n.blockSize,i=e.slice(t,t+r);n.decryptBlock(e,t),a.call(this,e,t,r),this._prevBlock=i;}}),u=u.CBC=c,c=(h.pad={}).Pkcs7={pad:function(e,t){for(var n,r=(n=(n=4*t)-e.sigBytes%n)<<24|n<<16|n<<8|n,i=[],o=0;o<n;o+=4)i.push(r);n=s.create(i,n),e.concat(n);},unpad:function(e){e.sigBytes-=255&e.words[e.sigBytes-1>>>2];}},e.BlockCipher=o.extend({cfg:o.cfg.extend({mode:u,padding:c}),reset:function(){o.reset.call(this);var e=(t=this.cfg).iv,t=t.mode;if(this._xformMode==this._ENC_XFORM_MODE)var n=t.createEncryptor;else n=t.createDecryptor,this._minBufferSize=1;this._mode=n.call(t,this,e&&e.words);},_doProcessBlock:function(e,t){this._mode.processBlock(e,t);},_doFinalize:function(){var e=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){e.pad(this._data,this.blockSize);var t=this._process(!0);}else t=this._process(!0),e.unpad(t);return t},blockSize:4});var f=e.CipherParams=t.extend({init:function(e){this.mixIn(e);},toString:function(e){return (e||this.formatter).stringify(this)}}),l=(u=(h.format={}).OpenSSL={stringify:function(e){var t=e.ciphertext;return ((e=e.salt)?s.create([1398893684,1701076831]).concat(e).concat(t):t).toString(r)},parse:function(e){var t=(e=r.parse(e)).words;if(1398893684==t[0]&&1701076831==t[1]){var n=s.create(t.slice(2,4));t.splice(0,4),e.sigBytes-=16;}return f.create({ciphertext:e,salt:n})}},e.SerializableCipher=t.extend({cfg:t.extend({format:u}),encrypt:function(e,t,n,r){r=this.cfg.extend(r);var i=e.createEncryptor(n,r);return t=i.finalize(t),i=i.cfg,f.create({ciphertext:t,key:n,iv:i.iv,algorithm:e,mode:i.mode,padding:i.padding,blockSize:e.blockSize,formatter:r.format})},decrypt:function(e,t,n,r){return r=this.cfg.extend(r),t=this._parse(t,r.format),e.createDecryptor(n,r).finalize(t.ciphertext)},_parse:function(e,t){return "string"==typeof e?t.parse(e,this):e}})),h=(h.kdf={}).OpenSSL={execute:function(e,t,n,r){return r=r||s.random(8),e=i.create({keySize:t+n}).compute(e,r),n=s.create(e.words.slice(t),4*n),e.sigBytes=4*t,f.create({key:e,iv:n,salt:r})}},p=e.PasswordBasedCipher=l.extend({cfg:l.cfg.extend({kdf:h}),encrypt:function(e,t,n,r){return n=(r=this.cfg.extend(r)).kdf.execute(n,e.keySize,e.ivSize),r.iv=n.iv,(e=l.encrypt.call(this,e,t,n.key,r)).mixIn(n),e},decrypt:function(e,t,n,r){return r=this.cfg.extend(r),t=this._parse(t,r.format),n=r.kdf.execute(n,e.keySize,e.ivSize,t.salt),r.iv=n.iv,l.decrypt.call(this,e,t,n.key,r)}});}(),function(){for(var e=E,t=e.lib.BlockCipher,n=e.algo,s=[],r=[],i=[],o=[],a=[],u=[],c=[],f=[],l=[],h=[],p=[],d=0;d<256;d++)p[d]=d<128?d<<1:d<<1^283;var g=0,y=0;for(d=0;d<256;d++){var v=(v=y^y<<1^y<<2^y<<3^y<<4)>>>8^255&v^99;s[g]=v;var b=p[r[v]=g],m=p[b],_=p[m],k=257*p[v]^16843008*v;i[g]=k<<24|k>>>8,o[g]=k<<16|k>>>16,a[g]=k<<8|k>>>24,u[g]=k,k=16843009*_^65537*m^257*b^16843008*g,c[v]=k<<24|k>>>8,f[v]=k<<16|k>>>16,l[v]=k<<8|k>>>24,h[v]=k,g?(g=b^p[p[p[_^b]]],y^=p[p[y]]):g=y=1;}var P=[0,1,2,4,8,16,32,64,128,27,54];n=n.AES=t.extend({_doReset:function(){for(var e=(n=this._key).words,t=n.sigBytes/4,n=4*((this._nRounds=t+6)+1),r=this._keySchedule=[],i=0;i<n;i++)if(i<t)r[i]=e[i];else{var o=r[i-1];i%t?6<t&&4==i%t&&(o=s[o>>>24]<<24|s[o>>>16&255]<<16|s[o>>>8&255]<<8|s[255&o]):(o=s[(o=o<<8|o>>>24)>>>24]<<24|s[o>>>16&255]<<16|s[o>>>8&255]<<8|s[255&o],o^=P[i/t|0]<<24),r[i]=r[i-t]^o;}for(e=this._invKeySchedule=[],t=0;t<n;t++)i=n-t,o=t%4?r[i]:r[i-4],e[t]=t<4||i<=4?o:c[s[o>>>24]]^f[s[o>>>16&255]]^l[s[o>>>8&255]]^h[s[255&o]];},encryptBlock:function(e,t){this._doCryptBlock(e,t,this._keySchedule,i,o,a,u,s);},decryptBlock:function(e,t){var n=e[t+1];e[t+1]=e[t+3],e[t+3]=n,this._doCryptBlock(e,t,this._invKeySchedule,c,f,l,h,r),n=e[t+1],e[t+1]=e[t+3],e[t+3]=n;},_doCryptBlock:function(e,t,n,r,i,o,s,a){for(var u=this._nRounds,c=e[t]^n[0],f=e[t+1]^n[1],l=e[t+2]^n[2],h=e[t+3]^n[3],p=4,d=1;d<u;d++){var g=r[c>>>24]^i[f>>>16&255]^o[l>>>8&255]^s[255&h]^n[p++],y=r[f>>>24]^i[l>>>16&255]^o[h>>>8&255]^s[255&c]^n[p++],v=r[l>>>24]^i[h>>>16&255]^o[c>>>8&255]^s[255&f]^n[p++];h=r[h>>>24]^i[c>>>16&255]^o[f>>>8&255]^s[255&l]^n[p++],c=g,f=y,l=v;}g=(a[c>>>24]<<24|a[f>>>16&255]<<16|a[l>>>8&255]<<8|a[255&h])^n[p++],y=(a[f>>>24]<<24|a[l>>>16&255]<<16|a[h>>>8&255]<<8|a[255&c])^n[p++],v=(a[l>>>24]<<24|a[h>>>16&255]<<16|a[c>>>8&255]<<8|a[255&f])^n[p++],h=(a[h>>>24]<<24|a[c>>>16&255]<<16|a[f>>>8&255]<<8|a[255&l])^n[p++],e[t]=g,e[t+1]=y,e[t+2]=v,e[t+3]=h;},keySize:8});e.AES=t._createHelper(n);}(),E.mode.ECB=((h=E.lib.BlockCipherMode.extend()).Encryptor=h.extend({processBlock:function(e,t){this._cipher.encryptBlock(e,t);}}),h.Decryptor=h.extend({processBlock:function(e,t){this._cipher.decryptBlock(e,t);}}),h),e.exports=E;},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;r(n(6)),r(n(3)),r(n(7));var c=r(n(16)),f=r(n(17)),l=r(n(2)),a=(n(0),r(n(4)));function r(e){return e&&e.__esModule?e:{default:e}}function i(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r);}}function h(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var o,s,p=(o=d,(s=[{key:"adaptStateChange",value:function(e,t){var n=this,r=e.state,i=e.channels,o=void 0===i?[]:i,s=e.channelGroups,a=void 0===s?[]:s;return o.forEach(function(e){e in n._channels&&(n._channels[e].state=r);}),a.forEach(function(e){e in n._channelGroups&&(n._channelGroups[e].state=r);}),this._setStateEndpoint({state:r,channels:o,channelGroups:a},t)}},{key:"adaptPresenceChange",value:function(e){var t=this,n=e.connected,r=e.channels,i=void 0===r?[]:r,o=e.channelGroups,s=void 0===o?[]:o;n?(i.forEach(function(e){t._heartbeatChannels[e]={state:{}};}),s.forEach(function(e){t._heartbeatChannelGroups[e]={state:{}};})):(i.forEach(function(e){e in t._heartbeatChannels&&delete t._heartbeatChannels[e];}),s.forEach(function(e){e in t._heartbeatChannelGroups&&delete t._heartbeatChannelGroups[e];}),!1===this._config.suppressLeaveEvents&&this._leaveEndpoint({channels:i,channelGroups:s},function(e){t._listenerManager.announceStatus(e);})),this.reconnect();}},{key:"adaptSubscribeChange",value:function(e){var t=this,n=e.timetoken,r=e.channels,i=void 0===r?[]:r,o=e.channelGroups,s=void 0===o?[]:o,a=e.withPresence,u=void 0!==a&&a,c=e.withHeartbeats,f=void 0!==c&&c;this._config.subscribeKey&&""!==this._config.subscribeKey?(n&&(this._lastTimetoken=this._currentTimetoken,this._currentTimetoken=n),"0"!==this._currentTimetoken&&0!==this._currentTimetoken&&(this._storedTimetoken=this._currentTimetoken,this._currentTimetoken=0),i.forEach(function(e){t._channels[e]={state:{}},u&&(t._presenceChannels[e]={}),(f||t._config.getHeartbeatInterval())&&(t._heartbeatChannels[e]={}),t._pendingChannelSubscriptions.push(e);}),s.forEach(function(e){t._channelGroups[e]={state:{}},u&&(t._presenceChannelGroups[e]={}),(f||t._config.getHeartbeatInterval())&&(t._heartbeatChannelGroups[e]={}),t._pendingChannelGroupSubscriptions.push(e);}),this._subscriptionStatusAnnounced=!1,this.reconnect()):console&&console.log&&console.log("subscribe key missing; aborting subscribe");}},{key:"adaptUnsubscribeChange",value:function(e,t){var n=this,r=e.channels,i=void 0===r?[]:r,o=e.channelGroups,s=void 0===o?[]:o,a=[],u=[];i.forEach(function(e){e in n._channels&&(delete n._channels[e],a.push(e),e in n._heartbeatChannels&&delete n._heartbeatChannels[e]),e in n._presenceChannels&&(delete n._presenceChannels[e],a.push(e));}),s.forEach(function(e){e in n._channelGroups&&(delete n._channelGroups[e],u.push(e),e in n._heartbeatChannelGroups&&delete n._heartbeatChannelGroups[e]),e in n._presenceChannelGroups&&(delete n._channelGroups[e],u.push(e));}),0===a.length&&0===u.length||(!1!==this._config.suppressLeaveEvents||t||this._leaveEndpoint({channels:a,channelGroups:u},function(e){e.affectedChannels=a,e.affectedChannelGroups=u,e.currentTimetoken=n._currentTimetoken,e.lastTimetoken=n._lastTimetoken,n._listenerManager.announceStatus(e);}),0===Object.keys(this._channels).length&&0===Object.keys(this._presenceChannels).length&&0===Object.keys(this._channelGroups).length&&0===Object.keys(this._presenceChannelGroups).length&&(this._lastTimetoken=0,this._currentTimetoken=0,this._storedTimetoken=null,this._region=null,this._reconnectionManager.stopPolling()),this.reconnect());}},{key:"unsubscribeAll",value:function(e){this.adaptUnsubscribeChange({channels:this.getSubscribedChannels(),channelGroups:this.getSubscribedChannelGroups()},e);}},{key:"getHeartbeatChannels",value:function(){return Object.keys(this._heartbeatChannels)}},{key:"getHeartbeatChannelGroups",value:function(){return Object.keys(this._heartbeatChannelGroups)}},{key:"getSubscribedChannels",value:function(){return Object.keys(this._channels)}},{key:"getSubscribedChannelGroups",value:function(){return Object.keys(this._channelGroups)}},{key:"reconnect",value:function(){this._startSubscribeLoop(),this._registerHeartbeatTimer();}},{key:"disconnect",value:function(){this._stopSubscribeLoop(),this._stopHeartbeatTimer(),this._reconnectionManager.stopPolling();}},{key:"_registerHeartbeatTimer",value:function(){this._stopHeartbeatTimer(),0!==this._config.getHeartbeatInterval()&&(this._performHeartbeatLoop(),this._heartbeatTimer=setInterval(this._performHeartbeatLoop.bind(this),1e3*this._config.getHeartbeatInterval()));}},{key:"_stopHeartbeatTimer",value:function(){this._heartbeatTimer&&(clearInterval(this._heartbeatTimer),this._heartbeatTimer=null);}},{key:"_performHeartbeatLoop",value:function(){var n=this,e=this.getHeartbeatChannels(),t=this.getHeartbeatChannelGroups(),r={};0===e.length&&0===t.length||(this.getSubscribedChannels().forEach(function(e){var t=n._channels[e].state;Object.keys(t).length&&(r[e]=t);}),this.getSubscribedChannelGroups().forEach(function(e){var t=n._channelGroups[e].state;Object.keys(t).length&&(r[e]=t);}),this._heartbeatEndpoint({channels:e,channelGroups:t,state:r},function(e){e.error&&n._config.announceFailedHeartbeats&&n._listenerManager.announceStatus(e),e.error&&n._config.autoNetworkDetection&&n._isOnline&&(n._isOnline=!1,n.disconnect(),n._listenerManager.announceNetworkDown(),n.reconnect()),!e.error&&n._config.announceSuccessfulHeartbeats&&n._listenerManager.announceStatus(e);}.bind(this)));}},{key:"_startSubscribeLoop",value:function(){var n=this;this._stopSubscribeLoop();var r={},i=[],o=[];if(Object.keys(this._channels).forEach(function(e){var t=n._channels[e].state;Object.keys(t).length&&(r[e]=t),i.push(e);}),Object.keys(this._presenceChannels).forEach(function(e){i.push("".concat(e,"-pnpres"));}),Object.keys(this._channelGroups).forEach(function(e){var t=n._channelGroups[e].state;Object.keys(t).length&&(r[e]=t),o.push(e);}),Object.keys(this._presenceChannelGroups).forEach(function(e){o.push("".concat(e,"-pnpres"));}),0!==i.length||0!==o.length){var e={channels:i,channelGroups:o,state:r,timetoken:this._currentTimetoken,filterExpression:this._config.filterExpression,region:this._region};this._subscribeCall=this._subscribeEndpoint(e,this._processSubscribeResponse.bind(this));}}},{key:"_processSubscribeResponse",value:function(t,e){var c=this;if(t.error)t.category===a.default.PNTimeoutCategory?this._startSubscribeLoop():(t.category===a.default.PNNetworkIssuesCategory?(this.disconnect(),t.error&&this._config.autoNetworkDetection&&this._isOnline&&(this._isOnline=!1,this._listenerManager.announceNetworkDown()),this._reconnectionManager.onReconnection(function(){c._config.autoNetworkDetection&&!c._isOnline&&(c._isOnline=!0,c._listenerManager.announceNetworkUp()),c.reconnect(),c._subscriptionStatusAnnounced=!0;var e={category:a.default.PNReconnectedCategory,operation:t.operation,lastTimetoken:c._lastTimetoken,currentTimetoken:c._currentTimetoken};c._listenerManager.announceStatus(e);}),this._reconnectionManager.startPolling()):t.category===a.default.PNBadRequestCategory&&this._stopHeartbeatTimer(),this._listenerManager.announceStatus(t));else{if(this._storedTimetoken?(this._currentTimetoken=this._storedTimetoken,this._storedTimetoken=null):(this._lastTimetoken=this._currentTimetoken,this._currentTimetoken=e.metadata.timetoken),!this._subscriptionStatusAnnounced){var n={};n.category=a.default.PNConnectedCategory,n.operation=t.operation,n.affectedChannels=this._pendingChannelSubscriptions,n.subscribedChannels=this.getSubscribedChannels(),n.affectedChannelGroups=this._pendingChannelGroupSubscriptions,n.lastTimetoken=this._lastTimetoken,n.currentTimetoken=this._currentTimetoken,this._subscriptionStatusAnnounced=!0,this._listenerManager.announceStatus(n),this._pendingChannelSubscriptions=[],this._pendingChannelGroupSubscriptions=[];}var r=e.messages||[],i=this._config,o=i.requestMessageCountThreshold,f=i.dedupeOnSubscribe;if(o&&r.length>=o){var s={};s.category=a.default.PNRequestMessageCountExceededCategory,s.operation=t.operation,this._listenerManager.announceStatus(s);}r.forEach(function(e){var t=e.channel,n=e.subscriptionMatch,r=e.publishMetaData;if(t===n&&(n=null),f){if(c._dedupingManager.isDuplicate(e))return;c._dedupingManager.addEntry(e);}if(l.default.endsWith(e.channel,"-pnpres")){var i={channel:null,subscription:null};i.actualChannel=null!=n?t:null,i.subscribedChannel=null!=n?n:t,t&&(i.channel=t.substring(0,t.lastIndexOf("-pnpres"))),n&&(i.subscription=n.substring(0,n.lastIndexOf("-pnpres"))),i.action=e.payload.action,i.state=e.payload.data,i.timetoken=r.publishTimetoken,i.occupancy=e.payload.occupancy,i.uuid=e.payload.uuid,i.timestamp=e.payload.timestamp,e.payload.join&&(i.join=e.payload.join),e.payload.leave&&(i.leave=e.payload.leave),e.payload.timeout&&(i.timeout=e.payload.timeout),c._listenerManager.announcePresence(i);}else if(1===e.messageType){var o={channel:null,subscription:null};o.channel=t,o.subscription=n,o.timetoken=r.publishTimetoken,o.publisher=e.issuingClientId,e.userMetadata&&(o.userMetadata=e.userMetadata),o.message=e.payload,c._listenerManager.announceSignal(o);}else if(2===e.messageType){var s={channel:null,subscription:null};s.channel=t,s.subscription=n,s.timetoken=r.publishTimetoken,s.publisher=e.issuingClientId,e.userMetadata&&(s.userMetadata=e.userMetadata),s.message={event:e.payload.event,type:e.payload.type,data:e.payload.data},"user"===e.payload.type?c._listenerManager.announceUser(s):"space"===e.payload.type?c._listenerManager.announceSpace(s):"membership"===e.payload.type&&c._listenerManager.announceMembership(s);}else if(3===e.messageType){var a={};a.channel=t,a.subscription=n,a.timetoken=r.publishTimetoken,a.publisher=e.issuingClientId,a.data={messageTimetoken:e.payload.data.messageTimetoken,actionTimetoken:e.payload.data.actionTimetoken,type:e.payload.data.type,uuid:e.issuingClientId,value:e.payload.data.value},a.event=e.payload.event,c._listenerManager.announceMessageAction(a);}else{var u={channel:null,subscription:null};u.actualChannel=null!=n?t:null,u.subscribedChannel=null!=n?n:t,u.channel=t,u.subscription=n,u.timetoken=r.publishTimetoken,u.publisher=e.issuingClientId,e.userMetadata&&(u.userMetadata=e.userMetadata),c._config.cipherKey?u.message=c._crypto.decrypt(e.payload):u.message=e.payload,c._listenerManager.announceMessage(u);}}),this._region=e.metadata.region,this._startSubscribeLoop();}}},{key:"_stopSubscribeLoop",value:function(){this._subscribeCall&&("function"==typeof this._subscribeCall.abort&&this._subscribeCall.abort(),this._subscribeCall=null);}}])&&i(o.prototype,s),d);function d(e){var t=e.subscribeEndpoint,n=e.leaveEndpoint,r=e.heartbeatEndpoint,i=e.setStateEndpoint,o=e.timeEndpoint,s=e.config,a=e.crypto,u=e.listenerManager;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,d),h(this,"_crypto",void 0),h(this,"_config",void 0),h(this,"_listenerManager",void 0),h(this,"_reconnectionManager",void 0),h(this,"_leaveEndpoint",void 0),h(this,"_heartbeatEndpoint",void 0),h(this,"_setStateEndpoint",void 0),h(this,"_subscribeEndpoint",void 0),h(this,"_channels",void 0),h(this,"_presenceChannels",void 0),h(this,"_heartbeatChannels",void 0),h(this,"_heartbeatChannelGroups",void 0),h(this,"_channelGroups",void 0),h(this,"_presenceChannelGroups",void 0),h(this,"_currentTimetoken",void 0),h(this,"_lastTimetoken",void 0),h(this,"_storedTimetoken",void 0),h(this,"_region",void 0),h(this,"_subscribeCall",void 0),h(this,"_heartbeatTimer",void 0),h(this,"_subscriptionStatusAnnounced",void 0),h(this,"_autoNetworkDetection",void 0),h(this,"_isOnline",void 0),h(this,"_pendingChannelSubscriptions",void 0),h(this,"_pendingChannelGroupSubscriptions",void 0),h(this,"_dedupingManager",void 0),this._listenerManager=u,this._config=s,this._leaveEndpoint=n,this._heartbeatEndpoint=r,this._setStateEndpoint=i,this._subscribeEndpoint=t,this._crypto=a,this._channels={},this._presenceChannels={},this._heartbeatChannels={},this._heartbeatChannelGroups={},this._channelGroups={},this._presenceChannelGroups={},this._pendingChannelSubscriptions=[],this._pendingChannelGroupSubscriptions=[],this._currentTimetoken=0,this._lastTimetoken=0,this._storedTimetoken=null,this._subscriptionStatusAnnounced=!1,this._isOnline=!0,this._reconnectionManager=new c.default({timeEndpoint:o}),this._dedupingManager=new f.default({config:s});}t.default=p,e.exports=t.default;},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var r;(r=n(8))&&r.__esModule,n(0);function i(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r);}}function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var s,a,c=(s=f,(a=[{key:"onReconnection",value:function(e){this._reconnectionCallback=e;}},{key:"startPolling",value:function(){this._timeTimer=setInterval(this._performTimeLoop.bind(this),3e3);}},{key:"stopPolling",value:function(){clearInterval(this._timeTimer);}},{key:"_performTimeLoop",value:function(){var t=this;this._timeEndpoint(function(e){e.error||(clearInterval(t._timeTimer),t._reconnectionCallback());});}}])&&i(s.prototype,a),f);function f(e){var t=e.timeEndpoint;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,f),o(this,"_reconnectionCallback",void 0),o(this,"_timeEndpoint",void 0),o(this,"_timeTimer",void 0),this._timeEndpoint=t;}t.default=c,e.exports=t.default;},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var r;(r=n(3))&&r.__esModule,n(0);function i(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r);}}function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var s,a,c=(s=f,(a=[{key:"getKey",value:function(e){var t=function(e){var t=0;if(0===e.length)return t;for(var n=0;n<e.length;n+=1)t=(t<<5)-t+e.charCodeAt(n),t&=t;return t}(JSON.stringify(e.payload)).toString(),n=e.publishMetaData.publishTimetoken;return "".concat(n,"-").concat(t)}},{key:"isDuplicate",value:function(e){return this.hashHistory.includes(this.getKey(e))}},{key:"addEntry",value:function(e){this.hashHistory.length>=this._config.maximumCacheSize&&this.hashHistory.shift(),this.hashHistory.push(this.getKey(e));}},{key:"clearHistory",value:function(){this.hashHistory=[];}}])&&i(s.prototype,a),f);function f(e){var t=e.config;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,f),o(this,"_config",void 0),o(this,"hashHistory",void 0),this.hashHistory=[],this._config=t;}t.default=c,e.exports=t.default;},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.default=t.FCMNotificationPayload=t.MPNSNotificationPayload=t.APNSNotificationPayload=void 0;n(0);function r(e){return (r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function i(e,t){if(null==e)return {};var n,r,i=function(e,t){if(null==e)return {};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],0<=t.indexOf(n)||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],0<=t.indexOf(n)||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n]);}return i}function o(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter(function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable})),n.push.apply(n,r);}return n}function s(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?o(Object(n),!0).forEach(function(e){g(t,e,n[e]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach(function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e));});}return t}function a(e,t){return !t||"object"!==r(t)&&"function"!=typeof t?c(e):t}function u(e){return (u=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function c(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function f(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&l(e,t);}function l(e,t){return (l=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function h(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function p(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r);}}function d(e,t,n){return t&&p(e.prototype,t),n&&p(e,n),e}function g(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var y=(d(v,[{key:"payload",get:function(){return this._payload}},{key:"title",set:function(e){this._title=e;}},{key:"subtitle",set:function(e){this._subtitle=e;}},{key:"body",set:function(e){this._body=e;}},{key:"badge",set:function(e){this._badge=e;}},{key:"sound",set:function(e){this._sound=e;}}]),d(v,[{key:"_setDefaultPayloadStructure",value:function(){}},{key:"toObject",value:function(){return {}}}]),v);function v(e,t,n){h(this,v),g(this,"_subtitle",void 0),g(this,"_payload",void 0),g(this,"_badge",void 0),g(this,"_sound",void 0),g(this,"_title",void 0),g(this,"_body",void 0),this._payload=e,this._setDefaultPayloadStructure(),this.title=t,this.body=n;}var b=(f(m,y),d(m,[{key:"_setDefaultPayloadStructure",value:function(){this._payload.aps={alert:{}};}},{key:"toObject",value:function(){var t=this,e=s({},this._payload),n=e.aps,r=n.alert;if(this._isSilent&&(n["content-available"]=1),"apns2"===this._apnsPushType){if(!this._configurations||!this._configurations.length)throw new ReferenceError("APNS2 configuration is missing");var i=[];this._configurations.forEach(function(e){i.push(t._objectFromAPNS2Configuration(e));}),i.length&&(e.pn_push=i);}return r&&Object.keys(r).length||delete n.alert,this._isSilent&&(delete n.alert,delete n.badge,delete n.sound,r={}),this._isSilent||Object.keys(r).length?e:null}},{key:"_objectFromAPNS2Configuration",value:function(e){var t=this;if(!e.targets||!e.targets.length)throw new ReferenceError("At least one APNS2 target should be provided");var n=[];e.targets.forEach(function(e){n.push(t._objectFromAPNSTarget(e));});var r=e.collapseId,i=e.expirationDate,o={auth_method:"token",targets:n,version:"v2"};return r&&r.length&&(o.collapse_id=r),i&&(o.expiration=i.toISOString()),o}},{key:"_objectFromAPNSTarget",value:function(e){if(!e.topic||!e.topic.length)throw new TypeError("Target 'topic' undefined.");var t=e.topic,n=e.environment,r=void 0===n?"development":n,i=e.excludedDevices,o=void 0===i?[]:i,s={topic:t,environment:r};return o.length&&(s.excluded_devices=o),s}},{key:"configurations",set:function(e){e&&e.length&&(this._configurations=e);}},{key:"notification",get:function(){return this._payload.aps}},{key:"title",get:function(){return this._title},set:function(e){e&&e.length&&(this._payload.aps.alert.title=e,this._title=e);}},{key:"subtitle",get:function(){return this._subtitle},set:function(e){e&&e.length&&(this._payload.aps.alert.subtitle=e,this._subtitle=e);}},{key:"body",get:function(){return this._body},set:function(e){e&&e.length&&(this._payload.aps.alert.body=e,this._body=e);}},{key:"badge",get:function(){return this._badge},set:function(e){null!=e&&(this._payload.aps.badge=e,this._badge=e);}},{key:"sound",get:function(){return this._sound},set:function(e){e&&e.length&&(this._payload.aps.sound=e,this._sound=e);}},{key:"silent",set:function(e){this._isSilent=e;}}]),m);function m(){var e,t;h(this,m);for(var n=arguments.length,r=new Array(n),i=0;i<n;i++)r[i]=arguments[i];return g(c(t=a(this,(e=u(m)).call.apply(e,[this].concat(r)))),"_configurations",void 0),g(c(t),"_apnsPushType",void 0),g(c(t),"_isSilent",void 0),t}t.APNSNotificationPayload=b;var _=(f(k,y),d(k,[{key:"toObject",value:function(){return Object.keys(this._payload).length?s({},this._payload):null}},{key:"backContent",get:function(){return this._backContent},set:function(e){e&&e.length&&(this._payload.back_content=e,this._backContent=e);}},{key:"backTitle",get:function(){return this._backTitle},set:function(e){e&&e.length&&(this._payload.back_title=e,this._backTitle=e);}},{key:"count",get:function(){return this._count},set:function(e){null!=e&&(this._payload.count=e,this._count=e);}},{key:"title",get:function(){return this._title},set:function(e){e&&e.length&&(this._payload.title=e,this._title=e);}},{key:"type",get:function(){return this._type},set:function(e){e&&e.length&&(this._payload.type=e,this._type=e);}},{key:"subtitle",get:function(){return this.backTitle},set:function(e){this.backTitle=e;}},{key:"body",get:function(){return this.backContent},set:function(e){this.backContent=e;}},{key:"badge",get:function(){return this.count},set:function(e){this.count=e;}}]),k);function k(){var e,t;h(this,k);for(var n=arguments.length,r=new Array(n),i=0;i<n;i++)r[i]=arguments[i];return g(c(t=a(this,(e=u(k)).call.apply(e,[this].concat(r)))),"_backContent",void 0),g(c(t),"_backTitle",void 0),g(c(t),"_count",void 0),g(c(t),"_type",void 0),t}t.MPNSNotificationPayload=_;var P=(f(w,y),d(w,[{key:"_setDefaultPayloadStructure",value:function(){this._payload.notification={},this._payload.data={};}},{key:"toObject",value:function(){var e=s({},this._payload.data),t=null,n={};if(2<Object.keys(this._payload).length){var r=this._payload;r.notification,r.data,e=s({},e,{},i(r,["notification","data"]));}return this._isSilent?e.notification=this._payload.notification:t=this._payload.notification,Object.keys(e).length&&(n.data=e),t&&Object.keys(t).length&&(n.notification=t),Object.keys(n).length?n:null}},{key:"notification",get:function(){return this._payload.notification}},{key:"data",get:function(){return this._payload.data}},{key:"title",get:function(){return this._title},set:function(e){e&&e.length&&(this._payload.notification.title=e,this._title=e);}},{key:"body",get:function(){return this._body},set:function(e){e&&e.length&&(this._payload.notification.body=e,this._body=e);}},{key:"sound",get:function(){return this._sound},set:function(e){e&&e.length&&(this._payload.notification.sound=e,this._sound=e);}},{key:"icon",get:function(){return this._icon},set:function(e){e&&e.length&&(this._payload.notification.icon=e,this._icon=e);}},{key:"tag",get:function(){return this._tag},set:function(e){e&&e.length&&(this._payload.notification.tag=e,this._tag=e);}},{key:"silent",set:function(e){this._isSilent=e;}}]),w);function w(){var e,t;h(this,w);for(var n=arguments.length,r=new Array(n),i=0;i<n;i++)r[i]=arguments[i];return g(c(t=a(this,(e=u(w)).call.apply(e,[this].concat(r)))),"_isSilent",void 0),g(c(t),"_icon",void 0),g(c(t),"_tag",void 0),t}function T(e,t){h(this,T),g(this,"_payload",void 0),g(this,"_debugging",void 0),g(this,"_subtitle",void 0),g(this,"_badge",void 0),g(this,"_sound",void 0),g(this,"_title",void 0),g(this,"_body",void 0),g(this,"apns",void 0),g(this,"mpns",void 0),g(this,"fcm",void 0),this._payload={apns:{},mpns:{},fcm:{}},this._title=e,this._body=t,this.apns=new b(this._payload.apns,e,t),this.mpns=new _(this._payload.mpns,e,t),this.fcm=new P(this._payload.fcm,e,t);}t.FCMNotificationPayload=P;var O=(d(T,[{key:"debugging",set:function(e){this._debugging=e;}},{key:"title",get:function(){return this._title}},{key:"body",get:function(){return this._body}},{key:"subtitle",get:function(){return this._subtitle},set:function(e){this._subtitle=e,this.apns.subtitle=e,this.mpns.subtitle=e,this.fcm.subtitle=e;}},{key:"badge",get:function(){return this._badge},set:function(e){this._badge=e,this.apns.badge=e,this.mpns.badge=e,this.fcm.badge=e;}},{key:"sound",get:function(){return this._sound},set:function(e){this._sound=e,this.apns.sound=e,this.mpns.sound=e,this.fcm.sound=e;}}]),d(T,[{key:"buildPayload",value:function(e){var t={};if(e.includes("apns")||e.includes("apns2")){this.apns._apnsPushType=e.includes("apns")?"apns":"apns2";var n=this.apns.toObject();n&&Object.keys(n).length&&(t.pn_apns=n);}if(e.includes("mpns")){var r=this.mpns.toObject();r&&Object.keys(r).length&&(t.pn_mpns=r);}if(e.includes("fcm")){var i=this.fcm.toObject();i&&Object.keys(i).length&&(t.pn_gcm=i);}return Object.keys(t).length&&this._debugging&&(t.pn_debug=!0),t}}]),T);t.default=O;},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var r;(r=n(3))&&r.__esModule,n(0);function i(e){return (i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function o(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r);}}function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var a,u,f=(a=l,(u=[{key:"_initializeTokens",value:function(){this._userTokens={},this._spaceTokens={},this._userToken=void 0,this._spaceToken=void 0;}},{key:"_setToken",value:function(t){var n=this,e=this.parseToken(t);e&&e.resources&&(e.resources.users&&Object.keys(e.resources.users).forEach(function(e){n._userTokens[e]=t;}),e.resources.spaces&&Object.keys(e.resources.spaces).forEach(function(e){n._spaceTokens[e]=t;})),e&&e.patterns&&(e.patterns.users&&0<Object.keys(e.patterns.users).length&&(this._userToken=t),e.patterns.spaces&&0<Object.keys(e.patterns.spaces).length&&(this._spaceToken=t));}},{key:"setToken",value:function(e){e&&0<e.length&&this._setToken(e);}},{key:"setTokens",value:function(e){var t=this;e&&e.length&&"object"===i(e)&&e.forEach(function(e){t.setToken(e);});}},{key:"getTokens",value:function(e){var t=this,n={users:{},spaces:{}};return e?(e.user&&(n.user=this._userToken),e.space&&(n.space=this._spaceToken),e.users&&e.users.forEach(function(e){n.users[e]=t._userTokens[e];}),e.space&&e.spaces.forEach(function(e){n.spaces[e]=t._spaceTokens[e];})):(this._userToken&&(n.user=this._userToken),this._spaceToken&&(n.space=this._spaceToken),Object.keys(this._userTokens).forEach(function(e){n.users[e]=t._userTokens[e];}),Object.keys(this._spaceTokens).forEach(function(e){n.spaces[e]=t._spaceTokens[e];})),n}},{key:"getToken",value:function(e,t){var n;return t?"user"===e?n=this._userTokens[t]:"space"===e&&(n=this._spaceTokens[t]):"user"===e?n=this._userToken:"space"===e&&(n=this._spaceToken),n}},{key:"extractPermissions",value:function(e){var t={create:!1,read:!1,write:!1,manage:!1,delete:!1};return 16==(16&e)&&(t.create=!0),8==(8&e)&&(t.delete=!0),4==(4&e)&&(t.manage=!0),2==(2&e)&&(t.write=!0),1==(1&e)&&(t.read=!0),t}},{key:"parseToken",value:function(e){var t=this,n=this._cbor.decodeToken(e);if(void 0!==n){var r=Object.keys(n.res.usr),i=Object.keys(n.res.spc),o=Object.keys(n.pat.usr),s=Object.keys(n.pat.spc),a={version:n.v,timestamp:n.t,ttl:n.ttl},u=0<r.length,c=0<i.length;(u||c)&&(a.resources={},u&&(a.resources.users={},r.forEach(function(e){a.resources.users[e]=t.extractPermissions(n.res.usr[e]);})),c&&(a.resources.spaces={},i.forEach(function(e){a.resources.spaces[e]=t.extractPermissions(n.res.spc[e]);})));var f=0<o.length,l=0<s.length;return (f||l)&&(a.patterns={},f&&(a.patterns.users={},o.forEach(function(e){a.patterns.users[e]=t.extractPermissions(n.pat.usr[e]);})),l&&(a.patterns.spaces={},s.forEach(function(e){a.patterns.spaces[e]=t.extractPermissions(n.pat.spc[e]);}))),0<Object.keys(n.meta).length&&(a.meta=n.meta),a.signature=n.sig,a}}},{key:"clearTokens",value:function(){this._initializeTokens();}}])&&o(a.prototype,u),l);function l(e,t){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,l),s(this,"_config",void 0),s(this,"_cbor",void 0),s(this,"_userTokens",void 0),s(this,"_spaceTokens",void 0),s(this,"_userToken",void 0),s(this,"_spaceToken",void 0),this._config=e,this._cbor=t,this._initializeTokens();}t.default=f,e.exports=t.default;},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(r,i){var e=r.networking,t=r.config,o=null,s=null,a={};o=i.getOperation()===b.default.PNTimeOperation||i.getOperation()===b.default.PNChannelGroupsOperation?arguments.length<=2?void 0:arguments[2]:(a=arguments.length<=2?void 0:arguments[2],arguments.length<=3?void 0:arguments[3]);"undefined"==typeof Promise||o||(s=v.default.createPromise());var n=i.validateParams(r,a);if(n)return o?o(_(n)):s?(s.reject(new m("Validation failed, check status for details",_(n))),s.promise):void 0;var u,c=i.prepareParams(r,a),f=function(e,t,n){return e.usePost&&e.usePost(t,n)?e.postURL(t,n):e.usePatch&&e.usePatch(t,n)?e.patchURL(t,n):e.getURL(t,n)}(i,r,a),l={url:f,operation:i.getOperation(),timeout:i.getRequestTimeout(r),headers:i.getRequestHeaders?i.getRequestHeaders():{}};c.uuid=t.UUID,c.pnsdk=function(e){if(e.sdkName)return e.sdkName;var t="PubNub-JS-".concat(e.sdkFamily);e.partnerId&&(t+="-".concat(e.partnerId));t+="/".concat(e.getVersion());var n=e._getPnsdkSuffix(" ");0<n.length&&(t+=n);return t}(t),t.useInstanceId&&(c.instanceid=t.instanceId);t.useRequestId&&(c.requestid=y.default.createUUID());if(i.isAuthSupported()){var h=function(e,t,n){var r;e.getAuthToken&&(r=e.getAuthToken(t,n));return r}(i,r,a)||t.getAuthKey();h&&(c.auth=h);}t.secretKey&&function(e,t,n,r,i){var o=e.config,s=e.crypto,a=k(e,i,r);n.timestamp=Math.floor((new Date).getTime()/1e3);var u="".concat(a,"\n").concat(o.publishKey,"\n").concat(t,"\n").concat(v.default.signPamFromParams(n),"\n");if("POST"===a){var c=i.postPayload(e,r);u+="string"==typeof c?c:JSON.stringify(c);}else if("PATCH"===a){var f=i.patchPayload(e,r);u+="string"==typeof f?f:JSON.stringify(f);}var l="v2.".concat(s.HMACSHA256(u));l=(l=(l=l.replace(/\+/g,"-")).replace(/\//g,"_")).replace(/=+$/,""),n.signature=l;}(r,f,c,a,i);function p(e,t){if(e.error)o?o(e):s&&s.reject(new m("PubNub call failed, check status for details",e));else{var n=i.handleResponse(r,t,a);o?o(e,n):s&&s.fulfill(n);}}if("POST"===k(r,i,a)){var d=i.postPayload(r,a);u=e.POST(c,d,l,p);}else if("PATCH"===k(r,i,a)){var g=i.patchPayload(r,a);u=e.PATCH(c,g,l,p);}else u="DELETE"===k(r,i,a)?e.DELETE(c,l,p):e.GET(c,l,p);if(i.getOperation()===b.default.PNSubscribeOperation)return u;if(s)return s.promise};var y=r(n(5)),v=(n(0),r(n(2))),b=(r(n(3)),r(n(1)));function r(e){return e&&e.__esModule?e:{default:e}}function i(e){return (i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function o(e,t){return !t||"object"!==i(t)&&"function"!=typeof t?function(e){if(void 0!==e)return e;throw new ReferenceError("this hasn't been initialised - super() hasn't been called")}(e):t}function s(e){var n="function"==typeof Map?new Map:void 0;return (s=function(e){if(null===e||!function(e){return -1!==Function.toString.call(e).indexOf("[native code]")}(e))return e;if("function"!=typeof e)throw new TypeError("Super expression must either be null or a function");if(void 0!==n){if(n.has(e))return n.get(e);n.set(e,t);}function t(){return a(e,arguments,c(this).constructor)}return t.prototype=Object.create(e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),u(t,e)})(e)}function a(e,t,n){return (a=function(){if("undefined"==typeof Reflect||!Reflect.construct)return !1;if(Reflect.construct.sham)return !1;if("function"==typeof Proxy)return !0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],function(){})),!0}catch(e){return !1}}()?Reflect.construct:function(e,t,n){var r=[null];r.push.apply(r,t);var i=new(Function.bind.apply(e,r));return n&&u(i,n.prototype),i}).apply(null,arguments)}function u(e,t){return (u=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function c(e){return (c=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}var m=(function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&u(e,t);}(f,s(Error)),f);function f(e,t){var n;return function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,f),(n=o(this,c(f).call(this,e))).name=n.constructor.name,n.status=t,n.message=e,n}function _(e){return function(e,t){return e.type=t,e.error=!0,e}({message:e},"validationError")}function k(e,t,n){return t.usePost&&t.usePost(e,n)?"POST":t.usePatch&&t.usePatch(e,n)?"PATCH":t.useDelete&&t.useDelete(e,n)?"DELETE":"GET"}e.exports=t.default;},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNAddChannelsToGroupOperation},t.validateParams=function(e,t){var n=t.channels,r=t.channelGroup,i=e.config;if(!r)return "Missing Channel Group";if(!n||0===n.length)return "Missing Channels";if(!i.subscribeKey)return "Missing Subscribe Key"},t.getURL=function(e,t){var n=t.channelGroup,r=e.config;return "/v1/channel-registration/sub-key/".concat(r.subscribeKey,"/channel-group/").concat(i.default.encodeString(n))},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.prepareParams=function(e,t){var n=t.channels;return {add:(void 0===n?[]:n).join(",")}},t.handleResponse=function(){return {}};n(0);var r=o(n(1)),i=o(n(2));function o(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNRemoveChannelsFromGroupOperation},t.validateParams=function(e,t){var n=t.channels,r=t.channelGroup,i=e.config;if(!r)return "Missing Channel Group";if(!n||0===n.length)return "Missing Channels";if(!i.subscribeKey)return "Missing Subscribe Key"},t.getURL=function(e,t){var n=t.channelGroup,r=e.config;return "/v1/channel-registration/sub-key/".concat(r.subscribeKey,"/channel-group/").concat(i.default.encodeString(n))},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.prepareParams=function(e,t){var n=t.channels;return {remove:(void 0===n?[]:n).join(",")}},t.handleResponse=function(){return {}};n(0);var r=o(n(1)),i=o(n(2));function o(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNRemoveGroupOperation},t.validateParams=function(e,t){var n=t.channelGroup,r=e.config;if(!n)return "Missing Channel Group";if(!r.subscribeKey)return "Missing Subscribe Key"},t.getURL=function(e,t){var n=t.channelGroup,r=e.config;return "/v1/channel-registration/sub-key/".concat(r.subscribeKey,"/channel-group/").concat(i.default.encodeString(n),"/remove")},t.isAuthSupported=function(){return !0},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.prepareParams=function(){return {}},t.handleResponse=function(){return {}};n(0);var r=o(n(1)),i=o(n(2));function o(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNChannelGroupsOperation},t.validateParams=function(e){if(!e.config.subscribeKey)return "Missing Subscribe Key"},t.getURL=function(e){var t=e.config;return "/v1/channel-registration/sub-key/".concat(t.subscribeKey,"/channel-group")},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.prepareParams=function(){return {}},t.handleResponse=function(e,t){return {groups:t.payload.groups}};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNChannelsForGroupOperation},t.validateParams=function(e,t){var n=t.channelGroup,r=e.config;if(!n)return "Missing Channel Group";if(!r.subscribeKey)return "Missing Subscribe Key"},t.getURL=function(e,t){var n=t.channelGroup,r=e.config;return "/v1/channel-registration/sub-key/".concat(r.subscribeKey,"/channel-group/").concat(i.default.encodeString(n))},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.prepareParams=function(){return {}},t.handleResponse=function(e,t){return {channels:t.payload.channels}};n(0);var r=o(n(1)),i=o(n(2));function o(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNPushNotificationEnabledChannelsOperation},t.validateParams=function(e,t){var n=t.device,r=t.pushGateway,i=t.channels,o=t.topic,s=e.config;if(!n)return "Missing Device ID (device)";if(!r)return "Missing GW Type (pushGateway: gcm, apns or apns2)";if("apns2"===r&&!o)return "Missing APNS2 topic";if(!i||0===i.length)return "Missing Channels";if(!s.subscribeKey)return "Missing Subscribe Key"},t.getURL=function(e,t){var n=t.device,r=t.pushGateway,i=e.config;return "apns2"!==r?"/v1/push/sub-key/".concat(i.subscribeKey,"/devices/").concat(n):"/v2/push/sub-key/".concat(i.subscribeKey,"/devices-apns2/").concat(n)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.prepareParams=function(e,t){var n=t.pushGateway,r=t.channels,i=void 0===r?[]:r,o=t.environment,s=void 0===o?"development":o,a=t.topic,u={type:n,add:i.join(",")};"apns2"===n&&delete(u=Object.assign({},u,{environment:s,topic:a})).type;return u},t.handleResponse=function(){return {}};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNPushNotificationEnabledChannelsOperation},t.validateParams=function(e,t){var n=t.device,r=t.pushGateway,i=t.channels,o=t.topic,s=e.config;if(!n)return "Missing Device ID (device)";if(!r)return "Missing GW Type (pushGateway: gcm, apns or apns2)";if("apns2"===r&&!o)return "Missing APNS2 topic";if(!i||0===i.length)return "Missing Channels";if(!s.subscribeKey)return "Missing Subscribe Key"},t.getURL=function(e,t){var n=t.device,r=t.pushGateway,i=e.config;return "apns2"!==r?"/v1/push/sub-key/".concat(i.subscribeKey,"/devices/").concat(n):"/v2/push/sub-key/".concat(i.subscribeKey,"/devices-apns2/").concat(n)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.prepareParams=function(e,t){var n=t.pushGateway,r=t.channels,i=void 0===r?[]:r,o=t.environment,s=void 0===o?"development":o,a=t.topic,u={type:n,remove:i.join(",")};"apns2"===n&&delete(u=Object.assign({},u,{environment:s,topic:a})).type;return u},t.handleResponse=function(){return {}};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNPushNotificationEnabledChannelsOperation},t.validateParams=function(e,t){var n=t.device,r=t.pushGateway,i=t.topic,o=e.config;if(!n)return "Missing Device ID (device)";if(!r)return "Missing GW Type (pushGateway: gcm, apns or apns2)";if("apns2"===r&&!i)return "Missing APNS2 topic";if(!o.subscribeKey)return "Missing Subscribe Key"},t.getURL=function(e,t){var n=t.device,r=t.pushGateway,i=e.config;return "apns2"!==r?"/v1/push/sub-key/".concat(i.subscribeKey,"/devices/").concat(n):"/v2/push/sub-key/".concat(i.subscribeKey,"/devices-apns2/").concat(n)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.prepareParams=function(e,t){var n=t.pushGateway,r=t.environment,i=void 0===r?"development":r,o=t.topic,s={type:n};"apns2"===n&&delete(s=Object.assign({},s,{environment:i,topic:o})).type;return s},t.handleResponse=function(e,t){return {channels:t}};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNRemoveAllPushNotificationsOperation},t.validateParams=function(e,t){var n=t.device,r=t.pushGateway,i=t.topic,o=e.config;if(!n)return "Missing Device ID (device)";if(!r)return "Missing GW Type (pushGateway: gcm, apns or apns2)";if("apns2"===r&&!i)return "Missing APNS2 topic";if(!o.subscribeKey)return "Missing Subscribe Key"},t.getURL=function(e,t){var n=t.device,r=t.pushGateway,i=e.config;return "apns2"!==r?"/v1/push/sub-key/".concat(i.subscribeKey,"/devices/").concat(n,"/remove"):"/v2/push/sub-key/".concat(i.subscribeKey,"/devices-apns2/").concat(n,"/remove")},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.prepareParams=function(e,t){var n=t.pushGateway,r=t.environment,i=void 0===r?"development":r,o=t.topic,s={type:n};"apns2"===n&&delete(s=Object.assign({},s,{environment:i,topic:o})).type;return s},t.handleResponse=function(){return {}};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNUnsubscribeOperation},t.validateParams=function(e){if(!e.config.subscribeKey)return "Missing Subscribe Key"},t.getURL=function(e,t){var n=e.config,r=t.channels,i=void 0===r?[]:r,o=0<i.length?i.join(","):",";return "/v2/presence/sub-key/".concat(n.subscribeKey,"/channel/").concat(s.default.encodeString(o),"/leave")},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.prepareParams=function(e,t){var n=t.channelGroups,r=void 0===n?[]:n,i={};0<r.length&&(i["channel-group"]=r.join(","));return i},t.handleResponse=function(){return {}};n(0);var r=i(n(1)),s=i(n(2));function i(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNWhereNowOperation},t.validateParams=function(e){if(!e.config.subscribeKey)return "Missing Subscribe Key"},t.getURL=function(e,t){var n=e.config,r=t.uuid,i=void 0===r?n.UUID:r;return "/v2/presence/sub-key/".concat(n.subscribeKey,"/uuid/").concat(i)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.prepareParams=function(){return {}},t.handleResponse=function(e,t){return t.payload?{channels:t.payload.channels}:{channels:[]}};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNHeartbeatOperation},t.validateParams=function(e){if(!e.config.subscribeKey)return "Missing Subscribe Key"},t.getURL=function(e,t){var n=e.config,r=t.channels,i=void 0===r?[]:r,o=0<i.length?i.join(","):",";return "/v2/presence/sub-key/".concat(n.subscribeKey,"/channel/").concat(s.default.encodeString(o),"/heartbeat")},t.isAuthSupported=function(){return !0},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.prepareParams=function(e,t){var n=t.channelGroups,r=void 0===n?[]:n,i=t.state,o=void 0===i?{}:i,s=e.config,a={};0<r.length&&(a["channel-group"]=r.join(","));return a.state=JSON.stringify(o),a.heartbeat=s.getPresenceTimeout(),a},t.handleResponse=function(){return {}};n(0);var r=i(n(1)),s=i(n(2));function i(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNGetStateOperation},t.validateParams=function(e){if(!e.config.subscribeKey)return "Missing Subscribe Key"},t.getURL=function(e,t){var n=e.config,r=t.uuid,i=void 0===r?n.UUID:r,o=t.channels,s=void 0===o?[]:o,a=0<s.length?s.join(","):",";return "/v2/presence/sub-key/".concat(n.subscribeKey,"/channel/").concat(u.default.encodeString(a),"/uuid/").concat(i)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.prepareParams=function(e,t){var n=t.channelGroups,r=void 0===n?[]:n,i={};0<r.length&&(i["channel-group"]=r.join(","));return i},t.handleResponse=function(e,t,n){var r=n.channels,i=void 0===r?[]:r,o=n.channelGroups,s=void 0===o?[]:o,a={};1===i.length&&0===s.length?a[i[0]]=t.payload:a=t.payload;return {channels:a}};n(0);var r=i(n(1)),u=i(n(2));function i(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNSetStateOperation},t.validateParams=function(e,t){var n=e.config,r=t.state,i=t.channels,o=void 0===i?[]:i,s=t.channelGroups,a=void 0===s?[]:s;if(!r)return "Missing State";if(!n.subscribeKey)return "Missing Subscribe Key";if(0===o.length&&0===a.length)return "Please provide a list of channels and/or channel-groups"},t.getURL=function(e,t){var n=e.config,r=t.channels,i=void 0===r?[]:r,o=0<i.length?i.join(","):",";return "/v2/presence/sub-key/".concat(n.subscribeKey,"/channel/").concat(s.default.encodeString(o),"/uuid/").concat(n.UUID,"/data")},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.prepareParams=function(e,t){var n=t.state,r=t.channelGroups,i=void 0===r?[]:r,o={};o.state=JSON.stringify(n),0<i.length&&(o["channel-group"]=i.join(","));return o},t.handleResponse=function(e,t){return {state:t.payload}};n(0);var r=i(n(1)),s=i(n(2));function i(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNHereNowOperation},t.validateParams=function(e){if(!e.config.subscribeKey)return "Missing Subscribe Key"},t.getURL=function(e,t){var n=e.config,r=t.channels,i=void 0===r?[]:r,o=t.channelGroups,s=void 0===o?[]:o,a="/v2/presence/sub-key/".concat(n.subscribeKey);if(0<i.length||0<s.length){var u=0<i.length?i.join(","):",";a+="/channel/".concat(c.default.encodeString(u));}return a},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.prepareParams=function(e,t){var n=t.channelGroups,r=void 0===n?[]:n,i=t.includeUUIDs,o=void 0===i||i,s=t.includeState,a=void 0!==s&&s,u={};o||(u.disable_uuids=1);a&&(u.state=1);0<r.length&&(u["channel-group"]=r.join(","));return u},t.handleResponse=function(e,i,t){var n,r=t.channels,o=void 0===r?[]:r,s=t.channelGroups,a=void 0===s?[]:s,u=t.includeUUIDs,c=void 0===u||u,f=t.includeState,l=void 0!==f&&f;n=1<o.length||0<a.length||0===a.length&&0===o.length?function(){var r={};return r.totalChannels=i.payload.total_channels,r.totalOccupancy=i.payload.total_occupancy,r.channels={},Object.keys(i.payload.channels).forEach(function(e){var t=i.payload.channels[e],n=[];return r.channels[e]={occupants:n,name:e,occupancy:t.occupancy},c&&t.uuids.forEach(function(e){l?n.push({state:e.state,uuid:e.uuid}):n.push({state:null,uuid:e});}),r}),r}():function(){var e={},t=[];return e.totalChannels=1,e.totalOccupancy=i.occupancy,e.channels={},e.channels[o[0]]={occupants:t,name:o[0],occupancy:i.occupancy},c&&i.uuids&&i.uuids.forEach(function(e){l?t.push({state:e.state,uuid:e.uuid}):t.push({state:null,uuid:e});}),e}();return n};n(0);var r=i(n(1)),c=i(n(2));function i(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNAddMessageActionOperation},t.validateParams=function(e,t){var n=e.config,r=t.action,i=t.channel;if(!t.messageTimetoken)return "Missing message timetoken";if(!n.subscribeKey)return "Missing Subscribe Key";if(!i)return "Missing message channel";if(!r)return "Missing Action";if(!r.value)return "Missing Action.value";if(!r.type)return "Missing Action.type";if(15<r.type.length)return "Action.type value exceed maximum length of 15"},t.usePost=function(){return !0},t.postURL=function(e,t){var n=e.config,r=t.channel,i=t.messageTimetoken;return "/v1/message-actions/".concat(n.subscribeKey,"/channel/").concat(r,"/message/").concat(i)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.getRequestHeaders=function(){return {"Content-Type":"application/json"}},t.isAuthSupported=function(){return !0},t.prepareParams=function(){return {}},t.postPayload=function(e,t){return t.action},t.handleResponse=function(e,t){return {data:t.data}};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNRemoveMessageActionOperation},t.validateParams=function(e,t){var n=e.config,r=t.channel,i=t.actionTimetoken;if(!t.messageTimetoken)return "Missing message timetoken";if(!i)return "Missing action timetoken";if(!n.subscribeKey)return "Missing Subscribe Key";if(!r)return "Missing message channel"},t.useDelete=function(){return !0},t.getURL=function(e,t){var n=e.config,r=t.channel,i=t.actionTimetoken,o=t.messageTimetoken;return "/v1/message-actions/".concat(n.subscribeKey,"/channel/").concat(r,"/message/").concat(o,"/action/").concat(i)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.prepareParams=function(){return {}},t.handleResponse=function(e,t){return {data:t.data}};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNGetMessageActionsOperation},t.validateParams=function(e,t){var n=e.config,r=t.channel;if(!n.subscribeKey)return "Missing Subscribe Key";if(!r)return "Missing message channel"},t.getURL=function(e,t){var n=e.config,r=t.channel;return "/v1/message-actions/".concat(n.subscribeKey,"/channel/").concat(r)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.prepareParams=function(e,t){var n=t.limit,r=t.start,i=t.end,o={};n&&(o.limit=n);r&&(o.start=r);i&&(o.end=i);return o},t.handleResponse=function(e,t){var n={data:t.data,start:null,end:null};n.data.length&&(n.end=n.data[n.data.length-1].actionTimetoken,n.start=n.data[0].actionTimetoken);return n};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNCreateUserOperation},t.validateParams=function(e,t){var n=e.config,r=t.id,i=t.name,o=t.custom;if(!r)return "Missing User.id";if(!i)return "Missing User.name";if(!n.subscribeKey)return "Missing Subscribe Key";if(o&&!Object.values(o).every(function(e){return "string"==typeof e||"number"==typeof e||"boolean"==typeof e}))return "Invalid custom type, only string, number and boolean values are allowed."},t.usePost=function(){return !0},t.getURL=function(e){var t=e.config;return "/v1/objects/".concat(t.subscribeKey,"/users")},t.postURL=function(e){var t=e.config;return "/v1/objects/".concat(t.subscribeKey,"/users")},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("user",t.id)||e.tokenManager.getToken("user")},t.prepareParams=function(e,t){var n=t.include,r={};n?void 0===n.customFields&&(n.customFields=!0):n={customFields:!0};if(n){var i=[];n.customFields&&i.push("custom");var o=i.join(",");0<o.length&&(r.include=o);}return r},t.postPayload=function(e,t){return function(e,t){return t}(0,t)},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNUpdateUserOperation},t.validateParams=function(e,t){var n=e.config,r=t.id,i=t.name,o=t.custom;if(!r)return "Missing User.id";if(!i)return "Missing User.name";if(!n.subscribeKey)return "Missing Subscribe Key";if(o&&!Object.values(o).every(function(e){return "string"==typeof e||"number"==typeof e||"boolean"==typeof e}))return "Invalid custom type, only string, number and boolean values are allowed."},t.usePatch=function(){return !0},t.getURL=function(e,t){var n=e.config,r=t.id;return "/v1/objects/".concat(n.subscribeKey,"/users/").concat(r)},t.patchURL=function(e,t){var n=e.config,r=t.id;return "/v1/objects/".concat(n.subscribeKey,"/users/").concat(r)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("user",t.id)||e.tokenManager.getToken("user")},t.prepareParams=function(e,t){var n=t.include,r={};n?void 0===n.customFields&&(n.customFields=!0):n={customFields:!0};if(n){var i=[];n.customFields&&i.push("custom");var o=i.join(",");0<o.length&&(r.include=o);}return r},t.patchPayload=function(e,t){return function(e,t){return t}(0,t)},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNDeleteUserOperation},t.validateParams=function(e,t){var n=e.config;if(!t)return "Missing UserId";if(!n.subscribeKey)return "Missing Subscribe Key"},t.useDelete=function(){return !0},t.getURL=function(e,t){var n=e.config;return "/v1/objects/".concat(n.subscribeKey,"/users/").concat(t)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("user",t)||e.tokenManager.getToken("user")},t.prepareParams=function(){return {}},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNGetUserOperation},t.validateParams=function(e,t){if(!t.userId)return "Missing userId"},t.getURL=function(e,t){var n=e.config;return "/v1/objects/".concat(n.subscribeKey,"/users/").concat(t.userId)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("user",t.userId)||e.tokenManager.getToken("user")},t.prepareParams=function(e,t){var n=t.include,r={};n?void 0===n.customFields&&(n.customFields=!0):n={customFields:!0};if(n){var i=[];n.customFields&&i.push("custom");var o=i.join(",");0<o.length&&(r.include=o);}return r},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNGetUsersOperation},t.validateParams=function(){},t.getURL=function(e){var t=e.config;return "/v1/objects/".concat(t.subscribeKey,"/users")},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.getAuthToken=function(e){return e.tokenManager.getToken("user")},t.prepareParams=function(e,t){var n=t.include,r=t.limit,i=t.page,o={};r&&(o.limit=r);if(n){var s=[];n.totalCount&&(o.count=!0),n.customFields&&s.push("custom");var a=s.join(",");0<a.length&&(o.include=a);}i&&(i.next&&(o.start=i.next),i.prev&&(o.end=i.prev));return o},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNCreateSpaceOperation},t.validateParams=function(e,t){var n=e.config,r=t.id,i=t.name,o=t.custom;if(!r)return "Missing Space.id";if(!i)return "Missing Space.name";if(!n.subscribeKey)return "Missing Subscribe Key";if(o&&!Object.values(o).every(function(e){return "string"==typeof e||"number"==typeof e||"boolean"==typeof e}))return "Invalid custom type, only string, number and boolean values are allowed."},t.usePost=function(){return !0},t.getURL=function(e){var t=e.config;return "/v1/objects/".concat(t.subscribeKey,"/spaces")},t.postURL=function(e){var t=e.config;return "/v1/objects/".concat(t.subscribeKey,"/spaces")},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("space",t.id)||e.tokenManager.getToken("space")},t.prepareParams=function(e,t){var n=t.include,r={};n?void 0===n.customFields&&(n.customFields=!0):n={customFields:!0};if(n){var i=[];n.customFields&&i.push("custom");var o=i.join(",");0<o.length&&(r.include=o);}return r},t.postPayload=function(e,t){return function(e,t){return t}(0,t)},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNUpdateSpaceOperation},t.validateParams=function(e,t){var n=e.config,r=t.id,i=t.name,o=t.custom;if(!r)return "Missing Space.id";if(!i)return "Missing Space.name";if(!n.subscribeKey)return "Missing Subscribe Key";if(o&&!Object.values(o).every(function(e){return "string"==typeof e||"number"==typeof e||"boolean"==typeof e}))return "Invalid custom type, only string, number and boolean values are allowed."},t.usePatch=function(){return !0},t.getURL=function(e,t){var n=e.config,r=t.id;return "/v1/objects/".concat(n.subscribeKey,"/spaces/").concat(r)},t.patchURL=function(e,t){var n=e.config,r=t.id;return "/v1/objects/".concat(n.subscribeKey,"/spaces/").concat(r)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("space",t.id)||e.tokenManager.getToken("space")},t.prepareParams=function(e,t){var n=t.include,r={};n?void 0===n.customFields&&(n.customFields=!0):n={customFields:!0};if(n){var i=[];n.customFields&&i.push("custom");var o=i.join(",");0<o.length&&(r.include=o);}return r},t.patchPayload=function(e,t){return function(e,t){return t}(0,t)},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNDeleteSpaceOperation},t.validateParams=function(e,t){var n=e.config;if(!t)return "Missing SpaceId";if(!n.subscribeKey)return "Missing Subscribe Key"},t.useDelete=function(){return !0},t.getURL=function(e,t){var n=e.config;return "/v1/objects/".concat(n.subscribeKey,"/spaces/").concat(t)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("space",t)||e.tokenManager.getToken("space")},t.prepareParams=function(){return {}},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNGetSpacesOperation},t.validateParams=function(){},t.getURL=function(e){var t=e.config;return "/v1/objects/".concat(t.subscribeKey,"/spaces")},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.getAuthToken=function(e){return e.tokenManager.getToken("space")},t.prepareParams=function(e,t){var n=t.include,r=t.limit,i=t.page,o={};r&&(o.limit=r);if(n){var s=[];n.totalCount&&(o.count=!0),n.customFields&&s.push("custom");var a=s.join(",");0<a.length&&(o.include=a);}i&&(i.next&&(o.start=i.next),i.prev&&(o.end=i.prev));return o},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNGetSpaceOperation},t.validateParams=function(e,t){if(!t.spaceId)return "Missing spaceId"},t.getURL=function(e,t){var n=e.config;return "/v1/objects/".concat(n.subscribeKey,"/spaces/").concat(t.spaceId)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("space",t.spaceId)||e.tokenManager.getToken("space")},t.prepareParams=function(e,t){var n=t.include,r={};n?void 0===n.customFields&&(n.customFields=!0):n={customFields:!0};if(n){var i=[];n.customFields&&i.push("custom");var o=i.join(",");0<o.length&&(r.include=o);}return r},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNGetMembersOperation},t.validateParams=function(e,t){if(!t.spaceId)return "Missing spaceId"},t.getURL=function(e,t){var n=e.config;return "/v1/objects/".concat(n.subscribeKey,"/spaces/").concat(t.spaceId,"/users")},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("space",t.spaceId)||e.tokenManager.getToken("space")},t.prepareParams=function(e,t){var n=t.include,r=t.limit,i=t.page,o={};r&&(o.limit=r);if(n){var s=[];n.totalCount&&(o.count=!0),n.customFields&&s.push("custom"),n.userFields&&s.push("user"),n.customUserFields&&s.push("user.custom");var a=s.join(",");0<a.length&&(o.include=a);}i&&(i.next&&(o.start=i.next),i.prev&&(o.end=i.prev));return o},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNUpdateMembersOperation},t.validateParams=function(e,t){var n=t.spaceId,r=t.users;if(!n)return "Missing spaceId";if(!r)return "Missing users"},t.getURL=function(e,t){var n=e.config;return "/v1/objects/".concat(n.subscribeKey,"/spaces/").concat(t.spaceId,"/users")},t.patchURL=function(e,t){var n=e.config;return "/v1/objects/".concat(n.subscribeKey,"/spaces/").concat(t.spaceId,"/users")},t.usePatch=function(){return !0},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("space",t.spaceId)||e.tokenManager.getToken("space")},t.prepareParams=function(e,t){var n=t.include,r=t.limit,i=t.page,o={};r&&(o.limit=r);if(n){var s=[];n.totalCount&&(o.count=!0),n.customFields&&s.push("custom"),n.spaceFields&&s.push("space"),n.customSpaceFields&&s.push("space.custom");var a=s.join(",");0<a.length&&(o.include=a);}i&&(i.next&&(o.start=i.next),i.prev&&(o.end=i.prev));return o},t.patchPayload=function(e,t){return function(e,t){var n=t.users,r={};n&&0<n.length&&(r.add=[],n.forEach(function(e){var t={id:e.id};e.custom&&(t.custom=e.custom),r.add.push(t);}));return r}(0,t)},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNUpdateMembersOperation},t.validateParams=function(e,t){var n=t.spaceId,r=t.users;if(!n)return "Missing spaceId";if(!r)return "Missing users"},t.getURL=function(e,t){var n=e.config;return "/v1/objects/".concat(n.subscribeKey,"/spaces/").concat(t.spaceId,"/users")},t.patchURL=function(e,t){var n=e.config;return "/v1/objects/".concat(n.subscribeKey,"/spaces/").concat(t.spaceId,"/users")},t.usePatch=function(){return !0},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("space",t.spaceId)||e.tokenManager.getToken("space")},t.prepareParams=function(e,t){var n=t.include,r=t.limit,i=t.page,o={};r&&(o.limit=r);if(n){var s=[];n.totalCount&&(o.count=!0),n.customFields&&s.push("custom"),n.spaceFields&&s.push("space"),n.customSpaceFields&&s.push("space.custom");var a=s.join(",");0<a.length&&(o.include=a);}i&&(i.next&&(o.start=i.next),i.prev&&(o.end=i.prev));return o},t.patchPayload=function(e,t){return function(e,t){var n=t.addMembers,r=t.updateMembers,i=t.removeMembers,o=t.users,s={};n&&0<n.length&&(s.add=[],n.forEach(function(e){var t={id:e.id};e.custom&&(t.custom=e.custom),s.add.push(t);}));r&&0<r.length&&(s.update=[],r.forEach(function(e){var t={id:e.id};e.custom&&(t.custom=e.custom),s.update.push(t);}));o&&0<o.length&&(s.update=s.update||[],o.forEach(function(e){var t={id:e.id};e.custom&&(t.custom=e.custom),s.update.push(t);}));i&&0<i.length&&(s.remove=[],i.forEach(function(e){s.remove.push({id:e});}));return s}(0,t)},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNUpdateMembersOperation},t.validateParams=function(e,t){var n=t.spaceId,r=t.users;if(!n)return "Missing spaceId";if(!r)return "Missing users"},t.getURL=function(e,t){var n=e.config;return "/v1/objects/".concat(n.subscribeKey,"/spaces/").concat(t.spaceId,"/users")},t.patchURL=function(e,t){var n=e.config;return "/v1/objects/".concat(n.subscribeKey,"/spaces/").concat(t.spaceId,"/users")},t.usePatch=function(){return !0},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("space",t.spaceId)||e.tokenManager.getToken("space")},t.prepareParams=function(e,t){var n=t.include,r=t.limit,i=t.page,o={};r&&(o.limit=r);if(n){var s=[];n.totalCount&&(o.count=!0),n.customFields&&s.push("custom"),n.spaceFields&&s.push("space"),n.customSpaceFields&&s.push("space.custom");var a=s.join(",");0<a.length&&(o.include=a);}i&&(i.next&&(o.start=i.next),i.prev&&(o.end=i.prev));return o},t.patchPayload=function(e,t){return function(e,t){var n=t.users,r={};n&&0<n.length&&(r.remove=[],n.forEach(function(e){r.remove.push({id:e});}));return r}(0,t)},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNGetMembershipsOperation},t.validateParams=function(e,t){if(!t.userId)return "Missing userId"},t.getURL=function(e,t){var n=e.config;return "/v1/objects/".concat(n.subscribeKey,"/users/").concat(t.userId,"/spaces")},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("user",t.userId)||e.tokenManager.getToken("user")},t.prepareParams=function(e,t){var n=t.include,r=t.limit,i=t.page,o={};r&&(o.limit=r);if(n){var s=[];n.totalCount&&(o.count=!0),n.customFields&&s.push("custom"),n.spaceFields&&s.push("space"),n.customSpaceFields&&s.push("space.custom");var a=s.join(",");0<a.length&&(o.include=a);}i&&(i.next&&(o.start=i.next),i.prev&&(o.end=i.prev));return o},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNUpdateMembershipsOperation},t.validateParams=function(e,t){var n=t.userId,r=t.spaces;if(!n)return "Missing userId";if(!r)return "Missing spaces"},t.getURL=function(e,t){var n=e.config;return "/v1/objects/".concat(n.subscribeKey,"/users/").concat(t.userId,"/spaces")},t.patchURL=function(e,t){var n=e.config;return "/v1/objects/".concat(n.subscribeKey,"/users/").concat(t.userId,"/spaces")},t.usePatch=function(){return !0},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("user",t.userId)||e.tokenManager.getToken("user")},t.prepareParams=function(e,t){var n=t.include,r=t.limit,i=t.page,o={};r&&(o.limit=r);if(n){var s=[];n.totalCount&&(o.count=!0),n.customFields&&s.push("custom"),n.spaceFields&&s.push("space"),n.customSpaceFields&&s.push("space.custom");var a=s.join(",");0<a.length&&(o.include=a);}i&&(i.next&&(o.start=i.next),i.prev&&(o.end=i.prev));return o},t.patchPayload=function(e,t){return function(e,t){var n=t.addMemberships,r=t.updateMemberships,i=t.removeMemberships,o=t.spaces,s={};n&&0<n.length&&(s.add=[],n.forEach(function(e){var t={id:e.id};e.custom&&(t.custom=e.custom),s.add.push(t);}));r&&0<r.length&&(s.update=[],r.forEach(function(e){var t={id:e.id};e.custom&&(t.custom=e.custom),s.update.push(t);}));o&&0<o.length&&(s.update=s.update||[],o.forEach(function(e){var t={id:e.id};e.custom&&(t.custom=e.custom),s.update.push(t);}));i&&0<i.length&&(s.remove=[],i.forEach(function(e){s.remove.push({id:e});}));return s}(0,t)},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNUpdateMembershipsOperation},t.validateParams=function(e,t){var n=t.userId,r=t.spaces;if(!n)return "Missing userId";if(!r)return "Missing spaces"},t.getURL=function(e,t){var n=e.config;return "/v1/objects/".concat(n.subscribeKey,"/users/").concat(t.userId,"/spaces")},t.patchURL=function(e,t){var n=e.config;return "/v1/objects/".concat(n.subscribeKey,"/users/").concat(t.userId,"/spaces")},t.usePatch=function(){return !0},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("user",t.userId)||e.tokenManager.getToken("user")},t.prepareParams=function(e,t){var n=t.include,r=t.limit,i=t.page,o={};r&&(o.limit=r);if(n){var s=[];n.totalCount&&(o.count=!0),n.customFields&&s.push("custom"),n.spaceFields&&s.push("space"),n.customSpaceFields&&s.push("space.custom");var a=s.join(",");0<a.length&&(o.include=a);}i&&(i.next&&(o.start=i.next),i.prev&&(o.end=i.prev));return o},t.patchPayload=function(e,t){return function(e,t){var n=t.spaces,r={};n&&0<n.length&&(r.add=[],n.forEach(function(e){var t={id:e.id};e.custom&&(t.custom=e.custom),r.add.push(t);}));return r}(0,t)},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNUpdateMembershipsOperation},t.validateParams=function(e,t){var n=t.userId,r=t.spaces;if(!n)return "Missing userId";if(!r)return "Missing spaces"},t.getURL=function(e,t){var n=e.config;return "/v1/objects/".concat(n.subscribeKey,"/users/").concat(t.userId,"/spaces")},t.patchURL=function(e,t){var n=e.config;return "/v1/objects/".concat(n.subscribeKey,"/users/").concat(t.userId,"/spaces")},t.usePatch=function(){return !0},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("user",t.userId)||e.tokenManager.getToken("user")},t.prepareParams=function(e,t){var n=t.include,r=t.limit,i=t.page,o={};r&&(o.limit=r);if(n){var s=[];n.totalCount&&(o.count=!0),n.customFields&&s.push("custom"),n.spaceFields&&s.push("space"),n.customSpaceFields&&s.push("space.custom");var a=s.join(",");0<a.length&&(o.include=a);}i&&(i.next&&(o.start=i.next),i.prev&&(o.end=i.prev));return o},t.patchPayload=function(e,t){return function(e,t){var n=t.spaces,r={};n&&0<n.length&&(r.remove=[],n.forEach(function(e){r.remove.push({id:e});}));return r}(0,t)},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNAccessManagerAudit},t.validateParams=function(e){if(!e.config.subscribeKey)return "Missing Subscribe Key"},t.getURL=function(e){var t=e.config;return "/v2/auth/audit/sub-key/".concat(t.subscribeKey)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !1},t.prepareParams=function(e,t){var n=t.channel,r=t.channelGroup,i=t.authKeys,o=void 0===i?[]:i,s={};n&&(s.channel=n);r&&(s["channel-group"]=r);0<o.length&&(s.auth=o.join(","));return s},t.handleResponse=function(e,t){return t.payload};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNAccessManagerGrant},t.validateParams=function(e){var t=e.config;if(!t.subscribeKey)return "Missing Subscribe Key";if(!t.publishKey)return "Missing Publish Key";if(!t.secretKey)return "Missing Secret Key"},t.getURL=function(e){var t=e.config;return "/v2/auth/grant/sub-key/".concat(t.subscribeKey)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !1},t.prepareParams=function(e,t){var n=t.channels,r=void 0===n?[]:n,i=t.channelGroups,o=void 0===i?[]:i,s=t.ttl,a=t.read,u=void 0!==a&&a,c=t.write,f=void 0!==c&&c,l=t.manage,h=void 0!==l&&l,p=t.authKeys,d=void 0===p?[]:p,g={};g.r=u?"1":"0",g.w=f?"1":"0",g.m=h?"1":"0",0<r.length&&(g.channel=r.join(","));0<o.length&&(g["channel-group"]=o.join(","));0<d.length&&(g.auth=d.join(","));!s&&0!==s||(g.ttl=s);return g},t.handleResponse=function(){return {}};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNAccessManagerGrantToken},t.extractPermissions=l,t.validateParams=function(e,t){var n=e.config;if(!n.subscribeKey)return "Missing Subscribe Key";if(!n.publishKey)return "Missing Publish Key";if(!n.secretKey)return "Missing Secret Key";if(!t.resources&&!t.patterns)return "Missing either Resources or Patterns.";if(t.resources&&(!t.resources.users||0===Object.keys(t.resources.users).length)&&(!t.resources.spaces||0===Object.keys(t.resources.spaces).length)||t.patterns&&(!t.patterns.users||0===Object.keys(t.patterns.users).length)&&(!t.patterns.spaces||0===Object.keys(t.patterns.spaces).length))return "Missing values for either Resources or Patterns."},t.postURL=function(e){var t=e.config;return "/v3/pam/".concat(t.subscribeKey,"/grant")},t.usePost=function(){return !0},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !1},t.prepareParams=function(){return {}},t.postPayload=function(e,t){return function(e,t){var n=t.ttl,r=t.resources,i=t.patterns,o=t.meta,s={ttl:0,permissions:{resources:{channels:{},groups:{},users:{},spaces:{}},patterns:{channels:{},groups:{},users:{},spaces:{}},meta:{}}};if(r){var a=r.users,u=r.spaces;a&&Object.keys(a).forEach(function(e){s.permissions.resources.users[e]=l(a[e]);}),u&&Object.keys(u).forEach(function(e){s.permissions.resources.spaces[e]=l(u[e]);});}if(i){var c=i.users,f=i.spaces;c&&Object.keys(c).forEach(function(e){s.permissions.patterns.users[e]=l(c[e]);}),f&&Object.keys(f).forEach(function(e){s.permissions.patterns.spaces[e]=l(f[e]);});}!n&&0!==n||(s.ttl=n);o&&(s.permissions.meta=o);return s}(0,t)},t.handleResponse=function(e,t){return t.data.token};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r};function l(e){var t=0;return e.create&&(t|=16),e.delete&&(t|=8),e.manage&&(t|=4),e.write&&(t|=2),e.read&&(t|=1),t}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNPublishOperation},t.validateParams=function(e,t){var n=e.config,r=t.message;if(!t.channel)return "Missing Channel";if(!r)return "Missing Message";if(!n.subscribeKey)return "Missing Subscribe Key"},t.usePost=function(e,t){var n=t.sendByPost;return void 0!==n&&n},t.getURL=function(e,t){var n=e.config,r=t.channel,i=t.message,o=a(e,i);return "/publish/".concat(n.publishKey,"/").concat(n.subscribeKey,"/0/").concat(s.default.encodeString(r),"/0/").concat(s.default.encodeString(o))},t.postURL=function(e,t){var n=e.config,r=t.channel;return "/publish/".concat(n.publishKey,"/").concat(n.subscribeKey,"/0/").concat(s.default.encodeString(r),"/0")},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.postPayload=function(e,t){var n=t.message;return a(e,n)},t.prepareParams=function(e,t){var n=t.meta,r=t.replicate,i=void 0===r||r,o=t.storeInHistory,s=t.ttl,a={};null!=o&&(a.store=o?"1":"0");s&&(a.ttl=s);!1===i&&(a.norep="true");n&&"object"===u(n)&&(a.meta=JSON.stringify(n));return a},t.handleResponse=function(e,t){return {timetoken:t[2]}};n(0);var r=i(n(1)),s=i(n(2));function i(e){return e&&e.__esModule?e:{default:e}}function u(e){return (u="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function a(e,t){var n=e.crypto,r=e.config,i=JSON.stringify(t);return r.cipherKey&&(i=n.encrypt(i),i=JSON.stringify(i)),i}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNSignalOperation},t.validateParams=function(e,t){var n=e.config,r=t.message;if(!t.channel)return "Missing Channel";if(!r)return "Missing Message";if(!n.subscribeKey)return "Missing Subscribe Key"},t.getURL=function(e,t){var n=e.config,r=t.channel,i=t.message,o=function(e,t){return JSON.stringify(t)}(0,i);return "/signal/".concat(n.publishKey,"/").concat(n.subscribeKey,"/0/").concat(s.default.encodeString(r),"/0/").concat(s.default.encodeString(o))},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.prepareParams=function(){return {}},t.handleResponse=function(e,t){return {timetoken:t[2]}};n(0);var r=i(n(1)),s=i(n(2));function i(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNHistoryOperation},t.validateParams=function(e,t){var n=t.channel,r=e.config;if(!n)return "Missing channel";if(!r.subscribeKey)return "Missing Subscribe Key"},t.getURL=function(e,t){var n=t.channel,r=e.config;return "/v2/history/sub-key/".concat(r.subscribeKey,"/channel/").concat(i.default.encodeString(n))},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.prepareParams=function(e,t){var n=t.start,r=t.end,i=t.reverse,o=t.count,s=void 0===o?100:o,a=t.stringifiedTimeToken,u=void 0!==a&&a,c=t.includeMeta,f=void 0!==c&&c,l={include_token:"true"};l.count=s,n&&(l.start=n);r&&(l.end=r);u&&(l.string_message_token="true");null!=i&&(l.reverse=i.toString());f&&(l.include_meta="true");return l},t.handleResponse=function(n,e){var r={messages:[],startTimeToken:e[1],endTimeToken:e[2]};Array.isArray(e[0])&&e[0].forEach(function(e){var t={timetoken:e.timetoken,entry:function(e,t){var n=e.config,r=e.crypto;if(!n.cipherKey)return t;try{return r.decrypt(t)}catch(e){return t}}(n,e.message)};e.meta&&(t.meta=e.meta),r.messages.push(t);});return r};n(0);var r=o(n(1)),i=o(n(2));function o(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNDeleteMessagesOperation},t.validateParams=function(e,t){var n=t.channel,r=e.config;if(!n)return "Missing channel";if(!r.subscribeKey)return "Missing Subscribe Key"},t.useDelete=function(){return !0},t.getURL=function(e,t){var n=t.channel,r=e.config;return "/v3/history/sub-key/".concat(r.subscribeKey,"/channel/").concat(i.default.encodeString(n))},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.prepareParams=function(e,t){var n=t.start,r=t.end,i={};n&&(i.start=n);r&&(i.end=r);return i},t.handleResponse=function(e,t){return t.payload};n(0);var r=o(n(1)),i=o(n(2));function o(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNMessageCounts},t.validateParams=function(e,t){var n=t.channels,r=t.timetoken,i=t.channelTimetokens,o=e.config;if(!n)return "Missing channel";if(r&&i)return "timetoken and channelTimetokens are incompatible together";if(r&&i&&1<i.length&&n.length!==i.length)return "Length of channelTimetokens and channels do not match";if(!o.subscribeKey)return "Missing Subscribe Key"},t.getURL=function(e,t){var n=t.channels,r=e.config,i=n.join(",");return "/v3/history/sub-key/".concat(r.subscribeKey,"/message-counts/").concat(o.default.encodeString(i))},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.prepareParams=function(e,t){var n=t.timetoken,r=t.channelTimetokens,i={};if(r&&1===r.length){var o=function(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){if(!(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e)))return;var n=[],r=!0,i=!1,o=void 0;try{for(var s,a=e[Symbol.iterator]();!(r=(s=a.next()).done)&&(n.push(s.value),!t||n.length!==t);r=!0);}catch(e){i=!0,o=e;}finally{try{r||null==a.return||a.return();}finally{if(i)throw o}}return n}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}(r,1)[0];i.timetoken=o;}else r?i.channelsTimetoken=r.join(","):n&&(i.timetoken=n);return i},t.handleResponse=function(e,t){return {channels:t.channels}};var r=i(n(1)),o=i(n(2));function i(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNFetchMessagesOperation},t.validateParams=function(e,t){var n=t.channels,r=t.includeMessageActions,i=void 0!==r&&r,o=e.config;if(!n||0===n.length)return "Missing channels";if(!o.subscribeKey)return "Missing Subscribe Key";if(i&&1<n.length)throw new TypeError("History can return actions data for a single channel only. Either pass a single channel or disable the includeMessageActions flag.")},t.getURL=function(e,t){var n=t.channels,r=void 0===n?[]:n,i=t.includeMessageActions,o=void 0!==i&&i,s=e.config,a=o?"history-with-actions":"history",u=0<r.length?r.join(","):",";return "/v3/".concat(a,"/sub-key/").concat(s.subscribeKey,"/channel/").concat(c.default.encodeString(u))},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return !0},t.prepareParams=function(e,t){var n=t.start,r=t.end,i=t.count,o=t.stringifiedTimeToken,s=void 0!==o&&o,a=t.includeMeta,u=void 0!==a&&a,c={};i&&(c.max=i);n&&(c.start=n);r&&(c.end=r);s&&(c.string_message_token="true");u&&(c.include_meta="true");return c},t.handleResponse=function(r,e){var i={channels:{}};return Object.keys(e.channels||{}).forEach(function(n){i.channels[n]=[],(e.channels[n]||[]).forEach(function(e){var t={};t.channel=n,t.timetoken=e.timetoken,t.message=function(e,t){var n=e.config,r=e.crypto;if(!n.cipherKey)return t;try{return r.decrypt(t)}catch(e){return t}}(r,e.message),e.actions&&(t.actions=e.actions,t.data=e.actions),e.meta&&(t.meta=e.meta),i.channels[n].push(t);});}),i};n(0);var r=i(n(1)),c=i(n(2));function i(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNSubscribeOperation},t.validateParams=function(e){if(!e.config.subscribeKey)return "Missing Subscribe Key"},t.getURL=function(e,t){var n=e.config,r=t.channels,i=void 0===r?[]:r,o=0<i.length?i.join(","):",";return "/v2/subscribe/".concat(n.subscribeKey,"/").concat(s.default.encodeString(o),"/0")},t.getRequestTimeout=function(e){return e.config.getSubscribeTimeout()},t.isAuthSupported=function(){return !0},t.prepareParams=function(e,t){var n=e.config,r=t.state,i=t.channelGroups,o=void 0===i?[]:i,s=t.timetoken,a=t.filterExpression,u=t.region,c={heartbeat:n.getPresenceTimeout()};0<o.length&&(c["channel-group"]=o.join(","));a&&0<a.length&&(c["filter-expr"]=a);Object.keys(r).length&&(c.state=JSON.stringify(r));s&&(c.tt=s);u&&(c.tr=u);return c},t.handleResponse=function(e,t){var r=[];t.m.forEach(function(e){var t={publishTimetoken:e.p.t,region:e.p.r},n={shard:parseInt(e.a,10),subscriptionMatch:e.b,channel:e.c,messageType:e.e,payload:e.d,flags:e.f,issuingClientId:e.i,subscribeKey:e.k,originationTimetoken:e.o,userMetadata:e.u,publishMetaData:t};r.push(n);});var n={timetoken:t.t.t,region:t.t.r};return {messages:r,metadata:n}};n(0);var r=i(n(1)),s=i(n(2));function i(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;i(n(3));var r=i(n(4));n(0);function i(e){return e&&e.__esModule?e:{default:e}}function o(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r);}}function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var a,u,f=(a=l,(u=[{key:"init",value:function(e){this._config=e,this._maxSubDomain=20,this._currentSubDomain=Math.floor(Math.random()*this._maxSubDomain),this._providedFQDN=(this._config.secure?"https://":"http://")+this._config.origin,this._coreParams={},this.shiftStandardOrigin();}},{key:"nextOrigin",value:function(){return this._providedFQDN.match(/ps\.pndsn\.com$/i)?(this._currentSubDomain=this._currentSubDomain+1,this._currentSubDomain>=this._maxSubDomain&&(this._currentSubDomain=1),e=this._currentSubDomain.toString(),this._providedFQDN.replace("ps.pndsn.com","ps".concat(e,".pndsn.com"))):this._providedFQDN;var e;}},{key:"hasModule",value:function(e){return e in this._modules}},{key:"shiftStandardOrigin",value:function(){return this._standardOrigin=this.nextOrigin(),this._standardOrigin}},{key:"getStandardOrigin",value:function(){return this._standardOrigin}},{key:"POST",value:function(e,t,n,r){return this._modules.post(e,t,n,r)}},{key:"PATCH",value:function(e,t,n,r){return this._modules.patch(e,t,n,r)}},{key:"GET",value:function(e,t,n){return this._modules.get(e,t,n)}},{key:"DELETE",value:function(e,t,n){return this._modules.del(e,t,n)}},{key:"_detectErrorCategory",value:function(e){if("ENOTFOUND"===e.code)return r.default.PNNetworkIssuesCategory;if("ECONNREFUSED"===e.code)return r.default.PNNetworkIssuesCategory;if("ECONNRESET"===e.code)return r.default.PNNetworkIssuesCategory;if("EAI_AGAIN"===e.code)return r.default.PNNetworkIssuesCategory;if(0===e.status||e.hasOwnProperty("status")&&void 0===e.status)return r.default.PNNetworkIssuesCategory;if(e.timeout)return r.default.PNTimeoutCategory;if("ETIMEDOUT"===e.code)return r.default.PNNetworkIssuesCategory;if(e.response){if(e.response.badRequest)return r.default.PNBadRequestCategory;if(e.response.forbidden)return r.default.PNAccessDeniedCategory}return r.default.PNUnknownCategory}}])&&o(a.prototype,u),l);function l(t){var n=this;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,l),s(this,"_modules",void 0),s(this,"_config",void 0),s(this,"_maxSubDomain",void 0),s(this,"_currentSubDomain",void 0),s(this,"_standardOrigin",void 0),s(this,"_subscribeOrigin",void 0),s(this,"_providedFQDN",void 0),s(this,"_requestTimeout",void 0),s(this,"_coreParams",void 0),this._modules={},Object.keys(t).forEach(function(e){n._modules[e]=t[e].bind(n);});}t.default=f,e.exports=t.default;},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var r={get:function(e){try{return localStorage.getItem(e)}catch(e){return null}},set:function(e,t){try{return localStorage.setItem(e,t)}catch(e){return null}}};t.default=r,e.exports=t.default;},function(f,l,h){(function(i){Object.defineProperty(l,"__esModule",{value:!0}),l.default=void 0;var e,o=(e=h(74))&&e.__esModule?e:{default:e};function s(e){return (s="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function t(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r);}}var n,r,u=(n=c,(r=[{key:"decodeToken",value:function(e){var t="";e.length%4==3?t="=":e.length%4==2&&(t="==");var n=e.replace("-","+").replace("_","/")+t,r=o.default.decode(new i.from(n,"base64"));if("object"===s(r))return r}}])&&t(n.prototype,r),c);function c(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,c);}l.default=u,f.exports=l.default;}).call(this,h(9).Buffer);},function(e,t){var n;n=function(){return this}();try{n=n||new Function("return this")();}catch(e){"object"==typeof window&&(n=window);}e.exports=n;},function(e,t,n){t.byteLength=function(e){var t=l(e),n=t[0],r=t[1];return 3*(n+r)/4-r},t.toByteArray=function(e){var t,n,r=l(e),i=r[0],o=r[1],s=new f(function(e,t,n){return 3*(t+n)/4-n}(0,i,o)),a=0,u=0<o?i-4:i;for(n=0;n<u;n+=4)t=c[e.charCodeAt(n)]<<18|c[e.charCodeAt(n+1)]<<12|c[e.charCodeAt(n+2)]<<6|c[e.charCodeAt(n+3)],s[a++]=t>>16&255,s[a++]=t>>8&255,s[a++]=255&t;2===o&&(t=c[e.charCodeAt(n)]<<2|c[e.charCodeAt(n+1)]>>4,s[a++]=255&t);1===o&&(t=c[e.charCodeAt(n)]<<10|c[e.charCodeAt(n+1)]<<4|c[e.charCodeAt(n+2)]>>2,s[a++]=t>>8&255,s[a++]=255&t);return s},t.fromByteArray=function(e){for(var t,n=e.length,r=n%3,i=[],o=0,s=n-r;o<s;o+=16383)i.push(u(e,o,s<o+16383?s:o+16383));1==r?(t=e[n-1],i.push(a[t>>2]+a[t<<4&63]+"==")):2==r&&(t=(e[n-2]<<8)+e[n-1],i.push(a[t>>10]+a[t>>4&63]+a[t<<2&63]+"="));return i.join("")};for(var a=[],c=[],f="undefined"!=typeof Uint8Array?Uint8Array:Array,r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",i=0,o=r.length;i<o;++i)a[i]=r[i],c[r.charCodeAt(i)]=i;function l(e){var t=e.length;if(0<t%4)throw new Error("Invalid string. Length must be a multiple of 4");var n=e.indexOf("=");return -1===n&&(n=t),[n,n===t?0:4-n%4]}function u(e,t,n){for(var r,i,o=[],s=t;s<n;s+=3)r=(e[s]<<16&16711680)+(e[s+1]<<8&65280)+(255&e[s+2]),o.push(a[(i=r)>>18&63]+a[i>>12&63]+a[i>>6&63]+a[63&i]);return o.join("")}c["-".charCodeAt(0)]=62,c["_".charCodeAt(0)]=63;},function(e,t){t.read=function(e,t,n,r,i){var o,s,a=8*i-r-1,u=(1<<a)-1,c=u>>1,f=-7,l=n?i-1:0,h=n?-1:1,p=e[t+l];for(l+=h,o=p&(1<<-f)-1,p>>=-f,f+=a;0<f;o=256*o+e[t+l],l+=h,f-=8);for(s=o&(1<<-f)-1,o>>=-f,f+=r;0<f;s=256*s+e[t+l],l+=h,f-=8);if(0===o)o=1-c;else{if(o===u)return s?NaN:1/0*(p?-1:1);s+=Math.pow(2,r),o-=c;}return (p?-1:1)*s*Math.pow(2,o-r)},t.write=function(e,t,n,r,i,o){var s,a,u,c=8*o-i-1,f=(1<<c)-1,l=f>>1,h=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,p=r?0:o-1,d=r?1:-1,g=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(a=isNaN(t)?1:0,s=f):(s=Math.floor(Math.log(t)/Math.LN2),t*(u=Math.pow(2,-s))<1&&(s--,u*=2),2<=(t+=1<=s+l?h/u:h*Math.pow(2,1-l))*u&&(s++,u/=2),f<=s+l?(a=0,s=f):1<=s+l?(a=(t*u-1)*Math.pow(2,i),s+=l):(a=t*Math.pow(2,l-1)*Math.pow(2,i),s=0));8<=i;e[n+p]=255&a,p+=d,a/=256,i-=8);for(s=s<<i|a,c+=i;0<c;e[n+p]=255&s,p+=d,s/=256,c-=8);e[n+p-d]|=128*g;};},function(e,t){var n={}.toString;e.exports=Array.isArray||function(e){return "[object Array]"==n.call(e)};},function(r,i,e){(function(b){var e,t,n;t=[],void 0===(n="function"==typeof(e=function(){var e=function(){function o(e){this.$hex=e;}o.prototype={length:function(){return this.$hex.length/2},toString:function(e){if(!e||"hex"===e||16===e)return this.$hex;if("utf-8"===e){for(var t="",n=0;n<this.$hex.length;n+=2)t+="%"+this.$hex.substring(n,n+2);return decodeURIComponent(t)}if("latin"!==e)throw new Error("Unrecognised format: "+e);for(var t=[],n=0;n<this.$hex.length;n+=2)t.push(parseInt(this.$hex.substring(n,n+2),16));return String.fromCharCode.apply(String,t)}},o.fromLatinString=function(e){for(var t="",n=0;n<e.length;n++){var r=e.charCodeAt(n).toString(16);1===r.length&&(r="0"+r),t+=r;}return new o(t)},o.fromUtf8String=function(e){for(var t=encodeURIComponent(e),n="",r=0;r<t.length;r++)if("%"===t.charAt(r))n+=t.substring(r+1,r+3),r+=2;else{var i=t.charCodeAt(r).toString(16);i.length<2&&(i="0"+i),n+=i;}return new o(n)};var s=[],f={},r=function(e){return function(){throw new Error(e+" not implemented")}};function e(){}function t(){}function l(e,t){var n=e.value;return n<24?n:24==n?t.readByte():25==n?t.readUint16():26==n?t.readUint32():27==n?t.readUint64():31==n?null:void r("Additional info: "+n)()}function a(e,t,n){var r=e<<5;t<24?n.writeByte(r|t):t<256?(n.writeByte(24|r),n.writeByte(t)):t<65536?(n.writeByte(25|r),n.writeUint16(t)):t<4294967296?(n.writeByte(26|r),n.writeUint32(t)):(n.writeByte(27|r),n.writeUint64(t));}e.prototype={peekByte:r("peekByte"),readByte:r("readByte"),readChunk:r("readChunk"),readFloat16:function(){var e=this.readUint16(),t=(32767&e)>>10,n=1023&e,r=32768&e;if(31==t)return 0==n?r?-1/0:1/0:NaN;var i=t?Math.pow(2,t-25)*(1024+n):Math.pow(2,-24)*n;return r?-i:i},readFloat32:function(){var e=this.readUint32(),t=(2147483647&e)>>23,n=8388607&e,r=2147483648&e;if(255==t)return 0==n?r?-1/0:1/0:NaN;var i=t?Math.pow(2,t-23-127)*(8388608+n):Math.pow(2,-149)*n;return r?-i:i},readFloat64:function(){var e=this.readUint32(),t=this.readUint32(),n=e>>20&2047,r=4294967296*(1048575&e)+t,i=2147483648&e;if(2047==n)return 0===r?i?-1/0:1/0:NaN;var o=n?Math.pow(2,n-52-1023)*(4503599627370496+r):Math.pow(2,-1074)*r;return i?-o:o},readUint16:function(){return 256*this.readByte()+this.readByte()},readUint32:function(){return 65536*this.readUint16()+this.readUint16()},readUint64:function(){return 4294967296*this.readUint32()+this.readUint32()}},t.prototype={writeByte:r("writeByte"),result:r("result"),writeFloat16:r("writeFloat16"),writeFloat32:r("writeFloat32"),writeFloat64:r("writeFloat64"),writeUint16:function(e){this.writeByte(e>>8&255),this.writeByte(255&e);},writeUint32:function(e){this.writeUint16(e>>16&65535),this.writeUint16(65535&e);},writeUint64:function(e){if(9007199254740992<=e||e<=-9007199254740992)throw new Error("Cannot encode Uint64 of: "+e+" magnitude to big (floating point errors)");this.writeUint32(Math.floor(e/4294967296)),this.writeUint32(e%4294967296);},writeString:r("writeString"),canWriteBinary:function(e){return !1},writeBinary:r("writeChunk")};var h=new Error;function p(e){var t=function(e){var t=e.readByte();return {type:t>>5,value:31&t}}(e);switch(t.type){case 0:return l(t,e);case 1:return -1-l(t,e);case 2:return e.readChunk(l(t,e));case 3:var n=e.readChunk(l(t,e));return n.toString("utf-8");case 4:case 5:var r=l(t,e),i=[];if(null!==r){5===t.type&&(r*=2);for(var o=0;o<r;o++)i[o]=p(e);}else for(var s;(s=p(e))!==h;)i.push(s);if(5!==t.type)return i;for(var a={},o=0;o<i.length;o+=2)a[i[o]]=i[o+1];return a;case 6:var u=l(t,e),c=f[u],i=p(e);return c?c(i):i;case 7:if(25===t.value)return e.readFloat16();if(26===t.value)return e.readFloat32();if(27===t.value)return e.readFloat64();switch(l(t,e)){case 20:return !1;case 21:return !0;case 22:return null;case 23:return;case null:return h;default:throw new Error("Unknown fixed value: "+t.value)}default:throw new Error("Unsupported header: "+JSON.stringify(t))}throw new Error("not implemented yet")}function u(e,t){for(var n=0;n<s.length;n++){var r=s[n].fn(e);if(void 0!==r)return a(6,s[n].tag,t),u(r,t)}if(e&&"function"==typeof e.toCBOR&&(e=e.toCBOR()),!1===e)a(7,20,t);else if(!0===e)a(7,21,t);else if(null===e)a(7,22,t);else if(void 0===e)a(7,23,t);else if("number"==typeof e)Math.floor(e)===e&&e<9007199254740992&&-9007199254740992<e?e<0?a(1,-1-e,t):a(0,e,t):(function(e,t,n){n.writeByte(e<<5|t);}(7,27,t),t.writeFloat64(e));else if("string"==typeof e)t.writeString(e,function(e){a(3,e,t);});else if(t.canWriteBinary(e))t.writeBinary(e,function(e){a(2,e,t);});else{if("object"!=typeof e)throw new Error("CBOR encoding not supported: "+e);if(g.config.useToJSON&&"function"==typeof e.toJSON&&(e=e.toJSON()),Array.isArray(e)){a(4,e.length,t);for(var n=0;n<e.length;n++)u(e[n],t);}else{var i=Object.keys(e);a(5,i.length,t);for(var n=0;n<i.length;n++)u(i[n],t),u(e[i[n]],t);}}}var c=[],d=[],g={config:{useToJSON:!0},addWriter:function(t,n){"string"==typeof t?d.push(function(e){if(t===e)return n(e)}):d.push(t);},addReader:function(n,r){"string"==typeof n?c.push(function(e,t){if(n===t)return r(e,t)}):c.push(n);},encode:function(e,t){for(var n=0;n<d.length;n++){var r=d[n],i=r(t);if(i)return u(e,i),i.result()}throw new Error("Unsupported output format: "+t)},decode:function(e,t){for(var n=0;n<c.length;n++){var r=c[n],i=r(e,t);if(i)return p(i)}throw new Error("Unsupported input format: "+t)},addSemanticEncode:function(e,t){if("number"!=typeof e||e%1!=0||e<0)throw new Error("Tag must be a positive integer");return s.push({tag:e,fn:t}),this},addSemanticDecode:function(e,t){if("number"!=typeof e||e%1!=0||e<0)throw new Error("Tag must be a positive integer");return f[e]=t,this},Reader:e,Writer:t};function i(e){this.buffer=e,this.pos=0;}function n(e){this.byteLength=0,this.defaultBufferLength=16384,this.latestBuffer=b.alloc(this.defaultBufferLength),this.latestBufferOffset=0,this.completeBuffers=[],this.stringFormat=e;}function y(e){this.hex=e,this.pos=0;}function v(e){this.$hex="",this.finalFormat=e||"hex";}return (i.prototype=Object.create(e.prototype)).peekByte=function(){return this.buffer[this.pos]},i.prototype.readByte=function(){return this.buffer[this.pos++]},i.prototype.readUint16=function(){var e=this.buffer.readUInt16BE(this.pos);return this.pos+=2,e},i.prototype.readUint32=function(){var e=this.buffer.readUInt32BE(this.pos);return this.pos+=4,e},i.prototype.readFloat32=function(){var e=this.buffer.readFloatBE(this.pos);return this.pos+=4,e},i.prototype.readFloat64=function(){var e=this.buffer.readDoubleBE(this.pos);return this.pos+=8,e},i.prototype.readChunk=function(e){var t=b.alloc(e);return this.buffer.copy(t,0,this.pos,this.pos+=e),t},(n.prototype=Object.create(t.prototype)).writeByte=function(e){this.latestBuffer[this.latestBufferOffset++]=e,this.latestBufferOffset>=this.latestBuffer.length&&(this.completeBuffers.push(this.latestBuffer),this.latestBuffer=b.alloc(this.defaultBufferLength),this.latestBufferOffset=0),this.byteLength++;},n.prototype.writeFloat32=function(e){var t=b.alloc(4);t.writeFloatBE(e,0),this.writeBuffer(t);},n.prototype.writeFloat64=function(e){var t=b.alloc(8);t.writeDoubleBE(e,0),this.writeBuffer(t);},n.prototype.writeString=function(e,t){var n=b.from(e,"utf-8");t(n.length),this.writeBuffer(n);},n.prototype.canWriteBinary=function(e){return e instanceof b},n.prototype.writeBinary=function(e,t){t(e.length),this.writeBuffer(e);},n.prototype.writeBuffer=function(e){if(!(e instanceof b))throw new TypeError("BufferWriter only accepts Buffers");this.latestBufferOffset?this.latestBuffer.length-this.latestBufferOffset>=e.length?(e.copy(this.latestBuffer,this.latestBufferOffset),this.latestBufferOffset+=e.length,this.latestBufferOffset>=this.latestBuffer.length&&(this.completeBuffers.push(this.latestBuffer),this.latestBuffer=b.alloc(this.defaultBufferLength),this.latestBufferOffset=0)):(this.completeBuffers.push(this.latestBuffer.slice(0,this.latestBufferOffset)),this.completeBuffers.push(e),this.latestBuffer=b.alloc(this.defaultBufferLength),this.latestBufferOffset=0):this.completeBuffers.push(e),this.byteLength+=e.length;},n.prototype.result=function(){for(var e=b.alloc(this.byteLength),t=0,n=0;n<this.completeBuffers.length;n++){var r=this.completeBuffers[n];r.copy(e,t,0,r.length),t+=r.length;}return this.latestBufferOffset&&this.latestBuffer.copy(e,t,0,this.latestBufferOffset),this.stringFormat?e.toString(this.stringFormat):e},"function"==typeof b&&(g.addReader(function(e,t){if(e instanceof b)return new i(e);if("hex"===t||"base64"===t){var n=b.from(e,t);return new i(n)}}),g.addWriter(function(e){return e&&"buffer"!==e?"hex"===e||"base64"===e?new n(e):void 0:new n})),(y.prototype=Object.create(e.prototype)).peekByte=function(){var e=this.hex.substring(this.pos,2);return parseInt(e,16)},y.prototype.readByte=function(){var e=this.hex.substring(this.pos,this.pos+2);return this.pos+=2,parseInt(e,16)},y.prototype.readChunk=function(e){var t=this.hex.substring(this.pos,this.pos+2*e);return this.pos+=2*e,"function"==typeof b?b.from(t,"hex"):new o(t)},(v.prototype=Object.create(t.prototype)).writeByte=function(e){if(e<0||255<e)throw new Error("Byte value out of range: "+e);var t=e.toString(16);1==t.length&&(t="0"+t),this.$hex+=t;},v.prototype.canWriteBinary=function(e){return e instanceof o||"function"==typeof b&&e instanceof b},v.prototype.writeBinary=function(e,t){if(e instanceof o)t(e.length()),this.$hex+=e.$hex;else{if(!("function"==typeof b&&e instanceof b))throw new TypeError("HexWriter only accepts BinaryHex or Buffers");t(e.length),this.$hex+=e.toString("hex");}},v.prototype.result=function(){return "buffer"===this.finalFormat&&"function"==typeof b?b.from(this.$hex,"hex"):new o(this.$hex).toString(this.finalFormat)},v.prototype.writeString=function(e,t){var n=o.fromUtf8String(e);t(n.length()),this.$hex+=n.$hex;},g.addReader(function(e,t){return e instanceof o||e.$hex?new y(e.$hex):"hex"===t?new y(e):void 0}),g.addWriter(function(e){if("hex"===e)return new v}),g}();return e.addSemanticEncode(0,function(e){if(e instanceof Date)return e.toISOString()}).addSemanticDecode(0,function(e){return new Date(e)}).addSemanticDecode(1,function(e){return new Date(e)}),e})?e.apply(i,t):e)||(r.exports=n);}).call(this,e(9).Buffer);},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.get=function(e,t,n){var r=o.default.get(this.getStandardOrigin()+t.url).set(t.headers).query(e);return s.call(this,r,t,n)},t.post=function(e,t,n,r){var i=o.default.post(this.getStandardOrigin()+n.url).query(e).set(n.headers).send(t);return s.call(this,i,n,r)},t.patch=function(e,t,n,r){var i=o.default.patch(this.getStandardOrigin()+n.url).query(e).set(n.headers).send(t);return s.call(this,i,n,r)},t.del=function(e,t,n){var r=o.default.delete(this.getStandardOrigin()+t.url).set(t.headers).query(e);return s.call(this,r,t,n)};var r,o=(r=n(76))&&r.__esModule?r:{default:r};n(0);function a(r){var i=(new Date).getTime(),e=(new Date).toISOString(),o=console&&console.log?console:window&&window.console&&window.console.log?window.console:console;o.log("<<<<<"),o.log("[".concat(e,"]"),"\n",r.url,"\n",r.qs),o.log("-----"),r.on("response",function(e){var t=(new Date).getTime()-i,n=(new Date).toISOString();o.log(">>>>>>"),o.log("[".concat(n," / ").concat(t,"]"),"\n",r.url,"\n",r.qs,"\n",e.text),o.log("-----");});}function s(e,i,o){var s=this;return this._config.logVerbosity&&(e=e.use(a)),this._config.proxy&&this._modules.proxy&&(e=this._modules.proxy.call(this,e)),this._config.keepAlive&&this._modules.keepAlive&&(e=this._modules.keepAlive(e)),e.timeout(i.timeout).end(function(t,n){var e,r={};if(r.error=null!==t,r.operation=i.operation,n&&n.status&&(r.statusCode=n.status),t){if(t.response&&t.response.text&&!s._config.logVerbosity)try{r.errorData=JSON.parse(t.response.text);}catch(e){r.errorData=t;}else r.errorData=t;return r.category=s._detectErrorCategory(t),o(r,null)}try{e=JSON.parse(n.text);}catch(e){return r.errorData=n,r.error=!0,o(r,null)}return e.error&&1===e.error&&e.status&&e.message&&e.service?(r.errorData=e,r.statusCode=e.status,r.error=!0,r.category=s._detectErrorCategory(r),o(r,null)):(e.error&&e.error.message&&(r.errorData=e.error),o(r,e))})}},function(e,n,t){var r;r="undefined"!=typeof window?window:"undefined"!=typeof self?self:(console.warn("Using browser-only version of superagent in non-browser environment"),this);var i=t(77),o=t(78),s=t(10),a=t(79),u=t(81);function c(){}var f=n=e.exports=function(e,t){return "function"==typeof t?new n.Request("GET",e).end(t):1==arguments.length?new n.Request("GET",e):new n.Request(e,t)};n.Request=v,f.getXHR=function(){if(!(!r.XMLHttpRequest||r.location&&"file:"==r.location.protocol&&r.ActiveXObject))return new XMLHttpRequest;try{return new ActiveXObject("Microsoft.XMLHTTP")}catch(e){}try{return new ActiveXObject("Msxml2.XMLHTTP.6.0")}catch(e){}try{return new ActiveXObject("Msxml2.XMLHTTP.3.0")}catch(e){}try{return new ActiveXObject("Msxml2.XMLHTTP")}catch(e){}throw Error("Browser-only version of superagent could not find XHR")};var l="".trim?function(e){return e.trim()}:function(e){return e.replace(/(^\s*|\s*$)/g,"")};function h(e){if(!s(e))return e;var t=[];for(var n in e)p(t,n,e[n]);return t.join("&")}function p(t,n,e){if(null!=e)if(Array.isArray(e))e.forEach(function(e){p(t,n,e);});else if(s(e))for(var r in e)p(t,n+"["+r+"]",e[r]);else t.push(encodeURIComponent(n)+"="+encodeURIComponent(e));else null===e&&t.push(encodeURIComponent(n));}function d(e){for(var t,n,r={},i=e.split("&"),o=0,s=i.length;o<s;++o)-1==(n=(t=i[o]).indexOf("="))?r[decodeURIComponent(t)]="":r[decodeURIComponent(t.slice(0,n))]=decodeURIComponent(t.slice(n+1));return r}function g(e){return /[\/+]json($|[^-\w])/.test(e)}function y(e){this.req=e,this.xhr=this.req.xhr,this.text="HEAD"!=this.req.method&&(""===this.xhr.responseType||"text"===this.xhr.responseType)||void 0===this.xhr.responseType?this.xhr.responseText:null,this.statusText=this.req.xhr.statusText;var t=this.xhr.status;1223===t&&(t=204),this._setStatusProperties(t),this.header=this.headers=function(e){for(var t,n,r,i,o=e.split(/\r?\n/),s={},a=0,u=o.length;a<u;++a)-1!==(t=(n=o[a]).indexOf(":"))&&(r=n.slice(0,t).toLowerCase(),i=l(n.slice(t+1)),s[r]=i);return s}(this.xhr.getAllResponseHeaders()),this.header["content-type"]=this.xhr.getResponseHeader("content-type"),this._setHeaderProperties(this.header),null===this.text&&e._responseType?this.body=this.xhr.response:this.body="HEAD"!=this.req.method?this._parseBody(this.text?this.text:this.xhr.response):null;}function v(e,t){var r=this;this._query=this._query||[],this.method=e,this.url=t,this.header={},this._header={},this.on("end",function(){var t,n=null,e=null;try{e=new y(r);}catch(e){return (n=new Error("Parser is unable to parse the response")).parse=!0,n.original=e,r.xhr?(n.rawResponse=void 0===r.xhr.responseType?r.xhr.responseText:r.xhr.response,n.status=r.xhr.status?r.xhr.status:null,n.statusCode=n.status):(n.rawResponse=null,n.status=null),r.callback(n)}r.emit("response",e);try{r._isResponseOK(e)||(t=new Error(e.statusText||"Unsuccessful HTTP response"));}catch(e){t=e;}t?(t.original=n,t.response=e,t.status=e.status,r.callback(t,e)):r.callback(null,e);});}function b(e,t,n){var r=f("DELETE",e);return "function"==typeof t&&(n=t,t=null),t&&r.send(t),n&&r.end(n),r}f.serializeObject=h,f.parseString=d,f.types={html:"text/html",json:"application/json",xml:"text/xml",urlencoded:"application/x-www-form-urlencoded",form:"application/x-www-form-urlencoded","form-data":"application/x-www-form-urlencoded"},f.serialize={"application/x-www-form-urlencoded":h,"application/json":JSON.stringify},f.parse={"application/x-www-form-urlencoded":d,"application/json":JSON.parse},a(y.prototype),y.prototype._parseBody=function(e){var t=f.parse[this.type];return this.req._parser?this.req._parser(this,e):(!t&&g(this.type)&&(t=f.parse["application/json"]),t&&e&&(e.length||e instanceof Object)?t(e):null)},y.prototype.toError=function(){var e=this.req,t=e.method,n=e.url,r="cannot "+t+" "+n+" ("+this.status+")",i=new Error(r);return i.status=this.status,i.method=t,i.url=n,i},f.Response=y,i(v.prototype),o(v.prototype),v.prototype.type=function(e){return this.set("Content-Type",f.types[e]||e),this},v.prototype.accept=function(e){return this.set("Accept",f.types[e]||e),this},v.prototype.auth=function(e,t,n){1===arguments.length&&(t=""),"object"==typeof t&&null!==t&&(n=t,t=""),n=n||{type:"function"==typeof btoa?"basic":"auto"};return this._auth(e,t,n,function(e){if("function"==typeof btoa)return btoa(e);throw new Error("Cannot use basic auth, btoa is not a function")})},v.prototype.query=function(e){return "string"!=typeof e&&(e=h(e)),e&&this._query.push(e),this},v.prototype.attach=function(e,t,n){if(t){if(this._data)throw Error("superagent can't mix .send() and .attach()");this._getFormData().append(e,t,n||t.name);}return this},v.prototype._getFormData=function(){return this._formData||(this._formData=new r.FormData),this._formData},v.prototype.callback=function(e,t){if(this._shouldRetry(e,t))return this._retry();var n=this._callback;this.clearTimeout(),e&&(this._maxRetries&&(e.retries=this._retries-1),this.emit("error",e)),n(e,t);},v.prototype.crossDomainError=function(){var e=new Error("Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.");e.crossDomain=!0,e.status=this.status,e.method=this.method,e.url=this.url,this.callback(e);},v.prototype.buffer=v.prototype.ca=v.prototype.agent=function(){return console.warn("This is not supported in browser version of superagent"),this},v.prototype.pipe=v.prototype.write=function(){throw Error("Streaming is not supported in browser version of superagent")},v.prototype._isHost=function(e){return e&&"object"==typeof e&&!Array.isArray(e)&&"[object Object]"!==Object.prototype.toString.call(e)},v.prototype.end=function(e){return this._endCalled&&console.warn("Warning: .end() was called twice. This is not supported in superagent"),this._endCalled=!0,this._callback=e||c,this._finalizeQueryString(),this._end()},v.prototype._end=function(){var n=this,r=this.xhr=f.getXHR(),e=this._formData||this._data;this._setTimeouts(),r.onreadystatechange=function(){var e=r.readyState;if(2<=e&&n._responseTimeoutTimer&&clearTimeout(n._responseTimeoutTimer),4==e){var t;try{t=r.status;}catch(e){t=0;}if(!t){if(n.timedout||n._aborted)return;return n.crossDomainError()}n.emit("end");}};function t(e,t){0<t.total&&(t.percent=t.loaded/t.total*100),t.direction=e,n.emit("progress",t);}if(this.hasListeners("progress"))try{r.onprogress=t.bind(null,"download"),r.upload&&(r.upload.onprogress=t.bind(null,"upload"));}catch(e){}try{this.username&&this.password?r.open(this.method,this.url,!0,this.username,this.password):r.open(this.method,this.url,!0);}catch(e){return this.callback(e)}if(this._withCredentials&&(r.withCredentials=!0),!this._formData&&"GET"!=this.method&&"HEAD"!=this.method&&"string"!=typeof e&&!this._isHost(e)){var i=this._header["content-type"],o=this._serializer||f.serialize[i?i.split(";")[0]:""];!o&&g(i)&&(o=f.serialize["application/json"]),o&&(e=o(e));}for(var s in this.header)null!=this.header[s]&&this.header.hasOwnProperty(s)&&r.setRequestHeader(s,this.header[s]);return this._responseType&&(r.responseType=this._responseType),this.emit("request",this),r.send(void 0!==e?e:null),this},f.agent=function(){return new u},["GET","POST","OPTIONS","PATCH","PUT","DELETE"].forEach(function(r){u.prototype[r.toLowerCase()]=function(e,t){var n=new f.Request(r,e);return this._setDefaults(n),t&&n.end(t),n};}),u.prototype.del=u.prototype.delete,f.get=function(e,t,n){var r=f("GET",e);return "function"==typeof t&&(n=t,t=null),t&&r.query(t),n&&r.end(n),r},f.head=function(e,t,n){var r=f("HEAD",e);return "function"==typeof t&&(n=t,t=null),t&&r.query(t),n&&r.end(n),r},f.options=function(e,t,n){var r=f("OPTIONS",e);return "function"==typeof t&&(n=t,t=null),t&&r.send(t),n&&r.end(n),r},f.del=b,f.delete=b,f.patch=function(e,t,n){var r=f("PATCH",e);return "function"==typeof t&&(n=t,t=null),t&&r.send(t),n&&r.end(n),r},f.post=function(e,t,n){var r=f("POST",e);return "function"==typeof t&&(n=t,t=null),t&&r.send(t),n&&r.end(n),r},f.put=function(e,t,n){var r=f("PUT",e);return "function"==typeof t&&(n=t,t=null),t&&r.send(t),n&&r.end(n),r};},function(e,t,n){function r(e){if(e)return function(e){for(var t in r.prototype)e[t]=r.prototype[t];return e}(e)}(e.exports=r).prototype.on=r.prototype.addEventListener=function(e,t){return this._callbacks=this._callbacks||{},(this._callbacks["$"+e]=this._callbacks["$"+e]||[]).push(t),this},r.prototype.once=function(e,t){function n(){this.off(e,n),t.apply(this,arguments);}return n.fn=t,this.on(e,n),this},r.prototype.off=r.prototype.removeListener=r.prototype.removeAllListeners=r.prototype.removeEventListener=function(e,t){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var n,r=this._callbacks["$"+e];if(!r)return this;if(1==arguments.length)return delete this._callbacks["$"+e],this;for(var i=0;i<r.length;i++)if((n=r[i])===t||n.fn===t){r.splice(i,1);break}return 0===r.length&&delete this._callbacks["$"+e],this},r.prototype.emit=function(e){this._callbacks=this._callbacks||{};for(var t=new Array(arguments.length-1),n=this._callbacks["$"+e],r=1;r<arguments.length;r++)t[r-1]=arguments[r];if(n){r=0;for(var i=(n=n.slice(0)).length;r<i;++r)n[r].apply(this,t);}return this},r.prototype.listeners=function(e){return this._callbacks=this._callbacks||{},this._callbacks["$"+e]||[]},r.prototype.hasListeners=function(e){return !!this.listeners(e).length};},function(e,t,n){var i=n(10);function r(e){if(e)return function(e){for(var t in r.prototype)e[t]=r.prototype[t];return e}(e)}(e.exports=r).prototype.clearTimeout=function(){return clearTimeout(this._timer),clearTimeout(this._responseTimeoutTimer),delete this._timer,delete this._responseTimeoutTimer,this},r.prototype.parse=function(e){return this._parser=e,this},r.prototype.responseType=function(e){return this._responseType=e,this},r.prototype.serialize=function(e){return this._serializer=e,this},r.prototype.timeout=function(e){if(!e||"object"!=typeof e)return this._timeout=e,this._responseTimeout=0,this;for(var t in e)switch(t){case"deadline":this._timeout=e.deadline;break;case"response":this._responseTimeout=e.response;break;default:console.warn("Unknown timeout option",t);}return this},r.prototype.retry=function(e,t){return 0!==arguments.length&&!0!==e||(e=1),e<=0&&(e=0),this._maxRetries=e,this._retries=0,this._retryCallback=t,this};var o=["ECONNRESET","ETIMEDOUT","EADDRINFO","ESOCKETTIMEDOUT"];r.prototype._shouldRetry=function(e,t){if(!this._maxRetries||this._retries++>=this._maxRetries)return !1;if(this._retryCallback)try{var n=this._retryCallback(e,t);if(!0===n)return !0;if(!1===n)return !1}catch(e){console.error(e);}if(t&&t.status&&500<=t.status&&501!=t.status)return !0;if(e){if(e.code&&~o.indexOf(e.code))return !0;if(e.timeout&&"ECONNABORTED"==e.code)return !0;if(e.crossDomain)return !0}return !1},r.prototype._retry=function(){return this.clearTimeout(),this.req&&(this.req=null,this.req=this.request()),this._aborted=!1,this.timedout=!1,this._end()},r.prototype.then=function(e,t){if(!this._fullfilledPromise){var i=this;this._endCalled&&console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises"),this._fullfilledPromise=new Promise(function(n,r){i.end(function(e,t){e?r(e):n(t);});});}return this._fullfilledPromise.then(e,t)},r.prototype.catch=function(e){return this.then(void 0,e)},r.prototype.use=function(e){return e(this),this},r.prototype.ok=function(e){if("function"!=typeof e)throw Error("Callback required");return this._okCallback=e,this},r.prototype._isResponseOK=function(e){return !!e&&(this._okCallback?this._okCallback(e):200<=e.status&&e.status<300)},r.prototype.getHeader=r.prototype.get=function(e){return this._header[e.toLowerCase()]},r.prototype.set=function(e,t){if(i(e)){for(var n in e)this.set(n,e[n]);return this}return this._header[e.toLowerCase()]=t,this.header[e]=t,this},r.prototype.unset=function(e){return delete this._header[e.toLowerCase()],delete this.header[e],this},r.prototype.field=function(e,t){if(null==e)throw new Error(".field(name, val) name can not be empty");if(this._data&&console.error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()"),i(e)){for(var n in e)this.field(n,e[n]);return this}if(Array.isArray(t)){for(var r in t)this.field(e,t[r]);return this}if(null==t)throw new Error(".field(name, val) val can not be empty");return "boolean"==typeof t&&(t=""+t),this._getFormData().append(e,t),this},r.prototype.abort=function(){return this._aborted||(this._aborted=!0,this.xhr&&this.xhr.abort(),this.req&&this.req.abort(),this.clearTimeout(),this.emit("abort")),this},r.prototype._auth=function(e,t,n,r){switch(n.type){case"basic":this.set("Authorization","Basic "+r(e+":"+t));break;case"auto":this.username=e,this.password=t;break;case"bearer":this.set("Authorization","Bearer "+e);}return this},r.prototype.withCredentials=function(e){return null==e&&(e=!0),this._withCredentials=e,this},r.prototype.redirects=function(e){return this._maxRedirects=e,this},r.prototype.maxResponseSize=function(e){if("number"!=typeof e)throw TypeError("Invalid argument");return this._maxResponseSize=e,this},r.prototype.toJSON=function(){return {method:this.method,url:this.url,data:this._data,headers:this._header}},r.prototype.send=function(e){var t=i(e),n=this._header["content-type"];if(this._formData&&console.error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()"),t&&!this._data)Array.isArray(e)?this._data=[]:this._isHost(e)||(this._data={});else if(e&&this._data&&this._isHost(this._data))throw Error("Can't merge these send calls");if(t&&i(this._data))for(var r in e)this._data[r]=e[r];else"string"==typeof e?(n||this.type("form"),n=this._header["content-type"],this._data="application/x-www-form-urlencoded"==n?this._data?this._data+"&"+e:e:(this._data||"")+e):this._data=e;return !t||this._isHost(e)||n||this.type("json"),this},r.prototype.sortQuery=function(e){return this._sort=void 0===e||e,this},r.prototype._finalizeQueryString=function(){var e=this._query.join("&");if(e&&(this.url+=(0<=this.url.indexOf("?")?"&":"?")+e),this._query.length=0,this._sort){var t=this.url.indexOf("?");if(0<=t){var n=this.url.substring(t+1).split("&");"function"==typeof this._sort?n.sort(this._sort):n.sort(),this.url=this.url.substring(0,t)+"?"+n.join("&");}}},r.prototype._appendQueryString=function(){console.trace("Unsupported");},r.prototype._timeoutError=function(e,t,n){if(!this._aborted){var r=new Error(e+t+"ms exceeded");r.timeout=t,r.code="ECONNABORTED",r.errno=n,this.timedout=!0,this.abort(),this.callback(r);}},r.prototype._setTimeouts=function(){var e=this;this._timeout&&!this._timer&&(this._timer=setTimeout(function(){e._timeoutError("Timeout of ",e._timeout,"ETIME");},this._timeout)),this._responseTimeout&&!this._responseTimeoutTimer&&(this._responseTimeoutTimer=setTimeout(function(){e._timeoutError("Response timeout of ",e._responseTimeout,"ETIMEDOUT");},this._responseTimeout));};},function(e,t,n){var i=n(80);function r(e){if(e)return function(e){for(var t in r.prototype)e[t]=r.prototype[t];return e}(e)}(e.exports=r).prototype.get=function(e){return this.header[e.toLowerCase()]},r.prototype._setHeaderProperties=function(e){var t=e["content-type"]||"";this.type=i.type(t);var n=i.params(t);for(var r in n)this[r]=n[r];this.links={};try{e.link&&(this.links=i.parseLinks(e.link));}catch(e){}},r.prototype._setStatusProperties=function(e){var t=e/100|0;this.status=this.statusCode=e,this.statusType=t,this.info=1==t,this.ok=2==t,this.redirect=3==t,this.clientError=4==t,this.serverError=5==t,this.error=(4==t||5==t)&&this.toError(),this.created=201==e,this.accepted=202==e,this.noContent=204==e,this.badRequest=400==e,this.unauthorized=401==e,this.notAcceptable=406==e,this.forbidden=403==e,this.notFound=404==e,this.unprocessableEntity=422==e;};},function(e,t,n){t.type=function(e){return e.split(/ *; */).shift()},t.params=function(e){return e.split(/ *; */).reduce(function(e,t){var n=t.split(/ *= */),r=n.shift(),i=n.shift();return r&&i&&(e[r]=i),e},{})},t.parseLinks=function(e){return e.split(/ *, */).reduce(function(e,t){var n=t.split(/ *; */),r=n[0].slice(1,-1);return e[n[1].split(/ *= */)[1].slice(1,-1)]=r,e},{})},t.cleanHeader=function(e,t){return delete e["content-type"],delete e["content-length"],delete e["transfer-encoding"],delete e.host,t&&(delete e.authorization,delete e.cookie),e};},function(e,t){function n(){this._defaults=[];}["use","on","once","set","query","type","accept","auth","withCredentials","sortQuery","retry","ok","redirects","timeout","buffer","serialize","parse","ca","key","pfx","cert"].forEach(function(e){n.prototype[e]=function(){return this._defaults.push({fn:e,arguments:arguments}),this};}),n.prototype._setDefaults=function(t){this._defaults.forEach(function(e){t[e.fn].apply(t,e.arguments);});},e.exports=n;}],i.c=r,i.d=function(e,t,n){i.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n});},i.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0});},i.t=function(t,e){if(1&e&&(t=i(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(i.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var r in t)i.d(n,r,function(e){return t[e]}.bind(null,r));return n},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="",i(i.s=11);function i(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,i),t.l=!0,t.exports}var n,r;});
    });

    var PubNub = unwrapExports(pubnub_min);
    var pubnub_min_1 = pubnub_min.PubNub;

    const pubnub = new PubNub({
      subscribeKey: 'sub-c-c4482926-7984-11ea-9770-0a12e0cf0d6e',
      publishKey: 'pub-c-766f0388-8e3c-4b8a-952e-9679734077e8',
      ssl: true,
    });

    // message: function (m) {
    //     const channelName = m.channel;
    //     let channelGroup = m.subscription;
    //     let pubTT = m.timetoken;
    //     let msg = m.message;
    //     console.log(msg);
    //     const publisher = m.publisher;
    //   },
    //   messageAction: function (ma) {
    //     let channelName = ma.channel;
    //     let publisher = ma.publisher;
    //     let event = ma.message.event;
    //     let type = ma.message.data.type;
    //     let value = ma.message.data.value;
    //     let messageTimetoken = ma.message.data.messageTimetoken;
    //     let actionTimetoken = ma.message.data.actionTimetoken;
    //   },
    //   presence: function (p) {
    //     console.log(p);
    //     let action = p.action;
    //     let channelName = p.channel;
    //     let occupancy = p.occupancy;
    //     let state = p.state;
    //     let channelGroup = p.subscription;
    //     let publishTime = p.timestamp;
    //     let timetoken = p.timetoken;
    //     let uuid = p.uuid;
    //   },
    //   signal: function (s) {
    //     let channelName = s.channel;
    //     let channelGroup = s.subscription;
    //     let pubTT = s.timetoken;
    //     let msg = s.message;
    //     let publisher = s.publisher;
    //   },

    const subscribe$3 = (email) => {
      pubnub.subscribe({
        channels: [`channel.${email}`],
        withPresence: true,
      });
    };
    const wildcardsubscription = () => {
      pubnub.subscribe({
        channels: ['channel.*'],
        withPresence: true,
      });
    };
    const grantPermissions = async (users) => {
      if (users.flag === 'A') {
        const message = await axios$1({
          method: 'post',
          url: 'http://localhost:3000/pubnubadmin',
          data: {
            id: users.email,
            ttl: users.ttl,
          },
        });
        console.log(message);
        pubnub.setAuthKey(users.email);
        pubnub.setUUID(users.email);
        wildcardsubscription();
      } else {
        const message = await axios$1({
          method: 'post',
          url: 'http://localhost:3000/pubnubuser',
          data: {
            id: users.email,
            ttl: users.ttl,
          },
        });
        console.log(message);
        pubnub.setAuthKey(users.email);
        pubnub.setUUID(users.email);
        subscribe$3(users.email);
      }
    };
    const publish = async (newMessage, channelName) => {
      try {
        await pubnub.publish({
          message: newMessage,
          channel: channelName,
          sendByPost: false,
          storeInHistory: false,
          meta: {
            cool: 'meta',
          },
        });
        return `publish message to the channel ${channelName}`;
      } catch (e) {
        throw new Error(e);
      }
    };

    /* src/Modals/userModal.svelte generated by Svelte v3.18.1 */
    const file$4 = "src/Modals/userModal.svelte";

    function create_fragment$6(ctx) {
    	let div11;
    	let div0;
    	let p;
    	let t1;
    	let form;
    	let div3;
    	let div1;
    	let label0;
    	let t3;
    	let div2;
    	let input0;
    	let t4;
    	let div6;
    	let div4;
    	let label1;
    	let t6;
    	let div5;
    	let input1;
    	let t7;
    	let div9;
    	let div7;
    	let label2;
    	let t9;
    	let div8;
    	let input2;
    	let t10;
    	let div10;
    	let button;
    	let dispose;

    	const block = {
    		c: function create() {
    			div11 = element("div");
    			div0 = element("div");
    			p = element("p");
    			p.textContent = "User Details";
    			t1 = space();
    			form = element("form");
    			div3 = element("div");
    			div1 = element("div");
    			label0 = element("label");
    			label0.textContent = "Name";
    			t3 = space();
    			div2 = element("div");
    			input0 = element("input");
    			t4 = space();
    			div6 = element("div");
    			div4 = element("div");
    			label1 = element("label");
    			label1.textContent = "College Name";
    			t6 = space();
    			div5 = element("div");
    			input1 = element("input");
    			t7 = space();
    			div9 = element("div");
    			div7 = element("div");
    			label2 = element("label");
    			label2.textContent = "E-mail";
    			t9 = space();
    			div8 = element("div");
    			input2 = element("input");
    			t10 = space();
    			div10 = element("div");
    			button = element("button");
    			button.textContent = "Submit";
    			attr_dev(p, "class", "text-2xl font-bold");
    			add_location(p, file$4, 38, 4, 1122);
    			attr_dev(div0, "class", "flex justify-between items-center pb-3");
    			add_location(div0, file$4, 37, 2, 1065);
    			attr_dev(label0, "class", "block text-gray-500 font-bold md:text-right mb-1 md:mb-0 pr-4");
    			attr_dev(label0, "for", "inline-full-name");
    			add_location(label0, file$4, 43, 8, 1295);
    			attr_dev(div1, "class", "md:w-1/3");
    			add_location(div1, file$4, 42, 6, 1264);
    			attr_dev(input0, "class", "bg-gray-200 appearance-none border-2 border-gray-200 rounded\n          w-full py-2 px-4 text-gray-700 leading-tight focus:outline-none\n          focus:bg-white focus:border-purple-500");
    			attr_dev(input0, "id", "inline-full-name");
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "placeholder", "Name");
    			input0.required = true;
    			add_location(input0, file$4, 50, 8, 1498);
    			attr_dev(div2, "class", "md:w-2/3");
    			add_location(div2, file$4, 49, 6, 1467);
    			attr_dev(div3, "class", "md:flex md:items-center mb-6");
    			add_location(div3, file$4, 41, 4, 1215);
    			attr_dev(label1, "class", "block text-gray-500 font-bold md:text-right mb-1 md:mb-0 pr-4");
    			attr_dev(label1, "for", "inline-username");
    			add_location(label1, file$4, 63, 8, 1953);
    			attr_dev(div4, "class", "md:w-1/3");
    			add_location(div4, file$4, 62, 6, 1922);
    			attr_dev(input1, "class", "bg-gray-200 appearance-none border-2 border-gray-200 rounded\n          w-full py-2 px-4 text-gray-700 leading-tight focus:outline-none\n          focus:bg-white focus:border-purple-500");
    			attr_dev(input1, "id", "inline-username");
    			attr_dev(input1, "type", "text-area");
    			attr_dev(input1, "placeholder", "College Name");
    			input1.required = true;
    			add_location(input1, file$4, 70, 8, 2163);
    			attr_dev(div5, "class", "md:w-2/3");
    			add_location(div5, file$4, 69, 6, 2132);
    			attr_dev(div6, "class", "md:flex md:items-center mb-6");
    			add_location(div6, file$4, 61, 4, 1873);
    			attr_dev(label2, "class", "block text-gray-500 font-bold md:text-right mb-1 md:mb-0 pr-4");
    			attr_dev(label2, "for", "inline-username");
    			add_location(label2, file$4, 83, 8, 2637);
    			attr_dev(div7, "class", "md:w-1/3");
    			add_location(div7, file$4, 82, 6, 2606);
    			attr_dev(input2, "class", "bg-gray-200 appearance-none border-2 border-gray-200 rounded\n          w-full py-2 px-4 text-gray-700 leading-tight focus:outline-none\n          focus:bg-white focus:border-purple-500");
    			attr_dev(input2, "id", "inline-username");
    			attr_dev(input2, "type", "text-area");
    			attr_dev(input2, "placeholder", "E-mail");
    			input2.required = true;
    			add_location(input2, file$4, 90, 8, 2841);
    			attr_dev(div8, "class", "md:w-2/3");
    			add_location(div8, file$4, 89, 6, 2810);
    			attr_dev(div9, "class", "md:flex md:items-center mb-6");
    			add_location(div9, file$4, 81, 4, 2557);
    			attr_dev(form, "class", "w-full max-w-md");
    			add_location(form, file$4, 40, 2, 1180);
    			attr_dev(button, "class", "px-4 bg-transparent p-3 rounded-lg text-indigo-500\n      hover:bg-gray-100 hover:text-indigo-400 mr-2");
    			add_location(button, file$4, 103, 4, 3271);
    			attr_dev(div10, "class", "flex justify-end pt-2");
    			add_location(div10, file$4, 102, 2, 3231);
    			add_location(div11, file$4, 36, 0, 1057);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div11, anchor);
    			append_dev(div11, div0);
    			append_dev(div0, p);
    			append_dev(div11, t1);
    			append_dev(div11, form);
    			append_dev(form, div3);
    			append_dev(div3, div1);
    			append_dev(div1, label0);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			append_dev(div2, input0);
    			set_input_value(input0, /*user*/ ctx[0].name);
    			append_dev(form, t4);
    			append_dev(form, div6);
    			append_dev(div6, div4);
    			append_dev(div4, label1);
    			append_dev(div6, t6);
    			append_dev(div6, div5);
    			append_dev(div5, input1);
    			set_input_value(input1, /*user*/ ctx[0].collegeName);
    			append_dev(form, t7);
    			append_dev(form, div9);
    			append_dev(div9, div7);
    			append_dev(div7, label2);
    			append_dev(div9, t9);
    			append_dev(div9, div8);
    			append_dev(div8, input2);
    			set_input_value(input2, /*user*/ ctx[0].email);
    			append_dev(div11, t10);
    			append_dev(div11, div10);
    			append_dev(div10, button);

    			dispose = [
    				listen_dev(input0, "input", /*input0_input_handler*/ ctx[4]),
    				listen_dev(input1, "input", /*input1_input_handler*/ ctx[5]),
    				listen_dev(input2, "input", /*input2_input_handler*/ ctx[6]),
    				listen_dev(button, "click", /*clickHandler*/ ctx[1], false, false, false)
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*user*/ 1 && input0.value !== /*user*/ ctx[0].name) {
    				set_input_value(input0, /*user*/ ctx[0].name);
    			}

    			if (dirty & /*user*/ 1) {
    				set_input_value(input1, /*user*/ ctx[0].collegeName);
    			}

    			if (dirty & /*user*/ 1) {
    				set_input_value(input2, /*user*/ ctx[0].email);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div11);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	const { close } = getContext("simple-modal");
    	let user = { name: "", email: "", collegeName: "" };
    	const client = getClient();

    	async function clickHandler() {
    		if (user.name === "" || user.email === "" || user.collegeName === "") {
    			return;
    		}

    		console.log(user);

    		try {
    			const res = await mutate(client, {
    				mutation: apolloClient.addUser,
    				variables: user
    			});

    			console.log(res);
    			cookieHandler.setCookie("user_id", res.data.addUser.user.id);
    			cookieHandler.setCookie("access_email", user.email);
    		} catch(err) {
    			console.log(err);
    		}

    		cookieHandler.setCookie("loggedIn", "true", 1);
    		close();
    	}

    	function input0_input_handler() {
    		user.name = this.value;
    		$$invalidate(0, user);
    	}

    	function input1_input_handler() {
    		user.collegeName = this.value;
    		$$invalidate(0, user);
    	}

    	function input2_input_handler() {
    		user.email = this.value;
    		$$invalidate(0, user);
    	}

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("user" in $$props) $$invalidate(0, user = $$props.user);
    	};

    	return [
    		user,
    		clickHandler,
    		close,
    		client,
    		input0_input_handler,
    		input1_input_handler,
    		input2_input_handler
    	];
    }

    class UserModal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "UserModal",
    			options,
    			id: create_fragment$6.name
    		});
    	}
    }

    /* src/Modals/userHelper.svelte generated by Svelte v3.18.1 */

    function create_fragment$7(ctx) {
    	const block = {
    		c: noop,
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self) {
    	const { open } = getContext("simple-modal");

    	const showSurprise = () => {
    		open(UserModal, {}, {
    			closeOnEsc: false,
    			closeOnOuterClick: false,
    			closeButton: false
    		});
    	};

    	showSurprise();

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		
    	};

    	return [];
    }

    class UserHelper extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "UserHelper",
    			options,
    			id: create_fragment$7.name
    		});
    	}
    }

    function fade(node, { delay = 0, duration = 400, easing = identity }) {
        const o = +getComputedStyle(node).opacity;
        return {
            delay,
            duration,
            easing,
            css: t => `opacity: ${t * o}`
        };
    }

    /* node_modules/svelte-simple-modal/src/Modal.svelte generated by Svelte v3.18.1 */

    const { Object: Object_1 } = globals;
    const file$5 = "node_modules/svelte-simple-modal/src/Modal.svelte";

    // (201:2) {#if Component}
    function create_if_block$1(ctx) {
    	let div3;
    	let div2;
    	let div1;
    	let t;
    	let div0;
    	let div1_transition;
    	let div3_transition;
    	let current;
    	let dispose;
    	let if_block = /*state*/ ctx[0].closeButton && create_if_block_1$1(ctx);
    	const component_spread_levels = [/*props*/ ctx[2]];
    	let component_props = {};

    	for (let i = 0; i < component_spread_levels.length; i += 1) {
    		component_props = assign(component_props, component_spread_levels[i]);
    	}

    	const component = new /*Component*/ ctx[1]({ props: component_props, $$inline: true });

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			div0 = element("div");
    			create_component(component.$$.fragment);
    			attr_dev(div0, "class", "content svelte-12ra95k");
    			attr_dev(div0, "style", /*cssContent*/ ctx[7]);
    			add_location(div0, file$5, 217, 10, 9065);
    			attr_dev(div1, "class", "window svelte-12ra95k");
    			attr_dev(div1, "style", /*cssWindow*/ ctx[6]);
    			add_location(div1, file$5, 209, 8, 8801);
    			attr_dev(div2, "class", "window-wrap svelte-12ra95k");
    			add_location(div2, file$5, 208, 6, 8750);
    			attr_dev(div3, "class", "bg svelte-12ra95k");
    			attr_dev(div3, "style", /*cssBg*/ ctx[5]);
    			add_location(div3, file$5, 201, 4, 8570);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			if (if_block) if_block.m(div1, null);
    			append_dev(div1, t);
    			append_dev(div1, div0);
    			mount_component(component, div0, null);
    			/*div2_binding*/ ctx[31](div2);
    			/*div3_binding*/ ctx[32](div3);
    			current = true;
    			dispose = listen_dev(div3, "click", /*handleOuterClick*/ ctx[12], false, false, false);
    		},
    		p: function update(ctx, dirty) {
    			if (/*state*/ ctx[0].closeButton) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$1(ctx);
    					if_block.c();
    					if_block.m(div1, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			const component_changes = (dirty[0] & /*props*/ 4)
    			? get_spread_update(component_spread_levels, [get_spread_object(/*props*/ ctx[2])])
    			: {};

    			component.$set(component_changes);

    			if (!current || dirty[0] & /*cssContent*/ 128) {
    				attr_dev(div0, "style", /*cssContent*/ ctx[7]);
    			}

    			if (!current || dirty[0] & /*cssWindow*/ 64) {
    				attr_dev(div1, "style", /*cssWindow*/ ctx[6]);
    			}

    			if (!current || dirty[0] & /*cssBg*/ 32) {
    				attr_dev(div3, "style", /*cssBg*/ ctx[5]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(component.$$.fragment, local);

    			add_render_callback(() => {
    				if (!div1_transition) div1_transition = create_bidirectional_transition(div1, /*currentTransitionWindow*/ ctx[9], /*state*/ ctx[0].transitionWindowProps, true);
    				div1_transition.run(1);
    			});

    			add_render_callback(() => {
    				if (!div3_transition) div3_transition = create_bidirectional_transition(div3, /*currentTransitionBg*/ ctx[8], /*state*/ ctx[0].transitionBgProps, true);
    				div3_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(component.$$.fragment, local);
    			if (!div1_transition) div1_transition = create_bidirectional_transition(div1, /*currentTransitionWindow*/ ctx[9], /*state*/ ctx[0].transitionWindowProps, false);
    			div1_transition.run(0);
    			if (!div3_transition) div3_transition = create_bidirectional_transition(div3, /*currentTransitionBg*/ ctx[8], /*state*/ ctx[0].transitionBgProps, false);
    			div3_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (if_block) if_block.d();
    			destroy_component(component);
    			if (detaching && div1_transition) div1_transition.end();
    			/*div2_binding*/ ctx[31](null);
    			/*div3_binding*/ ctx[32](null);
    			if (detaching && div3_transition) div3_transition.end();
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(201:2) {#if Component}",
    		ctx
    	});

    	return block;
    }

    // (215:10) {#if state.closeButton}
    function create_if_block_1$1(ctx) {
    	let button;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			attr_dev(button, "class", "close svelte-12ra95k");
    			add_location(button, file$5, 215, 12, 8990);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			dispose = listen_dev(button, "click", /*close*/ ctx[10], false, false, false);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(215:10) {#if state.closeButton}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let div;
    	let t;
    	let current;
    	let dispose;
    	let if_block = /*Component*/ ctx[1] && create_if_block$1(ctx);
    	const default_slot_template = /*$$slots*/ ctx[30].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[29], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "svelte-12ra95k");
    			add_location(div, file$5, 199, 0, 8542);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    			dispose = listen_dev(window, "keyup", /*handleKeyup*/ ctx[11], false, false, false);
    		},
    		p: function update(ctx, dirty) {
    			if (/*Component*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$1(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (default_slot && default_slot.p && dirty[0] & /*$$scope*/ 536870912) {
    				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[29], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[29], dirty, null));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			if (default_slot) default_slot.d(detaching);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let { key = "simple-modal" } = $$props;
    	let { closeButton = true } = $$props;
    	let { closeOnEsc = true } = $$props;
    	let { closeOnOuterClick = true } = $$props;
    	let { styleBg = { top: 0, left: 0 } } = $$props;
    	let { styleWindow = {} } = $$props;
    	let { styleContent = {} } = $$props;
    	let { setContext: setContext$1 = setContext } = $$props;
    	let { transitionBg = fade } = $$props;
    	let { transitionBgProps = { duration: 250 } } = $$props;
    	let { transitionWindow = transitionBg } = $$props;
    	let { transitionWindowProps = transitionBgProps } = $$props;

    	const defaultState = {
    		closeButton,
    		closeOnEsc,
    		closeOnOuterClick,
    		styleBg,
    		styleWindow,
    		styleContent,
    		transitionBg,
    		transitionBgProps,
    		transitionWindow,
    		transitionWindowProps
    	};

    	let state = { ...defaultState };
    	let Component = null;
    	let props = null;
    	let background;
    	let wrap;
    	const camelCaseToDash = str => str.replace(/([a-zA-Z])(?=[A-Z])/g, "$1-").toLowerCase();
    	const toCssString = props => Object.keys(props).reduce((str, key) => `${str}; ${camelCaseToDash(key)}: ${props[key]}`, "");

    	const open = (NewComponent, newProps = {}, options = {}) => {
    		$$invalidate(1, Component = NewComponent);
    		$$invalidate(2, props = newProps);
    		$$invalidate(0, state = { ...defaultState, ...options });
    	};

    	const close = () => {
    		$$invalidate(1, Component = null);
    		$$invalidate(2, props = null);
    	};

    	const handleKeyup = ({ key }) => {
    		if (state.closeOnEsc && Component && key === "Escape") {
    			event.preventDefault();
    			close();
    		}
    	};

    	const handleOuterClick = event => {
    		if (state.closeOnOuterClick && (event.target === background || event.target === wrap)) {
    			event.preventDefault();
    			close();
    		}
    	};

    	setContext$1(key, { open, close });

    	const writable_props = [
    		"key",
    		"closeButton",
    		"closeOnEsc",
    		"closeOnOuterClick",
    		"styleBg",
    		"styleWindow",
    		"styleContent",
    		"setContext",
    		"transitionBg",
    		"transitionBgProps",
    		"transitionWindow",
    		"transitionWindowProps"
    	];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Modal> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(4, wrap = $$value);
    		});
    	}

    	function div3_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(3, background = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ("key" in $$props) $$invalidate(13, key = $$props.key);
    		if ("closeButton" in $$props) $$invalidate(14, closeButton = $$props.closeButton);
    		if ("closeOnEsc" in $$props) $$invalidate(15, closeOnEsc = $$props.closeOnEsc);
    		if ("closeOnOuterClick" in $$props) $$invalidate(16, closeOnOuterClick = $$props.closeOnOuterClick);
    		if ("styleBg" in $$props) $$invalidate(17, styleBg = $$props.styleBg);
    		if ("styleWindow" in $$props) $$invalidate(18, styleWindow = $$props.styleWindow);
    		if ("styleContent" in $$props) $$invalidate(19, styleContent = $$props.styleContent);
    		if ("setContext" in $$props) $$invalidate(20, setContext$1 = $$props.setContext);
    		if ("transitionBg" in $$props) $$invalidate(21, transitionBg = $$props.transitionBg);
    		if ("transitionBgProps" in $$props) $$invalidate(22, transitionBgProps = $$props.transitionBgProps);
    		if ("transitionWindow" in $$props) $$invalidate(23, transitionWindow = $$props.transitionWindow);
    		if ("transitionWindowProps" in $$props) $$invalidate(24, transitionWindowProps = $$props.transitionWindowProps);
    		if ("$$scope" in $$props) $$invalidate(29, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => {
    		return {
    			key,
    			closeButton,
    			closeOnEsc,
    			closeOnOuterClick,
    			styleBg,
    			styleWindow,
    			styleContent,
    			setContext: setContext$1,
    			transitionBg,
    			transitionBgProps,
    			transitionWindow,
    			transitionWindowProps,
    			state,
    			Component,
    			props,
    			background,
    			wrap,
    			cssBg,
    			cssWindow,
    			cssContent,
    			currentTransitionBg,
    			currentTransitionWindow
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("key" in $$props) $$invalidate(13, key = $$props.key);
    		if ("closeButton" in $$props) $$invalidate(14, closeButton = $$props.closeButton);
    		if ("closeOnEsc" in $$props) $$invalidate(15, closeOnEsc = $$props.closeOnEsc);
    		if ("closeOnOuterClick" in $$props) $$invalidate(16, closeOnOuterClick = $$props.closeOnOuterClick);
    		if ("styleBg" in $$props) $$invalidate(17, styleBg = $$props.styleBg);
    		if ("styleWindow" in $$props) $$invalidate(18, styleWindow = $$props.styleWindow);
    		if ("styleContent" in $$props) $$invalidate(19, styleContent = $$props.styleContent);
    		if ("setContext" in $$props) $$invalidate(20, setContext$1 = $$props.setContext);
    		if ("transitionBg" in $$props) $$invalidate(21, transitionBg = $$props.transitionBg);
    		if ("transitionBgProps" in $$props) $$invalidate(22, transitionBgProps = $$props.transitionBgProps);
    		if ("transitionWindow" in $$props) $$invalidate(23, transitionWindow = $$props.transitionWindow);
    		if ("transitionWindowProps" in $$props) $$invalidate(24, transitionWindowProps = $$props.transitionWindowProps);
    		if ("state" in $$props) $$invalidate(0, state = $$props.state);
    		if ("Component" in $$props) $$invalidate(1, Component = $$props.Component);
    		if ("props" in $$props) $$invalidate(2, props = $$props.props);
    		if ("background" in $$props) $$invalidate(3, background = $$props.background);
    		if ("wrap" in $$props) $$invalidate(4, wrap = $$props.wrap);
    		if ("cssBg" in $$props) $$invalidate(5, cssBg = $$props.cssBg);
    		if ("cssWindow" in $$props) $$invalidate(6, cssWindow = $$props.cssWindow);
    		if ("cssContent" in $$props) $$invalidate(7, cssContent = $$props.cssContent);
    		if ("currentTransitionBg" in $$props) $$invalidate(8, currentTransitionBg = $$props.currentTransitionBg);
    		if ("currentTransitionWindow" in $$props) $$invalidate(9, currentTransitionWindow = $$props.currentTransitionWindow);
    	};

    	let cssBg;
    	let cssWindow;
    	let cssContent;
    	let currentTransitionBg;
    	let currentTransitionWindow;

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*state*/ 1) {
    			 $$invalidate(5, cssBg = toCssString(state.styleBg));
    		}

    		if ($$self.$$.dirty[0] & /*state*/ 1) {
    			 $$invalidate(6, cssWindow = toCssString(state.styleWindow));
    		}

    		if ($$self.$$.dirty[0] & /*state*/ 1) {
    			 $$invalidate(7, cssContent = toCssString(state.styleContent));
    		}

    		if ($$self.$$.dirty[0] & /*state*/ 1) {
    			 $$invalidate(8, currentTransitionBg = state.transitionBg);
    		}

    		if ($$self.$$.dirty[0] & /*state*/ 1) {
    			 $$invalidate(9, currentTransitionWindow = state.transitionWindow);
    		}
    	};

    	return [
    		state,
    		Component,
    		props,
    		background,
    		wrap,
    		cssBg,
    		cssWindow,
    		cssContent,
    		currentTransitionBg,
    		currentTransitionWindow,
    		close,
    		handleKeyup,
    		handleOuterClick,
    		key,
    		closeButton,
    		closeOnEsc,
    		closeOnOuterClick,
    		styleBg,
    		styleWindow,
    		styleContent,
    		setContext$1,
    		transitionBg,
    		transitionBgProps,
    		transitionWindow,
    		transitionWindowProps,
    		defaultState,
    		camelCaseToDash,
    		toCssString,
    		open,
    		$$scope,
    		$$slots,
    		div2_binding,
    		div3_binding
    	];
    }

    class Modal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$8,
    			create_fragment$8,
    			safe_not_equal,
    			{
    				key: 13,
    				closeButton: 14,
    				closeOnEsc: 15,
    				closeOnOuterClick: 16,
    				styleBg: 17,
    				styleWindow: 18,
    				styleContent: 19,
    				setContext: 20,
    				transitionBg: 21,
    				transitionBgProps: 22,
    				transitionWindow: 23,
    				transitionWindowProps: 24
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Modal",
    			options,
    			id: create_fragment$8.name
    		});
    	}

    	get key() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set key(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get closeButton() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set closeButton(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get closeOnEsc() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set closeOnEsc(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get closeOnOuterClick() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set closeOnOuterClick(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get styleBg() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set styleBg(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get styleWindow() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set styleWindow(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get styleContent() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set styleContent(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setContext() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set setContext(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transitionBg() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transitionBg(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transitionBgProps() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transitionBgProps(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transitionWindow() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transitionWindow(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transitionWindowProps() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transitionWindowProps(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/timer.svelte generated by Svelte v3.18.1 */

    const { console: console_1 } = globals;
    const file$6 = "src/components/timer.svelte";

    function create_fragment$9(ctx) {
    	let div6;
    	let div1;
    	let span0;
    	let t0_value = /*timer*/ ctx[0].hour + "";
    	let t0;
    	let t1;
    	let div0;
    	let t3;
    	let div3;
    	let span1;
    	let t4_value = /*timer*/ ctx[0].minute + "";
    	let t4;
    	let t5;
    	let div2;
    	let t7;
    	let div5;
    	let span2;
    	let t8_value = /*timer*/ ctx[0].second + "";
    	let t8;
    	let t9;
    	let div4;

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			div1 = element("div");
    			span0 = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			div0 = element("div");
    			div0.textContent = "Hours";
    			t3 = space();
    			div3 = element("div");
    			span1 = element("span");
    			t4 = text(t4_value);
    			t5 = space();
    			div2 = element("div");
    			div2.textContent = "Minutes";
    			t7 = space();
    			div5 = element("div");
    			span2 = element("span");
    			t8 = text(t8_value);
    			t9 = space();
    			div4 = element("div");
    			div4.textContent = "Seconds";
    			attr_dev(span0, "class", "hours svelte-wl0drd");
    			add_location(span0, file$6, 81, 4, 3124);
    			attr_dev(div0, "class", "smalltext svelte-wl0drd");
    			add_location(div0, file$6, 82, 4, 3168);
    			attr_dev(div1, "class", "svelte-wl0drd");
    			add_location(div1, file$6, 80, 2, 3114);
    			attr_dev(span1, "class", "minutes svelte-wl0drd");
    			add_location(span1, file$6, 85, 4, 3224);
    			attr_dev(div2, "class", "smalltext svelte-wl0drd");
    			add_location(div2, file$6, 86, 4, 3272);
    			attr_dev(div3, "class", "svelte-wl0drd");
    			add_location(div3, file$6, 84, 2, 3214);
    			attr_dev(span2, "class", "seconds svelte-wl0drd");
    			add_location(span2, file$6, 89, 4, 3330);
    			attr_dev(div4, "class", "smalltext svelte-wl0drd");
    			add_location(div4, file$6, 90, 4, 3378);
    			attr_dev(div5, "class", "svelte-wl0drd");
    			add_location(div5, file$6, 88, 2, 3320);
    			attr_dev(div6, "id", "clockdiv");
    			attr_dev(div6, "class", "svelte-wl0drd");
    			add_location(div6, file$6, 79, 0, 3092);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div1);
    			append_dev(div1, span0);
    			append_dev(span0, t0);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			append_dev(div6, t3);
    			append_dev(div6, div3);
    			append_dev(div3, span1);
    			append_dev(span1, t4);
    			append_dev(div3, t5);
    			append_dev(div3, div2);
    			append_dev(div6, t7);
    			append_dev(div6, div5);
    			append_dev(div5, span2);
    			append_dev(span2, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div4);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*timer*/ 1 && t0_value !== (t0_value = /*timer*/ ctx[0].hour + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*timer*/ 1 && t4_value !== (t4_value = /*timer*/ ctx[0].minute + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*timer*/ 1 && t8_value !== (t8_value = /*timer*/ ctx[0].second + "")) set_data_dev(t8, t8_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let $dataStore;
    	validate_store(dataStore, "dataStore");
    	component_subscribe($$self, dataStore, $$value => $$invalidate(2, $dataStore = $$value));
    	let { expireTime } = $$props;
    	console.log(expireTime);
    	let timer = { hour: "", minute: "", second: "" };
    	const client = getClient();

    	async function sendSolution(data) {
    		let solutions = {
    			u_id: parseInt(cookieHandler.getCookie("user_id")),
    			t_id: parseInt(cookieHandler.getCookie("test_id")),
    			solutions: JSON.stringify(data)
    		};

    		try {
    			await mutate(client, {
    				mutation: apolloClient.addAttempt,
    				variables: solutions
    			});

    			location.replace("http://localhost:5000/feedback");
    		} catch(err) {
    			console.log(err);
    		}
    	}

    	function InitializeTimer() {
    		let d = new Date();
    		let currentTime = Math.floor(d.getTime() / 1000);

    		if (currentTime > expireTime) {
    			clearInterval(timeCounter);
    			sendSolution($dataStore);
    			return;
    		}

    		let remainingTime = Math.floor(expireTime - currentTime);
    		$$invalidate(0, timer.hour = Math.floor(remainingTime / 3600).toString(), timer);
    		$$invalidate(0, timer.minute = (Math.floor(remainingTime / 60) % 60).toString(), timer);
    		$$invalidate(0, timer.second = (remainingTime % 60).toString(), timer);
    	}

    	let timeCounter = setInterval(InitializeTimer, 1000);
    	const writable_props = ["expireTime"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Timer> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ("expireTime" in $$props) $$invalidate(1, expireTime = $$props.expireTime);
    	};

    	$$self.$capture_state = () => {
    		return {
    			expireTime,
    			timer,
    			timeCounter,
    			$dataStore
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("expireTime" in $$props) $$invalidate(1, expireTime = $$props.expireTime);
    		if ("timer" in $$props) $$invalidate(0, timer = $$props.timer);
    		if ("timeCounter" in $$props) timeCounter = $$props.timeCounter;
    		if ("$dataStore" in $$props) dataStore.set($dataStore = $$props.$dataStore);
    	};

    	return [timer, expireTime];
    }

    class Timer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, { expireTime: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Timer",
    			options,
    			id: create_fragment$9.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*expireTime*/ ctx[1] === undefined && !("expireTime" in props)) {
    			console_1.warn("<Timer> was created without expected prop 'expireTime'");
    		}
    	}

    	get expireTime() {
    		throw new Error("<Timer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set expireTime(value) {
    		throw new Error("<Timer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Home.svelte generated by Svelte v3.18.1 */

    const { console: console_1$1 } = globals;
    const file$7 = "src/Home.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[17] = list[i];
    	return child_ctx;
    }

    // (307:2) {#if cookieHandler.getCookie('loggedIn') !== 'true'}
    function create_if_block_1$2(ctx) {
    	let div;
    	let current;

    	const modal = new Modal({
    			props: {
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(modal.$$.fragment);
    			attr_dev(div, "class", "svelte-kdwmpr");
    			add_location(div, file$7, 307, 4, 11195);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(modal, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(modal);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(307:2) {#if cookieHandler.getCookie('loggedIn') !== 'true'}",
    		ctx
    	});

    	return block;
    }

    // (309:6) <Modal>
    function create_default_slot(ctx) {
    	let current;

    	const content = new UserHelper({
    			props: { changeStatus: true },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(content.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(content, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(content.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(content.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(content, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(309:6) <Modal>",
    		ctx
    	});

    	return block;
    }

    // (324:2) {:catch err}
    function create_catch_block(ctx) {
    	let h1;

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Error :- Contact Admin";
    			attr_dev(h1, "class", "svelte-kdwmpr");
    			add_location(h1, file$7, 324, 4, 11537);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block.name,
    		type: "catch",
    		source: "(324:2) {:catch err}",
    		ctx
    	});

    	return block;
    }

    // (318:2) {:then result}
    function create_then_block(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let current;

    	const timer = new Timer({
    			props: {
    				expireTime: JSON.parse(atob(/*tokens*/ ctx[6][1])).exp
    			},
    			$$inline: true
    		});

    	const tabs = new Tabs({ $$inline: true });
    	const editorarea = new EditorArea({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(timer.$$.fragment);
    			t0 = space();
    			create_component(tabs.$$.fragment);
    			t1 = space();
    			create_component(editorarea.$$.fragment);
    			attr_dev(div, "class", "flex flex-col w-full svelte-kdwmpr");
    			add_location(div, file$7, 318, 4, 11377);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(timer, div, null);
    			append_dev(div, t0);
    			mount_component(tabs, div, null);
    			insert_dev(target, t1, anchor);
    			mount_component(editorarea, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(timer.$$.fragment, local);
    			transition_in(tabs.$$.fragment, local);
    			transition_in(editorarea.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(timer.$$.fragment, local);
    			transition_out(tabs.$$.fragment, local);
    			transition_out(editorarea.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(timer);
    			destroy_component(tabs);
    			if (detaching) detach_dev(t1);
    			destroy_component(editorarea, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block.name,
    		type: "then",
    		source: "(318:2) {:then result}",
    		ctx
    	});

    	return block;
    }

    // (315:20)      {pubbie()}
    function create_pending_block(ctx) {
    	let t0_value = /*pubbie*/ ctx[9]() + "";
    	let t0;
    	let t1;
    	let h1;

    	const block = {
    		c: function create() {
    			t0 = text(t0_value);
    			t1 = space();
    			h1 = element("h1");
    			h1.textContent = "Test is being loaded...";
    			attr_dev(h1, "class", "svelte-kdwmpr");
    			add_location(h1, file$7, 316, 4, 11323);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, h1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(h1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block.name,
    		type: "pending",
    		source: "(315:20)      {pubbie()}",
    		ctx
    	});

    	return block;
    }

    // (414:4) {:else}
    function create_else_block(ctx) {
    	let div3;
    	let div2;
    	let div0;
    	let img;
    	let img_src_value;
    	let t0;
    	let div1;
    	let h4;
    	let dispose;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			img = element("img");
    			t0 = space();
    			div1 = element("div");
    			h4 = element("h4");
    			h4.textContent = "Helpdesk";
    			attr_dev(img, "class", "chat-notification-logo svelte-kdwmpr");
    			if (img.src !== (img_src_value = "https://img.icons8.com/cotton/50/000000/filled-chat.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "ChitChat Logo");
    			add_location(img, file$7, 417, 12, 14629);
    			attr_dev(div0, "class", "chat-notification-logo-wrapper svelte-kdwmpr");
    			add_location(div0, file$7, 416, 10, 14572);
    			attr_dev(h4, "class", "chat-notification-title svelte-kdwmpr");
    			add_location(h4, file$7, 423, 12, 14871);
    			attr_dev(div1, "class", "chat-notification-content svelte-kdwmpr");
    			add_location(div1, file$7, 422, 10, 14819);
    			attr_dev(div2, "class", "chat-notification svelte-kdwmpr");
    			add_location(div2, file$7, 415, 8, 14530);
    			attr_dev(div3, "class", "btm svelte-kdwmpr");
    			add_location(div3, file$7, 414, 6, 14486);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div0, img);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, h4);
    			dispose = listen_dev(div3, "click", /*joined*/ ctx[7], false, false, false);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(414:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (329:4) {#if hasJoinedChat}
    function create_if_block$2(ctx) {
    	let div11;
    	let div3;
    	let div0;
    	let img0;
    	let img0_src_value;
    	let t0;
    	let div2;
    	let div1;
    	let p0;
    	let t2;
    	let p1;
    	let t4;
    	let div8;
    	let div7;
    	let div6;
    	let div5;
    	let div4;
    	let p2;
    	let t6;
    	let p3;
    	let t8;
    	let t9;
    	let div10;
    	let div9;
    	let form;
    	let input;
    	let t10;
    	let div14;
    	let div13;
    	let div12;
    	let img1;
    	let img1_src_value;
    	let dispose;
    	let each_value = /*output*/ ctx[2];
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div11 = element("div");
    			div3 = element("div");
    			div0 = element("div");
    			img0 = element("img");
    			t0 = space();
    			div2 = element("div");
    			div1 = element("div");
    			p0 = element("p");
    			p0.textContent = "Helpdesk";
    			t2 = space();
    			p1 = element("p");
    			p1.textContent = "User Assitant";
    			t4 = space();
    			div8 = element("div");
    			div7 = element("div");
    			div6 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			p2 = element("p");
    			p2.textContent = "Admin";
    			t6 = space();
    			p3 = element("p");
    			p3.textContent = "Hey! if you need any help,Please message me";
    			t8 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t9 = space();
    			div10 = element("div");
    			div9 = element("div");
    			form = element("form");
    			input = element("input");
    			t10 = space();
    			div14 = element("div");
    			div13 = element("div");
    			div12 = element("div");
    			img1 = element("img");
    			attr_dev(img0, "alt", "admin photo");
    			attr_dev(img0, "class", "h-12 w-12 rounded-full svelte-kdwmpr");
    			if (img0.src !== (img0_src_value = "https://darrenjameseeley.files.wordpress.com/2014/09/expendables3.jpeg")) attr_dev(img0, "src", img0_src_value);
    			add_location(img0, file$7, 335, 12, 11827);
    			attr_dev(div0, "class", "svelte-kdwmpr");
    			add_location(div0, file$7, 334, 10, 11809);
    			attr_dev(p0, "class", "text-grey-darkest svelte-kdwmpr");
    			add_location(p0, file$7, 342, 14, 12164);
    			attr_dev(div1, "class", "flex items-bottom justify-between svelte-kdwmpr");
    			add_location(div1, file$7, 341, 12, 12102);
    			attr_dev(p1, "class", "text-grey-dark mt-1 text-sm svelte-kdwmpr");
    			add_location(p1, file$7, 344, 12, 12237);
    			attr_dev(div2, "class", "ml-4 flex-1 border-b border-grey-lighter py-4 svelte-kdwmpr");
    			add_location(div2, file$7, 340, 10, 12030);
    			attr_dev(div3, "class", "px-3 flex items-center bg-grey-light cursor-pointer rounded-lg svelte-kdwmpr");
    			add_location(div3, file$7, 332, 8, 11712);
    			attr_dev(p2, "class", "text-grey-darkest svelte-kdwmpr");
    			add_location(p2, file$7, 356, 18, 12755);
    			attr_dev(div4, "class", "flex items-bottom justify-between svelte-kdwmpr");
    			add_location(div4, file$7, 355, 16, 12689);
    			attr_dev(p3, "class", "text-grey-dark mt-1 text-sm svelte-kdwmpr");
    			add_location(p3, file$7, 359, 16, 12834);
    			attr_dev(div5, "class", "ml-4 flex-1 border-b border-grey-lighter py-4 svelte-kdwmpr");
    			add_location(div5, file$7, 354, 14, 12613);
    			attr_dev(div6, "class", "flex-1 overflow-auto svelte-kdwmpr");
    			add_location(div6, file$7, 353, 12, 12564);
    			attr_dev(div7, "class", "message-form svelte-kdwmpr");
    			add_location(div7, file$7, 352, 10, 12525);
    			attr_dev(div8, "class", "container mx-auto overflow-auto margin-bottom:10%; svelte-kdwmpr");
    			set_style(div8, "bottom", "120px");
    			set_style(div8, "right", "55px");
    			set_style(div8, "height", "280px");
    			set_style(div8, "width", "295px");
    			add_location(div8, file$7, 349, 8, 12364);
    			attr_dev(input, "type", "search");
    			attr_dev(input, "name", "serch");
    			attr_dev(input, "placeholder", "Type Message and Press Enter");
    			attr_dev(input, "class", "bg-white h-10 px-5 pr-10 rounded-full text-sm\n                focus:outline-none svelte-kdwmpr");
    			add_location(input, file$7, 383, 14, 13684);
    			attr_dev(form, "class", "svelte-kdwmpr");
    			add_location(form, file$7, 381, 12, 13579);
    			attr_dev(div9, "class", "relative text-gray-600 svelte-kdwmpr");
    			add_location(div9, file$7, 380, 10, 13530);
    			attr_dev(div10, "class", "container block svelte-kdwmpr");
    			set_style(div10, "position", "absolute");
    			set_style(div10, "bottom", "0");
    			add_location(div10, file$7, 379, 8, 13450);
    			attr_dev(div11, "class", "chat shadow-xl rounded-lg svelte-kdwmpr");
    			add_location(div11, file$7, 329, 6, 11637);
    			attr_dev(img1, "class", "chat-notification-logo svelte-kdwmpr");
    			if (img1.src !== (img1_src_value = "https://img.icons8.com/cute-clipart/50/000000/close-window.png")) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "alt", "ChitChat Logo");
    			add_location(img1, file$7, 406, 12, 14253);
    			attr_dev(div12, "class", "chat-notification-logo-wrapper svelte-kdwmpr");
    			add_location(div12, file$7, 405, 10, 14196);
    			attr_dev(div13, "class", "chat-notification svelte-kdwmpr");
    			add_location(div13, file$7, 404, 8, 14154);
    			attr_dev(div14, "class", "btm svelte-kdwmpr");
    			add_location(div14, file$7, 403, 6, 14111);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div11, anchor);
    			append_dev(div11, div3);
    			append_dev(div3, div0);
    			append_dev(div0, img0);
    			append_dev(div3, t0);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div1, p0);
    			append_dev(div2, t2);
    			append_dev(div2, p1);
    			append_dev(div11, t4);
    			append_dev(div11, div8);
    			append_dev(div8, div7);
    			append_dev(div7, div6);
    			append_dev(div6, div5);
    			append_dev(div5, div4);
    			append_dev(div4, p2);
    			append_dev(div5, t6);
    			append_dev(div5, p3);
    			append_dev(div6, t8);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div6, null);
    			}

    			append_dev(div11, t9);
    			append_dev(div11, div10);
    			append_dev(div10, div9);
    			append_dev(div9, form);
    			append_dev(form, input);
    			set_input_value(input, /*newMessage*/ ctx[1]);
    			insert_dev(target, t10, anchor);
    			insert_dev(target, div14, anchor);
    			append_dev(div14, div13);
    			append_dev(div13, div12);
    			append_dev(div12, img1);

    			dispose = [
    				listen_dev(input, "input", /*input_input_handler*/ ctx[16]),
    				listen_dev(
    					form,
    					"submit",
    					prevent_default(function () {
    						if (is_function(publish(/*newMessage*/ ctx[1], "channel." + /*userName*/ ctx[3]))) publish(/*newMessage*/ ctx[1], "channel." + /*userName*/ ctx[3]).apply(this, arguments);
    					}),
    					false,
    					true,
    					false
    				),
    				listen_dev(div14, "click", /*close*/ ctx[8], false, false, false)
    			];
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*output*/ 4) {
    				each_value = /*output*/ ctx[2];
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div6, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*newMessage*/ 2) {
    				set_input_value(input, /*newMessage*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div11);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t10);
    			if (detaching) detach_dev(div14);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(329:4) {#if hasJoinedChat}",
    		ctx
    	});

    	return block;
    }

    // (364:14) {#each output as message}
    function create_each_block$1(ctx) {
    	let div1;
    	let div0;
    	let p;
    	let t0_value = /*message*/ ctx[17] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(p, "class", "text-sm mt-1 svelte-kdwmpr");
    			add_location(p, file$7, 368, 20, 13214);
    			attr_dev(div0, "class", "rounded py-2 px-3 svelte-kdwmpr");
    			set_style(div0, "background-color", "#E2F7CB");
    			add_location(div0, file$7, 365, 18, 13088);
    			attr_dev(div1, "class", "flex justify-end mb-2 svelte-kdwmpr");
    			add_location(div1, file$7, 364, 16, 13034);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, p);
    			append_dev(p, t0);
    			append_dev(div1, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*output*/ 4 && t0_value !== (t0_value = /*message*/ ctx[17] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(364:14) {#each output as message}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let body;
    	let show_if = cookieHandler.getCookie("loggedIn") !== "true";
    	let t0;
    	let promise;
    	let t1;
    	let div;
    	let current;
    	let if_block0 = show_if && create_if_block_1$2(ctx);

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		pending: create_pending_block,
    		then: create_then_block,
    		catch: create_catch_block,
    		value: 20,
    		error: 21,
    		blocks: [,,,]
    	};

    	handle_promise(promise = /*$problems*/ ctx[4], info);

    	function select_block_type(ctx, dirty) {
    		if (/*hasJoinedChat*/ ctx[0]) return create_if_block$2;
    		return create_else_block;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block1 = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			body = element("body");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			info.block.c();
    			t1 = space();
    			div = element("div");
    			if_block1.c();
    			attr_dev(div, "class", "container svelte-kdwmpr");
    			add_location(div, file$7, 327, 2, 11583);
    			attr_dev(body, "class", "svelte-kdwmpr");
    			add_location(body, file$7, 305, 0, 11129);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, body, anchor);
    			if (if_block0) if_block0.m(body, null);
    			append_dev(body, t0);
    			info.block.m(body, info.anchor = null);
    			info.mount = () => body;
    			info.anchor = t1;
    			append_dev(body, t1);
    			append_dev(body, div);
    			if_block1.m(div, null);
    			current = true;
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			info.ctx = ctx;

    			if (dirty & /*$problems*/ 16 && promise !== (promise = /*$problems*/ ctx[4]) && handle_promise(promise, info)) ; else {
    				const child_ctx = ctx.slice();
    				child_ctx[20] = info.resolved;
    				info.block.p(child_ctx, dirty);
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(div, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(info.block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);

    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(body);
    			if (if_block0) if_block0.d();
    			info.block.d();
    			info.token = null;
    			info = null;
    			if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let $problems;
    	let { currentRoute } = $$props;
    	console.log(currentRoute);
    	const client = getClient();

    	const problems = subscribe$2(client, {
    		query: apolloClient.testByToken,
    		variables: { token: currentRoute.namedParams.token }
    	});

    	validate_store(problems, "problems");
    	component_subscribe($$self, problems, value => $$invalidate(4, $problems = value));
    	var tokens = currentRoute.namedParams.token.split(".");
    	console.log(JSON.parse(atob(tokens[1])));
    	cookieHandler.setCookie("attemptId", JSON.parse(atob(tokens[1])).attemptId);

    	$problems.then(res => {
    		cookieHandler.setCookie("test_id", res.data.testByToken.id);
    		dataStore.updateStore(res.data.testByToken.problems);
    	});

    	let hasJoinedChat = false;
    	let channel = "";
    	let username = "";
    	let newMessage = "";
    	let messages = "";
    	let output = [""];

    	function joined() {
    		$$invalidate(0, hasJoinedChat = true);
    		pubbie();
    	}

    	function close() {
    		$$invalidate(0, hasJoinedChat = false);
    	}

    	pubnub.addListener({
    		message(m) {
    			$$invalidate(2, output = [...output, m.message]); // console.log(m);
    			$$invalidate(1, newMessage = "");
    		}, // console.log(m);
    		
    	});

    	let userName = "kumar.adarshluv99";

    	async function email() {
    		function getCookie(name) {
    			var match = document.cookie.match(new RegExp("(^| )" + name + "=([^;]+)"));
    			if (match) return match[2];
    		}

    		const userEmail = getCookie("access_email");
    		console.log(userEmail);
    		let sEmails = userEmail.split("@");
    		$$invalidate(3, userName = sEmails[0]);
    		return userName;
    	}

    	async function pubbie() {
    		// cookieHandler.setCookie("username",userName);
    		const usern = await email();

    		const users = {
    			id: Math.floor(Math.random() * 10) + 1,
    			email: usern,
    			name: usern,
    			flag: "U",
    			ttl: 1440,
    			profileUrl: null
    		};

    		grantPermissions(users);
    	}

    	const writable_props = ["currentRoute"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<Home> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		newMessage = this.value;
    		$$invalidate(1, newMessage);
    	}

    	$$self.$set = $$props => {
    		if ("currentRoute" in $$props) $$invalidate(10, currentRoute = $$props.currentRoute);
    	};

    	$$self.$capture_state = () => {
    		return {
    			currentRoute,
    			tokens,
    			hasJoinedChat,
    			channel,
    			username,
    			newMessage,
    			messages,
    			output,
    			userName,
    			$problems
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("currentRoute" in $$props) $$invalidate(10, currentRoute = $$props.currentRoute);
    		if ("tokens" in $$props) $$invalidate(6, tokens = $$props.tokens);
    		if ("hasJoinedChat" in $$props) $$invalidate(0, hasJoinedChat = $$props.hasJoinedChat);
    		if ("channel" in $$props) channel = $$props.channel;
    		if ("username" in $$props) username = $$props.username;
    		if ("newMessage" in $$props) $$invalidate(1, newMessage = $$props.newMessage);
    		if ("messages" in $$props) messages = $$props.messages;
    		if ("output" in $$props) $$invalidate(2, output = $$props.output);
    		if ("userName" in $$props) $$invalidate(3, userName = $$props.userName);
    		if ("$problems" in $$props) problems.set($problems = $$props.$problems);
    	};

    	return [
    		hasJoinedChat,
    		newMessage,
    		output,
    		userName,
    		$problems,
    		problems,
    		tokens,
    		joined,
    		close,
    		pubbie,
    		currentRoute,
    		client,
    		channel,
    		username,
    		messages,
    		email,
    		input_input_handler
    	];
    }

    class Home extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, { currentRoute: 10 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Home",
    			options,
    			id: create_fragment$a.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*currentRoute*/ ctx[10] === undefined && !("currentRoute" in props)) {
    			console_1$1.warn("<Home> was created without expected prop 'currentRoute'");
    		}
    	}

    	get currentRoute() {
    		throw new Error("<Home>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set currentRoute(value) {
    		throw new Error("<Home>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Modals/problemModal.svelte generated by Svelte v3.18.1 */
    const file$8 = "src/Modals/problemModal.svelte";

    function create_fragment$b(ctx) {
    	let p;
    	let button;
    	let dispose;

    	const block = {
    		c: function create() {
    			p = element("p");
    			button = element("button");
    			button.textContent = "Add Problems";
    			attr_dev(button, "class", "bg-transparent border border-gray-500 hover:border-indigo-500\n    text-gray-500 hover:text-indigo-500 font-bold py-2 px-4 rounded-full");
    			add_location(button, file$8, 8, 2, 159);
    			add_location(p, file$8, 7, 0, 153);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, button);
    			dispose = listen_dev(button, "click", /*showSurprise*/ ctx[0], false, false, false);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self) {
    	const showSurprise = () => {
    		location.replace("http://localhost:5000/newProblem");
    	};

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		
    	};

    	return [showSurprise];
    }

    class ProblemModal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ProblemModal",
    			options,
    			id: create_fragment$b.name
    		});
    	}
    }

    /* src/Modals/testModal.svelte generated by Svelte v3.18.1 */

    const file$9 = "src/Modals/testModal.svelte";

    function create_fragment$c(ctx) {
    	let p;
    	let button;
    	let dispose;

    	const block = {
    		c: function create() {
    			p = element("p");
    			button = element("button");
    			button.textContent = "Add Test";
    			attr_dev(button, "class", "bg-transparent border border-gray-500 hover:border-indigo-500\n    text-gray-500 hover:text-indigo-500 font-bold py-2 px-4 rounded-full");
    			add_location(button, file$9, 12, 2, 195);
    			add_location(p, file$9, 11, 0, 189);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, button);
    			dispose = listen_dev(button, "click", /*showSurprise*/ ctx[0], false, false, false);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let { changeCheck } = $$props;

    	const showSurprise = () => {
    		location.replace("http://localhost:5000/newtest");
    	};

    	const writable_props = ["changeCheck"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TestModal> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ("changeCheck" in $$props) $$invalidate(1, changeCheck = $$props.changeCheck);
    	};

    	$$self.$capture_state = () => {
    		return { changeCheck };
    	};

    	$$self.$inject_state = $$props => {
    		if ("changeCheck" in $$props) $$invalidate(1, changeCheck = $$props.changeCheck);
    	};

    	return [showSurprise, changeCheck];
    }

    class TestModal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, { changeCheck: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TestModal",
    			options,
    			id: create_fragment$c.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*changeCheck*/ ctx[1] === undefined && !("changeCheck" in props)) {
    			console.warn("<TestModal> was created without expected prop 'changeCheck'");
    		}
    	}

    	get changeCheck() {
    		throw new Error("<TestModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set changeCheck(value) {
    		throw new Error("<TestModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/navbar.svelte generated by Svelte v3.18.1 */
    const file$a = "src/components/navbar.svelte";

    function create_fragment$d(ctx) {
    	let link;
    	let t0;
    	let nav;
    	let div2;
    	let h1;
    	let t2;
    	let div1;
    	let div0;
    	let button;
    	let img0;
    	let img0_src_value;
    	let t3;
    	let p0;
    	let t6;
    	let ul;
    	let li0;
    	let img1;
    	let img1_src_value;
    	let t7;
    	let p1;
    	let t9;
    	let li1;
    	let img2;
    	let img2_src_value;
    	let t10;
    	let p2;
    	let dispose;

    	const block = {
    		c: function create() {
    			link = element("link");
    			t0 = space();
    			nav = element("nav");
    			div2 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Welcome Admin";
    			t2 = space();
    			div1 = element("div");
    			div0 = element("div");
    			button = element("button");
    			img0 = element("img");
    			t3 = space();
    			p0 = element("p");

    			p0.textContent = `
              ${JSON.parse(atob(/*tokens*/ ctx[1][1])).username}`;

    			t6 = space();
    			ul = element("ul");
    			li0 = element("li");
    			img1 = element("img");
    			t7 = space();
    			p1 = element("p");
    			p1.textContent = "  Theme";
    			t9 = space();
    			li1 = element("li");
    			img2 = element("img");
    			t10 = space();
    			p2 = element("p");
    			p2.textContent = "  Logout";
    			attr_dev(link, "href", "https://fonts.googleapis.com/css2?family=Jost&display=swap");
    			attr_dev(link, "rel", "stylesheet");
    			attr_dev(link, "class", "svelte-1thwvf9");
    			add_location(link, file$a, 61, 0, 2567);
    			attr_dev(h1, "class", "welcome text-primary svelte-1thwvf9");
    			add_location(h1, file$a, 69, 4, 2814);
    			attr_dev(img0, "alt", "admin");
    			attr_dev(img0, "width", "25");
    			attr_dev(img0, "height", "25");
    			if (img0.src !== (img0_src_value = "https://img.icons8.com/carbon-copy/64/000000/user.png")) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "class", "svelte-1thwvf9");
    			add_location(img0, file$a, 77, 10, 3195);
    			set_style(p0, "font-family", "'Jost', sans-serif");
    			attr_dev(p0, "class", "svelte-1thwvf9");
    			add_location(p0, file$a, 82, 10, 3356);
    			attr_dev(button, "class", "container bg-white mx-3 flex flex-row hover:bg-light text-dark\n          font-semibold hover:text-white py-4 px-6 border border-white-500\n          rounded hover:border-white hover:border-transparent rounded-full svelte-1thwvf9");
    			add_location(button, file$a, 73, 8, 2945);
    			attr_dev(img1, "alt", "Theme");
    			attr_dev(img1, "width", "25");
    			attr_dev(img1, "height", "25");
    			if (img1.src !== (img1_src_value = "https://img.icons8.com/material-rounded/24/000000/change.png")) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "class", "svelte-1thwvf9");
    			add_location(img1, file$a, 95, 12, 3878);
    			attr_dev(p1, "class", "svelte-1thwvf9");
    			add_location(p1, file$a, 100, 12, 4056);
    			attr_dev(li0, "class", "rounded-t flex flex-row bg-gray-200 hover:bg-gray-400 py-2\n            px-4 block whitespace-no-wrap svelte-1thwvf9");
    			add_location(li0, file$a, 87, 10, 3579);
    			attr_dev(img2, "alt", "logout");
    			attr_dev(img2, "width", "25");
    			attr_dev(img2, "height", "25");
    			if (img2.src !== (img2_src_value = "https://img.icons8.com/pastel-glyph/64/000000/logout-rounded-down.png")) attr_dev(img2, "src", img2_src_value);
    			attr_dev(img2, "class", "svelte-1thwvf9");
    			add_location(img2, file$a, 107, 12, 4270);
    			attr_dev(p2, "class", "svelte-1thwvf9");
    			add_location(p2, file$a, 112, 12, 4458);
    			attr_dev(li1, "class", "bg-gray-200 flex flex-row hover:bg-gray-400 py-2 px-4 block\n            whitespace-no-wrap svelte-1thwvf9");
    			add_location(li1, file$a, 102, 10, 4107);
    			attr_dev(ul, "class", "ml-3 dropdown-content container text-gray-700 pt-1 svelte-1thwvf9");
    			add_location(ul, file$a, 86, 8, 3505);
    			attr_dev(div0, "class", "dropdown svelte-1thwvf9");
    			add_location(div0, file$a, 72, 6, 2914);
    			attr_dev(div1, "id", "btn");
    			attr_dev(div1, "class", "flex flex-row svelte-1thwvf9");
    			add_location(div1, file$a, 70, 4, 2870);
    			attr_dev(div2, "class", "w-full block flex-grow lg:items-right svelte-1thwvf9");
    			add_location(div2, file$a, 68, 2, 2758);
    			attr_dev(nav, "class", "flex shadow-2xl items-center justify-between flex-wrap bg-dark sticky\n  p-6 svelte-1thwvf9");
    			add_location(nav, file$a, 64, 0, 2663);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, link, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, nav, anchor);
    			append_dev(nav, div2);
    			append_dev(div2, h1);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, button);
    			append_dev(button, img0);
    			append_dev(button, t3);
    			append_dev(button, p0);
    			append_dev(div0, t6);
    			append_dev(div0, ul);
    			append_dev(ul, li0);
    			append_dev(li0, img1);
    			append_dev(li0, t7);
    			append_dev(li0, p1);
    			append_dev(ul, t9);
    			append_dev(ul, li1);
    			append_dev(li1, img2);
    			append_dev(li1, t10);
    			append_dev(li1, p2);

    			dispose = [
    				listen_dev(li0, "click", /*click_handler*/ ctx[4], false, false, false),
    				listen_dev(li1, "click", myFunction, false, false, false)
    			];
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(link);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(nav);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function myFunction() {
    	location.replace("http://localhost:3000/logout");
    }

    function instance$d($$self, $$props, $$invalidate) {
    	const tokens = cookieHandler.getCookie("access_token").split(".");
    	console.log(atob(tokens[1]));

    	let themes = [
    		["#1D1F21", "#25282c", "#303030", "#c4c4c4"],
    		["#1d3e53", "#254b62", "#476d7c", "#77abb7"],
    		["#1b262c", "#0f4c75", "#3282b8", "#bbe1fa"],
    		["#071e3d", "#1f4287", "#278ea5", "#21e6c1"],
    		["#200f21", "#382039", "#5a3d5c", "#f638dc"],
    		["#2d132c", "#801336", "#c72c41", "#ee4540"]
    	];

    	let number = 0;

    	function changeTheme(num) {
    		console.log(themes[num], num);
    		document.documentElement.style.setProperty("--color-ed", themes[num][0]);
    		document.documentElement.style.setProperty("--color-d", themes[num][1]);
    		document.documentElement.style.setProperty("--color-l", themes[num][2]);
    		document.documentElement.style.setProperty("--color-el", themes[num][3]);
    	}

    	console.log(number);
    	changeTheme(number);

    	const click_handler = () => {
    		$$invalidate(0, number++, number);
    		let themesize = themes.length;
    		changeTheme(number % themesize);
    	};

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("themes" in $$props) $$invalidate(2, themes = $$props.themes);
    		if ("number" in $$props) $$invalidate(0, number = $$props.number);
    	};

    	return [number, tokens, themes, changeTheme, click_handler];
    }

    class Navbar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Navbar",
    			options,
    			id: create_fragment$d.name
    		});
    	}
    }

    /* src/routes/Admin.svelte generated by Svelte v3.18.1 */
    const file$b = "src/routes/Admin.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[23] = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[26] = list[i];
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[31] = list[i];
    	return child_ctx;
    }

    function get_each_context_3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[34] = list[i];
    	return child_ctx;
    }

    // (215:12) {:catch err}
    function create_catch_block_1(ctx) {
    	let t0;
    	let t1_value = /*err*/ ctx[30] + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("Error: ");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$Test*/ 32 && t1_value !== (t1_value = /*err*/ ctx[30] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block_1.name,
    		type: "catch",
    		source: "(215:12) {:catch err}",
    		ctx
    	});

    	return block;
    }

    // (207:12) {:then result}
    function create_then_block_1(ctx) {
    	let each_1_anchor;
    	let each_value_3 = /*result*/ ctx[29].data.allTests;
    	let each_blocks = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$Test*/ 32) {
    				each_value_3 = /*result*/ ctx[29].data.allTests;
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3(ctx, each_value_3, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_3.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block_1.name,
    		type: "then",
    		source: "(207:12) {:then result}",
    		ctx
    	});

    	return block;
    }

    // (208:14) {#each result.data.allTests as test}
    function create_each_block_3(ctx) {
    	let li;
    	let a;
    	let t0_value = /*test*/ ctx[34].testName + "";
    	let t0;
    	let a_href_value;
    	let t1;

    	const block = {
    		c: function create() {
    			li = element("li");
    			a = element("a");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(a, "href", a_href_value = "http://localhost:5000/test/" + /*test*/ ctx[34].id);
    			add_location(a, file$b, 209, 18, 7370);
    			attr_dev(li, "class", "prob svelte-r6lcc4");
    			add_location(li, file$b, 208, 16, 7334);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, a);
    			append_dev(a, t0);
    			append_dev(li, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$Test*/ 32 && t0_value !== (t0_value = /*test*/ ctx[34].testName + "")) set_data_dev(t0, t0_value);

    			if (dirty[0] & /*$Test*/ 32 && a_href_value !== (a_href_value = "http://localhost:5000/test/" + /*test*/ ctx[34].id)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3.name,
    		type: "each",
    		source: "(208:14) {#each result.data.allTests as test}",
    		ctx
    	});

    	return block;
    }

    // (205:26)                Loading...             {:then result}
    function create_pending_block_1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Loading...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block_1.name,
    		type: "pending",
    		source: "(205:26)                Loading...             {:then result}",
    		ctx
    	});

    	return block;
    }

    // (221:10) <Modal>
    function create_default_slot_1(ctx) {
    	let current;

    	const testmodal = new TestModal({
    			props: { changeCheck: /*handleTestAdd*/ ctx[10] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(testmodal.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(testmodal, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(testmodal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(testmodal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(testmodal, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(221:10) <Modal>",
    		ctx
    	});

    	return block;
    }

    // (242:12) {:catch err}
    function create_catch_block$1(ctx) {
    	let t0;
    	let t1_value = /*err*/ ctx[30] + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("Error: ");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$Problem*/ 64 && t1_value !== (t1_value = /*err*/ ctx[30] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block$1.name,
    		type: "catch",
    		source: "(242:12) {:catch err}",
    		ctx
    	});

    	return block;
    }

    // (234:12) {:then result}
    function create_then_block$1(ctx) {
    	let each_1_anchor;
    	let each_value_2 = /*result*/ ctx[29].data.allProblems;
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$Problem*/ 64) {
    				each_value_2 = /*result*/ ctx[29].data.allProblems;
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block$1.name,
    		type: "then",
    		source: "(234:12) {:then result}",
    		ctx
    	});

    	return block;
    }

    // (235:14) {#each result.data.allProblems as prob}
    function create_each_block_2(ctx) {
    	let li;
    	let a;
    	let t0_value = /*prob*/ ctx[31].problemName + "";
    	let t0;
    	let a_href_value;
    	let t1;

    	const block = {
    		c: function create() {
    			li = element("li");
    			a = element("a");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(a, "href", a_href_value = "http://localhost:5000/problem/" + /*prob*/ ctx[31].id);
    			add_location(a, file$b, 236, 18, 8205);
    			attr_dev(li, "class", "prob svelte-r6lcc4");
    			add_location(li, file$b, 235, 16, 8169);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, a);
    			append_dev(a, t0);
    			append_dev(li, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$Problem*/ 64 && t0_value !== (t0_value = /*prob*/ ctx[31].problemName + "")) set_data_dev(t0, t0_value);

    			if (dirty[0] & /*$Problem*/ 64 && a_href_value !== (a_href_value = "http://localhost:5000/problem/" + /*prob*/ ctx[31].id)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(235:14) {#each result.data.allProblems as prob}",
    		ctx
    	});

    	return block;
    }

    // (232:29)                Loading...             {:then result}
    function create_pending_block$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Loading...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block$1.name,
    		type: "pending",
    		source: "(232:29)                Loading...             {:then result}",
    		ctx
    	});

    	return block;
    }

    // (248:10) <Modal>
    function create_default_slot$1(ctx) {
    	let current;

    	const content = new ProblemModal({
    			props: { changeCheck: /*handleProblemAdd*/ ctx[9] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(content.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(content, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(content.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(content.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(content, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(248:10) <Modal>",
    		ctx
    	});

    	return block;
    }

    // (376:4) {:else}
    function create_else_block$1(ctx) {
    	let div3;
    	let div2;
    	let div0;
    	let img;
    	let img_src_value;
    	let t0;
    	let div1;
    	let h4;
    	let dispose;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			img = element("img");
    			t0 = space();
    			div1 = element("div");
    			h4 = element("h4");
    			h4.textContent = "User Chat";
    			attr_dev(img, "class", "chat-notification-logo svelte-r6lcc4");
    			if (img.src !== (img_src_value = "https://img.icons8.com/cotton/50/000000/filled-chat.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "ChitChat Logo");
    			add_location(img, file$b, 379, 12, 12697);
    			attr_dev(div0, "class", "chat-notification-logo-wrapper svelte-r6lcc4");
    			add_location(div0, file$b, 378, 10, 12640);
    			attr_dev(h4, "class", "chat-notification-title svelte-r6lcc4");
    			add_location(h4, file$b, 385, 12, 12939);
    			attr_dev(div1, "class", "chat-notification-content svelte-r6lcc4");
    			add_location(div1, file$b, 384, 10, 12887);
    			attr_dev(div2, "class", "chat-notification svelte-r6lcc4");
    			add_location(div2, file$b, 377, 8, 12598);
    			attr_dev(div3, "class", "btm svelte-r6lcc4");
    			add_location(div3, file$b, 376, 6, 12554);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div0, img);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, h4);
    			dispose = listen_dev(div3, "click", /*joined*/ ctx[11], false, false, false);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(376:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (257:4) {#if hasJoinedChat}
    function create_if_block$3(ctx) {
    	let div15;
    	let div3;
    	let div1;
    	let div0;
    	let p0;
    	let t1;
    	let div2;
    	let t2;
    	let div14;
    	let div6;
    	let div5;
    	let div4;
    	let p1;
    	let t3;
    	let t4;
    	let p2;
    	let t6;
    	let div11;
    	let div10;
    	let div9;
    	let div8;
    	let div7;
    	let p3;
    	let t8;
    	let p4;
    	let t10;
    	let t11;
    	let div13;
    	let div12;
    	let form;
    	let input;
    	let t12;
    	let div18;
    	let div17;
    	let div16;
    	let img;
    	let img_src_value;
    	let dispose;
    	let each_value_1 = /*channels*/ ctx[1];
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	let each_value = /*output*/ ctx[3];
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div15 = element("div");
    			div3 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			p0 = element("p");
    			p0.textContent = "Active User";
    			t1 = space();
    			div2 = element("div");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t2 = space();
    			div14 = element("div");
    			div6 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			p1 = element("p");
    			t3 = text(/*channelName*/ ctx[4]);
    			t4 = space();
    			p2 = element("p");
    			p2.textContent = "User Assitant";
    			t6 = space();
    			div11 = element("div");
    			div10 = element("div");
    			div9 = element("div");
    			div8 = element("div");
    			div7 = element("div");
    			p3 = element("p");
    			p3.textContent = "Admin";
    			t8 = space();
    			p4 = element("p");
    			p4.textContent = "Hey! if you need any help,Please message me";
    			t10 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t11 = space();
    			div13 = element("div");
    			div12 = element("div");
    			form = element("form");
    			input = element("input");
    			t12 = space();
    			div18 = element("div");
    			div17 = element("div");
    			div16 = element("div");
    			img = element("img");
    			add_location(p0, file$b, 267, 14, 9035);
    			attr_dev(div0, "class", "flex");
    			add_location(div0, file$b, 265, 12, 9001);
    			attr_dev(div1, "class", "py-2 px-3 bg-grey-lighter flex flex-row justify-between\n            items-center");
    			add_location(div1, file$b, 262, 10, 8882);
    			attr_dev(div2, "class", "bg-grey-lighter flex-1 overflow-auto");
    			add_location(div2, file$b, 272, 10, 9129);
    			attr_dev(div3, "class", "w-1/3 border flex flex-col");
    			add_location(div3, file$b, 259, 8, 8804);
    			attr_dev(p1, "class", "text-grey-darkest");
    			add_location(p1, file$b, 303, 16, 10120);
    			attr_dev(div4, "class", "flex items-bottom justify-between");
    			add_location(div4, file$b, 302, 14, 10056);
    			attr_dev(p2, "class", "text-grey-dark mt-1 text-sm");
    			add_location(p2, file$b, 305, 14, 10202);
    			attr_dev(div5, "class", "ml-4 flex-1 border-b border-grey-lighter py-4");
    			add_location(div5, file$b, 301, 12, 9982);
    			attr_dev(div6, "class", "px-3 flex-row items-center bg-grey-light cursor-pointer\n            rounded-lg");
    			add_location(div6, file$b, 298, 10, 9865);
    			attr_dev(p3, "class", "text-grey-darkest");
    			add_location(p3, file$b, 317, 20, 10742);
    			attr_dev(div7, "class", "flex items-bottom justify-between");
    			add_location(div7, file$b, 316, 18, 10674);
    			attr_dev(p4, "class", "text-grey-dark mt-1 text-sm");
    			add_location(p4, file$b, 320, 18, 10825);
    			attr_dev(div8, "class", "ml-4 flex-1 border-b border-grey-lighter py-4");
    			add_location(div8, file$b, 315, 16, 10596);
    			attr_dev(div9, "class", "flex-1 overflow-auto");
    			add_location(div9, file$b, 314, 14, 10545);
    			attr_dev(div10, "class", "message-form");
    			add_location(div10, file$b, 313, 12, 10504);
    			attr_dev(div11, "class", "container mx-auto overflow-auto margin-bottom:10%;");
    			set_style(div11, "bottom", "120px");
    			set_style(div11, "right", "55px");
    			set_style(div11, "height", "380px");
    			set_style(div11, "width", "390px");
    			add_location(div11, file$b, 310, 10, 10337);
    			attr_dev(input, "type", "search");
    			attr_dev(input, "name", "serch");
    			attr_dev(input, "placeholder", "Type Message and Press Enter");
    			attr_dev(input, "class", "bg-white h-10 px-5 pr-10 rounded-full text-sm\n                  focus:outline-none svelte-r6lcc4");
    			add_location(input, file$b, 344, 16, 11719);
    			add_location(form, file$b, 342, 14, 11610);
    			attr_dev(div12, "class", "relative text-gray-600");
    			add_location(div12, file$b, 341, 12, 11559);
    			attr_dev(div13, "class", "container block");
    			set_style(div13, "position", "absolute");
    			set_style(div13, "bottom", "0");
    			add_location(div13, file$b, 340, 10, 11477);
    			attr_dev(div14, "class", "w-2/3 border flex flex-col");
    			add_location(div14, file$b, 294, 8, 9784);
    			attr_dev(div15, "class", "chat flex flex-row shadow-xl rounded-lg svelte-r6lcc4");
    			add_location(div15, file$b, 257, 6, 8721);
    			attr_dev(img, "class", "chat-notification-logo svelte-r6lcc4");
    			if (img.src !== (img_src_value = "https://img.icons8.com/cute-clipart/50/000000/close-window.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "ChitChat Logo");
    			add_location(img, file$b, 368, 12, 12321);
    			attr_dev(div16, "class", "chat-notification-logo-wrapper svelte-r6lcc4");
    			add_location(div16, file$b, 367, 10, 12264);
    			attr_dev(div17, "class", "chat-notification svelte-r6lcc4");
    			add_location(div17, file$b, 366, 8, 12222);
    			attr_dev(div18, "class", "btm svelte-r6lcc4");
    			add_location(div18, file$b, 365, 6, 12179);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div15, anchor);
    			append_dev(div15, div3);
    			append_dev(div3, div1);
    			append_dev(div1, div0);
    			append_dev(div0, p0);
    			append_dev(div3, t1);
    			append_dev(div3, div2);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div2, null);
    			}

    			append_dev(div15, t2);
    			append_dev(div15, div14);
    			append_dev(div14, div6);
    			append_dev(div6, div5);
    			append_dev(div5, div4);
    			append_dev(div4, p1);
    			append_dev(p1, t3);
    			append_dev(div5, t4);
    			append_dev(div5, p2);
    			append_dev(div14, t6);
    			append_dev(div14, div11);
    			append_dev(div11, div10);
    			append_dev(div10, div9);
    			append_dev(div9, div8);
    			append_dev(div8, div7);
    			append_dev(div7, p3);
    			append_dev(div8, t8);
    			append_dev(div8, p4);
    			append_dev(div9, t10);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div9, null);
    			}

    			append_dev(div14, t11);
    			append_dev(div14, div13);
    			append_dev(div13, div12);
    			append_dev(div12, form);
    			append_dev(form, input);
    			set_input_value(input, /*newMessage*/ ctx[2]);
    			insert_dev(target, t12, anchor);
    			insert_dev(target, div18, anchor);
    			append_dev(div18, div17);
    			append_dev(div17, div16);
    			append_dev(div16, img);

    			dispose = [
    				listen_dev(input, "input", /*input_input_handler*/ ctx[22]),
    				listen_dev(
    					form,
    					"submit",
    					prevent_default(function () {
    						if (is_function(publish(/*newMessage*/ ctx[2], "channel." + /*userName*/ ctx[13]))) publish(/*newMessage*/ ctx[2], "channel." + /*userName*/ ctx[13]).apply(this, arguments);
    					}),
    					false,
    					true,
    					false
    				),
    				listen_dev(div18, "click", /*close*/ ctx[12], false, false, false)
    			];
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*changeChannel, channels*/ 16386) {
    				each_value_1 = /*channels*/ ctx[1];
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(div2, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if (dirty[0] & /*channelName*/ 16) set_data_dev(t3, /*channelName*/ ctx[4]);

    			if (dirty[0] & /*output*/ 8) {
    				each_value = /*output*/ ctx[3];
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div9, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty[0] & /*newMessage*/ 4) {
    				set_input_value(input, /*newMessage*/ ctx[2]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div15);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t12);
    			if (detaching) detach_dev(div18);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(257:4) {#if hasJoinedChat}",
    		ctx
    	});

    	return block;
    }

    // (275:12) {#each channels as channel}
    function create_each_block_1(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let p;
    	let t0_value = /*channel*/ ctx[26] + "";
    	let t0;
    	let t1;
    	let dispose;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(p, "class", "text-grey-darkest");
    			add_location(p, file$b, 282, 20, 9585);
    			attr_dev(div0, "class", "flex items-bottom justify-between");
    			add_location(div0, file$b, 281, 18, 9517);
    			attr_dev(div1, "class", "ml-4 flex-1 border-b border-grey-lighter py-4");
    			add_location(div1, file$b, 280, 16, 9439);
    			attr_dev(div2, "class", "bg-white hover:bg-gray-400 px-3 flex items-center\n                hover:bg-grey-lighter cursor-pointer");
    			add_location(div2, file$b, 275, 14, 9235);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, p);
    			append_dev(p, t0);
    			append_dev(div2, t1);

    			dispose = listen_dev(
    				div2,
    				"click",
    				function () {
    					if (is_function(/*changeChannel*/ ctx[14]({ channel: /*channel*/ ctx[26] }))) /*changeChannel*/ ctx[14]({ channel: /*channel*/ ctx[26] }).apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*channels*/ 2 && t0_value !== (t0_value = /*channel*/ ctx[26] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(275:12) {#each channels as channel}",
    		ctx
    	});

    	return block;
    }

    // (325:16) {#each output as message}
    function create_each_block$2(ctx) {
    	let div1;
    	let div0;
    	let p;
    	let t0_value = /*message*/ ctx[23] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(p, "class", "text-sm mt-1");
    			add_location(p, file$b, 329, 22, 11223);
    			attr_dev(div0, "class", "rounded py-2 px-3");
    			set_style(div0, "background-color", "#E2F7CB");
    			add_location(div0, file$b, 326, 20, 11091);
    			attr_dev(div1, "class", "flex justify-end mb-2");
    			add_location(div1, file$b, 325, 18, 11035);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, p);
    			append_dev(p, t0);
    			append_dev(div1, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*output*/ 8 && t0_value !== (t0_value = /*message*/ ctx[23] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(325:16) {#each output as message}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let link;
    	let t0;
    	let body;
    	let t1;
    	let div10;
    	let div4;
    	let div3;
    	let div1;
    	let div0;
    	let t3;
    	let ol0;
    	let promise;
    	let t4;
    	let div2;
    	let t5;
    	let div9;
    	let div8;
    	let div6;
    	let div5;
    	let t7;
    	let ol1;
    	let promise_1;
    	let t8;
    	let div7;
    	let t9;
    	let div11;
    	let current;
    	const navbar = new Navbar({ $$inline: true });

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		pending: create_pending_block_1,
    		then: create_then_block_1,
    		catch: create_catch_block_1,
    		value: 29,
    		error: 30
    	};

    	handle_promise(promise = /*$Test*/ ctx[5], info);

    	const modal0 = new Modal({
    			props: {
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let info_1 = {
    		ctx,
    		current: null,
    		token: null,
    		pending: create_pending_block$1,
    		then: create_then_block$1,
    		catch: create_catch_block$1,
    		value: 29,
    		error: 30
    	};

    	handle_promise(promise_1 = /*$Problem*/ ctx[6], info_1);

    	const modal1 = new Modal({
    			props: {
    				$$slots: { default: [create_default_slot$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function select_block_type(ctx, dirty) {
    		if (/*hasJoinedChat*/ ctx[0]) return create_if_block$3;
    		return create_else_block$1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			link = element("link");
    			t0 = space();
    			body = element("body");
    			create_component(navbar.$$.fragment);
    			t1 = space();
    			div10 = element("div");
    			div4 = element("div");
    			div3 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			div0.textContent = "Your Tests";
    			t3 = space();
    			ol0 = element("ol");
    			info.block.c();
    			t4 = space();
    			div2 = element("div");
    			create_component(modal0.$$.fragment);
    			t5 = space();
    			div9 = element("div");
    			div8 = element("div");
    			div6 = element("div");
    			div5 = element("div");
    			div5.textContent = "Your Problems";
    			t7 = space();
    			ol1 = element("ol");
    			info_1.block.c();
    			t8 = space();
    			div7 = element("div");
    			create_component(modal1.$$.fragment);
    			t9 = space();
    			div11 = element("div");
    			if_block.c();
    			attr_dev(link, "href", "https://unpkg.com/tailwindcss@^1.0/dist/tailwind.min.css");
    			attr_dev(link, "rel", "stylesheet");
    			add_location(link, file$b, 191, 0, 6835);
    			attr_dev(div0, "class", "font-bold text-xl mb-2");
    			add_location(div0, file$b, 202, 10, 7120);
    			add_location(ol0, file$b, 203, 10, 7183);
    			attr_dev(div1, "class", "px-6 py-4");
    			add_location(div1, file$b, 201, 8, 7086);
    			attr_dev(div2, "class", "px-6 py-4");
    			set_style(div2, "margin-right", "5%");
    			add_location(div2, file$b, 219, 8, 7633);
    			attr_dev(div3, "class", "max-w-lg rounded overflow-hidden shadow-lg");
    			add_location(div3, file$b, 200, 6, 7021);
    			attr_dev(div4, "class", "w-1/2 h-12");
    			add_location(div4, file$b, 199, 4, 6990);
    			attr_dev(div5, "class", "font-bold text-xl mb-2");
    			add_location(div5, file$b, 229, 10, 7946);
    			add_location(ol1, file$b, 230, 10, 8012);
    			attr_dev(div6, "class", "px-6 py-4");
    			add_location(div6, file$b, 228, 8, 7912);
    			attr_dev(div7, "class", "px-6 py-4");
    			set_style(div7, "margin-right", "10%");
    			add_location(div7, file$b, 246, 8, 8474);
    			attr_dev(div8, "class", "max-w-lg rounded overflow-hidden shadow-lg");
    			add_location(div8, file$b, 227, 6, 7847);
    			attr_dev(div9, "class", "w-1/2 h-12");
    			add_location(div9, file$b, 226, 4, 7816);
    			attr_dev(div10, "id", "blk");
    			attr_dev(div10, "class", "flex mb-4 svelte-r6lcc4");
    			add_location(div10, file$b, 198, 2, 6953);
    			attr_dev(div11, "class", "container");
    			add_location(div11, file$b, 255, 2, 8667);
    			add_location(body, file$b, 194, 0, 6929);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, link, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, body, anchor);
    			mount_component(navbar, body, null);
    			append_dev(body, t1);
    			append_dev(body, div10);
    			append_dev(div10, div4);
    			append_dev(div4, div3);
    			append_dev(div3, div1);
    			append_dev(div1, div0);
    			append_dev(div1, t3);
    			append_dev(div1, ol0);
    			info.block.m(ol0, info.anchor = null);
    			info.mount = () => ol0;
    			info.anchor = null;
    			append_dev(div3, t4);
    			append_dev(div3, div2);
    			mount_component(modal0, div2, null);
    			append_dev(div10, t5);
    			append_dev(div10, div9);
    			append_dev(div9, div8);
    			append_dev(div8, div6);
    			append_dev(div6, div5);
    			append_dev(div6, t7);
    			append_dev(div6, ol1);
    			info_1.block.m(ol1, info_1.anchor = null);
    			info_1.mount = () => ol1;
    			info_1.anchor = null;
    			append_dev(div8, t8);
    			append_dev(div8, div7);
    			mount_component(modal1, div7, null);
    			append_dev(body, t9);
    			append_dev(body, div11);
    			if_block.m(div11, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			info.ctx = ctx;

    			if (dirty[0] & /*$Test*/ 32 && promise !== (promise = /*$Test*/ ctx[5]) && handle_promise(promise, info)) ; else {
    				const child_ctx = ctx.slice();
    				child_ctx[29] = info.resolved;
    				info.block.p(child_ctx, dirty);
    			}

    			const modal0_changes = {};

    			if (dirty[1] & /*$$scope*/ 64) {
    				modal0_changes.$$scope = { dirty, ctx };
    			}

    			modal0.$set(modal0_changes);
    			info_1.ctx = ctx;

    			if (dirty[0] & /*$Problem*/ 64 && promise_1 !== (promise_1 = /*$Problem*/ ctx[6]) && handle_promise(promise_1, info_1)) ; else {
    				const child_ctx = ctx.slice();
    				child_ctx[29] = info_1.resolved;
    				info_1.block.p(child_ctx, dirty);
    			}

    			const modal1_changes = {};

    			if (dirty[1] & /*$$scope*/ 64) {
    				modal1_changes.$$scope = { dirty, ctx };
    			}

    			modal1.$set(modal1_changes);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div11, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(modal0.$$.fragment, local);
    			transition_in(modal1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(modal0.$$.fragment, local);
    			transition_out(modal1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(link);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(body);
    			destroy_component(navbar);
    			info.block.d();
    			info.token = null;
    			info = null;
    			destroy_component(modal0);
    			info_1.block.d();
    			info_1.token = null;
    			info_1 = null;
    			destroy_component(modal1);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function getCookie$1(name) {
    	var match = document.cookie.match(new RegExp("(^| )" + name + "=([^;]+)"));
    	if (match) return match[2];
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let $Test;
    	let $Problem;
    	const client = getClient();
    	const tokens = cookieHandler.getCookie("access_token").split(".");
    	console.log(atob(tokens[1]));
    	const Test = query(client, { query: apolloClient.allTests });
    	validate_store(Test, "Test");
    	component_subscribe($$self, Test, value => $$invalidate(5, $Test = value));
    	const Problem = query(client, { query: apolloClient.getProblems });
    	validate_store(Problem, "Problem");
    	component_subscribe($$self, Problem, value => $$invalidate(6, $Problem = value));

    	const handleProblemAdd = () => {
    		Problem.refetch();
    	};

    	const handleTestAdd = () => {
    		Test.refetch();
    	};

    	let hasJoinedChat = false;
    	let channels = [""];
    	let username = "";
    	let newMessage = "";
    	let messages = "";
    	let output = [""];

    	function joined() {
    		$$invalidate(0, hasJoinedChat = true);
    	}

    	function close() {
    		$$invalidate(0, hasJoinedChat = false);
    	}

    	const userEmail = getCookie$1("access_email");
    	let sEmails = userEmail.split("%");
    	let userName = sEmails[0];

    	const user = {
    		id: Math.floor(Math.random() * 10) + 1,
    		email: userName,
    		name: userName,
    		flag: "A",
    		ttl: 1440,
    		profileUrl: null
    	};

    	let channelName = "channel." + userName;
    	console.log(channelName);

    	pubnub.addListener({
    		message(m) {
    			let flag = true;

    			for (let i = 0; i < channels.length; i++) {
    				if (channels[i] == m.channel) {
    					flag = false;
    					break;
    				} else {
    					flag = true;
    				}
    			}

    			if (flag) {
    				console.log("different channel");
    				$$invalidate(3, output = [m.message]);
    				$$invalidate(1, channels = [...channels, m.channel]);
    				$$invalidate(2, newMessage = "");
    			} else {
    				$$invalidate(3, output = [...output, m.message]);
    				$$invalidate(2, newMessage = "");
    			}
    		}
    	});

    	grantPermissions(user);

    	//subscribe("newUserr.com");
    	const changeChannel = m => {
    		$$invalidate(4, channelName = m.channel);
    	};

    	function input_input_handler() {
    		newMessage = this.value;
    		$$invalidate(2, newMessage);
    	}

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("hasJoinedChat" in $$props) $$invalidate(0, hasJoinedChat = $$props.hasJoinedChat);
    		if ("channels" in $$props) $$invalidate(1, channels = $$props.channels);
    		if ("username" in $$props) username = $$props.username;
    		if ("newMessage" in $$props) $$invalidate(2, newMessage = $$props.newMessage);
    		if ("messages" in $$props) messages = $$props.messages;
    		if ("output" in $$props) $$invalidate(3, output = $$props.output);
    		if ("sEmails" in $$props) sEmails = $$props.sEmails;
    		if ("userName" in $$props) $$invalidate(13, userName = $$props.userName);
    		if ("channelName" in $$props) $$invalidate(4, channelName = $$props.channelName);
    		if ("$Test" in $$props) Test.set($Test = $$props.$Test);
    		if ("$Problem" in $$props) Problem.set($Problem = $$props.$Problem);
    	};

    	return [
    		hasJoinedChat,
    		channels,
    		newMessage,
    		output,
    		channelName,
    		$Test,
    		$Problem,
    		Test,
    		Problem,
    		handleProblemAdd,
    		handleTestAdd,
    		joined,
    		close,
    		userName,
    		changeChannel,
    		client,
    		tokens,
    		username,
    		messages,
    		userEmail,
    		sEmails,
    		user,
    		input_input_handler
    	];
    }

    class Admin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, {}, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Admin",
    			options,
    			id: create_fragment$e.name
    		});
    	}
    }

    /* src/routes/Login.svelte generated by Svelte v3.18.1 */

    const file$c = "src/routes/Login.svelte";

    function create_fragment$f(ctx) {
    	let link;
    	let t0;
    	let body;
    	let div5;
    	let div2;
    	let div1;
    	let h2;
    	let t2;
    	let p0;
    	let t4;
    	let a;
    	let div0;
    	let svg;
    	let path0;
    	let path1;
    	let path2;
    	let path3;
    	let t5;
    	let h1;
    	let t7;
    	let div4;
    	let img;
    	let img_src_value;
    	let t8;
    	let div3;
    	let p1;

    	const block = {
    		c: function create() {
    			link = element("link");
    			t0 = space();
    			body = element("body");
    			div5 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			h2 = element("h2");
    			h2.textContent = "Hey Admin";
    			t2 = space();
    			p0 = element("p");
    			p0.textContent = "Welcome back!";
    			t4 = space();
    			a = element("a");
    			div0 = element("div");
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			path3 = svg_element("path");
    			t5 = space();
    			h1 = element("h1");
    			h1.textContent = "Sign in with Google";
    			t7 = space();
    			div4 = element("div");
    			img = element("img");
    			t8 = space();
    			div3 = element("div");
    			p1 = element("p");
    			p1.textContent = "Try Out.";
    			attr_dev(link, "href", "https://unpkg.com/tailwindcss@^1.0/dist/tailwind.min.css");
    			attr_dev(link, "rel", "stylesheet");
    			add_location(link, file$c, 67, 0, 3074);
    			attr_dev(h2, "class", "text-2xl font-semibold text-gray-700 text-center");
    			add_location(h2, file$c, 81, 8, 3474);
    			attr_dev(p0, "class", "text-xl text-gray-600 text-center");
    			add_location(p0, file$c, 84, 8, 3578);
    			attr_dev(path0, "d", "M36.3425 16.7358H35V16.6667H20V23.3333H29.4192C28.045 27.2142\n                24.3525 30 20 30C14.4775 30 10 25.5225 10 20C10 14.4775 14.4775\n                9.99999 20 9.99999C22.5492 9.99999 24.8683 10.9617 26.6342\n                12.5325L31.3483 7.81833C28.3717 5.04416 24.39 3.33333 20\n                3.33333C10.7958 3.33333 3.33335 10.7958 3.33335 20C3.33335\n                29.2042 10.7958 36.6667 20 36.6667C29.2042 36.6667 36.6667\n                29.2042 36.6667 20C36.6667 18.8825 36.5517 17.7917 36.3425\n                16.7358Z");
    			attr_dev(path0, "fill", "#FFC107");
    			add_location(path0, file$c, 91, 14, 3922);
    			attr_dev(path1, "d", "M5.25497 12.2425L10.7308 16.2583C12.2125 12.59 15.8008\n                9.99999 20 9.99999C22.5491 9.99999 24.8683 10.9617 26.6341\n                12.5325L31.3483 7.81833C28.3716 5.04416 24.39 3.33333 20\n                3.33333C13.5983 3.33333 8.04663 6.94749 5.25497 12.2425Z");
    			attr_dev(path1, "fill", "#FF3D00");
    			add_location(path1, file$c, 101, 14, 4536);
    			attr_dev(path2, "d", "M20 36.6667C24.305 36.6667 28.2167 35.0192 31.1742\n                32.34L26.0159 27.975C24.3425 29.2425 22.2625 30 20 30C15.665 30\n                11.9842 27.2359 10.5975 23.3784L5.16254 27.5659C7.92087 32.9634\n                13.5225 36.6667 20 36.6667Z");
    			attr_dev(path2, "fill", "#4CAF50");
    			add_location(path2, file$c, 107, 14, 4886);
    			attr_dev(path3, "d", "M36.3425 16.7358H35V16.6667H20V23.3333H29.4192C28.7592\n                25.1975 27.56 26.805 26.0133 27.9758C26.0142 27.975 26.015\n                27.975 26.0158 27.9742L31.1742 32.3392C30.8092 32.6708 36.6667\n                28.3333 36.6667 20C36.6667 18.8825 36.5517 17.7917 36.3425\n                16.7358Z");
    			attr_dev(path3, "fill", "#1976D2");
    			add_location(path3, file$c, 113, 14, 5215);
    			attr_dev(svg, "class", "h-6 w-6");
    			attr_dev(svg, "viewBox", "0 0 40 40");
    			add_location(svg, file$c, 90, 12, 3866);
    			attr_dev(div0, "class", "px-4 py-3");
    			add_location(div0, file$c, 89, 10, 3830);
    			attr_dev(h1, "class", "px-4 py-3 w-5/6 text-center text-gray-600 font-bold");
    			add_location(h1, file$c, 122, 10, 5630);
    			attr_dev(a, "href", "http://localhost:3000/auth/google");
    			attr_dev(a, "class", "flex items-center justify-center mt-4 text-white rounded-lg\n          shadow-md hover:bg-gray-100");
    			add_location(a, file$c, 85, 8, 3649);
    			attr_dev(div1, "class", "flex flex-col justify-center md:justify-start w-full p-8 lg:w-1/2\n        m-64 lg:px-32 my-auto pt-8 ");
    			add_location(div1, file$c, 78, 6, 3342);
    			attr_dev(div2, "class", "w-full md:w-1/2 flex flex-col");
    			add_location(div2, file$c, 76, 4, 3291);
    			attr_dev(img, "alt", "acchi picture");
    			attr_dev(img, "class", "object-cover w-full h-screen hidden md:block");
    			if (img.src !== (img_src_value = "https://source.unsplash.com/IXUM4cJynP0")) attr_dev(img, "src", img_src_value);
    			add_location(img, file$c, 133, 6, 5861);
    			attr_dev(p1, "class", "line-1 anim-typewriter font-semibold text-gray-900 svelte-1imoluh");
    			set_style(p1, "font-size", "70px");
    			add_location(p1, file$c, 138, 8, 6049);
    			attr_dev(div3, "class", "centered svelte-1imoluh");
    			add_location(div3, file$c, 137, 6, 6018);
    			attr_dev(div4, "class", "container w-1/2 shadow-2xl svelte-1imoluh");
    			add_location(div4, file$c, 132, 4, 5814);
    			attr_dev(div5, "class", "w-full flex flex-wrap");
    			add_location(div5, file$c, 73, 2, 3223);
    			attr_dev(body, "class", "bg-white font-family-karla h-screen svelte-1imoluh");
    			add_location(body, file$c, 71, 0, 3169);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, link, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, body, anchor);
    			append_dev(body, div5);
    			append_dev(div5, div2);
    			append_dev(div2, div1);
    			append_dev(div1, h2);
    			append_dev(div1, t2);
    			append_dev(div1, p0);
    			append_dev(div1, t4);
    			append_dev(div1, a);
    			append_dev(a, div0);
    			append_dev(div0, svg);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    			append_dev(svg, path2);
    			append_dev(svg, path3);
    			append_dev(a, t5);
    			append_dev(a, h1);
    			append_dev(div5, t7);
    			append_dev(div5, div4);
    			append_dev(div4, img);
    			append_dev(div4, t8);
    			append_dev(div4, div3);
    			append_dev(div3, p1);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(link);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(body);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    class Login extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, null, create_fragment$f, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Login",
    			options,
    			id: create_fragment$f.name
    		});
    	}
    }

    /* src/routes/Problems.svelte generated by Svelte v3.18.1 */

    const { console: console_1$2 } = globals;
    const file$d = "src/routes/Problems.svelte";

    // (126:4) {:catch err}
    function create_catch_block$2(ctx) {
    	let t0;
    	let t1_value = /*err*/ ctx[7] + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("Error : ");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$problem*/ 2 && t1_value !== (t1_value = /*err*/ ctx[7] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block$2.name,
    		type: "catch",
    		source: "(126:4) {:catch err}",
    		ctx
    	});

    	return block;
    }

    // (57:4) {:then result}
    function create_then_block$2(ctx) {
    	let div3;
    	let div0;
    	let t0_value = /*result*/ ctx[6].data.problemById.problemName + "";
    	let t0;
    	let t1;
    	let div1;
    	let t2;
    	let t3_value = /*result*/ ctx[6].data.problemById.datalimit + "";
    	let t3;
    	let t4;
    	let t5;
    	let div2;
    	let t6;
    	let t7_value = /*result*/ ctx[6].data.problemById.timelimit + "";
    	let t7;
    	let t8;
    	let t9;
    	let div10;
    	let div9;
    	let div8;
    	let div4;
    	let label0;
    	let t11;
    	let p0;
    	let t12_value = /*result*/ ctx[6].data.problemById.description + "";
    	let t12;
    	let t13;
    	let div5;
    	let label1;
    	let t15;
    	let textarea0;
    	let textarea0_value_value;
    	let t16;
    	let div6;
    	let label2;
    	let t18;
    	let textarea1;
    	let textarea1_value_value;
    	let t19;
    	let div7;
    	let label3;
    	let t21;
    	let p1;
    	let t22_value = /*result*/ ctx[6].data.problemById.tags + "";
    	let t22;
    	let t23;
    	let div12;
    	let div11;
    	let button0;
    	let t25;
    	let button1;
    	let dispose;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			t2 = text("Data Limit :- ");
    			t3 = text(t3_value);
    			t4 = text(" Mb");
    			t5 = space();
    			div2 = element("div");
    			t6 = text("Time Limit :- ");
    			t7 = text(t7_value);
    			t8 = text(" ms");
    			t9 = space();
    			div10 = element("div");
    			div9 = element("div");
    			div8 = element("div");
    			div4 = element("div");
    			label0 = element("label");
    			label0.textContent = "Description";
    			t11 = space();
    			p0 = element("p");
    			t12 = text(t12_value);
    			t13 = space();
    			div5 = element("div");
    			label1 = element("label");
    			label1.textContent = "TestCases";
    			t15 = space();
    			textarea0 = element("textarea");
    			t16 = space();
    			div6 = element("div");
    			label2 = element("label");
    			label2.textContent = "Solution";
    			t18 = space();
    			textarea1 = element("textarea");
    			t19 = space();
    			div7 = element("div");
    			label3 = element("label");
    			label3.textContent = "Tags";
    			t21 = space();
    			p1 = element("p");
    			t22 = text(t22_value);
    			t23 = space();
    			div12 = element("div");
    			div11 = element("div");
    			button0 = element("button");
    			button0.textContent = "Edit";
    			t25 = space();
    			button1 = element("button");
    			button1.textContent = "Delete";
    			attr_dev(div0, "class", "font-bold text-2xl text-elight mx-auto svelte-1xwh2qq");
    			add_location(div0, file$d, 58, 8, 1977);
    			attr_dev(div1, "class", " text-xl text-elight mx-auto svelte-1xwh2qq");
    			add_location(div1, file$d, 61, 8, 2101);
    			attr_dev(div2, "class", " text-xl text-elight mx-auto svelte-1xwh2qq");
    			add_location(div2, file$d, 64, 8, 2230);
    			attr_dev(div3, "class", "mx-auto mt-8 max-w-xl flex flex-col svelte-1xwh2qq");
    			add_location(div3, file$d, 57, 6, 1919);
    			attr_dev(label0, "class", " text-2xl text-elight mb-3 my-2 svelte-1xwh2qq");
    			add_location(label0, file$d, 73, 14, 2565);
    			attr_dev(p0, "class", "text-xl text-elight svelte-1xwh2qq");
    			add_location(p0, file$d, 74, 14, 2646);
    			attr_dev(div4, "class", "w-full h-full px-3 flex flex-col svelte-1xwh2qq");
    			add_location(div4, file$d, 72, 12, 2504);
    			attr_dev(label1, "class", " text-2xl text-elight mb-3 my-2 svelte-1xwh2qq");
    			add_location(label1, file$d, 80, 14, 2844);
    			textarea0.value = textarea0_value_value = JSON.parse(/*result*/ ctx[6].data.problemById.problemTests);
    			attr_dev(textarea0, "class", " w-full bg-edark flex-grow text-elight text-2xl border\n                rounded py-3 px-4 mb-3 leading-tight focus:outline-none\n                focus:border-white h-48 resize-none svelte-1xwh2qq");
    			attr_dev(textarea0, "id", "message");
    			textarea0.readOnly = true;
    			add_location(textarea0, file$d, 81, 14, 2923);
    			attr_dev(div5, "class", "w-full h-full px-3 flex flex-col svelte-1xwh2qq");
    			add_location(div5, file$d, 79, 12, 2783);
    			attr_dev(label2, "class", " text-2xl text-elight mb-3 my-2 svelte-1xwh2qq");
    			add_location(label2, file$d, 90, 14, 3358);
    			textarea1.value = textarea1_value_value = /*result*/ ctx[6].data.problemById.solution;
    			attr_dev(textarea1, "class", " flex-grow w-full bg-edark text-elight text-2xl border\n                rounded py-3 px-4 mb-3 leading-tight focus:outline-none\n                focus:border-white h-48 resize-none svelte-1xwh2qq");
    			attr_dev(textarea1, "id", "message");
    			textarea1.readOnly = true;
    			add_location(textarea1, file$d, 91, 14, 3436);
    			attr_dev(div6, "class", "flex flex-col w-full h-full px-3 svelte-1xwh2qq");
    			add_location(div6, file$d, 89, 12, 3297);
    			attr_dev(label3, "class", " text-2xl text-elight mb-3 my-2 svelte-1xwh2qq");
    			add_location(label3, file$d, 101, 14, 3856);
    			attr_dev(p1, "class", "text-xl text-elight svelte-1xwh2qq");
    			add_location(p1, file$d, 102, 14, 3930);
    			attr_dev(div7, "class", "w-full h-full px-3 flex flex-col svelte-1xwh2qq");
    			add_location(div7, file$d, 100, 12, 3795);
    			attr_dev(div8, "class", "px-12 py-8 svelte-1xwh2qq");
    			add_location(div8, file$d, 71, 10, 2467);
    			attr_dev(div9, "class", "rounded shadow-lg svelte-1xwh2qq");
    			add_location(div9, file$d, 70, 8, 2425);
    			attr_dev(div10, "class", "bg-dark max-w-6xl mt-12 mx-auto svelte-1xwh2qq");
    			add_location(div10, file$d, 68, 6, 2370);
    			attr_dev(button0, "class", "savebutton hover:bg-white hover:text-edark font-bold py-2\n            px-4 border rounded svelte-1xwh2qq");
    			add_location(button0, file$d, 109, 10, 4168);
    			attr_dev(button1, "class", "savebutton hover:bg-white hover:text-edark font-bold py-2\n            px-4 border rounded svelte-1xwh2qq");
    			add_location(button1, file$d, 117, 10, 4479);
    			attr_dev(div11, "class", "float-right  svelte-1xwh2qq");
    			add_location(div11, file$d, 108, 8, 4131);
    			attr_dev(div12, "class", "max-w-6xl my-4 mb-32 flex flex-col mx-auto svelte-1xwh2qq");
    			add_location(div12, file$d, 107, 6, 4066);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div0, t0);
    			append_dev(div3, t1);
    			append_dev(div3, div1);
    			append_dev(div1, t2);
    			append_dev(div1, t3);
    			append_dev(div1, t4);
    			append_dev(div3, t5);
    			append_dev(div3, div2);
    			append_dev(div2, t6);
    			append_dev(div2, t7);
    			append_dev(div2, t8);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, div10, anchor);
    			append_dev(div10, div9);
    			append_dev(div9, div8);
    			append_dev(div8, div4);
    			append_dev(div4, label0);
    			append_dev(div4, t11);
    			append_dev(div4, p0);
    			append_dev(p0, t12);
    			append_dev(div8, t13);
    			append_dev(div8, div5);
    			append_dev(div5, label1);
    			append_dev(div5, t15);
    			append_dev(div5, textarea0);
    			append_dev(div8, t16);
    			append_dev(div8, div6);
    			append_dev(div6, label2);
    			append_dev(div6, t18);
    			append_dev(div6, textarea1);
    			append_dev(div8, t19);
    			append_dev(div8, div7);
    			append_dev(div7, label3);
    			append_dev(div7, t21);
    			append_dev(div7, p1);
    			append_dev(p1, t22);
    			insert_dev(target, t23, anchor);
    			insert_dev(target, div12, anchor);
    			append_dev(div12, div11);
    			append_dev(div11, button0);
    			append_dev(div11, t25);
    			append_dev(div11, button1);

    			dispose = [
    				listen_dev(button0, "click", /*click_handler*/ ctx[5], false, false, false),
    				listen_dev(button1, "click", /*deleteProblemHandler*/ ctx[3], false, false, false)
    			];
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$problem*/ 2 && t0_value !== (t0_value = /*result*/ ctx[6].data.problemById.problemName + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$problem*/ 2 && t3_value !== (t3_value = /*result*/ ctx[6].data.problemById.datalimit + "")) set_data_dev(t3, t3_value);
    			if (dirty & /*$problem*/ 2 && t7_value !== (t7_value = /*result*/ ctx[6].data.problemById.timelimit + "")) set_data_dev(t7, t7_value);
    			if (dirty & /*$problem*/ 2 && t12_value !== (t12_value = /*result*/ ctx[6].data.problemById.description + "")) set_data_dev(t12, t12_value);

    			if (dirty & /*$problem*/ 2 && textarea0_value_value !== (textarea0_value_value = JSON.parse(/*result*/ ctx[6].data.problemById.problemTests))) {
    				prop_dev(textarea0, "value", textarea0_value_value);
    			}

    			if (dirty & /*$problem*/ 2 && textarea1_value_value !== (textarea1_value_value = /*result*/ ctx[6].data.problemById.solution)) {
    				prop_dev(textarea1, "value", textarea1_value_value);
    			}

    			if (dirty & /*$problem*/ 2 && t22_value !== (t22_value = /*result*/ ctx[6].data.problemById.tags + "")) set_data_dev(t22, t22_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(div10);
    			if (detaching) detach_dev(t23);
    			if (detaching) detach_dev(div12);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block$2.name,
    		type: "then",
    		source: "(57:4) {:then result}",
    		ctx
    	});

    	return block;
    }

    // (55:21)        Loading...     {:then result}
    function create_pending_block$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Loading...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block$2.name,
    		type: "pending",
    		source: "(55:21)        Loading...     {:then result}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let link;
    	let t0;
    	let div1;
    	let header;
    	let t1;
    	let div0;
    	let promise;
    	let current;
    	const navbar = new Navbar({ $$inline: true });

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		pending: create_pending_block$2,
    		then: create_then_block$2,
    		catch: create_catch_block$2,
    		value: 6,
    		error: 7
    	};

    	handle_promise(promise = /*$problem*/ ctx[1], info);

    	const block = {
    		c: function create() {
    			link = element("link");
    			t0 = space();
    			div1 = element("div");
    			header = element("header");
    			create_component(navbar.$$.fragment);
    			t1 = space();
    			div0 = element("div");
    			info.block.c();
    			attr_dev(link, "href", "https://unpkg.com/tailwindcss@^1.0/dist/tailwind.min.css");
    			attr_dev(link, "rel", "stylesheet");
    			attr_dev(link, "class", "svelte-1xwh2qq");
    			add_location(link, file$d, 45, 0, 1603);
    			attr_dev(header, "class", "svelte-1xwh2qq");
    			add_location(header, file$d, 50, 2, 1755);
    			attr_dev(div0, "class", "bg-edark flex flex-col max-w-full overflow-auto svelte-1xwh2qq");
    			add_location(div0, file$d, 53, 2, 1793);
    			attr_dev(div1, "class", "bg-edark h-full flex flex-col box-border svelte-1xwh2qq");
    			add_location(div1, file$d, 49, 0, 1698);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, link, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, header);
    			mount_component(navbar, header, null);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			info.block.m(div0, info.anchor = null);
    			info.mount = () => div0;
    			info.anchor = null;
    			current = true;
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			info.ctx = ctx;

    			if (dirty & /*$problem*/ 2 && promise !== (promise = /*$problem*/ ctx[1]) && handle_promise(promise, info)) ; else {
    				const child_ctx = ctx.slice();
    				child_ctx[6] = info.resolved;
    				info.block.p(child_ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(link);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div1);
    			destroy_component(navbar);
    			info.block.d();
    			info.token = null;
    			info = null;
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let $problem;
    	let { currentRoute } = $$props;
    	console.log(currentRoute);
    	const client = getClient();

    	const problem = query(client, {
    		query: apolloClient.getProblemById,
    		variables: {
    			id: parseInt(currentRoute.namedParams.id)
    		}
    	});

    	validate_store(problem, "problem");
    	component_subscribe($$self, problem, value => $$invalidate(1, $problem = value));

    	async function deleteProblemHandler() {
    		try {
    			console.log("ddd");

    			mutate(client, {
    				mutation: apolloClient.deleteProblem,
    				variables: {
    					id: parseInt(currentRoute.namedParams.id)
    				}
    			});

    			console.log("hp");
    			location.replace("http://localhost:5000/admin");
    		} catch(err) {
    		}
    	}

    	const writable_props = ["currentRoute"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$2.warn(`<Problems> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		location.replace(`http://localhost:5000/editProblem/${currentRoute.namedParams.id}`);
    	};

    	$$self.$set = $$props => {
    		if ("currentRoute" in $$props) $$invalidate(0, currentRoute = $$props.currentRoute);
    	};

    	$$self.$capture_state = () => {
    		return { currentRoute, $problem };
    	};

    	$$self.$inject_state = $$props => {
    		if ("currentRoute" in $$props) $$invalidate(0, currentRoute = $$props.currentRoute);
    		if ("$problem" in $$props) problem.set($problem = $$props.$problem);
    	};

    	return [currentRoute, $problem, problem, deleteProblemHandler, client, click_handler];
    }

    class Problems extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$f, create_fragment$g, safe_not_equal, { currentRoute: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Problems",
    			options,
    			id: create_fragment$g.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*currentRoute*/ ctx[0] === undefined && !("currentRoute" in props)) {
    			console_1$2.warn("<Problems> was created without expected prop 'currentRoute'");
    		}
    	}

    	get currentRoute() {
    		throw new Error("<Problems>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set currentRoute(value) {
    		throw new Error("<Problems>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/routes/Tests.svelte generated by Svelte v3.18.1 */

    const { console: console_1$3 } = globals;
    const file$e = "src/routes/Tests.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[12] = list[i];
    	return child_ctx;
    }

    // (179:4) {:catch err}
    function create_catch_block_1$1(ctx) {
    	let t0;
    	let t1_value = /*err*/ ctx[9] + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("Error: ");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$test*/ 1 && t1_value !== (t1_value = /*err*/ ctx[9] + "")) set_data_dev(t1, t1_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block_1$1.name,
    		type: "catch",
    		source: "(179:4) {:catch err}",
    		ctx
    	});

    	return block;
    }

    // (80:4) {:then result}
    function create_then_block$3(ctx) {
    	let t0;
    	let div16;
    	let div13;
    	let div5;
    	let div4;
    	let div3;
    	let br0;
    	let t1;
    	let div2;
    	let div1;
    	let div0;
    	let t2_value = /*result*/ ctx[8].data.testById.testName + "";
    	let t2;
    	let t3;
    	let p0;
    	let t5;
    	let p1;
    	let t6_value = /*result*/ ctx[8].data.testById.difficultyLevel + "";
    	let t6;
    	let t7;
    	let br1;
    	let t8;
    	let br2;
    	let t9;
    	let p2;
    	let t11;
    	let ul;
    	let t12;
    	let div12;
    	let div11;
    	let div10;
    	let div9;
    	let div8;
    	let div7;
    	let div6;
    	let t14;
    	let ol;
    	let promise;
    	let t15;
    	let div15;
    	let div14;
    	let button0;
    	let t17;
    	let a;
    	let button1;
    	let a_href_value;
    	let t19;
    	let button2;
    	let current;
    	let dispose;
    	const navbar = new Navbar({ $$inline: true });
    	let each_value_1 = /*result*/ ctx[8].data.testById.problems;
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		pending: create_pending_block_1$1,
    		then: create_then_block_1$1,
    		catch: create_catch_block$3,
    		value: 8,
    		error: 9
    	};

    	handle_promise(promise = /*$attempt*/ ctx[1], info);

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[7](/*result*/ ctx[8], ...args);
    	}

    	const block = {
    		c: function create() {
    			create_component(navbar.$$.fragment);
    			t0 = space();
    			div16 = element("div");
    			div13 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			div3 = element("div");
    			br0 = element("br");
    			t1 = space();
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t2 = text(t2_value);
    			t3 = space();
    			p0 = element("p");
    			p0.textContent = "Difficulty Level :";
    			t5 = space();
    			p1 = element("p");
    			t6 = text(t6_value);
    			t7 = space();
    			br1 = element("br");
    			t8 = space();
    			br2 = element("br");
    			t9 = space();
    			p2 = element("p");
    			p2.textContent = "Problems :";
    			t11 = space();
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t12 = space();
    			div12 = element("div");
    			div11 = element("div");
    			div10 = element("div");
    			div9 = element("div");
    			div8 = element("div");
    			div7 = element("div");
    			div6 = element("div");
    			div6.textContent = "Test Submission";
    			t14 = space();
    			ol = element("ol");
    			info.block.c();
    			t15 = space();
    			div15 = element("div");
    			div14 = element("div");
    			button0 = element("button");
    			button0.textContent = "Edit";
    			t17 = space();
    			a = element("a");
    			button1 = element("button");
    			button1.textContent = "Send Test";
    			t19 = space();
    			button2 = element("button");
    			button2.textContent = "Delete";
    			attr_dev(br0, "class", "my-24");
    			add_location(br0, file$e, 89, 16, 3114);
    			attr_dev(div0, "class", "font-bold text-3xl mb-2");
    			add_location(div0, file$e, 93, 20, 3262);
    			attr_dev(div1, "class", "flex-initial text-center px-4 py-2 m-2");
    			add_location(div1, file$e, 92, 18, 3189);
    			attr_dev(div2, "class", "flex");
    			add_location(div2, file$e, 91, 16, 3152);
    			attr_dev(p0, "class", "font-bold text-2xl mb-2");
    			add_location(p0, file$e, 99, 16, 3446);
    			attr_dev(p1, "class", "text-gray-700 text-2xl");
    			add_location(p1, file$e, 100, 16, 3520);
    			add_location(br1, file$e, 103, 16, 3649);
    			add_location(br2, file$e, 104, 16, 3672);
    			attr_dev(p2, "class", "font-bold text-2xl mb-2");
    			add_location(p2, file$e, 105, 16, 3695);
    			add_location(ul, file$e, 106, 16, 3761);
    			attr_dev(div3, "class", "px-12 py-8");
    			add_location(div3, file$e, 87, 14, 3072);
    			attr_dev(div4, "class", "max-w-auto rounded overflow-hidden shadow-lg");
    			add_location(div4, file$e, 86, 12, 2999);
    			attr_dev(div5, "class", "p-8 mx-2 mt-24 items-center");
    			add_location(div5, file$e, 85, 10, 2945);
    			attr_dev(div6, "class", "font-bold text-3xl mb-2");
    			add_location(div6, file$e, 129, 22, 4560);
    			attr_dev(div7, "class", "flex-initial text-center px-4 py-2 m-2");
    			add_location(div7, file$e, 128, 20, 4485);
    			attr_dev(div8, "class", "flex");
    			add_location(div8, file$e, 127, 18, 4446);
    			add_location(ol, file$e, 132, 18, 4689);
    			attr_dev(div9, "class", "px-6 py-4");
    			add_location(div9, file$e, 126, 16, 4404);
    			attr_dev(div10, "class", "max-w-auto rounded overflow-hidden shadow-lg");
    			add_location(div10, file$e, 125, 14, 4329);
    			attr_dev(div11, "class", "p-8 mx-2 mt-24 items-center");
    			add_location(div11, file$e, 124, 12, 4273);
    			attr_dev(div12, "class", "w-1/2 h-12");
    			add_location(div12, file$e, 123, 10, 4236);
    			attr_dev(div13, "class", "h-12 w-1/2");
    			add_location(div13, file$e, 83, 8, 2909);
    			attr_dev(button0, "class", "savebutton bg-red-500 hover:bg-red-700 text-white font-bold\n              py-2 px-4 border border-red-700 rounded svelte-whjnru");
    			add_location(button0, file$e, 152, 12, 5332);
    			attr_dev(button1, "class", "bg-red-500 hover:bg-red-700 text-white font-bold py-2\n                px-4 border border-red-700 rounded");
    			add_location(button1, file$e, 161, 14, 5756);
    			attr_dev(a, "href", a_href_value = "http://localhost:5000/sendtest/" + /*result*/ ctx[8].data.testById.id);
    			add_location(a, file$e, 160, 12, 5674);
    			attr_dev(button2, "class", "deleteButton bg-red-500 hover:bg-red-700 text-white\n              font-bold py-2 px-4 border border-red-700 rounded svelte-whjnru");
    			add_location(button2, file$e, 167, 12, 5973);
    			attr_dev(div14, "class", "flex buttonbox svelte-whjnru");
    			add_location(div14, file$e, 151, 10, 5291);
    			attr_dev(div15, "class", "px-4 py-2");
    			add_location(div15, file$e, 150, 8, 5257);
    			attr_dev(div16, "class", "flex mb-4 h-12");
    			add_location(div16, file$e, 82, 6, 2872);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbar, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div16, anchor);
    			append_dev(div16, div13);
    			append_dev(div13, div5);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div3, br0);
    			append_dev(div3, t1);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, t2);
    			append_dev(div3, t3);
    			append_dev(div3, p0);
    			append_dev(div3, t5);
    			append_dev(div3, p1);
    			append_dev(p1, t6);
    			append_dev(div3, t7);
    			append_dev(div3, br1);
    			append_dev(div3, t8);
    			append_dev(div3, br2);
    			append_dev(div3, t9);
    			append_dev(div3, p2);
    			append_dev(div3, t11);
    			append_dev(div3, ul);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			append_dev(div13, t12);
    			append_dev(div13, div12);
    			append_dev(div12, div11);
    			append_dev(div11, div10);
    			append_dev(div10, div9);
    			append_dev(div9, div8);
    			append_dev(div8, div7);
    			append_dev(div7, div6);
    			append_dev(div9, t14);
    			append_dev(div9, ol);
    			info.block.m(ol, info.anchor = null);
    			info.mount = () => ol;
    			info.anchor = null;
    			append_dev(div16, t15);
    			append_dev(div16, div15);
    			append_dev(div15, div14);
    			append_dev(div14, button0);
    			append_dev(div14, t17);
    			append_dev(div14, a);
    			append_dev(a, button1);
    			append_dev(div14, t19);
    			append_dev(div14, button2);
    			current = true;

    			dispose = [
    				listen_dev(button0, "click", click_handler, false, false, false),
    				listen_dev(button2, "click", /*deleteTestHandler*/ ctx[3], false, false, false)
    			];
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if ((!current || dirty & /*$test*/ 1) && t2_value !== (t2_value = /*result*/ ctx[8].data.testById.testName + "")) set_data_dev(t2, t2_value);
    			if ((!current || dirty & /*$test*/ 1) && t6_value !== (t6_value = /*result*/ ctx[8].data.testById.difficultyLevel + "")) set_data_dev(t6, t6_value);

    			if (dirty & /*$test*/ 1) {
    				each_value_1 = /*result*/ ctx[8].data.testById.problems;
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			info.ctx = ctx;

    			if (dirty & /*$attempt*/ 2 && promise !== (promise = /*$attempt*/ ctx[1]) && handle_promise(promise, info)) ; else {
    				const child_ctx = ctx.slice();
    				child_ctx[8] = info.resolved;
    				info.block.p(child_ctx, dirty);
    			}

    			if (!current || dirty & /*$test*/ 1 && a_href_value !== (a_href_value = "http://localhost:5000/sendtest/" + /*result*/ ctx[8].data.testById.id)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbar, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div16);
    			destroy_each(each_blocks, detaching);
    			info.block.d();
    			info.token = null;
    			info = null;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block$3.name,
    		type: "then",
    		source: "(80:4) {:then result}",
    		ctx
    	});

    	return block;
    }

    // (108:18) {#each result.data.testById.problems as problem}
    function create_each_block_1$1(ctx) {
    	let li;
    	let a;
    	let t0_value = /*problem*/ ctx[12].problemName + "";
    	let t0;
    	let a_href_value;
    	let t1;

    	const block = {
    		c: function create() {
    			li = element("li");
    			a = element("a");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(a, "target", "_blank");
    			attr_dev(a, "href", a_href_value = "http://localhost:5000/problem/" + /*problem*/ ctx[12].id);
    			add_location(a, file$e, 109, 22, 3901);
    			attr_dev(li, "class", "text-xl mb-2");
    			add_location(li, file$e, 108, 20, 3853);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, a);
    			append_dev(a, t0);
    			append_dev(li, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$test*/ 1 && t0_value !== (t0_value = /*problem*/ ctx[12].problemName + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*$test*/ 1 && a_href_value !== (a_href_value = "http://localhost:5000/problem/" + /*problem*/ ctx[12].id)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(108:18) {#each result.data.testById.problems as problem}",
    		ctx
    	});

    	return block;
    }

    // (142:20) {:catch err}
    function create_catch_block$3(ctx) {
    	let t0;
    	let t1_value = /*err*/ ctx[9] + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("Error: ");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$attempt*/ 2 && t1_value !== (t1_value = /*err*/ ctx[9] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block$3.name,
    		type: "catch",
    		source: "(142:20) {:catch err}",
    		ctx
    	});

    	return block;
    }

    // (136:20) {:then result}
    function create_then_block_1$1(ctx) {
    	let each_1_anchor;
    	let each_value = /*result*/ ctx[8].data.getAttempt;
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$attempt*/ 2) {
    				each_value = /*result*/ ctx[8].data.getAttempt;
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block_1$1.name,
    		type: "then",
    		source: "(136:20) {:then result}",
    		ctx
    	});

    	return block;
    }

    // (137:22) {#each result.data.getAttempt as attempt}
    function create_each_block$3(ctx) {
    	let label;
    	let li;
    	let t0_value = /*attempt*/ ctx[4].user.name + "";
    	let t0;
    	let t1;
    	let t2_value = /*attempt*/ ctx[4].score + "";
    	let t2;
    	let t3;

    	const block = {
    		c: function create() {
    			label = element("label");
    			li = element("li");
    			t0 = text(t0_value);
    			t1 = text(" :- ");
    			t2 = text(t2_value);
    			t3 = space();
    			add_location(li, file$e, 138, 26, 4922);
    			add_location(label, file$e, 137, 24, 4888);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label, anchor);
    			append_dev(label, li);
    			append_dev(li, t0);
    			append_dev(li, t1);
    			append_dev(li, t2);
    			append_dev(label, t3);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$attempt*/ 2 && t0_value !== (t0_value = /*attempt*/ ctx[4].user.name + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$attempt*/ 2 && t2_value !== (t2_value = /*attempt*/ ctx[4].score + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(137:22) {#each result.data.getAttempt as attempt}",
    		ctx
    	});

    	return block;
    }

    // (134:37)                        Loading...                     {:then result}
    function create_pending_block_1$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Loading...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block_1$1.name,
    		type: "pending",
    		source: "(134:37)                        Loading...                     {:then result}",
    		ctx
    	});

    	return block;
    }

    // (78:18)        Loading ...     {:then result}
    function create_pending_block$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Loading ...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block$3.name,
    		type: "pending",
    		source: "(78:18)        Loading ...     {:then result}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$h(ctx) {
    	let link;
    	let t;
    	let body;
    	let div;
    	let promise;
    	let current;

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		pending: create_pending_block$3,
    		then: create_then_block$3,
    		catch: create_catch_block_1$1,
    		value: 8,
    		error: 9,
    		blocks: [,,,]
    	};

    	handle_promise(promise = /*$test*/ ctx[0], info);

    	const block = {
    		c: function create() {
    			link = element("link");
    			t = space();
    			body = element("body");
    			div = element("div");
    			info.block.c();
    			attr_dev(link, "href", "https://unpkg.com/tailwindcss@^1.0/dist/tailwind.min.css");
    			attr_dev(link, "rel", "stylesheet");
    			add_location(link, file$e, 72, 0, 2631);
    			add_location(div, file$e, 76, 2, 2734);
    			add_location(body, file$e, 75, 0, 2725);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, link, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, body, anchor);
    			append_dev(body, div);
    			info.block.m(div, info.anchor = null);
    			info.mount = () => div;
    			info.anchor = null;
    			current = true;
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			info.ctx = ctx;

    			if (dirty & /*$test*/ 1 && promise !== (promise = /*$test*/ ctx[0]) && handle_promise(promise, info)) ; else {
    				const child_ctx = ctx.slice();
    				child_ctx[8] = info.resolved;
    				info.block.p(child_ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(info.block);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(link);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(body);
    			info.block.d();
    			info.token = null;
    			info = null;
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let $test;
    	let $attempt;
    	let { currentRoute } = $$props;
    	console.log(currentRoute);
    	const client = getClient();

    	const test = query(client, {
    		query: apolloClient.getTestById,
    		variables: {
    			id: parseInt(currentRoute.namedParams.id)
    		}
    	});

    	validate_store(test, "test");
    	component_subscribe($$self, test, value => $$invalidate(0, $test = value));

    	const attempt = query(client, {
    		query: apolloClient.getAttempts,
    		variables: { id: currentRoute.namedParams.id }
    	});

    	validate_store(attempt, "attempt");
    	component_subscribe($$self, attempt, value => $$invalidate(1, $attempt = value));

    	async function deleteTestHandler() {
    		try {
    			mutate(client, {
    				mutation: apolloClient.deleteTest,
    				variables: { id: currentRoute.namedParams.id }
    			});
    		} catch(err) {
    		}

    		location.replace("http://localhost:5000/admin");
    	}

    	const writable_props = ["currentRoute"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$3.warn(`<Tests> was created with unknown prop '${key}'`);
    	});

    	const click_handler = result => {
    		location.replace(`http://localhost:5000/editTest/${result.data.testById.id}`);
    	};

    	$$self.$set = $$props => {
    		if ("currentRoute" in $$props) $$invalidate(5, currentRoute = $$props.currentRoute);
    	};

    	$$self.$capture_state = () => {
    		return { currentRoute, $test, $attempt };
    	};

    	$$self.$inject_state = $$props => {
    		if ("currentRoute" in $$props) $$invalidate(5, currentRoute = $$props.currentRoute);
    		if ("$test" in $$props) test.set($test = $$props.$test);
    		if ("$attempt" in $$props) attempt.set($attempt = $$props.$attempt);
    	};

    	return [
    		$test,
    		$attempt,
    		test,
    		deleteTestHandler,
    		attempt,
    		currentRoute,
    		client,
    		click_handler
    	];
    }

    class Tests extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$h, safe_not_equal, { currentRoute: 5 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tests",
    			options,
    			id: create_fragment$h.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*currentRoute*/ ctx[5] === undefined && !("currentRoute" in props)) {
    			console_1$3.warn("<Tests> was created without expected prop 'currentRoute'");
    		}
    	}

    	get currentRoute() {
    		throw new Error("<Tests>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set currentRoute(value) {
    		throw new Error("<Tests>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/routes/send_test.svelte generated by Svelte v3.18.1 */

    const { console: console_1$4 } = globals;
    const file$f = "src/routes/send_test.svelte";

    // (151:8) {:catch err}
    function create_catch_block$4(ctx) {
    	let t0;
    	let t1_value = /*err*/ ctx[9] + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("Error : ");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$token*/ 4 && t1_value !== (t1_value = /*err*/ ctx[9] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block$4.name,
    		type: "catch",
    		source: "(151:8) {:catch err}",
    		ctx
    	});

    	return block;
    }

    // (82:8) {:then result}
    function create_then_block$4(ctx) {
    	let div7;
    	let div6;
    	let div2;
    	let div0;
    	let label0;
    	let t1;
    	let div1;
    	let input0;
    	let input0_value_value;
    	let t2;
    	let div5;
    	let div3;
    	let label1;
    	let t4;
    	let div4;
    	let input1;
    	let t5;
    	let div9;
    	let div8;
    	let button;
    	let dispose;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[7](/*result*/ ctx[8], ...args);
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			label0 = element("label");
    			label0.textContent = "Test Link";
    			t1 = space();
    			div1 = element("div");
    			input0 = element("input");
    			t2 = space();
    			div5 = element("div");
    			div3 = element("div");
    			label1 = element("label");
    			label1.textContent = "Email";
    			t4 = space();
    			div4 = element("div");
    			input1 = element("input");
    			t5 = space();
    			div9 = element("div");
    			div8 = element("div");
    			button = element("button");
    			button.textContent = "Send Test";
    			attr_dev(label0, "class", "block text-gray-500 font-bold md:text-right mb-1\n                    md:mb-0 pr-4");
    			attr_dev(label0, "for", "inline-full-name");
    			add_location(label0, file$f, 87, 18, 3157);
    			attr_dev(div0, "class", "md:w-1/5");
    			add_location(div0, file$f, 86, 16, 3116);
    			attr_dev(input0, "class", "bg-gray-200 appearance-none border-2 border-gray-200\n                    rounded w-full py-2 px-4 text-gray-700 leading-tight\n                    focus:outline-none focus:bg-white focus:border-purple-500");
    			attr_dev(input0, "id", "inline-full-name");
    			attr_dev(input0, "type", "text");
    			input0.value = input0_value_value = "localhost:5000/givetest/" + /*result*/ ctx[8].data.getToken.token;
    			input0.readOnly = true;
    			add_location(input0, file$f, 95, 18, 3455);
    			attr_dev(div1, "class", "md:w-3/5");
    			add_location(div1, file$f, 94, 16, 3414);
    			attr_dev(div2, "class", "md:flex md:items-center mb-6");
    			add_location(div2, file$f, 85, 14, 3057);
    			attr_dev(label1, "class", "block text-gray-500 font-bold md:text-right mb-1\n                    md:mb-0 pr-4");
    			attr_dev(label1, "for", "inline-full-name");
    			add_location(label1, file$f, 107, 18, 4039);
    			attr_dev(div3, "class", "md:w-1/5");
    			add_location(div3, file$f, 106, 16, 3998);
    			attr_dev(input1, "class", "bg-gray-200 appearance-none border-2 border-gray-200\n                    rounded w-full py-2 px-4 text-gray-700 leading-tight\n                    focus:outline-none focus:bg-white focus:border-purple-500");
    			attr_dev(input1, "id", "inline-full-name");
    			attr_dev(input1, "type", "text");
    			attr_dev(input1, "placeholder", "Enter Email");
    			add_location(input1, file$f, 115, 18, 4333);
    			attr_dev(div4, "class", "md:w-3/5");
    			add_location(div4, file$f, 114, 16, 4292);
    			attr_dev(div5, "class", "md:flex md:items-center mb-6");
    			add_location(div5, file$f, 105, 14, 3939);
    			attr_dev(div6, "class", "max-w-auto rounded overflow-hidden shadow-lg");
    			add_location(div6, file$f, 84, 12, 2984);
    			attr_dev(div7, "class", "p-8 mx-2 mt-24 items-center");
    			add_location(div7, file$f, 83, 10, 2930);
    			attr_dev(button, "class", "bg-red-500 hover:bg-red-700 text-white font-bold py-2\n                px-4 border border-red-700 rounded");
    			add_location(button, file$f, 129, 14, 4903);
    			attr_dev(div8, "class", "flex buttonbox svelte-1icsd5l");
    			add_location(div8, file$f, 128, 12, 4860);
    			attr_dev(div9, "class", "px-4 py-2");
    			add_location(div9, file$f, 127, 10, 4824);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div2);
    			append_dev(div2, div0);
    			append_dev(div0, label0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, input0);
    			append_dev(div6, t2);
    			append_dev(div6, div5);
    			append_dev(div5, div3);
    			append_dev(div3, label1);
    			append_dev(div5, t4);
    			append_dev(div5, div4);
    			append_dev(div4, input1);
    			set_input_value(input1, /*email*/ ctx[0]);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, div9, anchor);
    			append_dev(div9, div8);
    			append_dev(div8, button);

    			dispose = [
    				listen_dev(input1, "input", /*input1_input_handler*/ ctx[6]),
    				listen_dev(button, "click", click_handler, false, false, false)
    			];
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*$token*/ 4 && input0_value_value !== (input0_value_value = "localhost:5000/givetest/" + /*result*/ ctx[8].data.getToken.token) && input0.value !== input0_value_value) {
    				prop_dev(input0, "value", input0_value_value);
    			}

    			if (dirty & /*email*/ 1 && input1.value !== /*email*/ ctx[0]) {
    				set_input_value(input1, /*email*/ ctx[0]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(div9);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block$4.name,
    		type: "then",
    		source: "(82:8) {:then result}",
    		ctx
    	});

    	return block;
    }

    // (80:23)            Loading...         {:then result}
    function create_pending_block$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Loading...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block$4.name,
    		type: "pending",
    		source: "(80:23)            Loading...         {:then result}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$i(ctx) {
    	let link;
    	let t0;
    	let body;
    	let div2;
    	let t1;
    	let h1;
    	let strong;
    	let t3;
    	let div1;
    	let div0;
    	let promise;
    	let current;
    	const navbar = new Navbar({ $$inline: true });

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		pending: create_pending_block$4,
    		then: create_then_block$4,
    		catch: create_catch_block$4,
    		value: 8,
    		error: 9
    	};

    	handle_promise(promise = /*$token*/ ctx[2], info);

    	const block = {
    		c: function create() {
    			link = element("link");
    			t0 = space();
    			body = element("body");
    			div2 = element("div");
    			create_component(navbar.$$.fragment);
    			t1 = space();
    			h1 = element("h1");
    			strong = element("strong");
    			strong.textContent = "Send Test";
    			t3 = space();
    			div1 = element("div");
    			div0 = element("div");
    			info.block.c();
    			attr_dev(link, "href", "https://unpkg.com/tailwindcss@^1.0/dist/tailwind.min.css");
    			attr_dev(link, "rel", "stylesheet");
    			add_location(link, file$f, 67, 0, 2564);
    			add_location(strong, file$f, 75, 6, 2770);
    			attr_dev(h1, "class", "heading svelte-1icsd5l");
    			add_location(h1, file$f, 74, 4, 2743);
    			attr_dev(div0, "class", "h-12");
    			add_location(div0, file$f, 78, 6, 2832);
    			attr_dev(div1, "class", "");
    			add_location(div1, file$f, 77, 4, 2811);
    			add_location(div2, file$f, 71, 2, 2667);
    			add_location(body, file$f, 70, 0, 2658);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, link, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, body, anchor);
    			append_dev(body, div2);
    			mount_component(navbar, div2, null);
    			append_dev(div2, t1);
    			append_dev(div2, h1);
    			append_dev(h1, strong);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			info.block.m(div0, info.anchor = null);
    			info.mount = () => div0;
    			info.anchor = null;
    			current = true;
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			info.ctx = ctx;

    			if (dirty & /*$token*/ 4 && promise !== (promise = /*$token*/ ctx[2]) && handle_promise(promise, info)) ; else {
    				const child_ctx = ctx.slice();
    				child_ctx[8] = info.resolved;
    				info.block.p(child_ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(link);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(body);
    			destroy_component(navbar);
    			info.block.d();
    			info.token = null;
    			info = null;
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let $token;
    	let { currentRoute } = $$props;
    	const client = getClient();

    	const token = query(client, {
    		query: apolloClient.getToken,
    		variables: { id: currentRoute.namedParams.id }
    	});

    	validate_store(token, "token");
    	component_subscribe($$self, token, value => $$invalidate(2, $token = value));
    	let email = "";
    	let mailBody = "";
    	const writable_props = ["currentRoute"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$4.warn(`<Send_test> was created with unknown prop '${key}'`);
    	});

    	function input1_input_handler() {
    		email = this.value;
    		$$invalidate(0, email);
    	}

    	const click_handler = async result => {
    		$$invalidate(1, mailBody = `localhost:5000/givetest/${result.data.getToken.token}`);
    		console.log(email, mailBody);

    		try {
    			await mutate(client, {
    				mutation: apolloClient.sendMail,
    				variables: { email, mailBody }
    			});
    		} catch(err) {
    			console.log(err);
    		}
    	};

    	$$self.$set = $$props => {
    		if ("currentRoute" in $$props) $$invalidate(5, currentRoute = $$props.currentRoute);
    	};

    	$$self.$capture_state = () => {
    		return { currentRoute, email, mailBody, $token };
    	};

    	$$self.$inject_state = $$props => {
    		if ("currentRoute" in $$props) $$invalidate(5, currentRoute = $$props.currentRoute);
    		if ("email" in $$props) $$invalidate(0, email = $$props.email);
    		if ("mailBody" in $$props) $$invalidate(1, mailBody = $$props.mailBody);
    		if ("$token" in $$props) token.set($token = $$props.$token);
    	};

    	return [
    		email,
    		mailBody,
    		$token,
    		client,
    		token,
    		currentRoute,
    		input1_input_handler,
    		click_handler
    	];
    }

    class Send_test extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$i, safe_not_equal, { currentRoute: 5 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Send_test",
    			options,
    			id: create_fragment$i.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*currentRoute*/ ctx[5] === undefined && !("currentRoute" in props)) {
    			console_1$4.warn("<Send_test> was created without expected prop 'currentRoute'");
    		}
    	}

    	get currentRoute() {
    		throw new Error("<Send_test>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set currentRoute(value) {
    		throw new Error("<Send_test>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/routes/test/test_navbar.svelte generated by Svelte v3.18.1 */

    const file$g = "src/routes/test/test_navbar.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (20:6) {#if index !== content.length}
    function create_if_block$4(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let div1_class_value;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "class", " text-xs leading-none py-1 text-center rounded ");
    			add_location(div0, file$g, 25, 12, 1003);

    			attr_dev(div1, "class", div1_class_value = /*index*/ ctx[4] < /*position*/ ctx[0]
    			? /*activeBar*/ ctx[3]
    			: "w-full text-grey-darkest  bg-light rounded items-center align-middle align-center flex-1");

    			add_location(div1, file$g, 23, 10, 843);
    			attr_dev(div2, "class", "w-1/3 align-center items-center align-middle content-center\n          flex");
    			add_location(div2, file$g, 20, 8, 734);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*position*/ 1 && div1_class_value !== (div1_class_value = /*index*/ ctx[4] < /*position*/ ctx[0]
    			? /*activeBar*/ ctx[3]
    			: "w-full text-grey-darkest  bg-light rounded items-center align-middle align-center flex-1")) {
    				attr_dev(div1, "class", div1_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(20:6) {#if index !== content.length}",
    		ctx
    	});

    	return block;
    }

    // (13:4) {#each content as index}
    function create_each_block$4(ctx) {
    	let div1;
    	let div0;
    	let span;
    	let t0_value = /*index*/ ctx[4] + "";
    	let t0;
    	let div0_class_value;
    	let t1;
    	let if_block_anchor;
    	let if_block = /*index*/ ctx[4] !== /*content*/ ctx[1].length && create_if_block$4(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr_dev(span, "class", "text-center w-full text-2xl");
    			add_location(span, file$g, 16, 10, 604);

    			attr_dev(div0, "class", div0_class_value = /*index*/ ctx[4] <= /*position*/ ctx[0]
    			? /*activeCircle*/ ctx[2]
    			: "w-16 h-16  bg-light text-white border-2 mx-auto rounded-full text-lg flex items-center");

    			add_location(div0, file$g, 14, 8, 446);
    			attr_dev(div1, "class", "flex-1");
    			add_location(div1, file$g, 13, 6, 417);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, span);
    			append_dev(span, t0);
    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*position*/ 1 && div0_class_value !== (div0_class_value = /*index*/ ctx[4] <= /*position*/ ctx[0]
    			? /*activeCircle*/ ctx[2]
    			: "w-16 h-16  bg-light text-white border-2 mx-auto rounded-full text-lg flex items-center")) {
    				attr_dev(div0, "class", div0_class_value);
    			}

    			if (/*index*/ ctx[4] !== /*content*/ ctx[1].length) if_block.p(ctx, dirty);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(13:4) {#each content as index}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let div6;
    	let div2;
    	let div0;
    	let t0;
    	let t1;
    	let div1;
    	let t2;
    	let div5;
    	let div3;
    	let t4;
    	let div4;
    	let each_value = /*content*/ ctx[1];
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			t0 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			div1 = element("div");
    			t2 = space();
    			div5 = element("div");
    			div3 = element("div");
    			div3.textContent = "Test Initials";
    			t4 = space();
    			div4 = element("div");
    			div4.textContent = "Select Problems";
    			attr_dev(div0, "class", "flex-1");
    			add_location(div0, file$g, 11, 4, 359);
    			attr_dev(div1, "class", "flex-1");
    			add_location(div1, file$g, 31, 4, 1128);
    			attr_dev(div2, "class", "flex pb-3");
    			add_location(div2, file$g, 10, 2, 331);
    			attr_dev(div3, "class", "w-1/2 flex-1 text-xl text-elight ");
    			add_location(div3, file$g, 35, 4, 1221);
    			attr_dev(div4, "class", "w-1/2 flex-1 text-xl text-elight");
    			add_location(div4, file$g, 37, 4, 1293);
    			attr_dev(div5, "class", "flex text-xs content-center text-center");
    			add_location(div5, file$g, 34, 2, 1163);
    			attr_dev(div6, "class", "max-w-2xl mx-auto py-4 my-4 pb-4");
    			add_location(div6, file$g, 9, 0, 282);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div2);
    			append_dev(div2, div0);
    			append_dev(div2, t0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div2, null);
    			}

    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div6, t2);
    			append_dev(div6, div5);
    			append_dev(div5, div3);
    			append_dev(div5, t4);
    			append_dev(div5, div4);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*content, position, activeBar, activeCircle*/ 15) {
    				each_value = /*content*/ ctx[1];
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div2, t1);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let { position = 1 } = $$props;
    	let content = [1, 2];
    	let activeCircle = "w-16 h-16 text-dark bg-elight  mx-auto rounded-full text-lg flex items-center";

    	let activeBar = `w-full bg-elight rounded items-center
            align-middle align-center flex-1`;

    	const writable_props = ["position"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Test_navbar> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ("position" in $$props) $$invalidate(0, position = $$props.position);
    	};

    	$$self.$capture_state = () => {
    		return {
    			position,
    			content,
    			activeCircle,
    			activeBar
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("position" in $$props) $$invalidate(0, position = $$props.position);
    		if ("content" in $$props) $$invalidate(1, content = $$props.content);
    		if ("activeCircle" in $$props) $$invalidate(2, activeCircle = $$props.activeCircle);
    		if ("activeBar" in $$props) $$invalidate(3, activeBar = $$props.activeBar);
    	};

    	return [position, content, activeCircle, activeBar];
    }

    class Test_navbar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$i, create_fragment$j, safe_not_equal, { position: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Test_navbar",
    			options,
    			id: create_fragment$j.name
    		});
    	}

    	get position() {
    		throw new Error("<Test_navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set position(value) {
    		throw new Error("<Test_navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/routes/test/loader.svelte generated by Svelte v3.18.1 */

    const file$h = "src/routes/test/loader.svelte";

    function create_fragment$k(ctx) {
    	let div3;
    	let div0;
    	let t0;
    	let div1;
    	let t1;
    	let div2;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			t1 = space();
    			div2 = element("div");
    			attr_dev(div0, "class", "LoaderBalls__item svelte-1xkje64");
    			add_location(div0, file$h, 42, 2, 2489);
    			attr_dev(div1, "class", "LoaderBalls__item svelte-1xkje64");
    			add_location(div1, file$h, 43, 2, 2525);
    			attr_dev(div2, "class", "LoaderBalls__item svelte-1xkje64");
    			add_location(div2, file$h, 44, 2, 2561);
    			attr_dev(div3, "class", "LoaderBalls svelte-1xkje64");
    			add_location(div3, file$h, 41, 0, 2461);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div3, t0);
    			append_dev(div3, div1);
    			append_dev(div3, t1);
    			append_dev(div3, div2);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    class Loader extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, null, create_fragment$k, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Loader",
    			options,
    			id: create_fragment$k.name
    		});
    	}
    }

    const testStore = writable({
      testName: '',
      timelimit: '',
      problems: '[]',
      difficultyLevel: '',
      email: 'Sample@gmail.com',
      tags: '',
    });

    /* src/routes/test/test_initials.svelte generated by Svelte v3.18.1 */
    const file$i = "src/routes/test/test_initials.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[17] = list[i];
    	child_ctx[19] = i;
    	return child_ctx;
    }

    // (114:10) {#if uniqueNameStatus === 2}
    function create_if_block_2$1(ctx) {
    	let current;
    	const loader = new Loader({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(loader.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loader, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loader, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(114:10) {#if uniqueNameStatus === 2}",
    		ctx
    	});

    	return block;
    }

    // (117:10) {#if uniqueNameStatus === 1}
    function create_if_block_1$3(ctx) {
    	let i;

    	const block = {
    		c: function create() {
    			i = element("i");
    			i.textContent = "";
    			attr_dev(i, "class", "material-icons status svelte-17qxgd1");
    			add_location(i, file$i, 117, 12, 3919);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(117:10) {#if uniqueNameStatus === 1}",
    		ctx
    	});

    	return block;
    }

    // (120:10) {#if uniqueNameStatus === 3}
    function create_if_block$5(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "clear";
    			attr_dev(span, "class", "status material-icons svelte-17qxgd1");
    			add_location(span, file$i, 120, 12, 4032);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(120:10) {#if uniqueNameStatus === 3}",
    		ctx
    	});

    	return block;
    }

    // (175:14) {#each tagList as tag, index}
    function create_each_block$5(ctx) {
    	let option;
    	let t0_value = /*tag*/ ctx[17] + "";
    	let t0;
    	let t1;
    	let option_name_value;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(option, "class", "text-xl px-2 text-edark");
    			attr_dev(option, "name", option_name_value = /*tag*/ ctx[17]);
    			option.__value = option_value_value = /*index*/ ctx[19];
    			option.value = option.__value;
    			add_location(option, file$i, 175, 16, 5855);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t0);
    			append_dev(option, t1);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(175:14) {#each tagList as tag, index}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let div15;
    	let div14;
    	let div5;
    	let label0;
    	let t1;
    	let div4;
    	let div2;
    	let div0;
    	let input0;
    	let t2;
    	let div1;
    	let p;
    	let t4;
    	let div3;
    	let t5;
    	let t6;
    	let t7;
    	let div13;
    	let div6;
    	let h2;
    	let t9;
    	let div12;
    	let div7;
    	let label1;
    	let t11;
    	let input1;
    	let t12;
    	let span0;
    	let t14;
    	let div9;
    	let div8;
    	let label2;
    	let t16;
    	let input2;
    	let t17;
    	let span1;
    	let t19;
    	let input3;
    	let t20;
    	let span2;
    	let t22;
    	let input4;
    	let t23;
    	let span3;
    	let t25;
    	let div11;
    	let label3;
    	let t27;
    	let div10;
    	let select;
    	let t28;
    	let input5;
    	let current;
    	let dispose;
    	let if_block0 = /*uniqueNameStatus*/ ctx[1] === 2 && create_if_block_2$1(ctx);
    	let if_block1 = /*uniqueNameStatus*/ ctx[1] === 1 && create_if_block_1$3(ctx);
    	let if_block2 = /*uniqueNameStatus*/ ctx[1] === 3 && create_if_block$5(ctx);
    	let each_value = /*tagList*/ ctx[3];
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div15 = element("div");
    			div14 = element("div");
    			div5 = element("div");
    			label0 = element("label");
    			label0.textContent = "Enter a unique Test code";
    			t1 = space();
    			div4 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			input0 = element("input");
    			t2 = space();
    			div1 = element("div");
    			p = element("p");
    			p.textContent = `${/*alert*/ ctx[2]}`;
    			t4 = space();
    			div3 = element("div");
    			if (if_block0) if_block0.c();
    			t5 = space();
    			if (if_block1) if_block1.c();
    			t6 = space();
    			if (if_block2) if_block2.c();
    			t7 = space();
    			div13 = element("div");
    			div6 = element("div");
    			h2 = element("h2");
    			h2.textContent = "Other Details";
    			t9 = space();
    			div12 = element("div");
    			div7 = element("div");
    			label1 = element("label");
    			label1.textContent = "Enter Time limit";
    			t11 = space();
    			input1 = element("input");
    			t12 = space();
    			span0 = element("span");
    			span0.textContent = "minutes";
    			t14 = space();
    			div9 = element("div");
    			div8 = element("div");
    			label2 = element("label");
    			label2.textContent = "Select Difficulty Level";
    			t16 = space();
    			input2 = element("input");
    			t17 = space();
    			span1 = element("span");
    			span1.textContent = "Easy";
    			t19 = space();
    			input3 = element("input");
    			t20 = space();
    			span2 = element("span");
    			span2.textContent = "Medium";
    			t22 = space();
    			input4 = element("input");
    			t23 = space();
    			span3 = element("span");
    			span3.textContent = "Difficult";
    			t25 = space();
    			div11 = element("div");
    			label3 = element("label");
    			label3.textContent = "Add Tags";
    			t27 = space();
    			div10 = element("div");
    			select = element("select");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t28 = space();
    			input5 = element("input");
    			attr_dev(label0, "class", "text-elight text-2xl my-3");
    			add_location(label0, file$i, 95, 6, 3157);
    			attr_dev(input0, "type", "search");
    			attr_dev(input0, "name", "serch");
    			attr_dev(input0, "placeholder", "Search");
    			attr_dev(input0, "class", "bg-elight h-10 px-5 pr-10 rounded-full w-full text-xl\n              tet-edark focus:outline-none");
    			add_location(input0, file$i, 99, 12, 3338);
    			attr_dev(div0, "class", "w-full");
    			add_location(div0, file$i, 98, 10, 3305);
    			attr_dev(p, "class", "text-white text-sm my-2");
    			add_location(p, file$i, 109, 12, 3684);
    			add_location(div1, file$i, 108, 10, 3666);
    			attr_dev(div2, "class", " flex-col w-full");
    			add_location(div2, file$i, 97, 8, 3264);
    			attr_dev(div3, "class", "ml-3");
    			add_location(div3, file$i, 112, 8, 3771);
    			attr_dev(div4, "class", "flex");
    			add_location(div4, file$i, 96, 6, 3237);
    			add_location(div5, file$i, 94, 4, 3145);
    			attr_dev(h2, "class", "labels text-3xl svelte-17qxgd1");
    			add_location(h2, file$i, 127, 8, 4218);
    			add_location(div6, file$i, 126, 6, 4204);
    			attr_dev(label1, "class", "labels svelte-17qxgd1");
    			add_location(label1, file$i, 131, 10, 4314);
    			attr_dev(input1, "class", "unitinput svelte-17qxgd1");
    			attr_dev(input1, "type", "text");
    			attr_dev(input1, "placeholder", "in minutes");
    			add_location(input1, file$i, 132, 10, 4371);
    			attr_dev(span0, "class", "unit svelte-17qxgd1");
    			add_location(span0, file$i, 137, 10, 4528);
    			add_location(div7, file$i, 130, 8, 4298);
    			attr_dev(label2, "class", "labels svelte-17qxgd1");
    			add_location(label2, file$i, 141, 12, 4632);
    			attr_dev(input2, "class", "unitinput svelte-17qxgd1");
    			attr_dev(input2, "type", "radio");
    			input2.__value = "Easy";
    			input2.value = input2.__value;
    			/*$$binding_groups*/ ctx[12][0].push(input2);
    			add_location(input2, file$i, 142, 12, 4698);
    			attr_dev(span1, "class", "unit text-2xl svelte-17qxgd1");
    			add_location(span1, file$i, 147, 12, 4860);
    			attr_dev(input3, "class", "unitinput svelte-17qxgd1");
    			attr_dev(input3, "type", "radio");
    			input3.__value = "Medium";
    			input3.value = input3.__value;
    			/*$$binding_groups*/ ctx[12][0].push(input3);
    			add_location(input3, file$i, 148, 12, 4912);
    			attr_dev(span2, "class", "unit text-2xl svelte-17qxgd1");
    			add_location(span2, file$i, 153, 12, 5076);
    			attr_dev(input4, "class", "unitinput svelte-17qxgd1");
    			attr_dev(input4, "type", "radio");
    			input4.__value = "Difficult";
    			input4.value = input4.__value;
    			/*$$binding_groups*/ ctx[12][0].push(input4);
    			add_location(input4, file$i, 154, 12, 5130);
    			attr_dev(span3, "class", "unit text-2xl svelte-17qxgd1");
    			add_location(span3, file$i, 159, 12, 5297);
    			add_location(div8, file$i, 140, 10, 4614);
    			attr_dev(div9, "class", "flex");
    			add_location(div9, file$i, 139, 8, 4585);
    			attr_dev(label3, "class", "labels svelte-17qxgd1");
    			add_location(label3, file$i, 163, 10, 5398);
    			attr_dev(select, "class", "unitinput outline-none w-64 svelte-17qxgd1");
    			add_location(select, file$i, 165, 12, 5487);
    			attr_dev(input5, "type", "text");
    			attr_dev(input5, "class", "unitinput svelte-17qxgd1");
    			input5.readOnly = true;
    			add_location(input5, file$i, 183, 12, 6081);
    			attr_dev(div10, "class", "flex-col flex");
    			add_location(div10, file$i, 164, 10, 5447);
    			add_location(div11, file$i, 162, 8, 5382);
    			add_location(div12, file$i, 129, 6, 4284);
    			attr_dev(div13, "class", "border-solid border-2 mt-6 border-light p-4");
    			add_location(div13, file$i, 125, 4, 4140);
    			attr_dev(div14, "class", "text-edark mx-auto max-w-5xl w-full");
    			add_location(div14, file$i, 93, 2, 3091);
    			attr_dev(div15, "class", "mx-auto flex-col flex-grow");
    			add_location(div15, file$i, 92, 0, 3048);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div15, anchor);
    			append_dev(div15, div14);
    			append_dev(div14, div5);
    			append_dev(div5, label0);
    			append_dev(div5, t1);
    			append_dev(div5, div4);
    			append_dev(div4, div2);
    			append_dev(div2, div0);
    			append_dev(div0, input0);
    			set_input_value(input0, /*$testStore*/ ctx[0].testName);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			append_dev(div1, p);
    			append_dev(div4, t4);
    			append_dev(div4, div3);
    			if (if_block0) if_block0.m(div3, null);
    			append_dev(div3, t5);
    			if (if_block1) if_block1.m(div3, null);
    			append_dev(div3, t6);
    			if (if_block2) if_block2.m(div3, null);
    			append_dev(div14, t7);
    			append_dev(div14, div13);
    			append_dev(div13, div6);
    			append_dev(div6, h2);
    			append_dev(div13, t9);
    			append_dev(div13, div12);
    			append_dev(div12, div7);
    			append_dev(div7, label1);
    			append_dev(div7, t11);
    			append_dev(div7, input1);
    			set_input_value(input1, /*$testStore*/ ctx[0].timelimit);
    			append_dev(div7, t12);
    			append_dev(div7, span0);
    			append_dev(div12, t14);
    			append_dev(div12, div9);
    			append_dev(div9, div8);
    			append_dev(div8, label2);
    			append_dev(div8, t16);
    			append_dev(div8, input2);
    			input2.checked = input2.__value === /*$testStore*/ ctx[0].difficultyLevel;
    			append_dev(div8, t17);
    			append_dev(div8, span1);
    			append_dev(div8, t19);
    			append_dev(div8, input3);
    			input3.checked = input3.__value === /*$testStore*/ ctx[0].difficultyLevel;
    			append_dev(div8, t20);
    			append_dev(div8, span2);
    			append_dev(div8, t22);
    			append_dev(div8, input4);
    			input4.checked = input4.__value === /*$testStore*/ ctx[0].difficultyLevel;
    			append_dev(div8, t23);
    			append_dev(div8, span3);
    			append_dev(div12, t25);
    			append_dev(div12, div11);
    			append_dev(div11, label3);
    			append_dev(div11, t27);
    			append_dev(div11, div10);
    			append_dev(div10, select);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			append_dev(div10, t28);
    			append_dev(div10, input5);
    			set_input_value(input5, /*$testStore*/ ctx[0].tags);
    			current = true;

    			dispose = [
    				listen_dev(input0, "keydown", /*onInput*/ ctx[5], false, false, false),
    				listen_dev(input0, "input", /*input0_input_handler*/ ctx[9]),
    				listen_dev(input1, "input", /*input1_input_handler*/ ctx[10]),
    				listen_dev(input2, "change", /*input2_change_handler*/ ctx[11]),
    				listen_dev(input3, "change", /*input3_change_handler*/ ctx[13]),
    				listen_dev(input4, "change", /*input4_change_handler*/ ctx[14]),
    				listen_dev(select, "change", /*change_handler*/ ctx[15], false, false, false),
    				listen_dev(input5, "input", /*input5_input_handler*/ ctx[16])
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$testStore*/ 1) {
    				set_input_value(input0, /*$testStore*/ ctx[0].testName);
    			}

    			if (/*uniqueNameStatus*/ ctx[1] === 2) {
    				if (!if_block0) {
    					if_block0 = create_if_block_2$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div3, t5);
    				} else {
    					transition_in(if_block0, 1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*uniqueNameStatus*/ ctx[1] === 1) {
    				if (!if_block1) {
    					if_block1 = create_if_block_1$3(ctx);
    					if_block1.c();
    					if_block1.m(div3, t6);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*uniqueNameStatus*/ ctx[1] === 3) {
    				if (!if_block2) {
    					if_block2 = create_if_block$5(ctx);
    					if_block2.c();
    					if_block2.m(div3, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (dirty & /*$testStore*/ 1 && input1.value !== /*$testStore*/ ctx[0].timelimit) {
    				set_input_value(input1, /*$testStore*/ ctx[0].timelimit);
    			}

    			if (dirty & /*$testStore*/ 1) {
    				input2.checked = input2.__value === /*$testStore*/ ctx[0].difficultyLevel;
    			}

    			if (dirty & /*$testStore*/ 1) {
    				input3.checked = input3.__value === /*$testStore*/ ctx[0].difficultyLevel;
    			}

    			if (dirty & /*$testStore*/ 1) {
    				input4.checked = input4.__value === /*$testStore*/ ctx[0].difficultyLevel;
    			}

    			if (dirty & /*tagList*/ 8) {
    				each_value = /*tagList*/ ctx[3];
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*$testStore*/ 1 && input5.value !== /*$testStore*/ ctx[0].tags) {
    				set_input_value(input5, /*$testStore*/ ctx[0].tags);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div15);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			/*$$binding_groups*/ ctx[12][0].splice(/*$$binding_groups*/ ctx[12][0].indexOf(input2), 1);
    			/*$$binding_groups*/ ctx[12][0].splice(/*$$binding_groups*/ ctx[12][0].indexOf(input3), 1);
    			/*$$binding_groups*/ ctx[12][0].splice(/*$$binding_groups*/ ctx[12][0].indexOf(input4), 1);
    			destroy_each(each_blocks, detaching);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let $testStore;
    	validate_store(testStore, "testStore");
    	component_subscribe($$self, testStore, $$value => $$invalidate(0, $testStore = $$value));
    	console.log($testStore);
    	let alert = "*Name must be in capital letters with no space in between and no special characters";

    	const tagList = [
    		"Choose Tags",
    		"Java",
    		"Nodejs",
    		"Angular",
    		"Fresher",
    		"Devops",
    		"Technical_architect"
    	];

    	const client = getClient();
    	let selectedTags = [];
    	let hastTagString = "";

    	function changeHandler(indexValue) {
    		console.log(selectedTags.length, indexValue);
    		let rr = selectedTags.length;

    		selectedTags = [
    			...selectedTags.filter(ele => {
    				return ele !== indexValue;
    			})
    		];

    		if (rr === selectedTags.length) {
    			selectedTags = [...selectedTags, indexValue];
    		}

    		hastTagString = "";

    		selectedTags.forEach(ind => {
    			hastTagString += "#" + tagList[ind];
    		});

    		set_store_value(testStore, $testStore.tags = hastTagString, $testStore);
    	}

    	const onInput = (function checkIfAvailable() {
    		let timer;

    		return e => {
    			timer = setTimeout(
    				async () => {
    					$$invalidate(1, uniqueNameStatus = 2);

    					const res = await mutate(client, {
    						mutation: apolloClient.checkTestIfAvailable,
    						variables: { testName: $testStore.testName }
    					});

    					console.log(res);

    					if (res.data.checkTestIfExists.success === false) {
    						$$invalidate(1, uniqueNameStatus = 1);
    					} else {
    						$$invalidate(1, uniqueNameStatus = 3);
    					}
    				},
    				30
    			);
    		};
    	})();

    	const $$binding_groups = [[]];

    	function input0_input_handler() {
    		$testStore.testName = this.value;
    		testStore.set($testStore);
    	}

    	function input1_input_handler() {
    		$testStore.timelimit = this.value;
    		testStore.set($testStore);
    	}

    	function input2_change_handler() {
    		$testStore.difficultyLevel = this.__value;
    		testStore.set($testStore);
    	}

    	function input3_change_handler() {
    		$testStore.difficultyLevel = this.__value;
    		testStore.set($testStore);
    	}

    	function input4_change_handler() {
    		$testStore.difficultyLevel = this.__value;
    		testStore.set($testStore);
    	}

    	const change_handler = e => {
    		console.log(e.target.value);

    		if (parseInt(e.target.value) === 0) {
    			return;
    		}

    		changeHandler(parseInt(e.target.value));
    	};

    	function input5_input_handler() {
    		$testStore.tags = this.value;
    		testStore.set($testStore);
    	}

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("alert" in $$props) $$invalidate(2, alert = $$props.alert);
    		if ("selectedTags" in $$props) selectedTags = $$props.selectedTags;
    		if ("hastTagString" in $$props) hastTagString = $$props.hastTagString;
    		if ("$testStore" in $$props) testStore.set($testStore = $$props.$testStore);
    		if ("uniqueNameStatus" in $$props) $$invalidate(1, uniqueNameStatus = $$props.uniqueNameStatus);
    	};

    	let uniqueNameStatus;
    	 $$invalidate(1, uniqueNameStatus = 0);

    	return [
    		$testStore,
    		uniqueNameStatus,
    		alert,
    		tagList,
    		changeHandler,
    		onInput,
    		selectedTags,
    		hastTagString,
    		client,
    		input0_input_handler,
    		input1_input_handler,
    		input2_change_handler,
    		$$binding_groups,
    		input3_change_handler,
    		input4_change_handler,
    		change_handler,
    		input5_input_handler
    	];
    }

    class Test_initials extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$j, create_fragment$l, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Test_initials",
    			options,
    			id: create_fragment$l.name
    		});
    	}
    }

    /* src/routes/test/all_problems.svelte generated by Svelte v3.18.1 */
    const file$j = "src/routes/test/all_problems.svelte";

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	return child_ctx;
    }

    // (47:2) {:catch err}
    function create_catch_block$5(ctx) {
    	let t0;
    	let t1_value = /*err*/ ctx[6] + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("Error: ");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$Problems*/ 2 && t1_value !== (t1_value = /*err*/ ctx[6] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block$5.name,
    		type: "catch",
    		source: "(47:2) {:catch err}",
    		ctx
    	});

    	return block;
    }

    // (18:2) {:then result}
    function create_then_block$5(ctx) {
    	let each_1_anchor;
    	let each_value = /*result*/ ctx[5].data.allProblems;
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$Problems, addProblem*/ 3) {
    				each_value = /*result*/ ctx[5].data.allProblems;
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block$5.name,
    		type: "then",
    		source: "(18:2) {:then result}",
    		ctx
    	});

    	return block;
    }

    // (19:4) {#each result.data.allProblems as prob}
    function create_each_block$6(ctx) {
    	let div4;
    	let div1;
    	let div0;
    	let a;
    	let t0_value = /*prob*/ ctx[7].problemName + "";
    	let t0;
    	let a_href_value;
    	let t1;
    	let div3;
    	let div2;
    	let button;
    	let t3;
    	let dispose;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[4](/*prob*/ ctx[7], ...args);
    	}

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			a = element("a");
    			t0 = text(t0_value);
    			t1 = space();
    			div3 = element("div");
    			div2 = element("div");
    			button = element("button");
    			button.textContent = "Add";
    			t3 = space();
    			attr_dev(a, "href", a_href_value = "http://localhost:5000/problem/" + /*prob*/ ctx[7].id);
    			attr_dev(a, "class", "no-underline px-3 text-elight svelte-gm8br7");
    			add_location(a, file$j, 24, 12, 996);
    			attr_dev(div0, "class", "rows bg-dark rounded-full p-2 px-4 mx-2 text-white text-xl\n            px-3 svelte-gm8br7");
    			add_location(div0, file$j, 21, 10, 882);
    			attr_dev(div1, "class", "w-10/12 svelte-gm8br7");
    			add_location(div1, file$j, 20, 8, 850);
    			attr_dev(button, "class", "w-3/4 bg-dark outline-none text-white rounded-full p-2 px-4\n              mx-2 svelte-gm8br7");
    			add_location(button, file$j, 33, 12, 1266);
    			attr_dev(div2, "class", "rows  svelte-gm8br7");
    			add_location(div2, file$j, 32, 10, 1234);
    			attr_dev(div3, "class", "w-2/12 svelte-gm8br7");
    			add_location(div3, file$j, 31, 8, 1203);
    			attr_dev(div4, "class", "flex mb mt-3 text-xl svelte-gm8br7");
    			add_location(div4, file$j, 19, 6, 807);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div1);
    			append_dev(div1, div0);
    			append_dev(div0, a);
    			append_dev(a, t0);
    			append_dev(div4, t1);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div2, button);
    			append_dev(div4, t3);
    			dispose = listen_dev(button, "click", click_handler, false, false, false);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*$Problems*/ 2 && t0_value !== (t0_value = /*prob*/ ctx[7].problemName + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*$Problems*/ 2 && a_href_value !== (a_href_value = "http://localhost:5000/problem/" + /*prob*/ ctx[7].id)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(19:4) {#each result.data.allProblems as prob}",
    		ctx
    	});

    	return block;
    }

    // (16:20)      Loading...   {:then result}
    function create_pending_block$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Loading...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block$5.name,
    		type: "pending",
    		source: "(16:20)      Loading...   {:then result}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let div;
    	let promise;

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		pending: create_pending_block$5,
    		then: create_then_block$5,
    		catch: create_catch_block$5,
    		value: 5,
    		error: 6
    	};

    	handle_promise(promise = /*$Problems*/ ctx[1], info);

    	const block = {
    		c: function create() {
    			div = element("div");
    			info.block.c();
    			attr_dev(div, "class", "w-full mt-2 svelte-gm8br7");
    			add_location(div, file$j, 14, 0, 678);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			info.block.m(div, info.anchor = null);
    			info.mount = () => div;
    			info.anchor = null;
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			info.ctx = ctx;

    			if (dirty & /*$Problems*/ 2 && promise !== (promise = /*$Problems*/ ctx[1]) && handle_promise(promise, info)) ; else {
    				const child_ctx = ctx.slice();
    				child_ctx[5] = info.resolved;
    				info.block.p(child_ctx, dirty);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			info.block.d();
    			info.token = null;
    			info = null;
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let $Problems;
    	let { addProblem } = $$props;
    	const client = getClient();
    	const Problems = subscribe$2(client, { query: apolloClient.getProblems });
    	validate_store(Problems, "Problems");
    	component_subscribe($$self, Problems, value => $$invalidate(1, $Problems = value));
    	const writable_props = ["addProblem"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<All_problems> was created with unknown prop '${key}'`);
    	});

    	const click_handler = prob => {
    		let proble = {
    			problemName: prob.problemName,
    			id: prob.id
    		};

    		addProblem(proble);
    	};

    	$$self.$set = $$props => {
    		if ("addProblem" in $$props) $$invalidate(0, addProblem = $$props.addProblem);
    	};

    	$$self.$capture_state = () => {
    		return { addProblem, $Problems };
    	};

    	$$self.$inject_state = $$props => {
    		if ("addProblem" in $$props) $$invalidate(0, addProblem = $$props.addProblem);
    		if ("$Problems" in $$props) Problems.set($Problems = $$props.$Problems);
    	};

    	return [addProblem, $Problems, Problems, client, click_handler];
    }

    class All_problems extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$k, create_fragment$m, safe_not_equal, { addProblem: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "All_problems",
    			options,
    			id: create_fragment$m.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*addProblem*/ ctx[0] === undefined && !("addProblem" in props)) {
    			console.warn("<All_problems> was created without expected prop 'addProblem'");
    		}
    	}

    	get addProblem() {
    		throw new Error("<All_problems>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set addProblem(value) {
    		throw new Error("<All_problems>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/routes/test/select_problems.svelte generated by Svelte v3.18.1 */
    const file$k = "src/routes/test/select_problems.svelte";

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	child_ctx[11] = list;
    	child_ctx[12] = i;
    	return child_ctx;
    }

    // (112:12) {#each problemScore as problem}
    function create_each_block$7(ctx) {
    	let div6;
    	let div1;
    	let div0;
    	let t0_value = /*problem*/ ctx[10].problem.problemName + "";
    	let t0;
    	let t1;
    	let div3;
    	let div2;
    	let input;
    	let t2;
    	let div5;
    	let div4;
    	let button;
    	let t4;
    	let dispose;

    	function input_input_handler() {
    		/*input_input_handler*/ ctx[7].call(input, /*problem*/ ctx[10]);
    	}

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[8](/*problem*/ ctx[10], ...args);
    	}

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			div3 = element("div");
    			div2 = element("div");
    			input = element("input");
    			t2 = space();
    			div5 = element("div");
    			div4 = element("div");
    			button = element("button");
    			button.textContent = "X";
    			t4 = space();
    			attr_dev(div0, "class", "rows bg-dark rounded-full p-2 px-4 mx-2 svelte-1xqcozc");
    			add_location(div0, file$k, 114, 18, 3814);
    			attr_dev(div1, "class", "w-9/12 svelte-1xqcozc");
    			add_location(div1, file$k, 113, 16, 3775);
    			attr_dev(input, "type", "string");
    			attr_dev(input, "class", "w-3/4 bg-dark outline-none text-white rounded-full\n                      p-2 px-4 mx-2 svelte-1xqcozc");
    			add_location(input, file$k, 120, 20, 4061);
    			attr_dev(div2, "class", "rows  svelte-1xqcozc");
    			add_location(div2, file$k, 119, 18, 4021);
    			attr_dev(div3, "class", "w-2/12 svelte-1xqcozc");
    			add_location(div3, file$k, 118, 16, 3982);
    			attr_dev(button, "class", "w-3/4 bg-dark outline-none text-white rounded-full\n                      p-2 px-4 mx-2 svelte-1xqcozc");
    			add_location(button, file$k, 132, 20, 4558);
    			attr_dev(div4, "class", "rows  svelte-1xqcozc");
    			add_location(div4, file$k, 131, 18, 4518);
    			attr_dev(div5, "class", "w-1/12 svelte-1xqcozc");
    			add_location(div5, file$k, 130, 16, 4479);
    			attr_dev(div6, "class", "flex pb-3 svelte-1xqcozc");
    			add_location(div6, file$k, 112, 14, 3735);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div1);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div3);
    			append_dev(div3, div2);
    			append_dev(div2, input);
    			set_input_value(input, /*problem*/ ctx[10].score);
    			append_dev(div6, t2);
    			append_dev(div6, div5);
    			append_dev(div5, div4);
    			append_dev(div4, button);
    			append_dev(div6, t4);

    			dispose = [
    				listen_dev(input, "change", /*change_handler*/ ctx[6], false, false, false),
    				listen_dev(input, "input", input_input_handler),
    				listen_dev(button, "click", click_handler, false, false, false)
    			];
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*problemScore*/ 1 && t0_value !== (t0_value = /*problem*/ ctx[10].problem.problemName + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*problemScore*/ 1) {
    				set_input_value(input, /*problem*/ ctx[10].score);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$7.name,
    		type: "each",
    		source: "(112:12) {#each problemScore as problem}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let div15;
    	let div13;
    	let div12;
    	let div8;
    	let div0;
    	let h10;
    	let t1;
    	let div7;
    	let div5;
    	let div2;
    	let div1;
    	let t3;
    	let div4;
    	let div3;
    	let t5;
    	let div6;
    	let t6;
    	let div11;
    	let div9;
    	let h11;
    	let t8;
    	let div10;
    	let t9;
    	let div14;
    	let button;
    	let current;
    	let dispose;
    	let each_value = /*problemScore*/ ctx[0];
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
    	}

    	const allproblems = new All_problems({
    			props: { addProblem: /*addingProblem*/ ctx[2] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div15 = element("div");
    			div13 = element("div");
    			div12 = element("div");
    			div8 = element("div");
    			div0 = element("div");
    			h10 = element("h1");
    			h10.textContent = "Selected Problems";
    			t1 = space();
    			div7 = element("div");
    			div5 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			div1.textContent = "Problem Name";
    			t3 = space();
    			div4 = element("div");
    			div3 = element("div");
    			div3.textContent = "Score";
    			t5 = space();
    			div6 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t6 = space();
    			div11 = element("div");
    			div9 = element("div");
    			h11 = element("h1");
    			h11.textContent = "Select Problems";
    			t8 = space();
    			div10 = element("div");
    			create_component(allproblems.$$.fragment);
    			t9 = space();
    			div14 = element("div");
    			button = element("button");
    			button.textContent = "Submit";
    			attr_dev(h10, "class", "labels svelte-1xqcozc");
    			add_location(h10, file$k, 99, 10, 3266);
    			attr_dev(div0, "class", "mx-auto w-64 mb-4 svelte-1xqcozc");
    			add_location(div0, file$k, 98, 8, 3224);
    			attr_dev(div1, "class", "rows mx-4 svelte-1xqcozc");
    			add_location(div1, file$k, 104, 14, 3435);
    			attr_dev(div2, "class", "w-9/12 svelte-1xqcozc");
    			add_location(div2, file$k, 103, 12, 3400);
    			attr_dev(div3, "class", "rows mx-4 svelte-1xqcozc");
    			add_location(div3, file$k, 107, 14, 3543);
    			attr_dev(div4, "class", "w-3/12 svelte-1xqcozc");
    			add_location(div4, file$k, 106, 12, 3508);
    			attr_dev(div5, "class", "flex mb-6 svelte-1xqcozc");
    			add_location(div5, file$k, 102, 10, 3364);
    			attr_dev(div6, "class", "boxheight2 flex flex-col overflow-auto svelte-1xqcozc");
    			add_location(div6, file$k, 110, 10, 3624);
    			attr_dev(div7, "class", "flex-col svelte-1xqcozc");
    			add_location(div7, file$k, 101, 8, 3331);
    			attr_dev(div8, "class", "outer_box flex-col h-full svelte-1xqcozc");
    			add_location(div8, file$k, 97, 6, 3176);
    			attr_dev(h11, "class", "labels svelte-1xqcozc");
    			add_location(h11, file$k, 149, 10, 5114);
    			attr_dev(div9, "class", "mx-auto w-64 pb-2 flex flex-col svelte-1xqcozc");
    			add_location(div9, file$k, 148, 8, 5058);
    			attr_dev(div10, "class", " pb-4 max-w-full boxheight flex flex-col overflow-auto svelte-1xqcozc");
    			add_location(div10, file$k, 151, 8, 5177);
    			attr_dev(div11, "class", "outer_box flex-wrap h-full svelte-1xqcozc");
    			add_location(div11, file$k, 147, 6, 5009);
    			attr_dev(div12, "class", "flex mx-3 w-full mb-6 h-full svelte-1xqcozc");
    			add_location(div12, file$k, 96, 4, 3127);
    			attr_dev(div13, "class", "max-w-full mx-auto flex statement mb-4  svelte-1xqcozc");
    			add_location(div13, file$k, 95, 2, 3069);
    			attr_dev(button, "class", "bg-dark hover:bg-elight hover:text-edark outline-none text-white\n      font-bold py-4 px-4 text-xl rounded-full svelte-1xqcozc");
    			add_location(button, file$k, 158, 4, 5393);
    			attr_dev(div14, "class", "mt-10 flex justify-center svelte-1xqcozc");
    			add_location(div14, file$k, 157, 2, 5349);
    			attr_dev(div15, "class", "svelte-1xqcozc");
    			add_location(div15, file$k, 94, 0, 3061);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div15, anchor);
    			append_dev(div15, div13);
    			append_dev(div13, div12);
    			append_dev(div12, div8);
    			append_dev(div8, div0);
    			append_dev(div0, h10);
    			append_dev(div8, t1);
    			append_dev(div8, div7);
    			append_dev(div7, div5);
    			append_dev(div5, div2);
    			append_dev(div2, div1);
    			append_dev(div5, t3);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div7, t5);
    			append_dev(div7, div6);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div6, null);
    			}

    			append_dev(div12, t6);
    			append_dev(div12, div11);
    			append_dev(div11, div9);
    			append_dev(div9, h11);
    			append_dev(div11, t8);
    			append_dev(div11, div10);
    			mount_component(allproblems, div10, null);
    			append_dev(div15, t9);
    			append_dev(div15, div14);
    			append_dev(div14, button);
    			current = true;
    			dispose = listen_dev(button, "click", /*click_handler_1*/ ctx[9], false, false, false);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*removeProblem, problemScore, $testStore, JSON*/ 11) {
    				each_value = /*problemScore*/ ctx[0];
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$7(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div6, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(allproblems.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(allproblems.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div15);
    			destroy_each(each_blocks, detaching);
    			destroy_component(allproblems);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let $testStore;
    	validate_store(testStore, "testStore");
    	component_subscribe($$self, testStore, $$value => $$invalidate(1, $testStore = $$value));
    	const client = getClient();
    	let problemScore = JSON.parse($testStore.problems);

    	function addingProblem(prob) {
    		let res = false;

    		problemScore.forEach(problem => {
    			if (problem.problem.id === prob.id) {
    				res = true;
    			}
    		});

    		if (res) {
    			return;
    		}

    		$$invalidate(0, problemScore = [...problemScore, { problem: prob, score: "" }]);
    		set_store_value(testStore, $testStore.problems = JSON.stringify(problemScore), $testStore);
    	}

    	function removeProblem(id) {
    		console.log(id);

    		$$invalidate(0, problemScore = [
    			...problemScore.filter(problem => {
    				return parseInt(problem.problem.id) !== parseInt(id);
    			})
    		]);

    		set_store_value(testStore, $testStore.problems = JSON.stringify(problemScore), $testStore);
    	}

    	async function submitHandler() {
    		set_store_value(testStore, $testStore.problems = JSON.stringify(problemScore), $testStore);

    		let test = {
    			testName: $testStore.testName,
    			tags: $testStore.tags,
    			problems: $testStore.problems,
    			timelimit: $testStore.timelimit,
    			difficultyLevel: $testStore.difficultyLevel,
    			email: "Sample@gmail.com"
    		};

    		console.log(test);

    		try {
    			await mutate(client, {
    				mutation: apolloClient.addTest,
    				variables: test
    			});

    			location.replace("http://localhost:5000/admin");
    		} catch(err) {
    			console.log(err);
    		}
    	}

    	const change_handler = () => {
    		set_store_value(testStore, $testStore.problems = JSON.stringify(problemScore), $testStore);
    	};

    	function input_input_handler(problem) {
    		problem.score = this.value;
    		$$invalidate(0, problemScore);
    	}

    	const click_handler = problem => {
    		return removeProblem(problem.problem.id);
    	};

    	const click_handler_1 = e => {
    		submitHandler();
    	};

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("problemScore" in $$props) $$invalidate(0, problemScore = $$props.problemScore);
    		if ("$testStore" in $$props) testStore.set($testStore = $$props.$testStore);
    	};

    	return [
    		problemScore,
    		$testStore,
    		addingProblem,
    		removeProblem,
    		submitHandler,
    		client,
    		change_handler,
    		input_input_handler,
    		click_handler,
    		click_handler_1
    	];
    }

    class Select_problems extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$n, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Select_problems",
    			options,
    			id: create_fragment$n.name
    		});
    	}
    }

    /* src/routes/test/select_page.svelte generated by Svelte v3.18.1 */
    const file$l = "src/routes/test/select_page.svelte";

    // (8:2) {#if pageNum === 1}
    function create_if_block_1$4(ctx) {
    	let current;
    	const testinitials = new Test_initials({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(testinitials.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(testinitials, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(testinitials.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(testinitials.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(testinitials, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(8:2) {#if pageNum === 1}",
    		ctx
    	});

    	return block;
    }

    // (11:2) {#if pageNum === 2}
    function create_if_block$6(ctx) {
    	let current;
    	const testproblems = new Select_problems({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(testproblems.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(testproblems, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(testproblems.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(testproblems.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(testproblems, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(11:2) {#if pageNum === 2}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let div;
    	let t;
    	let current;
    	let if_block0 = /*pageNum*/ ctx[0] === 1 && create_if_block_1$4(ctx);
    	let if_block1 = /*pageNum*/ ctx[0] === 2 && create_if_block$6(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			add_location(div, file$l, 6, 0, 154);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t);
    			if (if_block1) if_block1.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*pageNum*/ ctx[0] === 1) {
    				if (!if_block0) {
    					if_block0 = create_if_block_1$4(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t);
    				} else {
    					transition_in(if_block0, 1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*pageNum*/ ctx[0] === 2) {
    				if (!if_block1) {
    					if_block1 = create_if_block$6(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, null);
    				} else {
    					transition_in(if_block1, 1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let { pageNum = 1 } = $$props;
    	const writable_props = ["pageNum"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Select_page> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ("pageNum" in $$props) $$invalidate(0, pageNum = $$props.pageNum);
    	};

    	$$self.$capture_state = () => {
    		return { pageNum };
    	};

    	$$self.$inject_state = $$props => {
    		if ("pageNum" in $$props) $$invalidate(0, pageNum = $$props.pageNum);
    	};

    	return [pageNum];
    }

    class Select_page extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$o, safe_not_equal, { pageNum: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Select_page",
    			options,
    			id: create_fragment$o.name
    		});
    	}

    	get pageNum() {
    		throw new Error("<Select_page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pageNum(value) {
    		throw new Error("<Select_page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/routes/test/add_test.svelte generated by Svelte v3.18.1 */
    const file$m = "src/routes/test/add_test.svelte";

    function create_fragment$p(ctx) {
    	let div2;
    	let header;
    	let t0;
    	let subheader;
    	let t1;
    	let main;
    	let t2;
    	let footer;
    	let div0;
    	let button0;
    	let t4;
    	let div1;
    	let button1;
    	let current;
    	let dispose;
    	const navbar = new Navbar({ $$inline: true });

    	const subnavbar = new Test_navbar({
    			props: { position: /*pageNum*/ ctx[0] },
    			$$inline: true
    		});

    	const selectpage = new Select_page({
    			props: {
    				pageNum: /*pageNum*/ ctx[0],
    				class: "h-full"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			header = element("header");
    			create_component(navbar.$$.fragment);
    			t0 = space();
    			subheader = element("subheader");
    			create_component(subnavbar.$$.fragment);
    			t1 = space();
    			main = element("main");
    			create_component(selectpage.$$.fragment);
    			t2 = space();
    			footer = element("footer");
    			div0 = element("div");
    			button0 = element("button");
    			button0.textContent = "Prev";
    			t4 = space();
    			div1 = element("div");
    			button1 = element("button");
    			button1.textContent = "Next";
    			attr_dev(subheader, "class", "svelte-sxkr2r");
    			add_location(subheader, file$m, 16, 4, 664);
    			attr_dev(header, "class", "svelte-sxkr2r");
    			add_location(header, file$m, 14, 2, 636);
    			attr_dev(main, "class", " mx-auto w-full flex-grow overflow-auto svelte-sxkr2r");
    			add_location(main, file$m, 20, 2, 746);
    			attr_dev(button0, "id", "prevbutton");
    			attr_dev(button0, "class", "py-4 px-6 float-left shadow-md no-underline rounded-full bg-dark\n        text-white font-sans font-semibold text-sm border-white btn-primary\n        hover:text-white text-xl hover:bg-elight focus:outline-none\n        active:shadow-none mr-2 svelte-sxkr2r");
    			add_location(button0, file$m, 25, 6, 947);
    			attr_dev(div0, "class", "flex-1  svelte-sxkr2r");
    			add_location(div0, file$m, 24, 4, 919);
    			attr_dev(button1, "id", "nextbutton");
    			attr_dev(button1, "class", "py-4 px-6 shadow-md text-xl float-right no-underline rounded-full\n        bg-dark text-white font-sans font-semibold text-sm border-white\n        btn-primary hover:text-dark hover:bg-elight focus:outline-none\n        active:shadow-none mr-2 svelte-sxkr2r");
    			add_location(button1, file$m, 42, 6, 1461);
    			attr_dev(div1, "class", "flex-1 svelte-sxkr2r");
    			add_location(div1, file$m, 41, 4, 1434);
    			attr_dev(footer, "class", " footer my-8 w-full px-20 mx-auto sticky svelte-sxkr2r");
    			add_location(footer, file$m, 23, 2, 857);
    			attr_dev(div2, "class", "w-screen bg-edark h-screen flex flex-col svelte-sxkr2r");
    			add_location(div2, file$m, 13, 0, 579);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, header);
    			mount_component(navbar, header, null);
    			append_dev(header, t0);
    			append_dev(header, subheader);
    			mount_component(subnavbar, subheader, null);
    			append_dev(div2, t1);
    			append_dev(div2, main);
    			mount_component(selectpage, main, null);
    			append_dev(div2, t2);
    			append_dev(div2, footer);
    			append_dev(footer, div0);
    			append_dev(div0, button0);
    			append_dev(footer, t4);
    			append_dev(footer, div1);
    			append_dev(div1, button1);
    			current = true;

    			dispose = [
    				listen_dev(button0, "click", /*click_handler*/ ctx[1], false, false, false),
    				listen_dev(button1, "click", /*click_handler_1*/ ctx[2], false, false, false)
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			const subnavbar_changes = {};
    			if (dirty & /*pageNum*/ 1) subnavbar_changes.position = /*pageNum*/ ctx[0];
    			subnavbar.$set(subnavbar_changes);
    			const selectpage_changes = {};
    			if (dirty & /*pageNum*/ 1) selectpage_changes.pageNum = /*pageNum*/ ctx[0];
    			selectpage.$set(selectpage_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(subnavbar.$$.fragment, local);
    			transition_in(selectpage.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(subnavbar.$$.fragment, local);
    			transition_out(selectpage.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(navbar);
    			destroy_component(subnavbar);
    			destroy_component(selectpage);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	const click_handler = () => {
    		if (pageNum === 1) {
    			return;
    		}

    		$$invalidate(0, pageNum--, pageNum);
    		console.log(pageNum);
    	};

    	const click_handler_1 = () => {
    		if (pageNum === 2) {
    			return;
    		}

    		$$invalidate(0, pageNum++, pageNum);
    		console.log(pageNum);
    	};

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("pageNum" in $$props) $$invalidate(0, pageNum = $$props.pageNum);
    	};

    	let pageNum;
    	 $$invalidate(0, pageNum = 1);
    	return [pageNum, click_handler, click_handler_1];
    }

    class Add_test extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$n, create_fragment$p, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Add_test",
    			options,
    			id: create_fragment$p.name
    		});
    	}
    }

    /* src/routes/editTest.svelte generated by Svelte v3.18.1 */

    const { console: console_1$5 } = globals;
    const file$n = "src/routes/editTest.svelte";

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[19] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[22] = list[i];
    	return child_ctx;
    }

    // (205:16) {#each ppp as p}
    function create_each_block_1$2(ctx) {
    	let li;
    	let t_value = /*p*/ ctx[22] + "";
    	let t;

    	const block = {
    		c: function create() {
    			li = element("li");
    			t = text(t_value);
    			attr_dev(li, "class", "text-xl mb-2");
    			add_location(li, file$n, 205, 18, 7471);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*ppp*/ 2 && t_value !== (t_value = /*p*/ ctx[22] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$2.name,
    		type: "each",
    		source: "(205:16) {#each ppp as p}",
    		ctx
    	});

    	return block;
    }

    // (243:16) {:catch err}
    function create_catch_block$6(ctx) {
    	let t0;
    	let t1_value = /*err*/ ctx[18] + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("Error: ");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$Problems*/ 4 && t1_value !== (t1_value = /*err*/ ctx[18] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block$6.name,
    		type: "catch",
    		source: "(243:16) {:catch err}",
    		ctx
    	});

    	return block;
    }

    // (228:16) {:then result}
    function create_then_block$6(ctx) {
    	let each_1_anchor;
    	let each_value = /*result*/ ctx[17].data.allProblems;
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$Problems, testInitial, changeHandler*/ 69) {
    				each_value = /*result*/ ctx[17].data.allProblems;
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$8(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$8(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block$6.name,
    		type: "then",
    		source: "(228:16) {:then result}",
    		ctx
    	});

    	return block;
    }

    // (229:18) {#each result.data.allProblems as prob}
    function create_each_block$8(ctx) {
    	let label;
    	let li;
    	let input;
    	let input_value_value;
    	let t0;
    	let t1_value = /*prob*/ ctx[19].problemName + "";
    	let t1;
    	let t2;
    	let dispose;

    	const block = {
    		c: function create() {
    			label = element("label");
    			li = element("li");
    			input = element("input");
    			t0 = space();
    			t1 = text(t1_value);
    			t2 = space();
    			attr_dev(input, "type", "checkbox");
    			input.__value = input_value_value = /*prob*/ ctx[19].id;
    			input.value = input.__value;
    			/*$$binding_groups*/ ctx[13][0].push(input);
    			add_location(input, file$n, 232, 24, 8356);
    			add_location(li, file$n, 230, 22, 8243);
    			add_location(label, file$n, 229, 20, 8213);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label, anchor);
    			append_dev(label, li);
    			append_dev(li, input);
    			input.checked = ~/*testInitial*/ ctx[0].problems.indexOf(input.__value);
    			append_dev(li, t0);
    			append_dev(li, t1);
    			append_dev(label, t2);

    			dispose = [
    				listen_dev(input, "change", /*input_change_handler*/ ctx[16]),
    				listen_dev(
    					input,
    					"change",
    					function () {
    						if (is_function(/*changeHandler*/ ctx[6](/*prob*/ ctx[19].problemName))) /*changeHandler*/ ctx[6](/*prob*/ ctx[19].problemName).apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				)
    			];
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*$Problems*/ 4 && input_value_value !== (input_value_value = /*prob*/ ctx[19].id)) {
    				prop_dev(input, "__value", input_value_value);
    			}

    			input.value = input.__value;

    			if (dirty & /*testInitial*/ 1) {
    				input.checked = ~/*testInitial*/ ctx[0].problems.indexOf(input.__value);
    			}

    			if (dirty & /*$Problems*/ 4 && t1_value !== (t1_value = /*prob*/ ctx[19].problemName + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label);
    			/*$$binding_groups*/ ctx[13][0].splice(/*$$binding_groups*/ ctx[13][0].indexOf(input), 1);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$8.name,
    		type: "each",
    		source: "(229:18) {#each result.data.allProblems as prob}",
    		ctx
    	});

    	return block;
    }

    // (226:34)                    Loading...                 {:then result}
    function create_pending_block$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Loading...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block$6.name,
    		type: "pending",
    		source: "(226:34)                    Loading...                 {:then result}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$q(ctx) {
    	let link;
    	let t0;
    	let body;
    	let div22;
    	let t1;
    	let h1;
    	let strong;
    	let t3;
    	let div21;
    	let div12;
    	let div11;
    	let div10;
    	let div9;
    	let br0;
    	let t4;
    	let div2;
    	let div1;
    	let div0;
    	let input0;
    	let t5;
    	let br1;
    	let t6;
    	let div8;
    	let div7;
    	let div6;
    	let div5;
    	let div3;
    	let label0;
    	let t8;
    	let div4;
    	let label1;
    	let input1;
    	let t9;
    	let span0;
    	let t11;
    	let label2;
    	let input2;
    	let t12;
    	let span1;
    	let t14;
    	let label3;
    	let input3;
    	let t15;
    	let span2;
    	let t17;
    	let br2;
    	let t18;
    	let p;
    	let t20;
    	let ul;
    	let t21;
    	let div20;
    	let div18;
    	let div17;
    	let div16;
    	let div15;
    	let div14;
    	let div13;
    	let t23;
    	let ol;
    	let promise;
    	let t24;
    	let div19;
    	let button;
    	let current;
    	let dispose;
    	const navbar = new Navbar({ $$inline: true });
    	let each_value_1 = /*ppp*/ ctx[1];
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		pending: create_pending_block$6,
    		then: create_then_block$6,
    		catch: create_catch_block$6,
    		value: 17,
    		error: 18
    	};

    	handle_promise(promise = /*$Problems*/ ctx[2], info);

    	const block = {
    		c: function create() {
    			link = element("link");
    			t0 = space();
    			body = element("body");
    			div22 = element("div");
    			create_component(navbar.$$.fragment);
    			t1 = space();
    			h1 = element("h1");
    			strong = element("strong");
    			strong.textContent = "Add New Test";
    			t3 = space();
    			div21 = element("div");
    			div12 = element("div");
    			div11 = element("div");
    			div10 = element("div");
    			div9 = element("div");
    			br0 = element("br");
    			t4 = space();
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			input0 = element("input");
    			t5 = space();
    			br1 = element("br");
    			t6 = space();
    			div8 = element("div");
    			div7 = element("div");
    			div6 = element("div");
    			div5 = element("div");
    			div3 = element("div");
    			label0 = element("label");
    			label0.textContent = "Difficulty Type";
    			t8 = space();
    			div4 = element("div");
    			label1 = element("label");
    			input1 = element("input");
    			t9 = space();
    			span0 = element("span");
    			span0.textContent = "Easy";
    			t11 = space();
    			label2 = element("label");
    			input2 = element("input");
    			t12 = space();
    			span1 = element("span");
    			span1.textContent = "Medium";
    			t14 = space();
    			label3 = element("label");
    			input3 = element("input");
    			t15 = space();
    			span2 = element("span");
    			span2.textContent = "Hard";
    			t17 = space();
    			br2 = element("br");
    			t18 = space();
    			p = element("p");
    			p.textContent = "Problems Added:";
    			t20 = space();
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t21 = space();
    			div20 = element("div");
    			div18 = element("div");
    			div17 = element("div");
    			div16 = element("div");
    			div15 = element("div");
    			div14 = element("div");
    			div13 = element("div");
    			div13.textContent = "All Problems";
    			t23 = space();
    			ol = element("ol");
    			info.block.c();
    			t24 = space();
    			div19 = element("div");
    			button = element("button");
    			button.textContent = "Save";
    			attr_dev(link, "href", "https://unpkg.com/tailwindcss@^1.0/dist/tailwind.min.css");
    			attr_dev(link, "rel", "stylesheet");
    			add_location(link, file$n, 126, 0, 4268);
    			add_location(strong, file$n, 134, 6, 4474);
    			attr_dev(h1, "class", "heading svelte-1thzmrb");
    			add_location(h1, file$n, 133, 4, 4447);
    			attr_dev(br0, "class", "my-24");
    			add_location(br0, file$n, 143, 14, 4749);
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "placeholder", "Enter Test Name...");
    			add_location(input0, file$n, 148, 20, 4949);
    			attr_dev(div0, "class", "font-bold text-3xl mb-2");
    			add_location(div0, file$n, 147, 18, 4891);
    			attr_dev(div1, "class", "flex-initial text-center px-4 py-2 m-2");
    			add_location(div1, file$n, 146, 16, 4820);
    			attr_dev(div2, "class", "flex");
    			add_location(div2, file$n, 145, 14, 4785);
    			add_location(br1, file$n, 155, 14, 5187);
    			attr_dev(label0, "class", "block text-gray-500 font-bold md:text-right\n                          mb-1 md:mb-0 pr-4");
    			attr_dev(label0, "for", "inline-username");
    			add_location(label0, file$n, 161, 24, 5477);
    			attr_dev(div3, "class", "md:w-2/3");
    			add_location(div3, file$n, 160, 22, 5430);
    			attr_dev(input1, "type", "radio");
    			attr_dev(input1, "class", "form-radio");
    			attr_dev(input1, "name", "difficultyType");
    			input1.__value = "easy";
    			input1.value = input1.__value;
    			/*$$binding_groups*/ ctx[13][1].push(input1);
    			add_location(input1, file$n, 170, 26, 5887);
    			attr_dev(span0, "class", "ml-2 text-gray-500");
    			add_location(span0, file$n, 176, 26, 6171);
    			attr_dev(label1, "class", "inline-flex items-center");
    			add_location(label1, file$n, 169, 24, 5820);
    			attr_dev(input2, "type", "radio");
    			attr_dev(input2, "class", "form-radio");
    			attr_dev(input2, "name", "difficultyType");
    			input2.__value = "medium";
    			input2.value = input2.__value;
    			/*$$binding_groups*/ ctx[13][1].push(input2);
    			add_location(input2, file$n, 179, 26, 6345);
    			attr_dev(span1, "class", "ml-2 text-gray-500");
    			add_location(span1, file$n, 185, 26, 6631);
    			attr_dev(label2, "class", "inline-flex items-center ml-6");
    			add_location(label2, file$n, 178, 24, 6273);
    			attr_dev(input3, "type", "radio");
    			attr_dev(input3, "class", "form-radio");
    			attr_dev(input3, "name", "difficultyType");
    			input3.__value = "hard";
    			input3.value = input3.__value;
    			/*$$binding_groups*/ ctx[13][1].push(input3);
    			add_location(input3, file$n, 188, 26, 6807);
    			attr_dev(span2, "class", "ml-2 text-gray-500");
    			add_location(span2, file$n, 194, 26, 7091);
    			attr_dev(label3, "class", "inline-flex items-center ml-6");
    			add_location(label3, file$n, 187, 24, 6735);
    			attr_dev(div4, "class", "");
    			add_location(div4, file$n, 168, 22, 5781);
    			attr_dev(div5, "class", " md:items-center mb-6");
    			add_location(div5, file$n, 159, 20, 5372);
    			attr_dev(div6, "class", "font-bold text-3xl mb-2");
    			add_location(div6, file$n, 158, 18, 5314);
    			attr_dev(div7, "class", "flex-initial text-center px-4 py-2 m-2");
    			add_location(div7, file$n, 157, 16, 5243);
    			attr_dev(div8, "class", "flex");
    			add_location(div8, file$n, 156, 14, 5208);
    			add_location(br2, file$n, 201, 14, 7308);
    			attr_dev(p, "class", "font-bold text-2xl mb-2");
    			add_location(p, file$n, 202, 14, 7329);
    			attr_dev(ul, "class", "problist svelte-1thzmrb");
    			add_location(ul, file$n, 203, 14, 7398);
    			attr_dev(div9, "class", "px-12 py-8");
    			add_location(div9, file$n, 141, 12, 4709);
    			attr_dev(div10, "class", "max-w-auto rounded overflow-hidden shadow-lg");
    			add_location(div10, file$n, 140, 10, 4638);
    			attr_dev(div11, "class", "p-8 mx-2 mt-5 items-center");
    			add_location(div11, file$n, 139, 8, 4587);
    			attr_dev(div12, "class", "w-1/2 h-12");
    			add_location(div12, file$n, 137, 6, 4553);
    			attr_dev(div13, "class", "font-bold text-3xl mb-2");
    			add_location(div13, file$n, 221, 18, 7921);
    			attr_dev(div14, "class", "flex-initial text-center px-4 py-2 m-2");
    			add_location(div14, file$n, 220, 16, 7850);
    			attr_dev(div15, "class", "flex");
    			add_location(div15, file$n, 219, 14, 7815);
    			add_location(ol, file$n, 224, 14, 8035);
    			attr_dev(div16, "class", "px-6 py-4");
    			add_location(div16, file$n, 218, 12, 7777);
    			attr_dev(div17, "class", "max-w-auto rounded overflow-hidden shadow-lg");
    			add_location(div17, file$n, 217, 10, 7706);
    			attr_dev(div18, "class", "p-8 mx-2 mt-5 items-center");
    			add_location(div18, file$n, 216, 8, 7655);
    			attr_dev(button, "class", "bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4\n            border border-blue-700 rounded submitbutton svelte-1thzmrb");
    			add_location(button, file$n, 250, 10, 8942);
    			attr_dev(div19, "class", "buttonbox svelte-1thzmrb");
    			add_location(div19, file$n, 249, 8, 8908);
    			attr_dev(div20, "class", "w-1/2 h-12");
    			add_location(div20, file$n, 215, 6, 7622);
    			attr_dev(div21, "class", "flex mb-4 h-12");
    			add_location(div21, file$n, 136, 4, 4518);
    			add_location(div22, file$n, 130, 2, 4371);
    			add_location(body, file$n, 129, 0, 4362);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, link, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, body, anchor);
    			append_dev(body, div22);
    			mount_component(navbar, div22, null);
    			append_dev(div22, t1);
    			append_dev(div22, h1);
    			append_dev(h1, strong);
    			append_dev(div22, t3);
    			append_dev(div22, div21);
    			append_dev(div21, div12);
    			append_dev(div12, div11);
    			append_dev(div11, div10);
    			append_dev(div10, div9);
    			append_dev(div9, br0);
    			append_dev(div9, t4);
    			append_dev(div9, div2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, input0);
    			set_input_value(input0, /*testInitial*/ ctx[0].testName);
    			append_dev(div9, t5);
    			append_dev(div9, br1);
    			append_dev(div9, t6);
    			append_dev(div9, div8);
    			append_dev(div8, div7);
    			append_dev(div7, div6);
    			append_dev(div6, div5);
    			append_dev(div5, div3);
    			append_dev(div3, label0);
    			append_dev(div5, t8);
    			append_dev(div5, div4);
    			append_dev(div4, label1);
    			append_dev(label1, input1);
    			input1.checked = input1.__value === /*testInitial*/ ctx[0].difficultyLevel;
    			append_dev(label1, t9);
    			append_dev(label1, span0);
    			append_dev(div4, t11);
    			append_dev(div4, label2);
    			append_dev(label2, input2);
    			input2.checked = input2.__value === /*testInitial*/ ctx[0].difficultyLevel;
    			append_dev(label2, t12);
    			append_dev(label2, span1);
    			append_dev(div4, t14);
    			append_dev(div4, label3);
    			append_dev(label3, input3);
    			input3.checked = input3.__value === /*testInitial*/ ctx[0].difficultyLevel;
    			append_dev(label3, t15);
    			append_dev(label3, span2);
    			append_dev(div9, t17);
    			append_dev(div9, br2);
    			append_dev(div9, t18);
    			append_dev(div9, p);
    			append_dev(div9, t20);
    			append_dev(div9, ul);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			append_dev(div21, t21);
    			append_dev(div21, div20);
    			append_dev(div20, div18);
    			append_dev(div18, div17);
    			append_dev(div17, div16);
    			append_dev(div16, div15);
    			append_dev(div15, div14);
    			append_dev(div14, div13);
    			append_dev(div16, t23);
    			append_dev(div16, ol);
    			info.block.m(ol, info.anchor = null);
    			info.mount = () => ol;
    			info.anchor = null;
    			append_dev(div20, t24);
    			append_dev(div20, div19);
    			append_dev(div19, button);
    			current = true;

    			dispose = [
    				listen_dev(input0, "input", /*input0_input_handler*/ ctx[11]),
    				listen_dev(input1, "change", /*input1_change_handler*/ ctx[12]),
    				listen_dev(input2, "change", /*input2_change_handler*/ ctx[14]),
    				listen_dev(input3, "change", /*input3_change_handler*/ ctx[15]),
    				listen_dev(button, "click", /*clickHandler*/ ctx[5], false, false, false)
    			];
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;

    			if (dirty & /*testInitial*/ 1 && input0.value !== /*testInitial*/ ctx[0].testName) {
    				set_input_value(input0, /*testInitial*/ ctx[0].testName);
    			}

    			if (dirty & /*testInitial*/ 1) {
    				input1.checked = input1.__value === /*testInitial*/ ctx[0].difficultyLevel;
    			}

    			if (dirty & /*testInitial*/ 1) {
    				input2.checked = input2.__value === /*testInitial*/ ctx[0].difficultyLevel;
    			}

    			if (dirty & /*testInitial*/ 1) {
    				input3.checked = input3.__value === /*testInitial*/ ctx[0].difficultyLevel;
    			}

    			if (dirty & /*ppp*/ 2) {
    				each_value_1 = /*ppp*/ ctx[1];
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			info.ctx = ctx;

    			if (dirty & /*$Problems*/ 4 && promise !== (promise = /*$Problems*/ ctx[2]) && handle_promise(promise, info)) ; else {
    				const child_ctx = ctx.slice();
    				child_ctx[17] = info.resolved;
    				info.block.p(child_ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(link);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(body);
    			destroy_component(navbar);
    			/*$$binding_groups*/ ctx[13][1].splice(/*$$binding_groups*/ ctx[13][1].indexOf(input1), 1);
    			/*$$binding_groups*/ ctx[13][1].splice(/*$$binding_groups*/ ctx[13][1].indexOf(input2), 1);
    			/*$$binding_groups*/ ctx[13][1].splice(/*$$binding_groups*/ ctx[13][1].indexOf(input3), 1);
    			destroy_each(each_blocks, detaching);
    			info.block.d();
    			info.token = null;
    			info = null;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let $test;
    	let $Problems;
    	let { currentRoute } = $$props;

    	let testInitial = {
    		id: "",
    		testName: "",
    		difficultyLevel: "",
    		problems: []
    	};

    	const client = getClient();

    	const test = subscribe$2(client, {
    		query: apolloClient.getTestById,
    		variables: { id: currentRoute.namedParams.id }
    	});

    	validate_store(test, "test");
    	component_subscribe($$self, test, value => $$invalidate(8, $test = value));
    	let test_id;

    	$test.then(res => {
    		const tt = { ...res.data.testById };
    		$$invalidate(0, testInitial.testName = tt.testName, testInitial);
    		$$invalidate(0, testInitial.id = tt.id, testInitial);
    		$$invalidate(0, testInitial.difficultyLevel = tt.difficultyLevel, testInitial);

    		$$invalidate(
    			0,
    			testInitial.problems = [
    				...tt.problems.map(ele => {
    					$$invalidate(1, ppp = [...ppp, ele.problemName]);
    					return ele.id;
    				})
    			],
    			testInitial
    		);
    	});

    	const Problems = subscribe$2(client, { query: apolloClient.getProblems });
    	validate_store(Problems, "Problems");
    	component_subscribe($$self, Problems, value => $$invalidate(2, $Problems = value));

    	async function clickHandler() {
    		console.log(testInitial);

    		if (testInitial.testName === "" || testInitial.difficultyLevel === "" || testInitial.problems.length === 0) {
    			return false;
    		}

    		try {
    			await mutate(client, {
    				mutation: apolloClient.updateTest,
    				variables: testInitial
    			});
    		} catch(err) {
    			console.log(err);
    		}

    		location.replace("http://localhost:5000/admin");
    	}

    	function changeHandler(name) {
    		console.log(ppp.length, name);
    		let rr = ppp.length;

    		$$invalidate(1, ppp = [
    			...ppp.filter(ele => {
    				return ele !== name;
    			})
    		]);

    		if (rr === ppp.length) {
    			$$invalidate(1, ppp = [...ppp, name]);
    		}
    	}

    	const writable_props = ["currentRoute"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$5.warn(`<EditTest> was created with unknown prop '${key}'`);
    	});

    	const $$binding_groups = [[], []];

    	function input0_input_handler() {
    		testInitial.testName = this.value;
    		$$invalidate(0, testInitial);
    	}

    	function input1_change_handler() {
    		testInitial.difficultyLevel = this.__value;
    		$$invalidate(0, testInitial);
    	}

    	function input2_change_handler() {
    		testInitial.difficultyLevel = this.__value;
    		$$invalidate(0, testInitial);
    	}

    	function input3_change_handler() {
    		testInitial.difficultyLevel = this.__value;
    		$$invalidate(0, testInitial);
    	}

    	function input_change_handler() {
    		testInitial.problems = get_binding_group_value($$binding_groups[0]);
    		$$invalidate(0, testInitial);
    	}

    	$$self.$set = $$props => {
    		if ("currentRoute" in $$props) $$invalidate(7, currentRoute = $$props.currentRoute);
    	};

    	$$self.$capture_state = () => {
    		return {
    			currentRoute,
    			testInitial,
    			test_id,
    			ppp,
    			$test,
    			$Problems
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("currentRoute" in $$props) $$invalidate(7, currentRoute = $$props.currentRoute);
    		if ("testInitial" in $$props) $$invalidate(0, testInitial = $$props.testInitial);
    		if ("test_id" in $$props) test_id = $$props.test_id;
    		if ("ppp" in $$props) $$invalidate(1, ppp = $$props.ppp);
    		if ("$test" in $$props) test.set($test = $$props.$test);
    		if ("$Problems" in $$props) Problems.set($Problems = $$props.$Problems);
    	};

    	let ppp;
    	 $$invalidate(1, ppp = []);

    	return [
    		testInitial,
    		ppp,
    		$Problems,
    		test,
    		Problems,
    		clickHandler,
    		changeHandler,
    		currentRoute,
    		$test,
    		client,
    		test_id,
    		input0_input_handler,
    		input1_change_handler,
    		$$binding_groups,
    		input2_change_handler,
    		input3_change_handler,
    		input_change_handler
    	];
    }

    class EditTest extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$o, create_fragment$q, safe_not_equal, { currentRoute: 7 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EditTest",
    			options,
    			id: create_fragment$q.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*currentRoute*/ ctx[7] === undefined && !("currentRoute" in props)) {
    			console_1$5.warn("<EditTest> was created without expected prop 'currentRoute'");
    		}
    	}

    	get currentRoute() {
    		throw new Error("<EditTest>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set currentRoute(value) {
    		throw new Error("<EditTest>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/routes/problem/problem_navbar.svelte generated by Svelte v3.18.1 */

    const file$o = "src/routes/problem/problem_navbar.svelte";

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (20:6) {#if index !== content.length}
    function create_if_block$7(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let div1_class_value;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "class", " text-xs leading-none py-1 text-center rounded ");
    			add_location(div0, file$o, 25, 12, 1008);

    			attr_dev(div1, "class", div1_class_value = /*index*/ ctx[4] < /*position*/ ctx[0]
    			? /*activeBar*/ ctx[3]
    			: "w-full text-grey-darkest  bg-light rounded items-center align-middle align-center flex-1");

    			add_location(div1, file$o, 23, 10, 848);
    			attr_dev(div2, "class", "w-1/6 align-center items-center align-middle content-center\n          flex");
    			add_location(div2, file$o, 20, 8, 739);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*position*/ 1 && div1_class_value !== (div1_class_value = /*index*/ ctx[4] < /*position*/ ctx[0]
    			? /*activeBar*/ ctx[3]
    			: "w-full text-grey-darkest  bg-light rounded items-center align-middle align-center flex-1")) {
    				attr_dev(div1, "class", div1_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(20:6) {#if index !== content.length}",
    		ctx
    	});

    	return block;
    }

    // (13:4) {#each content as index}
    function create_each_block$9(ctx) {
    	let div1;
    	let div0;
    	let span;
    	let t0_value = /*index*/ ctx[4] + "";
    	let t0;
    	let div0_class_value;
    	let t1;
    	let if_block_anchor;
    	let if_block = /*index*/ ctx[4] !== /*content*/ ctx[1].length && create_if_block$7(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr_dev(span, "class", "text-center w-full text-2xl");
    			add_location(span, file$o, 16, 10, 609);

    			attr_dev(div0, "class", div0_class_value = /*index*/ ctx[4] <= /*position*/ ctx[0]
    			? /*activeCircle*/ ctx[2]
    			: "w-16 h-16  bg-light text-white border-2 mx-auto rounded-full text-lg flex items-center");

    			add_location(div0, file$o, 14, 8, 451);
    			attr_dev(div1, "class", "flex-1");
    			add_location(div1, file$o, 13, 6, 422);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, span);
    			append_dev(span, t0);
    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*position*/ 1 && div0_class_value !== (div0_class_value = /*index*/ ctx[4] <= /*position*/ ctx[0]
    			? /*activeCircle*/ ctx[2]
    			: "w-16 h-16  bg-light text-white border-2 mx-auto rounded-full text-lg flex items-center")) {
    				attr_dev(div0, "class", div0_class_value);
    			}

    			if (/*index*/ ctx[4] !== /*content*/ ctx[1].length) if_block.p(ctx, dirty);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$9.name,
    		type: "each",
    		source: "(13:4) {#each content as index}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$r(ctx) {
    	let div8;
    	let div2;
    	let div0;
    	let t0;
    	let t1;
    	let div1;
    	let t2;
    	let div7;
    	let div3;
    	let t4;
    	let div4;
    	let t6;
    	let div5;
    	let t8;
    	let div6;
    	let each_value = /*content*/ ctx[1];
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div8 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			t0 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			div1 = element("div");
    			t2 = space();
    			div7 = element("div");
    			div3 = element("div");
    			div3.textContent = "Problem Initials";
    			t4 = space();
    			div4 = element("div");
    			div4.textContent = "Problem Statement";
    			t6 = space();
    			div5 = element("div");
    			div5.textContent = "Solution";
    			t8 = space();
    			div6 = element("div");
    			div6.textContent = "Test Cases";
    			attr_dev(div0, "class", "flex-1");
    			add_location(div0, file$o, 11, 4, 364);
    			attr_dev(div1, "class", "flex-1");
    			add_location(div1, file$o, 31, 4, 1133);
    			attr_dev(div2, "class", "flex pb-3");
    			add_location(div2, file$o, 10, 2, 336);
    			attr_dev(div3, "class", "w-1/4 text-xl text-elight ");
    			add_location(div3, file$o, 35, 4, 1226);
    			attr_dev(div4, "class", "w-1/4 text-xl text-elight");
    			add_location(div4, file$o, 37, 4, 1294);
    			attr_dev(div5, "class", "w-1/4 text-xl text-elight");
    			add_location(div5, file$o, 39, 4, 1362);
    			attr_dev(div6, "class", "w-1/4 text-xl text-elight");
    			add_location(div6, file$o, 41, 4, 1421);
    			attr_dev(div7, "class", "flex text-xs content-center text-center");
    			add_location(div7, file$o, 34, 2, 1168);
    			attr_dev(div8, "class", "max-w-2xl mx-auto py-4 my-4 pb-4");
    			add_location(div8, file$o, 9, 0, 287);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div8, anchor);
    			append_dev(div8, div2);
    			append_dev(div2, div0);
    			append_dev(div2, t0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div2, null);
    			}

    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div8, t2);
    			append_dev(div8, div7);
    			append_dev(div7, div3);
    			append_dev(div7, t4);
    			append_dev(div7, div4);
    			append_dev(div7, t6);
    			append_dev(div7, div5);
    			append_dev(div7, t8);
    			append_dev(div7, div6);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*content, position, activeBar, activeCircle*/ 15) {
    				each_value = /*content*/ ctx[1];
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$9(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$9(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div2, t1);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div8);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let { position = 1 } = $$props;
    	let content = [1, 2, 3, 4];
    	let activeCircle = "w-16 h-16 text-dark bg-elight  mx-auto rounded-full text-lg flex items-center";

    	let activeBar = `w-full bg-elight rounded items-center
            align-middle align-center flex-1`;

    	const writable_props = ["position"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Problem_navbar> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ("position" in $$props) $$invalidate(0, position = $$props.position);
    	};

    	$$self.$capture_state = () => {
    		return {
    			position,
    			content,
    			activeCircle,
    			activeBar
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("position" in $$props) $$invalidate(0, position = $$props.position);
    		if ("content" in $$props) $$invalidate(1, content = $$props.content);
    		if ("activeCircle" in $$props) $$invalidate(2, activeCircle = $$props.activeCircle);
    		if ("activeBar" in $$props) $$invalidate(3, activeBar = $$props.activeBar);
    	};

    	return [position, content, activeCircle, activeBar];
    }

    class Problem_navbar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$p, create_fragment$r, safe_not_equal, { position: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Problem_navbar",
    			options,
    			id: create_fragment$r.name
    		});
    	}

    	get position() {
    		throw new Error("<Problem_navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set position(value) {
    		throw new Error("<Problem_navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/routes/problem/loader.svelte generated by Svelte v3.18.1 */

    const file$p = "src/routes/problem/loader.svelte";

    function create_fragment$s(ctx) {
    	let div3;
    	let div0;
    	let t0;
    	let div1;
    	let t1;
    	let div2;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			t1 = space();
    			div2 = element("div");
    			attr_dev(div0, "class", "LoaderBalls__item svelte-5k6xhq");
    			add_location(div0, file$p, 42, 2, 2497);
    			attr_dev(div1, "class", "LoaderBalls__item svelte-5k6xhq");
    			add_location(div1, file$p, 43, 2, 2533);
    			attr_dev(div2, "class", "LoaderBalls__item svelte-5k6xhq");
    			add_location(div2, file$p, 44, 2, 2569);
    			attr_dev(div3, "class", "LoaderBalls svelte-5k6xhq");
    			add_location(div3, file$p, 41, 0, 2469);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div3, t0);
    			append_dev(div3, div1);
    			append_dev(div3, t1);
    			append_dev(div3, div2);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    class Loader$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, null, create_fragment$s, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Loader",
    			options,
    			id: create_fragment$s.name
    		});
    	}
    }

    const problemStore = writable({
      problemName: '',
      timelimit: '',
      datalimit: '',
      solution: 'function solution([...args])',
      problemTests: '',
      tags: '',
      description: '',
      email: 'Sample@gmail.com',
    });

    /* src/routes/problem/problem_initials.svelte generated by Svelte v3.18.1 */
    const file$q = "src/routes/problem/problem_initials.svelte";

    function get_each_context$a(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i];
    	child_ctx[16] = i;
    	return child_ctx;
    }

    // (118:10) {#if uniqueNameStatus === 2}
    function create_if_block_2$2(ctx) {
    	let current;
    	const loader = new Loader$1({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(loader.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loader, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loader, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(118:10) {#if uniqueNameStatus === 2}",
    		ctx
    	});

    	return block;
    }

    // (121:10) {#if uniqueNameStatus === 1}
    function create_if_block_1$5(ctx) {
    	let i;

    	const block = {
    		c: function create() {
    			i = element("i");
    			i.textContent = "";
    			attr_dev(i, "class", "material-icons status svelte-cftn61");
    			add_location(i, file$q, 121, 12, 4019);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(121:10) {#if uniqueNameStatus === 1}",
    		ctx
    	});

    	return block;
    }

    // (124:10) {#if uniqueNameStatus === 3}
    function create_if_block$8(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "clear";
    			attr_dev(span, "class", "status material-icons svelte-cftn61");
    			add_location(span, file$q, 124, 12, 4132);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(124:10) {#if uniqueNameStatus === 3}",
    		ctx
    	});

    	return block;
    }

    // (166:14) {#each tagList as tag, index}
    function create_each_block$a(ctx) {
    	let option;
    	let t0_value = /*tag*/ ctx[14] + "";
    	let t0;
    	let t1;
    	let option_name_value;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(option, "class", "text-xl px-2 text-edark");
    			attr_dev(option, "name", option_name_value = /*tag*/ ctx[14]);
    			option.__value = option_value_value = /*index*/ ctx[16];
    			option.value = option.__value;
    			add_location(option, file$q, 166, 16, 5446);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t0);
    			append_dev(option, t1);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$a.name,
    		type: "each",
    		source: "(166:14) {#each tagList as tag, index}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$t(ctx) {
    	let div14;
    	let div13;
    	let div5;
    	let label0;
    	let t1;
    	let div4;
    	let div2;
    	let div0;
    	let input0;
    	let t2;
    	let div1;
    	let p;
    	let t4;
    	let div3;
    	let t5;
    	let t6;
    	let t7;
    	let div12;
    	let div6;
    	let h2;
    	let t9;
    	let div11;
    	let div7;
    	let label1;
    	let t11;
    	let input1;
    	let t12;
    	let span0;
    	let t14;
    	let div8;
    	let label2;
    	let t16;
    	let input2;
    	let t17;
    	let span1;
    	let t19;
    	let div10;
    	let label3;
    	let t21;
    	let div9;
    	let select;
    	let t22;
    	let input3;
    	let current;
    	let dispose;
    	let if_block0 = /*uniqueNameStatus*/ ctx[2] === 2 && create_if_block_2$2(ctx);
    	let if_block1 = /*uniqueNameStatus*/ ctx[2] === 1 && create_if_block_1$5(ctx);
    	let if_block2 = /*uniqueNameStatus*/ ctx[2] === 3 && create_if_block$8(ctx);
    	let each_value = /*tagList*/ ctx[4];
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div14 = element("div");
    			div13 = element("div");
    			div5 = element("div");
    			label0 = element("label");
    			label0.textContent = "Enter a unique Problem code";
    			t1 = space();
    			div4 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			input0 = element("input");
    			t2 = space();
    			div1 = element("div");
    			p = element("p");
    			p.textContent = `${/*alert*/ ctx[3]}`;
    			t4 = space();
    			div3 = element("div");
    			if (if_block0) if_block0.c();
    			t5 = space();
    			if (if_block1) if_block1.c();
    			t6 = space();
    			if (if_block2) if_block2.c();
    			t7 = space();
    			div12 = element("div");
    			div6 = element("div");
    			h2 = element("h2");
    			h2.textContent = "Other Details";
    			t9 = space();
    			div11 = element("div");
    			div7 = element("div");
    			label1 = element("label");
    			label1.textContent = "Enter Time limit";
    			t11 = space();
    			input1 = element("input");
    			t12 = space();
    			span0 = element("span");
    			span0.textContent = "ms";
    			t14 = space();
    			div8 = element("div");
    			label2 = element("label");
    			label2.textContent = "Enter Memory limit";
    			t16 = space();
    			input2 = element("input");
    			t17 = space();
    			span1 = element("span");
    			span1.textContent = "Mb";
    			t19 = space();
    			div10 = element("div");
    			label3 = element("label");
    			label3.textContent = "Add Tags";
    			t21 = space();
    			div9 = element("div");
    			select = element("select");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t22 = space();
    			input3 = element("input");
    			attr_dev(label0, "class", "text-elight text-2xl my-3");
    			add_location(label0, file$q, 97, 6, 3232);
    			attr_dev(input0, "type", "search");
    			attr_dev(input0, "name", "serch");
    			attr_dev(input0, "placeholder", "Search");
    			attr_dev(input0, "class", "bg-elight h-10 px-5 pr-10 rounded-full w-full text-xl\n              tet-edark focus:outline-none");
    			add_location(input0, file$q, 103, 12, 3432);
    			attr_dev(div0, "class", "w-full");
    			add_location(div0, file$q, 102, 10, 3399);
    			attr_dev(p, "class", "text-white text-sm my-2");
    			add_location(p, file$q, 113, 12, 3784);
    			add_location(div1, file$q, 112, 10, 3766);
    			attr_dev(div2, "class", " flex-col w-full");
    			add_location(div2, file$q, 101, 8, 3358);
    			attr_dev(div3, "class", "ml-3");
    			add_location(div3, file$q, 116, 8, 3871);
    			attr_dev(div4, "class", "flex");
    			add_location(div4, file$q, 100, 6, 3331);
    			add_location(div5, file$q, 96, 4, 3220);
    			attr_dev(h2, "class", "labels text-2xl svelte-cftn61");
    			add_location(h2, file$q, 131, 8, 4318);
    			add_location(div6, file$q, 130, 6, 4304);
    			attr_dev(label1, "class", "labels svelte-cftn61");
    			add_location(label1, file$q, 135, 10, 4414);
    			attr_dev(input1, "class", "unitinput svelte-cftn61");
    			attr_dev(input1, "type", "text");
    			attr_dev(input1, "placeholder", "in milli seconds");
    			add_location(input1, file$q, 136, 10, 4471);
    			attr_dev(span0, "class", "unit svelte-cftn61");
    			add_location(span0, file$q, 141, 10, 4637);
    			add_location(div7, file$q, 134, 8, 4398);
    			attr_dev(label2, "class", "labels svelte-cftn61");
    			add_location(label2, file$q, 144, 10, 4705);
    			attr_dev(input2, "class", "unitinput svelte-cftn61");
    			attr_dev(input2, "type", "text");
    			attr_dev(input2, "placeholder", "in Mbs");
    			add_location(input2, file$q, 145, 10, 4764);
    			attr_dev(span1, "class", "unit svelte-cftn61");
    			add_location(span1, file$q, 150, 10, 4920);
    			add_location(div8, file$q, 143, 8, 4689);
    			attr_dev(label3, "class", "labels svelte-cftn61");
    			add_location(label3, file$q, 154, 10, 4989);
    			attr_dev(select, "class", "unitinput outline-none w-64 svelte-cftn61");
    			add_location(select, file$q, 156, 12, 5078);
    			attr_dev(input3, "type", "text");
    			attr_dev(input3, "class", "unitinput svelte-cftn61");
    			input3.readOnly = true;
    			add_location(input3, file$q, 174, 12, 5672);
    			attr_dev(div9, "class", "flex-col flex");
    			add_location(div9, file$q, 155, 10, 5038);
    			add_location(div10, file$q, 153, 8, 4973);
    			add_location(div11, file$q, 133, 6, 4384);
    			attr_dev(div12, "class", "border-solid border-2 mt-6 border-light p-4");
    			add_location(div12, file$q, 129, 4, 4240);
    			attr_dev(div13, "class", "text-edark mx-auto max-w-5xl w-full");
    			add_location(div13, file$q, 95, 2, 3166);
    			attr_dev(div14, "class", "mx-auto flex-col flex-grow");
    			add_location(div14, file$q, 94, 0, 3123);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div14, anchor);
    			append_dev(div14, div13);
    			append_dev(div13, div5);
    			append_dev(div5, label0);
    			append_dev(div5, t1);
    			append_dev(div5, div4);
    			append_dev(div4, div2);
    			append_dev(div2, div0);
    			append_dev(div0, input0);
    			set_input_value(input0, /*$problemStore*/ ctx[1].problemName);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			append_dev(div1, p);
    			append_dev(div4, t4);
    			append_dev(div4, div3);
    			if (if_block0) if_block0.m(div3, null);
    			append_dev(div3, t5);
    			if (if_block1) if_block1.m(div3, null);
    			append_dev(div3, t6);
    			if (if_block2) if_block2.m(div3, null);
    			append_dev(div13, t7);
    			append_dev(div13, div12);
    			append_dev(div12, div6);
    			append_dev(div6, h2);
    			append_dev(div12, t9);
    			append_dev(div12, div11);
    			append_dev(div11, div7);
    			append_dev(div7, label1);
    			append_dev(div7, t11);
    			append_dev(div7, input1);
    			set_input_value(input1, /*$problemStore*/ ctx[1].timelimit);
    			append_dev(div7, t12);
    			append_dev(div7, span0);
    			append_dev(div11, t14);
    			append_dev(div11, div8);
    			append_dev(div8, label2);
    			append_dev(div8, t16);
    			append_dev(div8, input2);
    			set_input_value(input2, /*$problemStore*/ ctx[1].datalimit);
    			append_dev(div8, t17);
    			append_dev(div8, span1);
    			append_dev(div11, t19);
    			append_dev(div11, div10);
    			append_dev(div10, label3);
    			append_dev(div10, t21);
    			append_dev(div10, div9);
    			append_dev(div9, select);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			append_dev(div9, t22);
    			append_dev(div9, input3);
    			set_input_value(input3, /*hastTagString*/ ctx[0]);
    			current = true;

    			dispose = [
    				listen_dev(input0, "keydown", /*onInput*/ ctx[6], false, false, false),
    				listen_dev(input0, "input", /*input0_input_handler*/ ctx[9]),
    				listen_dev(input1, "input", /*input1_input_handler*/ ctx[10]),
    				listen_dev(input2, "input", /*input2_input_handler*/ ctx[11]),
    				listen_dev(select, "change", /*change_handler*/ ctx[12], false, false, false),
    				listen_dev(input3, "input", /*input3_input_handler*/ ctx[13])
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$problemStore*/ 2) {
    				set_input_value(input0, /*$problemStore*/ ctx[1].problemName);
    			}

    			if (/*uniqueNameStatus*/ ctx[2] === 2) {
    				if (!if_block0) {
    					if_block0 = create_if_block_2$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div3, t5);
    				} else {
    					transition_in(if_block0, 1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*uniqueNameStatus*/ ctx[2] === 1) {
    				if (!if_block1) {
    					if_block1 = create_if_block_1$5(ctx);
    					if_block1.c();
    					if_block1.m(div3, t6);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*uniqueNameStatus*/ ctx[2] === 3) {
    				if (!if_block2) {
    					if_block2 = create_if_block$8(ctx);
    					if_block2.c();
    					if_block2.m(div3, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (dirty & /*$problemStore*/ 2 && input1.value !== /*$problemStore*/ ctx[1].timelimit) {
    				set_input_value(input1, /*$problemStore*/ ctx[1].timelimit);
    			}

    			if (dirty & /*$problemStore*/ 2 && input2.value !== /*$problemStore*/ ctx[1].datalimit) {
    				set_input_value(input2, /*$problemStore*/ ctx[1].datalimit);
    			}

    			if (dirty & /*tagList*/ 16) {
    				each_value = /*tagList*/ ctx[4];
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$a(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$a(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*hastTagString*/ 1 && input3.value !== /*hastTagString*/ ctx[0]) {
    				set_input_value(input3, /*hastTagString*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div14);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			destroy_each(each_blocks, detaching);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let $problemStore;
    	validate_store(problemStore, "problemStore");
    	component_subscribe($$self, problemStore, $$value => $$invalidate(1, $problemStore = $$value));
    	console.log($problemStore);
    	let alert = "*Name must be in capital letters with no space in between and no special characters";

    	const tagList = [
    		"Choose Tags",
    		"Dynamic_Programming",
    		"Mathematics",
    		"Binary_Search",
    		"Graph",
    		"Algorithm",
    		"Data_Structure",
    		"Trees"
    	];

    	const client = getClient();
    	let selectedTags = [];
    	let hastTagString = "";

    	function changeHandler(indexValue) {
    		console.log(selectedTags.length, indexValue);
    		let rr = selectedTags.length;

    		selectedTags = [
    			...selectedTags.filter(ele => {
    				return ele !== indexValue;
    			})
    		];

    		if (rr === selectedTags.length) {
    			selectedTags = [...selectedTags, indexValue];
    		}

    		$$invalidate(0, hastTagString = "");

    		selectedTags.forEach(ind => {
    			$$invalidate(0, hastTagString += "#" + tagList[ind]);
    		});

    		set_store_value(problemStore, $problemStore.tags = hastTagString, $problemStore);
    	}

    	const onInput = (function checkIfAvailable() {
    		let timer;

    		return e => {
    			timer = setTimeout(
    				async () => {
    					$$invalidate(2, uniqueNameStatus = 2);

    					const res = await mutate(client, {
    						mutation: apolloClient.checkIfAvailable,
    						variables: { problemName: $problemStore.problemName }
    					});

    					console.log(res);

    					if (res.data.checkProblemIfExists.success === false) {
    						$$invalidate(2, uniqueNameStatus = 1);
    					} else {
    						$$invalidate(2, uniqueNameStatus = 3);
    					}
    				},
    				30
    			);
    		};
    	})();

    	function input0_input_handler() {
    		$problemStore.problemName = this.value;
    		problemStore.set($problemStore);
    	}

    	function input1_input_handler() {
    		$problemStore.timelimit = this.value;
    		problemStore.set($problemStore);
    	}

    	function input2_input_handler() {
    		$problemStore.datalimit = this.value;
    		problemStore.set($problemStore);
    	}

    	const change_handler = e => {
    		console.log(e.target.value);

    		if (parseInt(e.target.value) === 0) {
    			return;
    		}

    		changeHandler(parseInt(e.target.value));
    	};

    	function input3_input_handler() {
    		hastTagString = this.value;
    		$$invalidate(0, hastTagString);
    	}

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("alert" in $$props) $$invalidate(3, alert = $$props.alert);
    		if ("selectedTags" in $$props) selectedTags = $$props.selectedTags;
    		if ("hastTagString" in $$props) $$invalidate(0, hastTagString = $$props.hastTagString);
    		if ("$problemStore" in $$props) problemStore.set($problemStore = $$props.$problemStore);
    		if ("uniqueNameStatus" in $$props) $$invalidate(2, uniqueNameStatus = $$props.uniqueNameStatus);
    	};

    	let uniqueNameStatus;
    	 $$invalidate(2, uniqueNameStatus = 0);

    	return [
    		hastTagString,
    		$problemStore,
    		uniqueNameStatus,
    		alert,
    		tagList,
    		changeHandler,
    		onInput,
    		selectedTags,
    		client,
    		input0_input_handler,
    		input1_input_handler,
    		input2_input_handler,
    		change_handler,
    		input3_input_handler
    	];
    }

    class Problem_initials extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$q, create_fragment$t, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Problem_initials",
    			options,
    			id: create_fragment$t.name
    		});
    	}
    }

    /* src/routes/problem/problem_statement.svelte generated by Svelte v3.18.1 */
    const file$r = "src/routes/problem/problem_statement.svelte";

    function create_fragment$u(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let label;
    	let t1;
    	let textarea;
    	let dispose;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			label = element("label");
    			label.textContent = "Describe Problem Statement here";
    			t1 = space();
    			textarea = element("textarea");
    			attr_dev(label, "class", " text-2xl text-elight mb-3 my-2");
    			add_location(label, file$r, 13, 6, 622);
    			attr_dev(textarea, "class", " h-full w-full bg-dark text-elight text-2xl border\n        border-gray-200 rounded py-3 px-4 mb-3 leading-tight focus:outline-none\n        focus:border-white h-48 resize-none");
    			attr_dev(textarea, "id", "message");
    			add_location(textarea, file$r, 16, 6, 731);
    			attr_dev(div0, "class", "w-full h-full px-3");
    			add_location(div0, file$r, 12, 4, 583);
    			attr_dev(div1, "class", "flex-col mx-3 w-full mb-6");
    			add_location(div1, file$r, 11, 2, 539);
    			attr_dev(div2, "class", "max-w-6xl mx-auto flex statement flex-grow  svelte-ah4uim");
    			add_location(div2, file$r, 10, 0, 479);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, label);
    			append_dev(div0, t1);
    			append_dev(div0, textarea);
    			set_input_value(textarea, /*$problemStore*/ ctx[0].description);
    			dispose = listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[1]);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$problemStore*/ 1) {
    				set_input_value(textarea, /*$problemStore*/ ctx[0].description);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let $problemStore;
    	validate_store(problemStore, "problemStore");
    	component_subscribe($$self, problemStore, $$value => $$invalidate(0, $problemStore = $$value));

    	function textarea_input_handler() {
    		$problemStore.description = this.value;
    		problemStore.set($problemStore);
    	}

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("$problemStore" in $$props) problemStore.set($problemStore = $$props.$problemStore);
    	};

    	return [$problemStore, textarea_input_handler];
    }

    class Problem_statement extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$r, create_fragment$u, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Problem_statement",
    			options,
    			id: create_fragment$u.name
    		});
    	}
    }

    /* src/routes/problem/testcase.svelte generated by Svelte v3.18.1 */
    const file$s = "src/routes/problem/testcase.svelte";

    function create_fragment$v(ctx) {
    	let div2;
    	let h1;
    	let t1;
    	let div0;
    	let t2;
    	let div1;
    	let button;
    	let dispose;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Enter TestCases";
    			t1 = space();
    			div0 = element("div");
    			t2 = space();
    			div1 = element("div");
    			button = element("button");
    			button.textContent = "Submit";
    			attr_dev(h1, "class", "text-2xl text-elight mt-3 my-2 svelte-ashmvh");
    			add_location(h1, file$s, 78, 2, 2812);
    			attr_dev(div0, "id", "editor");
    			attr_dev(div0, "class", "editor mx-60 box-border flex-grow svelte-ashmvh");
    			add_location(div0, file$s, 80, 2, 2879);
    			attr_dev(button, "class", "bg-dark hover:bg-elight hover:text-edark outline-none text-white\n      font-bold py-4 px-4 text-xl rounded-full svelte-ashmvh");
    			add_location(button, file$s, 85, 4, 3019);
    			attr_dev(div1, "class", "my-3 flex justify-center svelte-ashmvh");
    			add_location(div1, file$s, 84, 2, 2976);
    			attr_dev(div2, "class", "mx-64 flex-grow editor_window box-border svelte-ashmvh");
    			add_location(div2, file$s, 77, 0, 2755);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, h1);
    			append_dev(div2, t1);
    			append_dev(div2, div0);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			append_dev(div1, button);

    			dispose = [
    				listen_dev(div0, "keydown", /*onInput*/ ctx[0], false, false, false),
    				listen_dev(button, "click", /*click_handler*/ ctx[5], false, false, false)
    			];
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let $problemStore;
    	validate_store(problemStore, "problemStore");
    	component_subscribe($$self, problemStore, $$value => $$invalidate(3, $problemStore = $$value));
    	const client = getClient();
    	console.log($problemStore);
    	let editor;

    	onMount(() => {
    		ace.config.set("basePath", "ace-builds/src-noconflict/");
    		editor = ace.edit("editor");

    		editor.setOptions({
    			enableBasicAutocompletion: true,
    			enableSnippets: true,
    			highlightActiveLine: true,
    			showPrintMargin: false,
    			theme: "ace/theme/tomorrow_night",
    			mode: "ace/mode/javascript",
    			enableLiveAutocompletion: true,
    			useWorker: false
    		});
    	});

    	afterUpdate(() => {
    		var pos = editor.session.selection.toJSON();
    		editor.session.setValue($problemStore.problemTests);
    		editor.session.selection.fromJSON(pos);
    	});

    	const onInput = (function onInput() {
    		let timer;

    		return e => {
    			clearTimeout(timer);

    			timer = setTimeout(
    				() => {
    					set_store_value(problemStore, $problemStore.problemTests = editor.getValue(), $problemStore);
    				},
    				500
    			);
    		};
    	})();

    	async function submitData() {
    		let problemValue = {
    			problemName: $problemStore.problemName,
    			description: $problemStore.description,
    			problemTests: JSON.stringify($problemStore.problemTests),
    			tags: $problemStore.tags,
    			solution: $problemStore.solution,
    			timelimit: $problemStore.timelimit,
    			datalimit: $problemStore.datalimit,
    			email: $problemStore.email
    		};

    		console.log(problemValue);

    		const res = await mutate(client, {
    			mutation: apolloClient.addProblem,
    			variables: problemValue
    		});

    		location.replace("http://localhost:5000/admin");
    	}

    	const click_handler = e => {
    		submitData();
    	};

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("editor" in $$props) editor = $$props.editor;
    		if ("$problemStore" in $$props) problemStore.set($problemStore = $$props.$problemStore);
    	};

    	return [onInput, submitData, editor, $problemStore, client, click_handler];
    }

    class Testcase extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$s, create_fragment$v, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Testcase",
    			options,
    			id: create_fragment$v.name
    		});
    	}
    }

    /* src/routes/problem/problem_solution.svelte generated by Svelte v3.18.1 */
    const file$t = "src/routes/problem/problem_solution.svelte";

    function create_fragment$w(ctx) {
    	let div8;
    	let h1;
    	let t1;
    	let div0;
    	let t2;
    	let div6;
    	let div3;
    	let h20;
    	let t4;
    	let div2;
    	let div1;
    	let t5;
    	let div5;
    	let h21;
    	let t7;
    	let div4;
    	let textarea;
    	let t8;
    	let div7;
    	let button;
    	let dispose;

    	const block = {
    		c: function create() {
    			div8 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Enter Solution";
    			t1 = space();
    			div0 = element("div");
    			t2 = space();
    			div6 = element("div");
    			div3 = element("div");
    			h20 = element("h2");
    			h20.textContent = "Input";
    			t4 = space();
    			div2 = element("div");
    			div1 = element("div");
    			t5 = space();
    			div5 = element("div");
    			h21 = element("h2");
    			h21.textContent = "Output";
    			t7 = space();
    			div4 = element("div");
    			textarea = element("textarea");
    			t8 = space();
    			div7 = element("div");
    			button = element("button");
    			button.textContent = "Run";
    			attr_dev(h1, "class", "text-2xl text-elight mt-3 my-2 svelte-1da7xg3");
    			add_location(h1, file$t, 82, 2, 2798);
    			attr_dev(div0, "id", "editor");
    			attr_dev(div0, "class", "editor mx-60 box-border flex-grow svelte-1da7xg3");
    			add_location(div0, file$t, 83, 2, 2863);
    			attr_dev(h20, "class", "text-xl text-elight my-3 my-2 svelte-1da7xg3");
    			add_location(h20, file$t, 90, 6, 3076);
    			attr_dev(div1, "id", "inputeditor");
    			attr_dev(div1, "class", "inputeditor text-xl h-full box-border  svelte-1da7xg3");
    			add_location(div1, file$t, 92, 8, 3183);
    			attr_dev(div2, "class", "flex-grow h-48 box-border svelte-1da7xg3");
    			add_location(div2, file$t, 91, 6, 3135);
    			attr_dev(div3, "class", "flex-1 mr-4 box-border svelte-1da7xg3");
    			add_location(div3, file$t, 89, 4, 3033);
    			attr_dev(h21, "class", "text-xl text-elight my-3 my-2 box-border svelte-1da7xg3");
    			add_location(h21, file$t, 99, 6, 3366);
    			attr_dev(textarea, "class", " h-full w-full bg-dark text-elight text-xl box-border\n          border-none rounded py-3 px-4 mb-3 leading-tight focus:outline-none\n          resize-none svelte-1da7xg3");
    			attr_dev(textarea, "id", "message");
    			textarea.readOnly = true;
    			add_location(textarea, file$t, 101, 8, 3474);
    			attr_dev(div4, "class", "flex-grow h-48 svelte-1da7xg3");
    			add_location(div4, file$t, 100, 6, 3437);
    			attr_dev(div5, "class", "flex-1 ml-4 svelte-1da7xg3");
    			add_location(div5, file$t, 98, 4, 3334);
    			attr_dev(div6, "class", "flex my-4 p-2 border-solid h-64 border-2 border-light svelte-1da7xg3");
    			add_location(div6, file$t, 88, 2, 2961);
    			attr_dev(button, "class", "bg-dark hover:bg-elight hover:text-edark outline-none text-white\n      float-right font-bold py-2 px-4 rounded-full svelte-1da7xg3");
    			add_location(button, file$t, 112, 4, 3776);
    			attr_dev(div7, "class", "svelte-1da7xg3");
    			add_location(div7, file$t, 111, 2, 3766);
    			attr_dev(div8, "class", "mx-64 flex-grow editor_window box-border svelte-1da7xg3");
    			add_location(div8, file$t, 81, 0, 2741);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div8, anchor);
    			append_dev(div8, h1);
    			append_dev(div8, t1);
    			append_dev(div8, div0);
    			append_dev(div8, t2);
    			append_dev(div8, div6);
    			append_dev(div6, div3);
    			append_dev(div3, h20);
    			append_dev(div3, t4);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div6, t5);
    			append_dev(div6, div5);
    			append_dev(div5, h21);
    			append_dev(div5, t7);
    			append_dev(div5, div4);
    			append_dev(div4, textarea);
    			set_input_value(textarea, /*result*/ ctx[0]);
    			append_dev(div8, t8);
    			append_dev(div8, div7);
    			append_dev(div7, button);

    			dispose = [
    				listen_dev(div0, "keydown", /*onInput*/ ctx[1], false, false, false),
    				listen_dev(div1, "keydown", /*onInput*/ ctx[1], false, false, false),
    				listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[6]),
    				listen_dev(button, "click", /*click_handler*/ ctx[7], false, false, false)
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*result*/ 1) {
    				set_input_value(textarea, /*result*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div8);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let $problemStore;
    	validate_store(problemStore, "problemStore");
    	component_subscribe($$self, problemStore, $$value => $$invalidate(5, $problemStore = $$value));
    	console.log($problemStore);
    	let editor;
    	let inputeditor;

    	onMount(() => {
    		ace.config.set("basePath", "ace-builds/src-noconflict/");
    		editor = ace.edit("editor");

    		editor.setOptions({
    			enableBasicAutocompletion: true,
    			enableSnippets: true,
    			highlightActiveLine: true,
    			showPrintMargin: false,
    			theme: "ace/theme/tomorrow_night",
    			mode: "ace/mode/javascript",
    			enableLiveAutocompletion: true,
    			useWorker: false
    		});

    		inputeditor = ace.edit("inputeditor");

    		inputeditor.setOptions({
    			enableBasicAutocompletion: true,
    			enableSnippets: true,
    			highlightActiveLine: true,
    			showPrintMargin: false,
    			theme: "ace/theme/tomorrow_night",
    			mode: "ace/mode/javascript",
    			enableLiveAutocompletion: true,
    			useWorker: false
    		});
    	});

    	afterUpdate(() => {
    		var pos = editor.session.selection.toJSON();
    		console.log($problemStore.solution);
    		editor.session.setValue($problemStore.solution);
    		editor.session.selection.fromJSON(pos);
    	});

    	const onInput = (function onInput() {
    		let timer;

    		return e => {
    			clearTimeout(timer);

    			timer = setTimeout(
    				() => {
    					set_store_value(problemStore, $problemStore.solution = editor.getValue(), $problemStore);
    				},
    				500
    			);
    		};
    	})();

    	let result = "";

    	function outputData(e) {
    		try {
    			let code = editor.getValue();
    			console.log(code);
    			set_store_value(problemStore, $problemStore.solution = code, $problemStore);
    			console.log(editor.getValue());
    			let testCase = inputeditor.getValue();
    			$$invalidate(0, result = eval(`${code} solution(${testCase})`));
    		} catch(err) {
    			$$invalidate(0, result = err);
    		}
    	}

    	function textarea_input_handler() {
    		result = this.value;
    		$$invalidate(0, result);
    	}

    	const click_handler = e => {
    		outputData();
    	};

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("editor" in $$props) editor = $$props.editor;
    		if ("inputeditor" in $$props) inputeditor = $$props.inputeditor;
    		if ("result" in $$props) $$invalidate(0, result = $$props.result);
    		if ("$problemStore" in $$props) problemStore.set($problemStore = $$props.$problemStore);
    	};

    	return [
    		result,
    		onInput,
    		outputData,
    		editor,
    		inputeditor,
    		$problemStore,
    		textarea_input_handler,
    		click_handler
    	];
    }

    class Problem_solution extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$t, create_fragment$w, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Problem_solution",
    			options,
    			id: create_fragment$w.name
    		});
    	}
    }

    /* src/routes/problem/select_page.svelte generated by Svelte v3.18.1 */
    const file$u = "src/routes/problem/select_page.svelte";

    // (10:2) {#if pageNum === 1}
    function create_if_block_3(ctx) {
    	let current;
    	const probleminitials = new Problem_initials({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(probleminitials.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(probleminitials, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(probleminitials.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(probleminitials.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(probleminitials, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(10:2) {#if pageNum === 1}",
    		ctx
    	});

    	return block;
    }

    // (13:2) {#if pageNum === 2}
    function create_if_block_2$3(ctx) {
    	let current;
    	const problemstatement = new Problem_statement({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(problemstatement.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(problemstatement, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(problemstatement.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(problemstatement.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(problemstatement, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(13:2) {#if pageNum === 2}",
    		ctx
    	});

    	return block;
    }

    // (16:2) {#if pageNum === 3}
    function create_if_block_1$6(ctx) {
    	let current;
    	const problemsolution = new Problem_solution({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(problemsolution.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(problemsolution, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(problemsolution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(problemsolution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(problemsolution, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(16:2) {#if pageNum === 3}",
    		ctx
    	});

    	return block;
    }

    // (19:2) {#if pageNum === 4}
    function create_if_block$9(ctx) {
    	let current;
    	const testcase = new Testcase({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(testcase.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(testcase, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(testcase.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(testcase.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(testcase, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(19:2) {#if pageNum === 4}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$x(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let current;
    	let if_block0 = /*pageNum*/ ctx[0] === 1 && create_if_block_3(ctx);
    	let if_block1 = /*pageNum*/ ctx[0] === 2 && create_if_block_2$3(ctx);
    	let if_block2 = /*pageNum*/ ctx[0] === 3 && create_if_block_1$6(ctx);
    	let if_block3 = /*pageNum*/ ctx[0] === 4 && create_if_block$9(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			if (if_block3) if_block3.c();
    			add_location(div, file$u, 8, 0, 269);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);
    			if (if_block2) if_block2.m(div, null);
    			append_dev(div, t2);
    			if (if_block3) if_block3.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*pageNum*/ ctx[0] === 1) {
    				if (!if_block0) {
    					if_block0 = create_if_block_3(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				} else {
    					transition_in(if_block0, 1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*pageNum*/ ctx[0] === 2) {
    				if (!if_block1) {
    					if_block1 = create_if_block_2$3(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t1);
    				} else {
    					transition_in(if_block1, 1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*pageNum*/ ctx[0] === 3) {
    				if (!if_block2) {
    					if_block2 = create_if_block_1$6(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, t2);
    				} else {
    					transition_in(if_block2, 1);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*pageNum*/ ctx[0] === 4) {
    				if (!if_block3) {
    					if_block3 = create_if_block$9(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div, null);
    				} else {
    					transition_in(if_block3, 1);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let { pageNum = 1 } = $$props;
    	const writable_props = ["pageNum"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Select_page> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ("pageNum" in $$props) $$invalidate(0, pageNum = $$props.pageNum);
    	};

    	$$self.$capture_state = () => {
    		return { pageNum };
    	};

    	$$self.$inject_state = $$props => {
    		if ("pageNum" in $$props) $$invalidate(0, pageNum = $$props.pageNum);
    	};

    	return [pageNum];
    }

    class Select_page$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$u, create_fragment$x, safe_not_equal, { pageNum: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Select_page",
    			options,
    			id: create_fragment$x.name
    		});
    	}

    	get pageNum() {
    		throw new Error("<Select_page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pageNum(value) {
    		throw new Error("<Select_page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/routes/problem/add_problem.svelte generated by Svelte v3.18.1 */
    const file$v = "src/routes/problem/add_problem.svelte";

    function create_fragment$y(ctx) {
    	let div2;
    	let header;
    	let t0;
    	let subheader;
    	let t1;
    	let main;
    	let t2;
    	let footer;
    	let div0;
    	let button0;
    	let t4;
    	let div1;
    	let button1;
    	let current;
    	let dispose;
    	const navbar = new Navbar({ $$inline: true });

    	const subnavbar = new Problem_navbar({
    			props: { position: /*pageNum*/ ctx[0] },
    			$$inline: true
    		});

    	const selectpage = new Select_page$1({
    			props: {
    				pageNum: /*pageNum*/ ctx[0],
    				class: "h-full"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			header = element("header");
    			create_component(navbar.$$.fragment);
    			t0 = space();
    			subheader = element("subheader");
    			create_component(subnavbar.$$.fragment);
    			t1 = space();
    			main = element("main");
    			create_component(selectpage.$$.fragment);
    			t2 = space();
    			footer = element("footer");
    			div0 = element("div");
    			button0 = element("button");
    			button0.textContent = "Prev";
    			t4 = space();
    			div1 = element("div");
    			button1 = element("button");
    			button1.textContent = "Next";
    			attr_dev(subheader, "class", "svelte-1cw36oz");
    			add_location(subheader, file$v, 16, 4, 683);
    			attr_dev(header, "class", "svelte-1cw36oz");
    			add_location(header, file$v, 14, 2, 655);
    			attr_dev(main, "class", " mx-auto w-full flex-grow overflow-auto svelte-1cw36oz");
    			add_location(main, file$v, 20, 2, 765);
    			attr_dev(button0, "id", "prevbutton");
    			attr_dev(button0, "class", "py-4 px-6 float-left shadow-md no-underline rounded-full bg-dark\n        text-white font-sans font-semibold text-sm border-white btn-primary\n        hover:text-white text-xl hover:bg-elight focus:outline-none\n        active:shadow-none mr-2 svelte-1cw36oz");
    			add_location(button0, file$v, 25, 6, 966);
    			attr_dev(div0, "class", "flex-1  svelte-1cw36oz");
    			add_location(div0, file$v, 24, 4, 938);
    			attr_dev(button1, "id", "nextbutton");
    			attr_dev(button1, "class", "py-4 px-6 shadow-md text-xl float-right no-underline rounded-full\n        bg-dark text-white font-sans font-semibold text-sm border-white\n        btn-primary hover:text-dark hover:bg-elight focus:outline-none\n        active:shadow-none mr-2 svelte-1cw36oz");
    			add_location(button1, file$v, 42, 6, 1480);
    			attr_dev(div1, "class", "flex-1 svelte-1cw36oz");
    			add_location(div1, file$v, 41, 4, 1453);
    			attr_dev(footer, "class", " footer my-8 w-full px-20 mx-auto sticky svelte-1cw36oz");
    			add_location(footer, file$v, 23, 2, 876);
    			attr_dev(div2, "class", "w-screen bg-edark h-screen flex flex-col svelte-1cw36oz");
    			add_location(div2, file$v, 13, 0, 598);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, header);
    			mount_component(navbar, header, null);
    			append_dev(header, t0);
    			append_dev(header, subheader);
    			mount_component(subnavbar, subheader, null);
    			append_dev(div2, t1);
    			append_dev(div2, main);
    			mount_component(selectpage, main, null);
    			append_dev(div2, t2);
    			append_dev(div2, footer);
    			append_dev(footer, div0);
    			append_dev(div0, button0);
    			append_dev(footer, t4);
    			append_dev(footer, div1);
    			append_dev(div1, button1);
    			current = true;

    			dispose = [
    				listen_dev(button0, "click", /*click_handler*/ ctx[1], false, false, false),
    				listen_dev(button1, "click", /*click_handler_1*/ ctx[2], false, false, false)
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			const subnavbar_changes = {};
    			if (dirty & /*pageNum*/ 1) subnavbar_changes.position = /*pageNum*/ ctx[0];
    			subnavbar.$set(subnavbar_changes);
    			const selectpage_changes = {};
    			if (dirty & /*pageNum*/ 1) selectpage_changes.pageNum = /*pageNum*/ ctx[0];
    			selectpage.$set(selectpage_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(subnavbar.$$.fragment, local);
    			transition_in(selectpage.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(subnavbar.$$.fragment, local);
    			transition_out(selectpage.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(navbar);
    			destroy_component(subnavbar);
    			destroy_component(selectpage);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	const click_handler = () => {
    		if (pageNum === 1) {
    			return;
    		}

    		$$invalidate(0, pageNum--, pageNum);
    		console.log(pageNum);
    	};

    	const click_handler_1 = () => {
    		if (pageNum === 4) {
    			return;
    		}

    		$$invalidate(0, pageNum++, pageNum);
    		console.log(pageNum);
    	};

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("pageNum" in $$props) $$invalidate(0, pageNum = $$props.pageNum);
    	};

    	let pageNum;
    	 $$invalidate(0, pageNum = 1);
    	return [pageNum, click_handler, click_handler_1];
    }

    class Add_problem extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$v, create_fragment$y, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Add_problem",
    			options,
    			id: create_fragment$y.name
    		});
    	}
    }

    /* src/routes/update_problem/problem_navbar.svelte generated by Svelte v3.18.1 */

    const file$w = "src/routes/update_problem/problem_navbar.svelte";

    function get_each_context$b(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (20:6) {#if index !== content.length}
    function create_if_block$a(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let div1_class_value;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "class", " text-xs leading-none py-1 text-center rounded ");
    			add_location(div0, file$w, 25, 12, 1008);

    			attr_dev(div1, "class", div1_class_value = /*index*/ ctx[4] < /*position*/ ctx[0]
    			? /*activeBar*/ ctx[3]
    			: "w-full text-grey-darkest  bg-light rounded items-center align-middle align-center flex-1");

    			add_location(div1, file$w, 23, 10, 848);
    			attr_dev(div2, "class", "w-1/6 align-center items-center align-middle content-center\n          flex");
    			add_location(div2, file$w, 20, 8, 739);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*position*/ 1 && div1_class_value !== (div1_class_value = /*index*/ ctx[4] < /*position*/ ctx[0]
    			? /*activeBar*/ ctx[3]
    			: "w-full text-grey-darkest  bg-light rounded items-center align-middle align-center flex-1")) {
    				attr_dev(div1, "class", div1_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(20:6) {#if index !== content.length}",
    		ctx
    	});

    	return block;
    }

    // (13:4) {#each content as index}
    function create_each_block$b(ctx) {
    	let div1;
    	let div0;
    	let span;
    	let t0_value = /*index*/ ctx[4] + "";
    	let t0;
    	let div0_class_value;
    	let t1;
    	let if_block_anchor;
    	let if_block = /*index*/ ctx[4] !== /*content*/ ctx[1].length && create_if_block$a(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr_dev(span, "class", "text-center w-full text-2xl");
    			add_location(span, file$w, 16, 10, 609);

    			attr_dev(div0, "class", div0_class_value = /*index*/ ctx[4] <= /*position*/ ctx[0]
    			? /*activeCircle*/ ctx[2]
    			: "w-16 h-16  bg-light text-white border-2 mx-auto rounded-full text-lg flex items-center");

    			add_location(div0, file$w, 14, 8, 451);
    			attr_dev(div1, "class", "flex-1");
    			add_location(div1, file$w, 13, 6, 422);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, span);
    			append_dev(span, t0);
    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*position*/ 1 && div0_class_value !== (div0_class_value = /*index*/ ctx[4] <= /*position*/ ctx[0]
    			? /*activeCircle*/ ctx[2]
    			: "w-16 h-16  bg-light text-white border-2 mx-auto rounded-full text-lg flex items-center")) {
    				attr_dev(div0, "class", div0_class_value);
    			}

    			if (/*index*/ ctx[4] !== /*content*/ ctx[1].length) if_block.p(ctx, dirty);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$b.name,
    		type: "each",
    		source: "(13:4) {#each content as index}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$z(ctx) {
    	let div8;
    	let div2;
    	let div0;
    	let t0;
    	let t1;
    	let div1;
    	let t2;
    	let div7;
    	let div3;
    	let t4;
    	let div4;
    	let t6;
    	let div5;
    	let t8;
    	let div6;
    	let each_value = /*content*/ ctx[1];
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div8 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			t0 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			div1 = element("div");
    			t2 = space();
    			div7 = element("div");
    			div3 = element("div");
    			div3.textContent = "Problem Initials";
    			t4 = space();
    			div4 = element("div");
    			div4.textContent = "Problem Statement";
    			t6 = space();
    			div5 = element("div");
    			div5.textContent = "Solution";
    			t8 = space();
    			div6 = element("div");
    			div6.textContent = "Test Cases";
    			attr_dev(div0, "class", "flex-1");
    			add_location(div0, file$w, 11, 4, 364);
    			attr_dev(div1, "class", "flex-1");
    			add_location(div1, file$w, 31, 4, 1133);
    			attr_dev(div2, "class", "flex pb-3");
    			add_location(div2, file$w, 10, 2, 336);
    			attr_dev(div3, "class", "w-1/4 text-xl text-elight ");
    			add_location(div3, file$w, 35, 4, 1226);
    			attr_dev(div4, "class", "w-1/4 text-xl text-elight");
    			add_location(div4, file$w, 37, 4, 1294);
    			attr_dev(div5, "class", "w-1/4 text-xl text-elight");
    			add_location(div5, file$w, 39, 4, 1362);
    			attr_dev(div6, "class", "w-1/4 text-xl text-elight");
    			add_location(div6, file$w, 41, 4, 1421);
    			attr_dev(div7, "class", "flex text-xs content-center text-center");
    			add_location(div7, file$w, 34, 2, 1168);
    			attr_dev(div8, "class", "max-w-2xl mx-auto py-4 my-4 pb-4");
    			add_location(div8, file$w, 9, 0, 287);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div8, anchor);
    			append_dev(div8, div2);
    			append_dev(div2, div0);
    			append_dev(div2, t0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div2, null);
    			}

    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div8, t2);
    			append_dev(div8, div7);
    			append_dev(div7, div3);
    			append_dev(div7, t4);
    			append_dev(div7, div4);
    			append_dev(div7, t6);
    			append_dev(div7, div5);
    			append_dev(div7, t8);
    			append_dev(div7, div6);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*content, position, activeBar, activeCircle*/ 15) {
    				each_value = /*content*/ ctx[1];
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$b(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$b(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div2, t1);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div8);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let { position = 1 } = $$props;
    	let content = [1, 2, 3, 4];
    	let activeCircle = "w-16 h-16 text-dark bg-elight  mx-auto rounded-full text-lg flex items-center";

    	let activeBar = `w-full bg-elight rounded items-center
            align-middle align-center flex-1`;

    	const writable_props = ["position"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Problem_navbar> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ("position" in $$props) $$invalidate(0, position = $$props.position);
    	};

    	$$self.$capture_state = () => {
    		return {
    			position,
    			content,
    			activeCircle,
    			activeBar
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("position" in $$props) $$invalidate(0, position = $$props.position);
    		if ("content" in $$props) $$invalidate(1, content = $$props.content);
    		if ("activeCircle" in $$props) $$invalidate(2, activeCircle = $$props.activeCircle);
    		if ("activeBar" in $$props) $$invalidate(3, activeBar = $$props.activeBar);
    	};

    	return [position, content, activeCircle, activeBar];
    }

    class Problem_navbar$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$w, create_fragment$z, safe_not_equal, { position: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Problem_navbar",
    			options,
    			id: create_fragment$z.name
    		});
    	}

    	get position() {
    		throw new Error("<Problem_navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set position(value) {
    		throw new Error("<Problem_navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/routes/update_problem/loader.svelte generated by Svelte v3.18.1 */

    const file$x = "src/routes/update_problem/loader.svelte";

    function create_fragment$A(ctx) {
    	let div3;
    	let div0;
    	let t0;
    	let div1;
    	let t1;
    	let div2;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			t1 = space();
    			div2 = element("div");
    			attr_dev(div0, "class", "LoaderBalls__item svelte-42m7bp");
    			add_location(div0, file$x, 42, 2, 2513);
    			attr_dev(div1, "class", "LoaderBalls__item svelte-42m7bp");
    			add_location(div1, file$x, 43, 2, 2549);
    			attr_dev(div2, "class", "LoaderBalls__item svelte-42m7bp");
    			add_location(div2, file$x, 44, 2, 2585);
    			attr_dev(div3, "class", "LoaderBalls svelte-42m7bp");
    			add_location(div3, file$x, 41, 0, 2485);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div3, t0);
    			append_dev(div3, div1);
    			append_dev(div3, t1);
    			append_dev(div3, div2);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    class Loader$2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, null, create_fragment$A, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Loader",
    			options,
    			id: create_fragment$A.name
    		});
    	}
    }

    const problemStore$1 = writable({
      problemName: '',
      timelimit: '',
      datalimit: '',
      solution: '',
      problemTests: '',
      tags: '',
      description: '',
      email: 'Sample@gmail.com',
    });

    /* src/routes/update_problem/problem_initials.svelte generated by Svelte v3.18.1 */
    const file$y = "src/routes/update_problem/problem_initials.svelte";

    function get_each_context$c(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[15] = list[i];
    	child_ctx[17] = i;
    	return child_ctx;
    }

    // (128:10) {#if uniqueNameStatus === 2}
    function create_if_block_2$4(ctx) {
    	let current;
    	const loader = new Loader$2({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(loader.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loader, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loader, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(128:10) {#if uniqueNameStatus === 2}",
    		ctx
    	});

    	return block;
    }

    // (131:10) {#if uniqueNameStatus === 1}
    function create_if_block_1$7(ctx) {
    	let i;

    	const block = {
    		c: function create() {
    			i = element("i");
    			i.textContent = "";
    			attr_dev(i, "class", "material-icons status svelte-1nbk2ow");
    			add_location(i, file$y, 131, 12, 4321);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(131:10) {#if uniqueNameStatus === 1}",
    		ctx
    	});

    	return block;
    }

    // (134:10) {#if uniqueNameStatus === 3}
    function create_if_block$b(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "clear";
    			attr_dev(span, "class", "status material-icons svelte-1nbk2ow");
    			add_location(span, file$y, 134, 12, 4434);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(134:10) {#if uniqueNameStatus === 3}",
    		ctx
    	});

    	return block;
    }

    // (176:14) {#each tagList as tag, index}
    function create_each_block$c(ctx) {
    	let option;
    	let t0_value = /*tag*/ ctx[15] + "";
    	let t0;
    	let t1;
    	let option_name_value;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(option, "class", "text-xl px-2 text-edark");
    			attr_dev(option, "name", option_name_value = /*tag*/ ctx[15]);
    			option.__value = option_value_value = /*index*/ ctx[17];
    			option.value = option.__value;
    			add_location(option, file$y, 176, 16, 5748);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t0);
    			append_dev(option, t1);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$c.name,
    		type: "each",
    		source: "(176:14) {#each tagList as tag, index}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$B(ctx) {
    	let div14;
    	let div13;
    	let div5;
    	let label0;
    	let t1;
    	let div4;
    	let div2;
    	let div0;
    	let input0;
    	let t2;
    	let div1;
    	let p;
    	let t4;
    	let div3;
    	let t5;
    	let t6;
    	let t7;
    	let div12;
    	let div6;
    	let h2;
    	let t9;
    	let div11;
    	let div7;
    	let label1;
    	let t11;
    	let input1;
    	let t12;
    	let span0;
    	let t14;
    	let div8;
    	let label2;
    	let t16;
    	let input2;
    	let t17;
    	let span1;
    	let t19;
    	let div10;
    	let label3;
    	let t21;
    	let div9;
    	let select;
    	let t22;
    	let input3;
    	let current;
    	let dispose;
    	let if_block0 = /*uniqueNameStatus*/ ctx[0] === 2 && create_if_block_2$4(ctx);
    	let if_block1 = /*uniqueNameStatus*/ ctx[0] === 1 && create_if_block_1$7(ctx);
    	let if_block2 = /*uniqueNameStatus*/ ctx[0] === 3 && create_if_block$b(ctx);
    	let each_value = /*tagList*/ ctx[4];
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div14 = element("div");
    			div13 = element("div");
    			div5 = element("div");
    			label0 = element("label");
    			label0.textContent = "Enter a unique Problem code";
    			t1 = space();
    			div4 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			input0 = element("input");
    			t2 = space();
    			div1 = element("div");
    			p = element("p");
    			p.textContent = `${/*alert*/ ctx[3]}`;
    			t4 = space();
    			div3 = element("div");
    			if (if_block0) if_block0.c();
    			t5 = space();
    			if (if_block1) if_block1.c();
    			t6 = space();
    			if (if_block2) if_block2.c();
    			t7 = space();
    			div12 = element("div");
    			div6 = element("div");
    			h2 = element("h2");
    			h2.textContent = "Other Details";
    			t9 = space();
    			div11 = element("div");
    			div7 = element("div");
    			label1 = element("label");
    			label1.textContent = "Enter Time limit";
    			t11 = space();
    			input1 = element("input");
    			t12 = space();
    			span0 = element("span");
    			span0.textContent = "ms";
    			t14 = space();
    			div8 = element("div");
    			label2 = element("label");
    			label2.textContent = "Enter Memory limit";
    			t16 = space();
    			input2 = element("input");
    			t17 = space();
    			span1 = element("span");
    			span1.textContent = "Mb";
    			t19 = space();
    			div10 = element("div");
    			label3 = element("label");
    			label3.textContent = "Add Tags";
    			t21 = space();
    			div9 = element("div");
    			select = element("select");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t22 = space();
    			input3 = element("input");
    			attr_dev(label0, "class", "text-elight text-2xl my-3");
    			add_location(label0, file$y, 106, 6, 3511);
    			attr_dev(input0, "type", "search");
    			attr_dev(input0, "name", "serch");
    			attr_dev(input0, "placeholder", "Search");
    			attr_dev(input0, "class", "bg-elight h-10 px-5 pr-10 rounded-full w-full text-xl\n              tet-edark focus:outline-none");
    			input0.readOnly = true;
    			add_location(input0, file$y, 112, 12, 3711);
    			attr_dev(div0, "class", "w-full");
    			add_location(div0, file$y, 111, 10, 3678);
    			attr_dev(p, "class", "text-white text-sm my-2");
    			add_location(p, file$y, 123, 12, 4086);
    			add_location(div1, file$y, 122, 10, 4068);
    			attr_dev(div2, "class", " flex-col w-full");
    			add_location(div2, file$y, 110, 8, 3637);
    			attr_dev(div3, "class", "ml-3");
    			add_location(div3, file$y, 126, 8, 4173);
    			attr_dev(div4, "class", "flex");
    			add_location(div4, file$y, 109, 6, 3610);
    			add_location(div5, file$y, 105, 4, 3499);
    			attr_dev(h2, "class", "labels text-2xl svelte-1nbk2ow");
    			add_location(h2, file$y, 141, 8, 4620);
    			add_location(div6, file$y, 140, 6, 4606);
    			attr_dev(label1, "class", "labels svelte-1nbk2ow");
    			add_location(label1, file$y, 145, 10, 4716);
    			attr_dev(input1, "class", "unitinput svelte-1nbk2ow");
    			attr_dev(input1, "type", "text");
    			attr_dev(input1, "placeholder", "in milli seconds");
    			add_location(input1, file$y, 146, 10, 4773);
    			attr_dev(span0, "class", "unit svelte-1nbk2ow");
    			add_location(span0, file$y, 151, 10, 4939);
    			add_location(div7, file$y, 144, 8, 4700);
    			attr_dev(label2, "class", "labels svelte-1nbk2ow");
    			add_location(label2, file$y, 154, 10, 5007);
    			attr_dev(input2, "class", "unitinput svelte-1nbk2ow");
    			attr_dev(input2, "type", "text");
    			attr_dev(input2, "placeholder", "in Mbs");
    			add_location(input2, file$y, 155, 10, 5066);
    			attr_dev(span1, "class", "unit svelte-1nbk2ow");
    			add_location(span1, file$y, 160, 10, 5222);
    			add_location(div8, file$y, 153, 8, 4991);
    			attr_dev(label3, "class", "labels svelte-1nbk2ow");
    			add_location(label3, file$y, 164, 10, 5291);
    			attr_dev(select, "class", "unitinput outline-none w-64 svelte-1nbk2ow");
    			add_location(select, file$y, 166, 12, 5380);
    			attr_dev(input3, "type", "text");
    			attr_dev(input3, "class", "unitinput svelte-1nbk2ow");
    			input3.readOnly = true;
    			add_location(input3, file$y, 184, 12, 5974);
    			attr_dev(div9, "class", "flex-col flex");
    			add_location(div9, file$y, 165, 10, 5340);
    			add_location(div10, file$y, 163, 8, 5275);
    			add_location(div11, file$y, 143, 6, 4686);
    			attr_dev(div12, "class", "border-solid border-2 mt-6 border-light p-4");
    			add_location(div12, file$y, 139, 4, 4542);
    			attr_dev(div13, "class", "text-edark mx-auto max-w-5xl w-full");
    			add_location(div13, file$y, 104, 2, 3445);
    			attr_dev(div14, "class", "mx-auto flex-col flex-grow");
    			add_location(div14, file$y, 103, 0, 3402);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div14, anchor);
    			append_dev(div14, div13);
    			append_dev(div13, div5);
    			append_dev(div5, label0);
    			append_dev(div5, t1);
    			append_dev(div5, div4);
    			append_dev(div4, div2);
    			append_dev(div2, div0);
    			append_dev(div0, input0);
    			set_input_value(input0, /*$problemStore*/ ctx[2].problemName);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			append_dev(div1, p);
    			append_dev(div4, t4);
    			append_dev(div4, div3);
    			if (if_block0) if_block0.m(div3, null);
    			append_dev(div3, t5);
    			if (if_block1) if_block1.m(div3, null);
    			append_dev(div3, t6);
    			if (if_block2) if_block2.m(div3, null);
    			append_dev(div13, t7);
    			append_dev(div13, div12);
    			append_dev(div12, div6);
    			append_dev(div6, h2);
    			append_dev(div12, t9);
    			append_dev(div12, div11);
    			append_dev(div11, div7);
    			append_dev(div7, label1);
    			append_dev(div7, t11);
    			append_dev(div7, input1);
    			set_input_value(input1, /*$problemStore*/ ctx[2].timelimit);
    			append_dev(div7, t12);
    			append_dev(div7, span0);
    			append_dev(div11, t14);
    			append_dev(div11, div8);
    			append_dev(div8, label2);
    			append_dev(div8, t16);
    			append_dev(div8, input2);
    			set_input_value(input2, /*$problemStore*/ ctx[2].datalimit);
    			append_dev(div8, t17);
    			append_dev(div8, span1);
    			append_dev(div11, t19);
    			append_dev(div11, div10);
    			append_dev(div10, label3);
    			append_dev(div10, t21);
    			append_dev(div10, div9);
    			append_dev(div9, select);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			append_dev(div9, t22);
    			append_dev(div9, input3);
    			set_input_value(input3, /*hashTagString*/ ctx[1]);
    			current = true;

    			dispose = [
    				listen_dev(input0, "keydown", /*onInput*/ ctx[6], false, false, false),
    				listen_dev(input0, "input", /*input0_input_handler*/ ctx[10]),
    				listen_dev(input1, "input", /*input1_input_handler*/ ctx[11]),
    				listen_dev(input2, "input", /*input2_input_handler*/ ctx[12]),
    				listen_dev(select, "change", /*change_handler*/ ctx[13], false, false, false),
    				listen_dev(input3, "input", /*input3_input_handler*/ ctx[14])
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$problemStore*/ 4) {
    				set_input_value(input0, /*$problemStore*/ ctx[2].problemName);
    			}

    			if (/*uniqueNameStatus*/ ctx[0] === 2) {
    				if (!if_block0) {
    					if_block0 = create_if_block_2$4(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div3, t5);
    				} else {
    					transition_in(if_block0, 1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*uniqueNameStatus*/ ctx[0] === 1) {
    				if (!if_block1) {
    					if_block1 = create_if_block_1$7(ctx);
    					if_block1.c();
    					if_block1.m(div3, t6);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*uniqueNameStatus*/ ctx[0] === 3) {
    				if (!if_block2) {
    					if_block2 = create_if_block$b(ctx);
    					if_block2.c();
    					if_block2.m(div3, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (dirty & /*$problemStore*/ 4 && input1.value !== /*$problemStore*/ ctx[2].timelimit) {
    				set_input_value(input1, /*$problemStore*/ ctx[2].timelimit);
    			}

    			if (dirty & /*$problemStore*/ 4 && input2.value !== /*$problemStore*/ ctx[2].datalimit) {
    				set_input_value(input2, /*$problemStore*/ ctx[2].datalimit);
    			}

    			if (dirty & /*tagList*/ 16) {
    				each_value = /*tagList*/ ctx[4];
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$c(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$c(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*hashTagString*/ 2 && input3.value !== /*hashTagString*/ ctx[1]) {
    				set_input_value(input3, /*hashTagString*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div14);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			destroy_each(each_blocks, detaching);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let $problemStore;
    	validate_store(problemStore$1, "problemStore");
    	component_subscribe($$self, problemStore$1, $$value => $$invalidate(2, $problemStore = $$value));
    	let alert = "*Name must be in capital letters with no space in between and no special characters";

    	const tagList = [
    		"Choose Tags",
    		"Dynamic_Programming",
    		"Mathematics",
    		"Binary_Search",
    		"Graph",
    		"Algorithm",
    		"Data_Structure",
    		"Trees"
    	];

    	const client = getClient();

    	setTimeout(
    		() => {
    			tagsName.forEach(tag => {
    				tagList.forEach((tt, index) => {
    					if (tag === tt) {
    						selectedTags = [...selectedTags, index];
    						return;
    					}
    				});
    			});
    		},
    		300
    	);

    	function changeHandler(indexValue) {
    		console.log(selectedTags.length, indexValue);
    		let rr = selectedTags.length;

    		selectedTags = [
    			...selectedTags.filter(ele => {
    				return ele !== indexValue;
    			})
    		];

    		if (rr === selectedTags.length) {
    			selectedTags = [...selectedTags, indexValue];
    		}

    		$$invalidate(1, hashTagString = "");

    		selectedTags.forEach(ind => {
    			$$invalidate(1, hashTagString += "#" + tagList[ind]);
    		});

    		set_store_value(problemStore$1, $problemStore.tags = hashTagString, $problemStore);
    	}

    	const onInput = (function checkIfAvailable() {
    		let timer;

    		return e => {
    			timer = setTimeout(
    				async () => {
    					$$invalidate(0, uniqueNameStatus = 2);

    					const res = await mutate(client, {
    						mutation: apolloClient.checkIfAvailable,
    						variables: { problemName: $problemStore.problemName }
    					});

    					console.log(res);

    					if (res.data.checkProblemIfExists.success === false) {
    						$$invalidate(0, uniqueNameStatus = 1);
    					} else {
    						$$invalidate(0, uniqueNameStatus = 3);
    					}
    				},
    				30
    			);
    		};
    	})();

    	function input0_input_handler() {
    		$problemStore.problemName = this.value;
    		problemStore$1.set($problemStore);
    	}

    	function input1_input_handler() {
    		$problemStore.timelimit = this.value;
    		problemStore$1.set($problemStore);
    	}

    	function input2_input_handler() {
    		$problemStore.datalimit = this.value;
    		problemStore$1.set($problemStore);
    	}

    	const change_handler = e => {
    		console.log(e.target.value);

    		if (parseInt(e.target.value) === 0) {
    			return;
    		}

    		changeHandler(parseInt(e.target.value));
    	};

    	function input3_input_handler() {
    		hashTagString = this.value;
    		($$invalidate(1, hashTagString), $$invalidate(2, $problemStore));
    	}

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("alert" in $$props) $$invalidate(3, alert = $$props.alert);
    		if ("uniqueNameStatus" in $$props) $$invalidate(0, uniqueNameStatus = $$props.uniqueNameStatus);
    		if ("selectedTags" in $$props) selectedTags = $$props.selectedTags;
    		if ("hashTagString" in $$props) $$invalidate(1, hashTagString = $$props.hashTagString);
    		if ("$problemStore" in $$props) problemStore$1.set($problemStore = $$props.$problemStore);
    		if ("tagsName" in $$props) tagsName = $$props.tagsName;
    	};

    	let uniqueNameStatus;
    	let selectedTags;
    	let hashTagString;
    	let tagsName;

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$problemStore*/ 4) {
    			 $$invalidate(1, hashTagString = $problemStore.tags);
    		}

    		if ($$self.$$.dirty & /*$problemStore*/ 4) {
    			 tagsName = [...$problemStore.tags.split("#")];
    		}
    	};

    	 $$invalidate(0, uniqueNameStatus = 0);
    	 selectedTags = [];

    	return [
    		uniqueNameStatus,
    		hashTagString,
    		$problemStore,
    		alert,
    		tagList,
    		changeHandler,
    		onInput,
    		selectedTags,
    		tagsName,
    		client,
    		input0_input_handler,
    		input1_input_handler,
    		input2_input_handler,
    		change_handler,
    		input3_input_handler
    	];
    }

    class Problem_initials$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$x, create_fragment$B, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Problem_initials",
    			options,
    			id: create_fragment$B.name
    		});
    	}
    }

    /* src/routes/update_problem/problem_statement.svelte generated by Svelte v3.18.1 */
    const file$z = "src/routes/update_problem/problem_statement.svelte";

    function create_fragment$C(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let label;
    	let t1;
    	let textarea;
    	let dispose;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			label = element("label");
    			label.textContent = "Describe Problem Statement here";
    			t1 = space();
    			textarea = element("textarea");
    			attr_dev(label, "class", " text-2xl text-elight mb-3 my-2");
    			add_location(label, file$z, 13, 6, 638);
    			attr_dev(textarea, "class", " h-full w-full bg-dark text-elight text-2xl border\n        border-gray-200 rounded py-3 px-4 mb-3 leading-tight focus:outline-none\n        focus:border-white h-48 resize-none");
    			attr_dev(textarea, "id", "message");
    			add_location(textarea, file$z, 16, 6, 747);
    			attr_dev(div0, "class", "w-full h-full px-3");
    			add_location(div0, file$z, 12, 4, 599);
    			attr_dev(div1, "class", "flex-col mx-3 w-full mb-6");
    			add_location(div1, file$z, 11, 2, 555);
    			attr_dev(div2, "class", "max-w-6xl mx-auto flex statement flex-grow  svelte-i0x5sn");
    			add_location(div2, file$z, 10, 0, 495);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, label);
    			append_dev(div0, t1);
    			append_dev(div0, textarea);
    			set_input_value(textarea, /*$problemStore*/ ctx[0].description);
    			dispose = listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[1]);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$problemStore*/ 1) {
    				set_input_value(textarea, /*$problemStore*/ ctx[0].description);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$y($$self, $$props, $$invalidate) {
    	let $problemStore;
    	validate_store(problemStore$1, "problemStore");
    	component_subscribe($$self, problemStore$1, $$value => $$invalidate(0, $problemStore = $$value));

    	function textarea_input_handler() {
    		$problemStore.description = this.value;
    		problemStore$1.set($problemStore);
    	}

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("$problemStore" in $$props) problemStore$1.set($problemStore = $$props.$problemStore);
    	};

    	return [$problemStore, textarea_input_handler];
    }

    class Problem_statement$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$y, create_fragment$C, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Problem_statement",
    			options,
    			id: create_fragment$C.name
    		});
    	}
    }

    /* src/routes/update_problem/testcase.svelte generated by Svelte v3.18.1 */

    const { console: console_1$6 } = globals;
    const file$A = "src/routes/update_problem/testcase.svelte";

    function create_fragment$D(ctx) {
    	let div2;
    	let h1;
    	let t1;
    	let div0;
    	let t2;
    	let div1;
    	let button;
    	let dispose;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Enter TestCases";
    			t1 = space();
    			div0 = element("div");
    			t2 = space();
    			div1 = element("div");
    			button = element("button");
    			button.textContent = "Submit";
    			attr_dev(h1, "class", "text-2xl text-elight mt-3 my-2 svelte-1hcojl0");
    			add_location(h1, file$A, 80, 2, 2902);
    			attr_dev(div0, "id", "editor");
    			attr_dev(div0, "class", "editor mx-60 box-border flex-grow svelte-1hcojl0");
    			add_location(div0, file$A, 82, 2, 2969);
    			attr_dev(button, "class", "bg-dark hover:bg-elight hover:text-edark outline-none text-white\n      font-bold py-4 px-4 text-xl rounded-full svelte-1hcojl0");
    			add_location(button, file$A, 87, 4, 3109);
    			attr_dev(div1, "class", "my-3 flex justify-center svelte-1hcojl0");
    			add_location(div1, file$A, 86, 2, 3066);
    			attr_dev(div2, "class", "mx-64 flex-grow editor_window box-border svelte-1hcojl0");
    			add_location(div2, file$A, 79, 0, 2845);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, h1);
    			append_dev(div2, t1);
    			append_dev(div2, div0);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			append_dev(div1, button);

    			dispose = [
    				listen_dev(div0, "keydown", /*onInput*/ ctx[0], false, false, false),
    				listen_dev(button, "click", /*click_handler*/ ctx[6], false, false, false)
    			];
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$z($$self, $$props, $$invalidate) {
    	let $problemStore;
    	validate_store(problemStore$1, "problemStore");
    	component_subscribe($$self, problemStore$1, $$value => $$invalidate(4, $problemStore = $$value));
    	let { currentRoute } = $$props;
    	console.log(currentRoute);
    	const client = getClient();
    	console.log($problemStore);
    	let editor;

    	onMount(() => {
    		ace.config.set("basePath", "ace-builds/src-noconflict/");
    		editor = ace.edit("editor");

    		editor.setOptions({
    			enableBasicAutocompletion: true,
    			enableSnippets: true,
    			highlightActiveLine: true,
    			showPrintMargin: false,
    			theme: "ace/theme/tomorrow_night",
    			mode: "ace/mode/javascript",
    			enableLiveAutocompletion: true,
    			useWorker: false
    		});
    	});

    	afterUpdate(() => {
    		var pos = editor.session.selection.toJSON();
    		editor.session.setValue($problemStore.problemTests);
    		editor.session.selection.fromJSON(pos);
    	});

    	const onInput = (function onInput() {
    		let timer;

    		return e => {
    			clearTimeout(timer);

    			timer = setTimeout(
    				() => {
    					set_store_value(problemStore$1, $problemStore.problemTests = editor.getValue(), $problemStore);
    				},
    				500
    			);
    		};
    	})();

    	async function submitData() {
    		let problemValue = {
    			id: parseInt(currentRoute.namedParams.id),
    			problemName: $problemStore.problemName,
    			description: $problemStore.description,
    			problemTests: JSON.stringify($problemStore.problemTests),
    			tags: $problemStore.tags,
    			solution: $problemStore.solution,
    			timelimit: $problemStore.timelimit,
    			datalimit: $problemStore.datalimit
    		};

    		console.log(problemValue);

    		const res = await mutate(client, {
    			mutation: apolloClient.updateProblem,
    			variables: problemValue
    		});

    		location.replace("http://localhost:5000/admin");
    	}

    	const writable_props = ["currentRoute"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$6.warn(`<Testcase> was created with unknown prop '${key}'`);
    	});

    	const click_handler = e => {
    		submitData();
    	};

    	$$self.$set = $$props => {
    		if ("currentRoute" in $$props) $$invalidate(2, currentRoute = $$props.currentRoute);
    	};

    	$$self.$capture_state = () => {
    		return { currentRoute, editor, $problemStore };
    	};

    	$$self.$inject_state = $$props => {
    		if ("currentRoute" in $$props) $$invalidate(2, currentRoute = $$props.currentRoute);
    		if ("editor" in $$props) editor = $$props.editor;
    		if ("$problemStore" in $$props) problemStore$1.set($problemStore = $$props.$problemStore);
    	};

    	return [
    		onInput,
    		submitData,
    		currentRoute,
    		editor,
    		$problemStore,
    		client,
    		click_handler
    	];
    }

    class Testcase$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$z, create_fragment$D, safe_not_equal, { currentRoute: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Testcase",
    			options,
    			id: create_fragment$D.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*currentRoute*/ ctx[2] === undefined && !("currentRoute" in props)) {
    			console_1$6.warn("<Testcase> was created without expected prop 'currentRoute'");
    		}
    	}

    	get currentRoute() {
    		throw new Error("<Testcase>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set currentRoute(value) {
    		throw new Error("<Testcase>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/routes/update_problem/problem_solution.svelte generated by Svelte v3.18.1 */
    const file$B = "src/routes/update_problem/problem_solution.svelte";

    function create_fragment$E(ctx) {
    	let div8;
    	let h1;
    	let t1;
    	let div0;
    	let t2;
    	let div6;
    	let div3;
    	let h20;
    	let t4;
    	let div2;
    	let div1;
    	let t5;
    	let div5;
    	let h21;
    	let t7;
    	let div4;
    	let textarea;
    	let t8;
    	let div7;
    	let button;
    	let dispose;

    	const block = {
    		c: function create() {
    			div8 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Enter Solution";
    			t1 = space();
    			div0 = element("div");
    			t2 = space();
    			div6 = element("div");
    			div3 = element("div");
    			h20 = element("h2");
    			h20.textContent = "Input";
    			t4 = space();
    			div2 = element("div");
    			div1 = element("div");
    			t5 = space();
    			div5 = element("div");
    			h21 = element("h2");
    			h21.textContent = "Output";
    			t7 = space();
    			div4 = element("div");
    			textarea = element("textarea");
    			t8 = space();
    			div7 = element("div");
    			button = element("button");
    			button.textContent = "Run";
    			attr_dev(h1, "class", "text-2xl text-elight mt-3 my-2 svelte-4b5gef");
    			add_location(h1, file$B, 81, 2, 2778);
    			attr_dev(div0, "id", "editor");
    			attr_dev(div0, "class", "editor mx-60 box-border flex-grow svelte-4b5gef");
    			add_location(div0, file$B, 82, 2, 2843);
    			attr_dev(h20, "class", "text-xl text-elight my-3 my-2 svelte-4b5gef");
    			add_location(h20, file$B, 89, 6, 3056);
    			attr_dev(div1, "id", "inputeditor");
    			attr_dev(div1, "class", "inputeditor text-xl h-full box-border  svelte-4b5gef");
    			add_location(div1, file$B, 91, 8, 3163);
    			attr_dev(div2, "class", "flex-grow h-48 box-border svelte-4b5gef");
    			add_location(div2, file$B, 90, 6, 3115);
    			attr_dev(div3, "class", "flex-1 mr-4 box-border svelte-4b5gef");
    			add_location(div3, file$B, 88, 4, 3013);
    			attr_dev(h21, "class", "text-xl text-elight my-3 my-2 box-border svelte-4b5gef");
    			add_location(h21, file$B, 98, 6, 3346);
    			attr_dev(textarea, "class", " h-full w-full bg-dark text-elight text-xl box-border\n          border-none rounded py-3 px-4 mb-3 leading-tight focus:outline-none\n          resize-none svelte-4b5gef");
    			attr_dev(textarea, "id", "message");
    			textarea.readOnly = true;
    			add_location(textarea, file$B, 100, 8, 3454);
    			attr_dev(div4, "class", "flex-grow h-48 svelte-4b5gef");
    			add_location(div4, file$B, 99, 6, 3417);
    			attr_dev(div5, "class", "flex-1 ml-4 svelte-4b5gef");
    			add_location(div5, file$B, 97, 4, 3314);
    			attr_dev(div6, "class", "flex my-4 p-2 border-solid h-64 border-2 border-light svelte-4b5gef");
    			add_location(div6, file$B, 87, 2, 2941);
    			attr_dev(button, "class", "bg-dark hover:bg-elight hover:text-edark outline-none text-white\n      float-right font-bold py-2 px-4 rounded-full svelte-4b5gef");
    			add_location(button, file$B, 111, 4, 3756);
    			attr_dev(div7, "class", "svelte-4b5gef");
    			add_location(div7, file$B, 110, 2, 3746);
    			attr_dev(div8, "class", "mx-64 flex-grow editor_window box-border svelte-4b5gef");
    			add_location(div8, file$B, 80, 0, 2721);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div8, anchor);
    			append_dev(div8, h1);
    			append_dev(div8, t1);
    			append_dev(div8, div0);
    			append_dev(div8, t2);
    			append_dev(div8, div6);
    			append_dev(div6, div3);
    			append_dev(div3, h20);
    			append_dev(div3, t4);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div6, t5);
    			append_dev(div6, div5);
    			append_dev(div5, h21);
    			append_dev(div5, t7);
    			append_dev(div5, div4);
    			append_dev(div4, textarea);
    			set_input_value(textarea, /*result*/ ctx[0]);
    			append_dev(div8, t8);
    			append_dev(div8, div7);
    			append_dev(div7, button);

    			dispose = [
    				listen_dev(div0, "keydown", /*onInput*/ ctx[1], false, false, false),
    				listen_dev(div1, "keydown", /*onInput*/ ctx[1], false, false, false),
    				listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[6]),
    				listen_dev(button, "click", /*click_handler*/ ctx[7], false, false, false)
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*result*/ 1) {
    				set_input_value(textarea, /*result*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div8);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let $problemStore;
    	validate_store(problemStore$1, "problemStore");
    	component_subscribe($$self, problemStore$1, $$value => $$invalidate(5, $problemStore = $$value));
    	console.log($problemStore);
    	let editor;
    	let inputeditor;

    	onMount(() => {
    		ace.config.set("basePath", "ace-builds/src-noconflict/");
    		editor = ace.edit("editor");

    		editor.setOptions({
    			enableBasicAutocompletion: true,
    			enableSnippets: true,
    			highlightActiveLine: true,
    			showPrintMargin: false,
    			theme: "ace/theme/tomorrow_night",
    			mode: "ace/mode/javascript",
    			enableLiveAutocompletion: true,
    			useWorker: false
    		});

    		inputeditor = ace.edit("inputeditor");

    		inputeditor.setOptions({
    			enableBasicAutocompletion: true,
    			enableSnippets: true,
    			highlightActiveLine: true,
    			showPrintMargin: false,
    			theme: "ace/theme/tomorrow_night",
    			mode: "ace/mode/javascript",
    			enableLiveAutocompletion: true,
    			useWorker: false
    		});
    	});

    	afterUpdate(() => {
    		var pos = editor.session.selection.toJSON();
    		editor.session.setValue($problemStore.solution);
    		editor.session.selection.fromJSON(pos);
    	});

    	const onInput = (function onInput() {
    		let timer;

    		return e => {
    			clearTimeout(timer);

    			timer = setTimeout(
    				() => {
    					set_store_value(problemStore$1, $problemStore.solution = editor.getValue(), $problemStore);
    				},
    				500
    			);
    		};
    	})();

    	let result = "";

    	function outputData(e) {
    		try {
    			let code = editor.getValue();
    			console.log(code);
    			set_store_value(problemStore$1, $problemStore.solution = code, $problemStore);
    			console.log(editor.getValue());
    			let testCase = inputeditor.getValue();
    			$$invalidate(0, result = eval(`${code} solution(${testCase})`));
    		} catch(err) {
    			$$invalidate(0, result = err);
    		}
    	}

    	function textarea_input_handler() {
    		result = this.value;
    		$$invalidate(0, result);
    	}

    	const click_handler = e => {
    		outputData();
    	};

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("editor" in $$props) editor = $$props.editor;
    		if ("inputeditor" in $$props) inputeditor = $$props.inputeditor;
    		if ("result" in $$props) $$invalidate(0, result = $$props.result);
    		if ("$problemStore" in $$props) problemStore$1.set($problemStore = $$props.$problemStore);
    	};

    	return [
    		result,
    		onInput,
    		outputData,
    		editor,
    		inputeditor,
    		$problemStore,
    		textarea_input_handler,
    		click_handler
    	];
    }

    class Problem_solution$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$A, create_fragment$E, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Problem_solution",
    			options,
    			id: create_fragment$E.name
    		});
    	}
    }

    /* src/routes/update_problem/select_page.svelte generated by Svelte v3.18.1 */
    const file$C = "src/routes/update_problem/select_page.svelte";

    // (12:2) {#if pageNum === 1}
    function create_if_block_3$1(ctx) {
    	let current;
    	const probleminitials = new Problem_initials$1({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(probleminitials.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(probleminitials, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(probleminitials.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(probleminitials.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(probleminitials, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(12:2) {#if pageNum === 1}",
    		ctx
    	});

    	return block;
    }

    // (15:2) {#if pageNum === 2}
    function create_if_block_2$5(ctx) {
    	let current;
    	const problemstatement = new Problem_statement$1({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(problemstatement.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(problemstatement, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(problemstatement.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(problemstatement.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(problemstatement, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$5.name,
    		type: "if",
    		source: "(15:2) {#if pageNum === 2}",
    		ctx
    	});

    	return block;
    }

    // (18:2) {#if pageNum === 3}
    function create_if_block_1$8(ctx) {
    	let current;
    	const problemsolution = new Problem_solution$1({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(problemsolution.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(problemsolution, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(problemsolution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(problemsolution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(problemsolution, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(18:2) {#if pageNum === 3}",
    		ctx
    	});

    	return block;
    }

    // (21:2) {#if pageNum === 4}
    function create_if_block$c(ctx) {
    	let current;

    	const testcase = new Testcase$1({
    			props: { currentRoute: /*currentRoute*/ ctx[1] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(testcase.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(testcase, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const testcase_changes = {};
    			if (dirty & /*currentRoute*/ 2) testcase_changes.currentRoute = /*currentRoute*/ ctx[1];
    			testcase.$set(testcase_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(testcase.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(testcase.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(testcase, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(21:2) {#if pageNum === 4}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$F(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let current;
    	let if_block0 = /*pageNum*/ ctx[0] === 1 && create_if_block_3$1(ctx);
    	let if_block1 = /*pageNum*/ ctx[0] === 2 && create_if_block_2$5(ctx);
    	let if_block2 = /*pageNum*/ ctx[0] === 3 && create_if_block_1$8(ctx);
    	let if_block3 = /*pageNum*/ ctx[0] === 4 && create_if_block$c(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			if (if_block3) if_block3.c();
    			add_location(div, file$C, 10, 0, 297);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);
    			if (if_block2) if_block2.m(div, null);
    			append_dev(div, t2);
    			if (if_block3) if_block3.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*pageNum*/ ctx[0] === 1) {
    				if (!if_block0) {
    					if_block0 = create_if_block_3$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				} else {
    					transition_in(if_block0, 1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*pageNum*/ ctx[0] === 2) {
    				if (!if_block1) {
    					if_block1 = create_if_block_2$5(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t1);
    				} else {
    					transition_in(if_block1, 1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*pageNum*/ ctx[0] === 3) {
    				if (!if_block2) {
    					if_block2 = create_if_block_1$8(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, t2);
    				} else {
    					transition_in(if_block2, 1);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*pageNum*/ ctx[0] === 4) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    					transition_in(if_block3, 1);
    				} else {
    					if_block3 = create_if_block$c(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div, null);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$B($$self, $$props, $$invalidate) {
    	let { pageNum = 1 } = $$props;
    	let { currentRoute } = $$props;
    	const writable_props = ["pageNum", "currentRoute"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Select_page> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ("pageNum" in $$props) $$invalidate(0, pageNum = $$props.pageNum);
    		if ("currentRoute" in $$props) $$invalidate(1, currentRoute = $$props.currentRoute);
    	};

    	$$self.$capture_state = () => {
    		return { pageNum, currentRoute };
    	};

    	$$self.$inject_state = $$props => {
    		if ("pageNum" in $$props) $$invalidate(0, pageNum = $$props.pageNum);
    		if ("currentRoute" in $$props) $$invalidate(1, currentRoute = $$props.currentRoute);
    	};

    	return [pageNum, currentRoute];
    }

    class Select_page$2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$B, create_fragment$F, safe_not_equal, { pageNum: 0, currentRoute: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Select_page",
    			options,
    			id: create_fragment$F.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*currentRoute*/ ctx[1] === undefined && !("currentRoute" in props)) {
    			console.warn("<Select_page> was created without expected prop 'currentRoute'");
    		}
    	}

    	get pageNum() {
    		throw new Error("<Select_page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pageNum(value) {
    		throw new Error("<Select_page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get currentRoute() {
    		throw new Error("<Select_page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set currentRoute(value) {
    		throw new Error("<Select_page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/routes/update_problem/edit_problem.svelte generated by Svelte v3.18.1 */

    const { console: console_1$7 } = globals;
    const file$D = "src/routes/update_problem/edit_problem.svelte";

    function create_fragment$G(ctx) {
    	let div2;
    	let header;
    	let t0;
    	let subheader;
    	let t1;
    	let main;
    	let t2;
    	let footer;
    	let div0;
    	let button0;
    	let t4;
    	let div1;
    	let button1;
    	let current;
    	let dispose;
    	const navbar = new Navbar({ $$inline: true });

    	const subnavbar = new Problem_navbar$1({
    			props: { position: /*pageNum*/ ctx[1] },
    			$$inline: true
    		});

    	const selectpage = new Select_page$2({
    			props: {
    				pageNum: /*pageNum*/ ctx[1],
    				class: "h-full",
    				currentRoute: /*currentRoute*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			header = element("header");
    			create_component(navbar.$$.fragment);
    			t0 = space();
    			subheader = element("subheader");
    			create_component(subnavbar.$$.fragment);
    			t1 = space();
    			main = element("main");
    			create_component(selectpage.$$.fragment);
    			t2 = space();
    			footer = element("footer");
    			div0 = element("div");
    			button0 = element("button");
    			button0.textContent = "Prev";
    			t4 = space();
    			div1 = element("div");
    			button1 = element("button");
    			button1.textContent = "Next";
    			attr_dev(subheader, "class", "svelte-18fkda7");
    			add_location(subheader, file$D, 37, 4, 1509);
    			attr_dev(header, "class", "svelte-18fkda7");
    			add_location(header, file$D, 35, 2, 1481);
    			attr_dev(main, "class", " mx-auto w-full flex-grow overflow-auto svelte-18fkda7");
    			add_location(main, file$D, 41, 2, 1591);
    			attr_dev(button0, "id", "prevbutton");
    			attr_dev(button0, "class", "py-4 px-6 float-left shadow-md no-underline rounded-full bg-dark\n        text-white font-sans font-semibold text-sm border-white btn-primary\n        hover:text-white text-xl hover:bg-elight focus:outline-none\n        active:shadow-none mr-2 svelte-18fkda7");
    			add_location(button0, file$D, 46, 6, 1806);
    			attr_dev(div0, "class", "flex-1  svelte-18fkda7");
    			add_location(div0, file$D, 45, 4, 1778);
    			attr_dev(button1, "id", "nextbutton");
    			attr_dev(button1, "class", "py-4 px-6 shadow-md text-xl float-right no-underline rounded-full\n        bg-dark text-white font-sans font-semibold text-sm border-white\n        btn-primary hover:text-dark hover:bg-elight focus:outline-none\n        active:shadow-none mr-2 svelte-18fkda7");
    			add_location(button1, file$D, 63, 6, 2320);
    			attr_dev(div1, "class", "flex-1 svelte-18fkda7");
    			add_location(div1, file$D, 62, 4, 2293);
    			attr_dev(footer, "class", " footer my-8 w-full px-20 mx-auto sticky svelte-18fkda7");
    			add_location(footer, file$D, 44, 2, 1716);
    			attr_dev(div2, "class", "w-screen bg-edark h-screen flex flex-col svelte-18fkda7");
    			add_location(div2, file$D, 34, 0, 1424);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, header);
    			mount_component(navbar, header, null);
    			append_dev(header, t0);
    			append_dev(header, subheader);
    			mount_component(subnavbar, subheader, null);
    			append_dev(div2, t1);
    			append_dev(div2, main);
    			mount_component(selectpage, main, null);
    			append_dev(div2, t2);
    			append_dev(div2, footer);
    			append_dev(footer, div0);
    			append_dev(div0, button0);
    			append_dev(footer, t4);
    			append_dev(footer, div1);
    			append_dev(div1, button1);
    			current = true;

    			dispose = [
    				listen_dev(button0, "click", /*click_handler*/ ctx[6], false, false, false),
    				listen_dev(button1, "click", /*click_handler_1*/ ctx[7], false, false, false)
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			const subnavbar_changes = {};
    			if (dirty & /*pageNum*/ 2) subnavbar_changes.position = /*pageNum*/ ctx[1];
    			subnavbar.$set(subnavbar_changes);
    			const selectpage_changes = {};
    			if (dirty & /*pageNum*/ 2) selectpage_changes.pageNum = /*pageNum*/ ctx[1];
    			if (dirty & /*currentRoute*/ 1) selectpage_changes.currentRoute = /*currentRoute*/ ctx[0];
    			selectpage.$set(selectpage_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(subnavbar.$$.fragment, local);
    			transition_in(selectpage.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(subnavbar.$$.fragment, local);
    			transition_out(selectpage.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(navbar);
    			destroy_component(subnavbar);
    			destroy_component(selectpage);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$C($$self, $$props, $$invalidate) {
    	let $problem;
    	let $problemStore;
    	validate_store(problemStore$1, "problemStore");
    	component_subscribe($$self, problemStore$1, $$value => $$invalidate(4, $problemStore = $$value));
    	let { currentRoute } = $$props;
    	console.log(currentRoute);
    	const client = getClient();

    	const problem = query(client, {
    		query: apolloClient.getProblemById,
    		variables: { id: currentRoute.namedParams.id }
    	});

    	validate_store(problem, "problem");
    	component_subscribe($$self, problem, value => $$invalidate(3, $problem = value));

    	$problem.then(res => {
    		let tt = res.data.problemById;
    		console.log(tt);
    		set_store_value(problemStore$1, $problemStore.problemName = tt.problemName, $problemStore);
    		set_store_value(problemStore$1, $problemStore.description = tt.description, $problemStore);
    		set_store_value(problemStore$1, $problemStore.problemTests = JSON.parse(tt.problemTests), $problemStore);
    		set_store_value(problemStore$1, $problemStore.tags = tt.tags, $problemStore);
    		set_store_value(problemStore$1, $problemStore.datalimit = tt.datalimit, $problemStore);
    		set_store_value(problemStore$1, $problemStore.timelimit = tt.timelimit, $problemStore);
    		set_store_value(problemStore$1, $problemStore.solution = tt.solution, $problemStore);
    	});

    	const writable_props = ["currentRoute"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$7.warn(`<Edit_problem> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		if (pageNum === 1) {
    			return;
    		}

    		$$invalidate(1, pageNum--, pageNum);
    		console.log(pageNum);
    	};

    	const click_handler_1 = () => {
    		if (pageNum === 4) {
    			return;
    		}

    		$$invalidate(1, pageNum++, pageNum);
    		console.log(pageNum);
    	};

    	$$self.$set = $$props => {
    		if ("currentRoute" in $$props) $$invalidate(0, currentRoute = $$props.currentRoute);
    	};

    	$$self.$capture_state = () => {
    		return {
    			currentRoute,
    			pageNum,
    			$problem,
    			$problemStore
    		};
    	};

    	$$self.$inject_state = $$props => {
    		if ("currentRoute" in $$props) $$invalidate(0, currentRoute = $$props.currentRoute);
    		if ("pageNum" in $$props) $$invalidate(1, pageNum = $$props.pageNum);
    		if ("$problem" in $$props) problem.set($problem = $$props.$problem);
    		if ("$problemStore" in $$props) problemStore$1.set($problemStore = $$props.$problemStore);
    	};

    	let pageNum;
    	 $$invalidate(1, pageNum = 1);

    	return [
    		currentRoute,
    		pageNum,
    		problem,
    		$problem,
    		$problemStore,
    		client,
    		click_handler,
    		click_handler_1
    	];
    }

    class Edit_problem extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$C, create_fragment$G, safe_not_equal, { currentRoute: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Edit_problem",
    			options,
    			id: create_fragment$G.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*currentRoute*/ ctx[0] === undefined && !("currentRoute" in props)) {
    			console_1$7.warn("<Edit_problem> was created without expected prop 'currentRoute'");
    		}
    	}

    	get currentRoute() {
    		throw new Error("<Edit_problem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set currentRoute(value) {
    		throw new Error("<Edit_problem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/routes/thankyou.svelte generated by Svelte v3.18.1 */

    const file$E = "src/routes/thankyou.svelte";

    function create_fragment$H(ctx) {
    	let h10;
    	let t1;
    	let h11;
    	let t3;
    	let h2;

    	const block = {
    		c: function create() {
    			h10 = element("h1");
    			h10.textContent = "Thank You";
    			t1 = space();
    			h11 = element("h1");
    			h11.textContent = "You Response is submitted Successfully";
    			t3 = space();
    			h2 = element("h2");
    			h2.textContent = "We will get back to you";
    			add_location(h10, file$E, 0, 0, 0);
    			add_location(h11, file$E, 1, 0, 19);
    			add_location(h2, file$E, 2, 0, 67);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h10, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, h11, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, h2, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h10);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(h11);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(h2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    class Thankyou extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, null, create_fragment$H, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Thankyou",
    			options,
    			id: create_fragment$H.name
    		});
    	}
    }

    /* src/routes/pubnub.svelte generated by Svelte v3.18.1 */
    const file$F = "src/routes/pubnub.svelte";

    function get_each_context$d(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[18] = list[i];
    	return child_ctx;
    }

    // (265:4) {:else}
    function create_else_block$2(ctx) {
    	let div;
    	let button;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			button.textContent = "Helpdesk...";
    			attr_dev(button, "class", "bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4\n          rounded-full svelte-vqb2s2");
    			add_location(button, file$F, 266, 8, 8882);
    			attr_dev(div, "class", "btm svelte-vqb2s2");
    			add_location(div, file$F, 265, 6, 8856);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			dispose = listen_dev(button, "click", /*joined*/ ctx[3], false, false, false);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(265:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (229:4) {#if hasJoinedChat}
    function create_if_block$d(ctx) {
    	let div2;
    	let div0;
    	let button0;
    	let t1;
    	let p0;
    	let a;
    	let img;
    	let img_src_value;
    	let t2;
    	let p1;
    	let t3;
    	let p2;
    	let t5;
    	let form;
    	let input;
    	let t6;
    	let button1;
    	let t8;
    	let p3;
    	let t10;
    	let div1;
    	let ul;
    	let dispose;
    	let each_value = /*output*/ ctx[2];
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			button0 = element("button");
    			button0.textContent = "Close";
    			t1 = space();
    			p0 = element("p");
    			a = element("a");
    			img = element("img");
    			t2 = space();
    			p1 = element("p");
    			t3 = space();
    			p2 = element("p");
    			p2.textContent = "Enter chat and press enter.";
    			t5 = space();
    			form = element("form");
    			input = element("input");
    			t6 = space();
    			button1 = element("button");
    			button1.textContent = "Send";
    			t8 = space();
    			p3 = element("p");
    			p3.textContent = "Chat Output:";
    			t10 = space();
    			div1 = element("div");
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(button0, "class", "btm2 bg-blue-500 hover:bg-blue-700 text-white font-bold py-2\n            px-4 rounded-full svelte-vqb2s2");
    			add_location(button0, file$F, 231, 10, 7794);
    			attr_dev(div0, "class", "header svelte-vqb2s2");
    			add_location(div0, file$F, 230, 8, 7763);
    			if (img.src !== (img_src_value = "https://d2c805weuec6z7.cloudfront.net/Powered_By_PubNub.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "Powered By PubNub");
    			attr_dev(img, "width", "150");
    			attr_dev(img, "class", "svelte-vqb2s2");
    			add_location(img, file$F, 240, 12, 8093);
    			attr_dev(a, "href", "https://www.pubnub.com/?devrel_pbpn=javascript-chat");
    			attr_dev(a, "class", "svelte-vqb2s2");
    			add_location(a, file$F, 239, 10, 8018);
    			attr_dev(p0, "class", "svelte-vqb2s2");
    			add_location(p0, file$F, 238, 8, 8004);
    			attr_dev(p1, "class", "svelte-vqb2s2");
    			add_location(p1, file$F, 246, 8, 8281);
    			attr_dev(p2, "class", "svelte-vqb2s2");
    			add_location(p2, file$F, 247, 8, 8295);
    			attr_dev(input, "placeholder", "Your Message Here");
    			attr_dev(input, "class", "svelte-vqb2s2");
    			add_location(input, file$F, 250, 10, 8435);
    			attr_dev(button1, "type", "submit");
    			attr_dev(button1, "class", "svelte-vqb2s2");
    			add_location(button1, file$F, 251, 10, 8511);
    			attr_dev(form, "class", "svelte-vqb2s2");
    			add_location(form, file$F, 248, 8, 8338);
    			attr_dev(p3, "class", "svelte-vqb2s2");
    			add_location(p3, file$F, 253, 8, 8571);
    			attr_dev(ul, "class", "messages svelte-vqb2s2");
    			add_location(ul, file$F, 255, 10, 8636);
    			attr_dev(div1, "class", "message-form svelte-vqb2s2");
    			add_location(div1, file$F, 254, 8, 8599);
    			attr_dev(div2, "class", "chat svelte-vqb2s2");
    			add_location(div2, file$F, 229, 6, 7736);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, button0);
    			append_dev(div2, t1);
    			append_dev(div2, p0);
    			append_dev(p0, a);
    			append_dev(a, img);
    			append_dev(div2, t2);
    			append_dev(div2, p1);
    			append_dev(div2, t3);
    			append_dev(div2, p2);
    			append_dev(div2, t5);
    			append_dev(div2, form);
    			append_dev(form, input);
    			set_input_value(input, /*newMessage*/ ctx[1]);
    			append_dev(form, t6);
    			append_dev(form, button1);
    			append_dev(div2, t8);
    			append_dev(div2, p3);
    			append_dev(div2, t10);
    			append_dev(div2, div1);
    			append_dev(div1, ul);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			dispose = [
    				listen_dev(button0, "click", /*close*/ ctx[4], false, false, false),
    				listen_dev(input, "input", /*input_input_handler*/ ctx[17]),
    				listen_dev(
    					form,
    					"submit",
    					prevent_default(function () {
    						if (is_function(publish(/*newMessage*/ ctx[1], "channel." + /*userName*/ ctx[5]))) publish(/*newMessage*/ ctx[1], "channel." + /*userName*/ ctx[5]).apply(this, arguments);
    					}),
    					false,
    					true,
    					false
    				)
    			];
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*newMessage*/ 2 && input.value !== /*newMessage*/ ctx[1]) {
    				set_input_value(input, /*newMessage*/ ctx[1]);
    			}

    			if (dirty & /*output*/ 4) {
    				each_value = /*output*/ ctx[2];
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$d(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$d(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_each(each_blocks, detaching);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(229:4) {#if hasJoinedChat}",
    		ctx
    	});

    	return block;
    }

    // (257:12) {#each output as message}
    function create_each_block$d(ctx) {
    	let li;
    	let span;
    	let t0_value = /*message*/ ctx[18] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			li = element("li");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(span, "class", "svelte-vqb2s2");
    			add_location(span, file$F, 258, 16, 8731);
    			attr_dev(li, "class", "svelte-vqb2s2");
    			add_location(li, file$F, 257, 14, 8710);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, span);
    			append_dev(span, t0);
    			append_dev(li, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*output*/ 4 && t0_value !== (t0_value = /*message*/ ctx[18] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$d.name,
    		type: "each",
    		source: "(257:12) {#each output as message}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$I(ctx) {
    	let link;
    	let t0;
    	let body;
    	let t1;
    	let div0;
    	let p;
    	let t3;
    	let div1;
    	let current;
    	const navbar = new Navbar({ $$inline: true });

    	function select_block_type(ctx, dirty) {
    		if (/*hasJoinedChat*/ ctx[0]) return create_if_block$d;
    		return create_else_block$2;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			link = element("link");
    			t0 = space();
    			body = element("body");
    			create_component(navbar.$$.fragment);
    			t1 = space();
    			div0 = element("div");
    			p = element("p");
    			p.textContent = "USER PAGE";
    			t3 = space();
    			div1 = element("div");
    			if_block.c();
    			attr_dev(link, "href", "https://unpkg.com/tailwindcss@^1.0/dist/tailwind.min.css");
    			attr_dev(link, "rel", "stylesheet");
    			attr_dev(link, "class", "svelte-vqb2s2");
    			add_location(link, file$F, 216, 0, 7531);
    			attr_dev(p, "class", "svelte-vqb2s2");
    			add_location(p, file$F, 224, 4, 7659);
    			attr_dev(div0, "class", "svelte-vqb2s2");
    			add_location(div0, file$F, 223, 2, 7649);
    			attr_dev(div1, "class", "App svelte-vqb2s2");
    			add_location(div1, file$F, 227, 2, 7688);
    			attr_dev(body, "class", "svelte-vqb2s2");
    			add_location(body, file$F, 219, 0, 7625);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, link, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, body, anchor);
    			mount_component(navbar, body, null);
    			append_dev(body, t1);
    			append_dev(body, div0);
    			append_dev(div0, p);
    			append_dev(body, t3);
    			append_dev(body, div1);
    			if_block.m(div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div1, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(link);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(body);
    			destroy_component(navbar);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function getCookie$2(name) {
    	var match = document.cookie.match(new RegExp("(^| )" + name + "=([^;]+)"));
    	if (match) return match[2];
    }

    function instance$D($$self, $$props, $$invalidate) {
    	const client = getClient();
    	const Test = query(client, { query: apolloClient.allTests });
    	const Problem = query(client, { query: apolloClient.getProblems });

    	const handleProblemAdd = () => {
    		Problem.refetch();
    	};

    	const handleTestAdd = () => {
    		Test.refetch();
    	};

    	let hasJoinedChat = false;
    	let channel = "";
    	let username = "";
    	let newMessage = "";
    	let messages = "";
    	let output = [""];

    	function joined() {
    		$$invalidate(0, hasJoinedChat = true);
    	}

    	function close() {
    		$$invalidate(0, hasJoinedChat = false);
    	}

    	// const user = {
    	//   id: 1,
    	//   email: "newUserr.com",
    	//   name: "adarash",
    	//   flag: "U",
    	//   ttl: 1440,
    	//   profileUrl: "xyz.com"
    	// };
    	pubnub.addListener({
    		message(m) {
    			$$invalidate(2, output = [...output, m.message]); // console.log(m);
    			$$invalidate(1, newMessage = "");
    		}, // console.log(m);
    		
    	});

    	const userEmail = getCookie$2("access_email");
    	let sEmails = userEmail.split("%");
    	let userName = sEmails[0];

    	const user = {
    		id: Math.floor(Math.random() * 10) + 1,
    		email: userName,
    		name: userName,
    		flag: "U",
    		ttl: 1440,
    		profileUrl: null
    	};

    	grantPermissions(user);

    	function input_input_handler() {
    		newMessage = this.value;
    		$$invalidate(1, newMessage);
    	}

    	$$self.$capture_state = () => {
    		return {};
    	};

    	$$self.$inject_state = $$props => {
    		if ("hasJoinedChat" in $$props) $$invalidate(0, hasJoinedChat = $$props.hasJoinedChat);
    		if ("channel" in $$props) channel = $$props.channel;
    		if ("username" in $$props) username = $$props.username;
    		if ("newMessage" in $$props) $$invalidate(1, newMessage = $$props.newMessage);
    		if ("messages" in $$props) messages = $$props.messages;
    		if ("output" in $$props) $$invalidate(2, output = $$props.output);
    		if ("sEmails" in $$props) sEmails = $$props.sEmails;
    		if ("userName" in $$props) $$invalidate(5, userName = $$props.userName);
    	};

    	return [
    		hasJoinedChat,
    		newMessage,
    		output,
    		joined,
    		close,
    		userName,
    		client,
    		Test,
    		Problem,
    		handleProblemAdd,
    		handleTestAdd,
    		channel,
    		username,
    		messages,
    		userEmail,
    		sEmails,
    		user,
    		input_input_handler
    	];
    }

    class Pubnub extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$D, create_fragment$I, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Pubnub",
    			options,
    			id: create_fragment$I.name
    		});
    	}
    }

    const routes = [
      {
        name: '/',
        component: Login,
      },
      {
        name: '/newtest',
        component: Add_test,
      },
      {
        name: '/newProblem',
        component: Add_problem,
      },
      {
        name: '/editProblem/:id',
        component: Edit_problem,
      },
      {
        name: '/editTest/:id',
        component: EditTest,
      },
      {
        name: '/admin',
        component: Admin,
      },
      {
        name: '/test/:id',
        component: Tests,
      },
      {
        name: '/problem/:id',
        component: Problems,
      },
      {
        name: '/sendtest/:id',
        component: Send_test,
      },
      {
        name: '/givetest/:token',
        component: Home,
      },
      {
        name: '/thankyou',
        component: Thankyou,
      },
      {
        name: '/pubnub',
        component: Pubnub,
      },
      {
        name: '/home',
        component: Home,
      },
      {
        name: '/sendtest/:id',
        component: Send_test,
      },
    ];

    var Observable_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Observable = void 0;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

    // === Symbol Support ===
    var hasSymbols = function () {
      return typeof Symbol === 'function';
    };

    var hasSymbol = function (name) {
      return hasSymbols() && Boolean(Symbol[name]);
    };

    var getSymbol = function (name) {
      return hasSymbol(name) ? Symbol[name] : '@@' + name;
    };

    if (hasSymbols() && !hasSymbol('observable')) {
      Symbol.observable = Symbol('observable');
    }

    var SymbolIterator = getSymbol('iterator');
    var SymbolObservable = getSymbol('observable');
    var SymbolSpecies = getSymbol('species'); // === Abstract Operations ===

    function getMethod(obj, key) {
      var value = obj[key];
      if (value == null) return undefined;
      if (typeof value !== 'function') throw new TypeError(value + ' is not a function');
      return value;
    }

    function getSpecies(obj) {
      var ctor = obj.constructor;

      if (ctor !== undefined) {
        ctor = ctor[SymbolSpecies];

        if (ctor === null) {
          ctor = undefined;
        }
      }

      return ctor !== undefined ? ctor : Observable;
    }

    function isObservable(x) {
      return x instanceof Observable; // SPEC: Brand check
    }

    function hostReportError(e) {
      if (hostReportError.log) {
        hostReportError.log(e);
      } else {
        setTimeout(function () {
          throw e;
        });
      }
    }

    function enqueue(fn) {
      Promise.resolve().then(function () {
        try {
          fn();
        } catch (e) {
          hostReportError(e);
        }
      });
    }

    function cleanupSubscription(subscription) {
      var cleanup = subscription._cleanup;
      if (cleanup === undefined) return;
      subscription._cleanup = undefined;

      if (!cleanup) {
        return;
      }

      try {
        if (typeof cleanup === 'function') {
          cleanup();
        } else {
          var unsubscribe = getMethod(cleanup, 'unsubscribe');

          if (unsubscribe) {
            unsubscribe.call(cleanup);
          }
        }
      } catch (e) {
        hostReportError(e);
      }
    }

    function closeSubscription(subscription) {
      subscription._observer = undefined;
      subscription._queue = undefined;
      subscription._state = 'closed';
    }

    function flushSubscription(subscription) {
      var queue = subscription._queue;

      if (!queue) {
        return;
      }

      subscription._queue = undefined;
      subscription._state = 'ready';

      for (var i = 0; i < queue.length; ++i) {
        notifySubscription(subscription, queue[i].type, queue[i].value);
        if (subscription._state === 'closed') break;
      }
    }

    function notifySubscription(subscription, type, value) {
      subscription._state = 'running';
      var observer = subscription._observer;

      try {
        var m = getMethod(observer, type);

        switch (type) {
          case 'next':
            if (m) m.call(observer, value);
            break;

          case 'error':
            closeSubscription(subscription);
            if (m) m.call(observer, value);else throw value;
            break;

          case 'complete':
            closeSubscription(subscription);
            if (m) m.call(observer);
            break;
        }
      } catch (e) {
        hostReportError(e);
      }

      if (subscription._state === 'closed') cleanupSubscription(subscription);else if (subscription._state === 'running') subscription._state = 'ready';
    }

    function onNotify(subscription, type, value) {
      if (subscription._state === 'closed') return;

      if (subscription._state === 'buffering') {
        subscription._queue.push({
          type: type,
          value: value
        });

        return;
      }

      if (subscription._state !== 'ready') {
        subscription._state = 'buffering';
        subscription._queue = [{
          type: type,
          value: value
        }];
        enqueue(function () {
          return flushSubscription(subscription);
        });
        return;
      }

      notifySubscription(subscription, type, value);
    }

    var Subscription =
    /*#__PURE__*/
    function () {
      function Subscription(observer, subscriber) {
        _classCallCheck(this, Subscription);

        // ASSERT: observer is an object
        // ASSERT: subscriber is callable
        this._cleanup = undefined;
        this._observer = observer;
        this._queue = undefined;
        this._state = 'initializing';
        var subscriptionObserver = new SubscriptionObserver(this);

        try {
          this._cleanup = subscriber.call(undefined, subscriptionObserver);
        } catch (e) {
          subscriptionObserver.error(e);
        }

        if (this._state === 'initializing') this._state = 'ready';
      }

      _createClass(Subscription, [{
        key: "unsubscribe",
        value: function unsubscribe() {
          if (this._state !== 'closed') {
            closeSubscription(this);
            cleanupSubscription(this);
          }
        }
      }, {
        key: "closed",
        get: function () {
          return this._state === 'closed';
        }
      }]);

      return Subscription;
    }();

    var SubscriptionObserver =
    /*#__PURE__*/
    function () {
      function SubscriptionObserver(subscription) {
        _classCallCheck(this, SubscriptionObserver);

        this._subscription = subscription;
      }

      _createClass(SubscriptionObserver, [{
        key: "next",
        value: function next(value) {
          onNotify(this._subscription, 'next', value);
        }
      }, {
        key: "error",
        value: function error(value) {
          onNotify(this._subscription, 'error', value);
        }
      }, {
        key: "complete",
        value: function complete() {
          onNotify(this._subscription, 'complete');
        }
      }, {
        key: "closed",
        get: function () {
          return this._subscription._state === 'closed';
        }
      }]);

      return SubscriptionObserver;
    }();

    var Observable =
    /*#__PURE__*/
    function () {
      function Observable(subscriber) {
        _classCallCheck(this, Observable);

        if (!(this instanceof Observable)) throw new TypeError('Observable cannot be called as a function');
        if (typeof subscriber !== 'function') throw new TypeError('Observable initializer must be a function');
        this._subscriber = subscriber;
      }

      _createClass(Observable, [{
        key: "subscribe",
        value: function subscribe(observer) {
          if (typeof observer !== 'object' || observer === null) {
            observer = {
              next: observer,
              error: arguments[1],
              complete: arguments[2]
            };
          }

          return new Subscription(observer, this._subscriber);
        }
      }, {
        key: "forEach",
        value: function forEach(fn) {
          var _this = this;

          return new Promise(function (resolve, reject) {
            if (typeof fn !== 'function') {
              reject(new TypeError(fn + ' is not a function'));
              return;
            }

            function done() {
              subscription.unsubscribe();
              resolve();
            }

            var subscription = _this.subscribe({
              next: function (value) {
                try {
                  fn(value, done);
                } catch (e) {
                  reject(e);
                  subscription.unsubscribe();
                }
              },
              error: reject,
              complete: resolve
            });
          });
        }
      }, {
        key: "map",
        value: function map(fn) {
          var _this2 = this;

          if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');
          var C = getSpecies(this);
          return new C(function (observer) {
            return _this2.subscribe({
              next: function (value) {
                try {
                  value = fn(value);
                } catch (e) {
                  return observer.error(e);
                }

                observer.next(value);
              },
              error: function (e) {
                observer.error(e);
              },
              complete: function () {
                observer.complete();
              }
            });
          });
        }
      }, {
        key: "filter",
        value: function filter(fn) {
          var _this3 = this;

          if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');
          var C = getSpecies(this);
          return new C(function (observer) {
            return _this3.subscribe({
              next: function (value) {
                try {
                  if (!fn(value)) return;
                } catch (e) {
                  return observer.error(e);
                }

                observer.next(value);
              },
              error: function (e) {
                observer.error(e);
              },
              complete: function () {
                observer.complete();
              }
            });
          });
        }
      }, {
        key: "reduce",
        value: function reduce(fn) {
          var _this4 = this;

          if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');
          var C = getSpecies(this);
          var hasSeed = arguments.length > 1;
          var hasValue = false;
          var seed = arguments[1];
          var acc = seed;
          return new C(function (observer) {
            return _this4.subscribe({
              next: function (value) {
                var first = !hasValue;
                hasValue = true;

                if (!first || hasSeed) {
                  try {
                    acc = fn(acc, value);
                  } catch (e) {
                    return observer.error(e);
                  }
                } else {
                  acc = value;
                }
              },
              error: function (e) {
                observer.error(e);
              },
              complete: function () {
                if (!hasValue && !hasSeed) return observer.error(new TypeError('Cannot reduce an empty sequence'));
                observer.next(acc);
                observer.complete();
              }
            });
          });
        }
      }, {
        key: "concat",
        value: function concat() {
          var _this5 = this;

          for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
            sources[_key] = arguments[_key];
          }

          var C = getSpecies(this);
          return new C(function (observer) {
            var subscription;
            var index = 0;

            function startNext(next) {
              subscription = next.subscribe({
                next: function (v) {
                  observer.next(v);
                },
                error: function (e) {
                  observer.error(e);
                },
                complete: function () {
                  if (index === sources.length) {
                    subscription = undefined;
                    observer.complete();
                  } else {
                    startNext(C.from(sources[index++]));
                  }
                }
              });
            }

            startNext(_this5);
            return function () {
              if (subscription) {
                subscription.unsubscribe();
                subscription = undefined;
              }
            };
          });
        }
      }, {
        key: "flatMap",
        value: function flatMap(fn) {
          var _this6 = this;

          if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');
          var C = getSpecies(this);
          return new C(function (observer) {
            var subscriptions = [];

            var outer = _this6.subscribe({
              next: function (value) {
                if (fn) {
                  try {
                    value = fn(value);
                  } catch (e) {
                    return observer.error(e);
                  }
                }

                var inner = C.from(value).subscribe({
                  next: function (value) {
                    observer.next(value);
                  },
                  error: function (e) {
                    observer.error(e);
                  },
                  complete: function () {
                    var i = subscriptions.indexOf(inner);
                    if (i >= 0) subscriptions.splice(i, 1);
                    completeIfDone();
                  }
                });
                subscriptions.push(inner);
              },
              error: function (e) {
                observer.error(e);
              },
              complete: function () {
                completeIfDone();
              }
            });

            function completeIfDone() {
              if (outer.closed && subscriptions.length === 0) observer.complete();
            }

            return function () {
              subscriptions.forEach(function (s) {
                return s.unsubscribe();
              });
              outer.unsubscribe();
            };
          });
        }
      }, {
        key: SymbolObservable,
        value: function () {
          return this;
        }
      }], [{
        key: "from",
        value: function from(x) {
          var C = typeof this === 'function' ? this : Observable;
          if (x == null) throw new TypeError(x + ' is not an object');
          var method = getMethod(x, SymbolObservable);

          if (method) {
            var observable = method.call(x);
            if (Object(observable) !== observable) throw new TypeError(observable + ' is not an object');
            if (isObservable(observable) && observable.constructor === C) return observable;
            return new C(function (observer) {
              return observable.subscribe(observer);
            });
          }

          if (hasSymbol('iterator')) {
            method = getMethod(x, SymbolIterator);

            if (method) {
              return new C(function (observer) {
                enqueue(function () {
                  if (observer.closed) return;
                  var _iteratorNormalCompletion = true;
                  var _didIteratorError = false;
                  var _iteratorError = undefined;

                  try {
                    for (var _iterator = method.call(x)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                      var _item = _step.value;
                      observer.next(_item);
                      if (observer.closed) return;
                    }
                  } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                      }
                    } finally {
                      if (_didIteratorError) {
                        throw _iteratorError;
                      }
                    }
                  }

                  observer.complete();
                });
              });
            }
          }

          if (Array.isArray(x)) {
            return new C(function (observer) {
              enqueue(function () {
                if (observer.closed) return;

                for (var i = 0; i < x.length; ++i) {
                  observer.next(x[i]);
                  if (observer.closed) return;
                }

                observer.complete();
              });
            });
          }

          throw new TypeError(x + ' is not observable');
        }
      }, {
        key: "of",
        value: function of() {
          for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            items[_key2] = arguments[_key2];
          }

          var C = typeof this === 'function' ? this : Observable;
          return new C(function (observer) {
            enqueue(function () {
              if (observer.closed) return;

              for (var i = 0; i < items.length; ++i) {
                observer.next(items[i]);
                if (observer.closed) return;
              }

              observer.complete();
            });
          });
        }
      }, {
        key: SymbolSpecies,
        get: function () {
          return this;
        }
      }]);

      return Observable;
    }();

    exports.Observable = Observable;

    if (hasSymbols()) {
      Object.defineProperty(Observable, Symbol('extensions'), {
        value: {
          symbol: SymbolObservable,
          hostReportError: hostReportError
        },
        configurable: true
      });
    }
    });

    unwrapExports(Observable_1);
    var Observable_2 = Observable_1.Observable;

    var zenObservable = Observable_1.Observable;

    var Observable = zenObservable;
    //# sourceMappingURL=bundle.esm.js.map

    function validateOperation(operation) {
        var OPERATION_FIELDS = [
            'query',
            'operationName',
            'variables',
            'extensions',
            'context',
        ];
        for (var _i = 0, _a = Object.keys(operation); _i < _a.length; _i++) {
            var key = _a[_i];
            if (OPERATION_FIELDS.indexOf(key) < 0) {
                throw process.env.NODE_ENV === "production" ? new InvariantError(2) : new InvariantError("illegal argument: " + key);
            }
        }
        return operation;
    }
    var LinkError = (function (_super) {
        __extends(LinkError, _super);
        function LinkError(message, link) {
            var _this = _super.call(this, message) || this;
            _this.link = link;
            return _this;
        }
        return LinkError;
    }(Error));
    function isTerminating(link) {
        return link.request.length <= 1;
    }
    function fromError(errorValue) {
        return new Observable(function (observer) {
            observer.error(errorValue);
        });
    }
    function transformOperation(operation) {
        var transformedOperation = {
            variables: operation.variables || {},
            extensions: operation.extensions || {},
            operationName: operation.operationName,
            query: operation.query,
        };
        if (!transformedOperation.operationName) {
            transformedOperation.operationName =
                typeof transformedOperation.query !== 'string'
                    ? getOperationName(transformedOperation.query)
                    : '';
        }
        return transformedOperation;
    }
    function createOperation(starting, operation) {
        var context = __assign({}, starting);
        var setContext = function (next) {
            if (typeof next === 'function') {
                context = __assign({}, context, next(context));
            }
            else {
                context = __assign({}, context, next);
            }
        };
        var getContext = function () { return (__assign({}, context)); };
        Object.defineProperty(operation, 'setContext', {
            enumerable: false,
            value: setContext,
        });
        Object.defineProperty(operation, 'getContext', {
            enumerable: false,
            value: getContext,
        });
        Object.defineProperty(operation, 'toKey', {
            enumerable: false,
            value: function () { return getKey(operation); },
        });
        return operation;
    }
    function getKey(operation) {
        var query = operation.query, variables = operation.variables, operationName = operation.operationName;
        return JSON.stringify([operationName, query, variables]);
    }

    function passthrough(op, forward) {
        return forward ? forward(op) : Observable.of();
    }
    function toLink(handler) {
        return typeof handler === 'function' ? new ApolloLink(handler) : handler;
    }
    function empty$1() {
        return new ApolloLink(function () { return Observable.of(); });
    }
    function from(links) {
        if (links.length === 0)
            return empty$1();
        return links.map(toLink).reduce(function (x, y) { return x.concat(y); });
    }
    function split(test, left, right) {
        var leftLink = toLink(left);
        var rightLink = toLink(right || new ApolloLink(passthrough));
        if (isTerminating(leftLink) && isTerminating(rightLink)) {
            return new ApolloLink(function (operation) {
                return test(operation)
                    ? leftLink.request(operation) || Observable.of()
                    : rightLink.request(operation) || Observable.of();
            });
        }
        else {
            return new ApolloLink(function (operation, forward) {
                return test(operation)
                    ? leftLink.request(operation, forward) || Observable.of()
                    : rightLink.request(operation, forward) || Observable.of();
            });
        }
    }
    var concat = function (first, second) {
        var firstLink = toLink(first);
        if (isTerminating(firstLink)) {
            process.env.NODE_ENV === "production" || invariant.warn(new LinkError("You are calling concat on a terminating link, which will have no effect", firstLink));
            return firstLink;
        }
        var nextLink = toLink(second);
        if (isTerminating(nextLink)) {
            return new ApolloLink(function (operation) {
                return firstLink.request(operation, function (op) { return nextLink.request(op) || Observable.of(); }) || Observable.of();
            });
        }
        else {
            return new ApolloLink(function (operation, forward) {
                return (firstLink.request(operation, function (op) {
                    return nextLink.request(op, forward) || Observable.of();
                }) || Observable.of());
            });
        }
    };
    var ApolloLink = (function () {
        function ApolloLink(request) {
            if (request)
                this.request = request;
        }
        ApolloLink.prototype.split = function (test, left, right) {
            return this.concat(split(test, left, right || new ApolloLink(passthrough)));
        };
        ApolloLink.prototype.concat = function (next) {
            return concat(this, next);
        };
        ApolloLink.prototype.request = function (operation, forward) {
            throw process.env.NODE_ENV === "production" ? new InvariantError(1) : new InvariantError('request is not implemented');
        };
        ApolloLink.empty = empty$1;
        ApolloLink.from = from;
        ApolloLink.split = split;
        ApolloLink.execute = execute;
        return ApolloLink;
    }());
    function execute(link, operation) {
        return (link.request(createOperation(operation.context, transformOperation(validateOperation(operation)))) || Observable.of());
    }
    //# sourceMappingURL=bundle.esm.js.map

    function symbolObservablePonyfill(root) {
    	var result;
    	var Symbol = root.Symbol;

    	if (typeof Symbol === 'function') {
    		if (Symbol.observable) {
    			result = Symbol.observable;
    		} else {
    			result = Symbol('observable');
    			Symbol.observable = result;
    		}
    	} else {
    		result = '@@observable';
    	}

    	return result;
    }

    /* global window */

    var root;

    if (typeof self !== 'undefined') {
      root = self;
    } else if (typeof window !== 'undefined') {
      root = window;
    } else if (typeof global !== 'undefined') {
      root = global;
    } else if (typeof module !== 'undefined') {
      root = module;
    } else {
      root = Function('return this')();
    }

    var result = symbolObservablePonyfill(root);

    var NetworkStatus;
    (function (NetworkStatus) {
        NetworkStatus[NetworkStatus["loading"] = 1] = "loading";
        NetworkStatus[NetworkStatus["setVariables"] = 2] = "setVariables";
        NetworkStatus[NetworkStatus["fetchMore"] = 3] = "fetchMore";
        NetworkStatus[NetworkStatus["refetch"] = 4] = "refetch";
        NetworkStatus[NetworkStatus["poll"] = 6] = "poll";
        NetworkStatus[NetworkStatus["ready"] = 7] = "ready";
        NetworkStatus[NetworkStatus["error"] = 8] = "error";
    })(NetworkStatus || (NetworkStatus = {}));
    function isNetworkRequestInFlight(networkStatus) {
        return networkStatus < 7;
    }

    var Observable$1 = (function (_super) {
        __extends(Observable, _super);
        function Observable() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Observable.prototype[result] = function () {
            return this;
        };
        Observable.prototype['@@observable'] = function () {
            return this;
        };
        return Observable;
    }(Observable));

    function isNonEmptyArray(value) {
        return Array.isArray(value) && value.length > 0;
    }

    function isApolloError(err) {
        return err.hasOwnProperty('graphQLErrors');
    }
    var generateErrorMessage = function (err) {
        var message = '';
        if (isNonEmptyArray(err.graphQLErrors)) {
            err.graphQLErrors.forEach(function (graphQLError) {
                var errorMessage = graphQLError
                    ? graphQLError.message
                    : 'Error message not found.';
                message += "GraphQL error: " + errorMessage + "\n";
            });
        }
        if (err.networkError) {
            message += 'Network error: ' + err.networkError.message + '\n';
        }
        message = message.replace(/\n$/, '');
        return message;
    };
    var ApolloError = (function (_super) {
        __extends(ApolloError, _super);
        function ApolloError(_a) {
            var graphQLErrors = _a.graphQLErrors, networkError = _a.networkError, errorMessage = _a.errorMessage, extraInfo = _a.extraInfo;
            var _this = _super.call(this, errorMessage) || this;
            _this.graphQLErrors = graphQLErrors || [];
            _this.networkError = networkError || null;
            if (!errorMessage) {
                _this.message = generateErrorMessage(_this);
            }
            else {
                _this.message = errorMessage;
            }
            _this.extraInfo = extraInfo;
            _this.__proto__ = ApolloError.prototype;
            return _this;
        }
        return ApolloError;
    }(Error));

    var FetchType;
    (function (FetchType) {
        FetchType[FetchType["normal"] = 1] = "normal";
        FetchType[FetchType["refetch"] = 2] = "refetch";
        FetchType[FetchType["poll"] = 3] = "poll";
    })(FetchType || (FetchType = {}));

    var hasError = function (storeValue, policy) {
        if (policy === void 0) { policy = 'none'; }
        return storeValue && (storeValue.networkError ||
            (policy === 'none' && isNonEmptyArray(storeValue.graphQLErrors)));
    };
    var ObservableQuery = (function (_super) {
        __extends(ObservableQuery, _super);
        function ObservableQuery(_a) {
            var queryManager = _a.queryManager, options = _a.options, _b = _a.shouldSubscribe, shouldSubscribe = _b === void 0 ? true : _b;
            var _this = _super.call(this, function (observer) {
                return _this.onSubscribe(observer);
            }) || this;
            _this.observers = new Set();
            _this.subscriptions = new Set();
            _this.isTornDown = false;
            _this.options = options;
            _this.variables = options.variables || {};
            _this.queryId = queryManager.generateQueryId();
            _this.shouldSubscribe = shouldSubscribe;
            var opDef = getOperationDefinition(options.query);
            _this.queryName = opDef && opDef.name && opDef.name.value;
            _this.queryManager = queryManager;
            return _this;
        }
        ObservableQuery.prototype.result = function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var observer = {
                    next: function (result) {
                        resolve(result);
                        _this.observers.delete(observer);
                        if (!_this.observers.size) {
                            _this.queryManager.removeQuery(_this.queryId);
                        }
                        setTimeout(function () {
                            subscription.unsubscribe();
                        }, 0);
                    },
                    error: reject,
                };
                var subscription = _this.subscribe(observer);
            });
        };
        ObservableQuery.prototype.currentResult = function () {
            var result = this.getCurrentResult();
            if (result.data === undefined) {
                result.data = {};
            }
            return result;
        };
        ObservableQuery.prototype.getCurrentResult = function () {
            if (this.isTornDown) {
                var lastResult = this.lastResult;
                return {
                    data: !this.lastError && lastResult && lastResult.data || void 0,
                    error: this.lastError,
                    loading: false,
                    networkStatus: NetworkStatus.error,
                };
            }
            var _a = this.queryManager.getCurrentQueryResult(this), data = _a.data, partial = _a.partial;
            var queryStoreValue = this.queryManager.queryStore.get(this.queryId);
            var result;
            var fetchPolicy = this.options.fetchPolicy;
            var isNetworkFetchPolicy = fetchPolicy === 'network-only' ||
                fetchPolicy === 'no-cache';
            if (queryStoreValue) {
                var networkStatus = queryStoreValue.networkStatus;
                if (hasError(queryStoreValue, this.options.errorPolicy)) {
                    return {
                        data: void 0,
                        loading: false,
                        networkStatus: networkStatus,
                        error: new ApolloError({
                            graphQLErrors: queryStoreValue.graphQLErrors,
                            networkError: queryStoreValue.networkError,
                        }),
                    };
                }
                if (queryStoreValue.variables) {
                    this.options.variables = __assign(__assign({}, this.options.variables), queryStoreValue.variables);
                    this.variables = this.options.variables;
                }
                result = {
                    data: data,
                    loading: isNetworkRequestInFlight(networkStatus),
                    networkStatus: networkStatus,
                };
                if (queryStoreValue.graphQLErrors && this.options.errorPolicy === 'all') {
                    result.errors = queryStoreValue.graphQLErrors;
                }
            }
            else {
                var loading = isNetworkFetchPolicy ||
                    (partial && fetchPolicy !== 'cache-only');
                result = {
                    data: data,
                    loading: loading,
                    networkStatus: loading ? NetworkStatus.loading : NetworkStatus.ready,
                };
            }
            if (!partial) {
                this.updateLastResult(__assign(__assign({}, result), { stale: false }));
            }
            return __assign(__assign({}, result), { partial: partial });
        };
        ObservableQuery.prototype.isDifferentFromLastResult = function (newResult) {
            var snapshot = this.lastResultSnapshot;
            return !(snapshot &&
                newResult &&
                snapshot.networkStatus === newResult.networkStatus &&
                snapshot.stale === newResult.stale &&
                equal(snapshot.data, newResult.data));
        };
        ObservableQuery.prototype.getLastResult = function () {
            return this.lastResult;
        };
        ObservableQuery.prototype.getLastError = function () {
            return this.lastError;
        };
        ObservableQuery.prototype.resetLastResults = function () {
            delete this.lastResult;
            delete this.lastResultSnapshot;
            delete this.lastError;
            this.isTornDown = false;
        };
        ObservableQuery.prototype.resetQueryStoreErrors = function () {
            var queryStore = this.queryManager.queryStore.get(this.queryId);
            if (queryStore) {
                queryStore.networkError = null;
                queryStore.graphQLErrors = [];
            }
        };
        ObservableQuery.prototype.refetch = function (variables) {
            var fetchPolicy = this.options.fetchPolicy;
            if (fetchPolicy === 'cache-only') {
                return Promise.reject(process.env.NODE_ENV === "production" ? new InvariantError(3) : new InvariantError('cache-only fetchPolicy option should not be used together with query refetch.'));
            }
            if (fetchPolicy !== 'no-cache' &&
                fetchPolicy !== 'cache-and-network') {
                fetchPolicy = 'network-only';
            }
            if (!equal(this.variables, variables)) {
                this.variables = __assign(__assign({}, this.variables), variables);
            }
            if (!equal(this.options.variables, this.variables)) {
                this.options.variables = __assign(__assign({}, this.options.variables), this.variables);
            }
            return this.queryManager.fetchQuery(this.queryId, __assign(__assign({}, this.options), { fetchPolicy: fetchPolicy }), FetchType.refetch);
        };
        ObservableQuery.prototype.fetchMore = function (fetchMoreOptions) {
            var _this = this;
            process.env.NODE_ENV === "production" ? invariant(fetchMoreOptions.updateQuery, 4) : invariant(fetchMoreOptions.updateQuery, 'updateQuery option is required. This function defines how to update the query data with the new results.');
            var combinedOptions = __assign(__assign({}, (fetchMoreOptions.query ? fetchMoreOptions : __assign(__assign(__assign({}, this.options), fetchMoreOptions), { variables: __assign(__assign({}, this.variables), fetchMoreOptions.variables) }))), { fetchPolicy: 'network-only' });
            var qid = this.queryManager.generateQueryId();
            return this.queryManager
                .fetchQuery(qid, combinedOptions, FetchType.normal, this.queryId)
                .then(function (fetchMoreResult) {
                _this.updateQuery(function (previousResult) {
                    return fetchMoreOptions.updateQuery(previousResult, {
                        fetchMoreResult: fetchMoreResult.data,
                        variables: combinedOptions.variables,
                    });
                });
                _this.queryManager.stopQuery(qid);
                return fetchMoreResult;
            }, function (error) {
                _this.queryManager.stopQuery(qid);
                throw error;
            });
        };
        ObservableQuery.prototype.subscribeToMore = function (options) {
            var _this = this;
            var subscription = this.queryManager
                .startGraphQLSubscription({
                query: options.document,
                variables: options.variables,
            })
                .subscribe({
                next: function (subscriptionData) {
                    var updateQuery = options.updateQuery;
                    if (updateQuery) {
                        _this.updateQuery(function (previous, _a) {
                            var variables = _a.variables;
                            return updateQuery(previous, {
                                subscriptionData: subscriptionData,
                                variables: variables,
                            });
                        });
                    }
                },
                error: function (err) {
                    if (options.onError) {
                        options.onError(err);
                        return;
                    }
                    process.env.NODE_ENV === "production" || invariant.error('Unhandled GraphQL subscription error', err);
                },
            });
            this.subscriptions.add(subscription);
            return function () {
                if (_this.subscriptions.delete(subscription)) {
                    subscription.unsubscribe();
                }
            };
        };
        ObservableQuery.prototype.setOptions = function (opts) {
            var oldFetchPolicy = this.options.fetchPolicy;
            this.options = __assign(__assign({}, this.options), opts);
            if (opts.pollInterval) {
                this.startPolling(opts.pollInterval);
            }
            else if (opts.pollInterval === 0) {
                this.stopPolling();
            }
            var fetchPolicy = opts.fetchPolicy;
            return this.setVariables(this.options.variables, oldFetchPolicy !== fetchPolicy && (oldFetchPolicy === 'cache-only' ||
                oldFetchPolicy === 'standby' ||
                fetchPolicy === 'network-only'), opts.fetchResults);
        };
        ObservableQuery.prototype.setVariables = function (variables, tryFetch, fetchResults) {
            if (tryFetch === void 0) { tryFetch = false; }
            if (fetchResults === void 0) { fetchResults = true; }
            this.isTornDown = false;
            variables = variables || this.variables;
            if (!tryFetch && equal(variables, this.variables)) {
                return this.observers.size && fetchResults
                    ? this.result()
                    : Promise.resolve();
            }
            this.variables = this.options.variables = variables;
            if (!this.observers.size) {
                return Promise.resolve();
            }
            return this.queryManager.fetchQuery(this.queryId, this.options);
        };
        ObservableQuery.prototype.updateQuery = function (mapFn) {
            var queryManager = this.queryManager;
            var _a = queryManager.getQueryWithPreviousResult(this.queryId), previousResult = _a.previousResult, variables = _a.variables, document = _a.document;
            var newResult = tryFunctionOrLogError(function () {
                return mapFn(previousResult, { variables: variables });
            });
            if (newResult) {
                queryManager.dataStore.markUpdateQueryResult(document, variables, newResult);
                queryManager.broadcastQueries();
            }
        };
        ObservableQuery.prototype.stopPolling = function () {
            this.queryManager.stopPollingQuery(this.queryId);
            this.options.pollInterval = undefined;
        };
        ObservableQuery.prototype.startPolling = function (pollInterval) {
            assertNotCacheFirstOrOnly(this);
            this.options.pollInterval = pollInterval;
            this.queryManager.startPollingQuery(this.options, this.queryId);
        };
        ObservableQuery.prototype.updateLastResult = function (newResult) {
            var previousResult = this.lastResult;
            this.lastResult = newResult;
            this.lastResultSnapshot = this.queryManager.assumeImmutableResults
                ? newResult
                : cloneDeep(newResult);
            return previousResult;
        };
        ObservableQuery.prototype.onSubscribe = function (observer) {
            var _this = this;
            try {
                var subObserver = observer._subscription._observer;
                if (subObserver && !subObserver.error) {
                    subObserver.error = defaultSubscriptionObserverErrorCallback;
                }
            }
            catch (_a) { }
            var first = !this.observers.size;
            this.observers.add(observer);
            if (observer.next && this.lastResult)
                observer.next(this.lastResult);
            if (observer.error && this.lastError)
                observer.error(this.lastError);
            if (first) {
                this.setUpQuery();
            }
            return function () {
                if (_this.observers.delete(observer) && !_this.observers.size) {
                    _this.tearDownQuery();
                }
            };
        };
        ObservableQuery.prototype.setUpQuery = function () {
            var _this = this;
            var _a = this, queryManager = _a.queryManager, queryId = _a.queryId;
            if (this.shouldSubscribe) {
                queryManager.addObservableQuery(queryId, this);
            }
            if (this.options.pollInterval) {
                assertNotCacheFirstOrOnly(this);
                queryManager.startPollingQuery(this.options, queryId);
            }
            var onError = function (error) {
                _this.updateLastResult(__assign(__assign({}, _this.lastResult), { errors: error.graphQLErrors, networkStatus: NetworkStatus.error, loading: false }));
                iterateObserversSafely(_this.observers, 'error', _this.lastError = error);
            };
            queryManager.observeQuery(queryId, this.options, {
                next: function (result) {
                    if (_this.lastError || _this.isDifferentFromLastResult(result)) {
                        var previousResult_1 = _this.updateLastResult(result);
                        var _a = _this.options, query_1 = _a.query, variables = _a.variables, fetchPolicy_1 = _a.fetchPolicy;
                        if (queryManager.transform(query_1).hasClientExports) {
                            queryManager.getLocalState().addExportedVariables(query_1, variables).then(function (variables) {
                                var previousVariables = _this.variables;
                                _this.variables = _this.options.variables = variables;
                                if (!result.loading &&
                                    previousResult_1 &&
                                    fetchPolicy_1 !== 'cache-only' &&
                                    queryManager.transform(query_1).serverQuery &&
                                    !equal(previousVariables, variables)) {
                                    _this.refetch();
                                }
                                else {
                                    iterateObserversSafely(_this.observers, 'next', result);
                                }
                            });
                        }
                        else {
                            iterateObserversSafely(_this.observers, 'next', result);
                        }
                    }
                },
                error: onError,
            }).catch(onError);
        };
        ObservableQuery.prototype.tearDownQuery = function () {
            var queryManager = this.queryManager;
            this.isTornDown = true;
            queryManager.stopPollingQuery(this.queryId);
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            this.subscriptions.clear();
            queryManager.removeObservableQuery(this.queryId);
            queryManager.stopQuery(this.queryId);
            this.observers.clear();
        };
        return ObservableQuery;
    }(Observable$1));
    function defaultSubscriptionObserverErrorCallback(error) {
        process.env.NODE_ENV === "production" || invariant.error('Unhandled error', error.message, error.stack);
    }
    function iterateObserversSafely(observers, method, argument) {
        var observersWithMethod = [];
        observers.forEach(function (obs) { return obs[method] && observersWithMethod.push(obs); });
        observersWithMethod.forEach(function (obs) { return obs[method](argument); });
    }
    function assertNotCacheFirstOrOnly(obsQuery) {
        var fetchPolicy = obsQuery.options.fetchPolicy;
        process.env.NODE_ENV === "production" ? invariant(fetchPolicy !== 'cache-first' && fetchPolicy !== 'cache-only', 5) : invariant(fetchPolicy !== 'cache-first' && fetchPolicy !== 'cache-only', 'Queries that specify the cache-first and cache-only fetchPolicies cannot also be polling queries.');
    }

    var MutationStore = (function () {
        function MutationStore() {
            this.store = {};
        }
        MutationStore.prototype.getStore = function () {
            return this.store;
        };
        MutationStore.prototype.get = function (mutationId) {
            return this.store[mutationId];
        };
        MutationStore.prototype.initMutation = function (mutationId, mutation, variables) {
            this.store[mutationId] = {
                mutation: mutation,
                variables: variables || {},
                loading: true,
                error: null,
            };
        };
        MutationStore.prototype.markMutationError = function (mutationId, error) {
            var mutation = this.store[mutationId];
            if (mutation) {
                mutation.loading = false;
                mutation.error = error;
            }
        };
        MutationStore.prototype.markMutationResult = function (mutationId) {
            var mutation = this.store[mutationId];
            if (mutation) {
                mutation.loading = false;
                mutation.error = null;
            }
        };
        MutationStore.prototype.reset = function () {
            this.store = {};
        };
        return MutationStore;
    }());

    var QueryStore = (function () {
        function QueryStore() {
            this.store = {};
        }
        QueryStore.prototype.getStore = function () {
            return this.store;
        };
        QueryStore.prototype.get = function (queryId) {
            return this.store[queryId];
        };
        QueryStore.prototype.initQuery = function (query) {
            var previousQuery = this.store[query.queryId];
            process.env.NODE_ENV === "production" ? invariant(!previousQuery ||
                previousQuery.document === query.document ||
                equal(previousQuery.document, query.document), 19) : invariant(!previousQuery ||
                previousQuery.document === query.document ||
                equal(previousQuery.document, query.document), 'Internal Error: may not update existing query string in store');
            var isSetVariables = false;
            var previousVariables = null;
            if (query.storePreviousVariables &&
                previousQuery &&
                previousQuery.networkStatus !== NetworkStatus.loading) {
                if (!equal(previousQuery.variables, query.variables)) {
                    isSetVariables = true;
                    previousVariables = previousQuery.variables;
                }
            }
            var networkStatus;
            if (isSetVariables) {
                networkStatus = NetworkStatus.setVariables;
            }
            else if (query.isPoll) {
                networkStatus = NetworkStatus.poll;
            }
            else if (query.isRefetch) {
                networkStatus = NetworkStatus.refetch;
            }
            else {
                networkStatus = NetworkStatus.loading;
            }
            var graphQLErrors = [];
            if (previousQuery && previousQuery.graphQLErrors) {
                graphQLErrors = previousQuery.graphQLErrors;
            }
            this.store[query.queryId] = {
                document: query.document,
                variables: query.variables,
                previousVariables: previousVariables,
                networkError: null,
                graphQLErrors: graphQLErrors,
                networkStatus: networkStatus,
                metadata: query.metadata,
            };
            if (typeof query.fetchMoreForQueryId === 'string' &&
                this.store[query.fetchMoreForQueryId]) {
                this.store[query.fetchMoreForQueryId].networkStatus =
                    NetworkStatus.fetchMore;
            }
        };
        QueryStore.prototype.markQueryResult = function (queryId, result, fetchMoreForQueryId) {
            if (!this.store || !this.store[queryId])
                return;
            this.store[queryId].networkError = null;
            this.store[queryId].graphQLErrors = isNonEmptyArray(result.errors) ? result.errors : [];
            this.store[queryId].previousVariables = null;
            this.store[queryId].networkStatus = NetworkStatus.ready;
            if (typeof fetchMoreForQueryId === 'string' &&
                this.store[fetchMoreForQueryId]) {
                this.store[fetchMoreForQueryId].networkStatus = NetworkStatus.ready;
            }
        };
        QueryStore.prototype.markQueryError = function (queryId, error, fetchMoreForQueryId) {
            if (!this.store || !this.store[queryId])
                return;
            this.store[queryId].networkError = error;
            this.store[queryId].networkStatus = NetworkStatus.error;
            if (typeof fetchMoreForQueryId === 'string') {
                this.markQueryResultClient(fetchMoreForQueryId, true);
            }
        };
        QueryStore.prototype.markQueryResultClient = function (queryId, complete) {
            var storeValue = this.store && this.store[queryId];
            if (storeValue) {
                storeValue.networkError = null;
                storeValue.previousVariables = null;
                if (complete) {
                    storeValue.networkStatus = NetworkStatus.ready;
                }
            }
        };
        QueryStore.prototype.stopQuery = function (queryId) {
            delete this.store[queryId];
        };
        QueryStore.prototype.reset = function (observableQueryIds) {
            var _this = this;
            Object.keys(this.store).forEach(function (queryId) {
                if (observableQueryIds.indexOf(queryId) < 0) {
                    _this.stopQuery(queryId);
                }
                else {
                    _this.store[queryId].networkStatus = NetworkStatus.loading;
                }
            });
        };
        return QueryStore;
    }());

    function capitalizeFirstLetter(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }

    var LocalState = (function () {
        function LocalState(_a) {
            var cache = _a.cache, client = _a.client, resolvers = _a.resolvers, fragmentMatcher = _a.fragmentMatcher;
            this.cache = cache;
            if (client) {
                this.client = client;
            }
            if (resolvers) {
                this.addResolvers(resolvers);
            }
            if (fragmentMatcher) {
                this.setFragmentMatcher(fragmentMatcher);
            }
        }
        LocalState.prototype.addResolvers = function (resolvers) {
            var _this = this;
            this.resolvers = this.resolvers || {};
            if (Array.isArray(resolvers)) {
                resolvers.forEach(function (resolverGroup) {
                    _this.resolvers = mergeDeep(_this.resolvers, resolverGroup);
                });
            }
            else {
                this.resolvers = mergeDeep(this.resolvers, resolvers);
            }
        };
        LocalState.prototype.setResolvers = function (resolvers) {
            this.resolvers = {};
            this.addResolvers(resolvers);
        };
        LocalState.prototype.getResolvers = function () {
            return this.resolvers || {};
        };
        LocalState.prototype.runResolvers = function (_a) {
            var document = _a.document, remoteResult = _a.remoteResult, context = _a.context, variables = _a.variables, _b = _a.onlyRunForcedResolvers, onlyRunForcedResolvers = _b === void 0 ? false : _b;
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_c) {
                    if (document) {
                        return [2, this.resolveDocument(document, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function (localResult) { return (__assign(__assign({}, remoteResult), { data: localResult.result })); })];
                    }
                    return [2, remoteResult];
                });
            });
        };
        LocalState.prototype.setFragmentMatcher = function (fragmentMatcher) {
            this.fragmentMatcher = fragmentMatcher;
        };
        LocalState.prototype.getFragmentMatcher = function () {
            return this.fragmentMatcher;
        };
        LocalState.prototype.clientQuery = function (document) {
            if (hasDirectives(['client'], document)) {
                if (this.resolvers) {
                    return document;
                }
                process.env.NODE_ENV === "production" || invariant.warn('Found @client directives in a query but no ApolloClient resolvers ' +
                    'were specified. This means ApolloClient local resolver handling ' +
                    'has been disabled, and @client directives will be passed through ' +
                    'to your link chain.');
            }
            return null;
        };
        LocalState.prototype.serverQuery = function (document) {
            return this.resolvers ? removeClientSetsFromDocument(document) : document;
        };
        LocalState.prototype.prepareContext = function (context) {
            if (context === void 0) { context = {}; }
            var cache = this.cache;
            var newContext = __assign(__assign({}, context), { cache: cache, getCacheKey: function (obj) {
                    if (cache.config) {
                        return cache.config.dataIdFromObject(obj);
                    }
                    else {
                        process.env.NODE_ENV === "production" ? invariant(false, 6) : invariant(false, 'To use context.getCacheKey, you need to use a cache that has ' +
                            'a configurable dataIdFromObject, like apollo-cache-inmemory.');
                    }
                } });
            return newContext;
        };
        LocalState.prototype.addExportedVariables = function (document, variables, context) {
            if (variables === void 0) { variables = {}; }
            if (context === void 0) { context = {}; }
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    if (document) {
                        return [2, this.resolveDocument(document, this.buildRootValueFromCache(document, variables) || {}, this.prepareContext(context), variables).then(function (data) { return (__assign(__assign({}, variables), data.exportedVariables)); })];
                    }
                    return [2, __assign({}, variables)];
                });
            });
        };
        LocalState.prototype.shouldForceResolvers = function (document) {
            var forceResolvers = false;
            visit(document, {
                Directive: {
                    enter: function (node) {
                        if (node.name.value === 'client' && node.arguments) {
                            forceResolvers = node.arguments.some(function (arg) {
                                return arg.name.value === 'always' &&
                                    arg.value.kind === 'BooleanValue' &&
                                    arg.value.value === true;
                            });
                            if (forceResolvers) {
                                return BREAK;
                            }
                        }
                    },
                },
            });
            return forceResolvers;
        };
        LocalState.prototype.buildRootValueFromCache = function (document, variables) {
            return this.cache.diff({
                query: buildQueryFromSelectionSet(document),
                variables: variables,
                returnPartialData: true,
                optimistic: false,
            }).result;
        };
        LocalState.prototype.resolveDocument = function (document, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {
            if (context === void 0) { context = {}; }
            if (variables === void 0) { variables = {}; }
            if (fragmentMatcher === void 0) { fragmentMatcher = function () { return true; }; }
            if (onlyRunForcedResolvers === void 0) { onlyRunForcedResolvers = false; }
            return __awaiter(this, void 0, void 0, function () {
                var mainDefinition, fragments, fragmentMap, definitionOperation, defaultOperationType, _a, cache, client, execContext;
                return __generator(this, function (_b) {
                    mainDefinition = getMainDefinition(document);
                    fragments = getFragmentDefinitions(document);
                    fragmentMap = createFragmentMap(fragments);
                    definitionOperation = mainDefinition
                        .operation;
                    defaultOperationType = definitionOperation
                        ? capitalizeFirstLetter(definitionOperation)
                        : 'Query';
                    _a = this, cache = _a.cache, client = _a.client;
                    execContext = {
                        fragmentMap: fragmentMap,
                        context: __assign(__assign({}, context), { cache: cache,
                            client: client }),
                        variables: variables,
                        fragmentMatcher: fragmentMatcher,
                        defaultOperationType: defaultOperationType,
                        exportedVariables: {},
                        onlyRunForcedResolvers: onlyRunForcedResolvers,
                    };
                    return [2, this.resolveSelectionSet(mainDefinition.selectionSet, rootValue, execContext).then(function (result) { return ({
                            result: result,
                            exportedVariables: execContext.exportedVariables,
                        }); })];
                });
            });
        };
        LocalState.prototype.resolveSelectionSet = function (selectionSet, rootValue, execContext) {
            return __awaiter(this, void 0, void 0, function () {
                var fragmentMap, context, variables, resultsToMerge, execute;
                var _this = this;
                return __generator(this, function (_a) {
                    fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;
                    resultsToMerge = [rootValue];
                    execute = function (selection) { return __awaiter(_this, void 0, void 0, function () {
                        var fragment, typeCondition;
                        return __generator(this, function (_a) {
                            if (!shouldInclude(selection, variables)) {
                                return [2];
                            }
                            if (isField(selection)) {
                                return [2, this.resolveField(selection, rootValue, execContext).then(function (fieldResult) {
                                        var _a;
                                        if (typeof fieldResult !== 'undefined') {
                                            resultsToMerge.push((_a = {},
                                                _a[resultKeyNameFromField(selection)] = fieldResult,
                                                _a));
                                        }
                                    })];
                            }
                            if (isInlineFragment(selection)) {
                                fragment = selection;
                            }
                            else {
                                fragment = fragmentMap[selection.name.value];
                                process.env.NODE_ENV === "production" ? invariant(fragment, 7) : invariant(fragment, "No fragment named " + selection.name.value);
                            }
                            if (fragment && fragment.typeCondition) {
                                typeCondition = fragment.typeCondition.name.value;
                                if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {
                                    return [2, this.resolveSelectionSet(fragment.selectionSet, rootValue, execContext).then(function (fragmentResult) {
                                            resultsToMerge.push(fragmentResult);
                                        })];
                                }
                            }
                            return [2];
                        });
                    }); };
                    return [2, Promise.all(selectionSet.selections.map(execute)).then(function () {
                            return mergeDeepArray(resultsToMerge);
                        })];
                });
            });
        };
        LocalState.prototype.resolveField = function (field, rootValue, execContext) {
            return __awaiter(this, void 0, void 0, function () {
                var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;
                var _this = this;
                return __generator(this, function (_a) {
                    variables = execContext.variables;
                    fieldName = field.name.value;
                    aliasedFieldName = resultKeyNameFromField(field);
                    aliasUsed = fieldName !== aliasedFieldName;
                    defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];
                    resultPromise = Promise.resolve(defaultResult);
                    if (!execContext.onlyRunForcedResolvers ||
                        this.shouldForceResolvers(field)) {
                        resolverType = rootValue.__typename || execContext.defaultOperationType;
                        resolverMap = this.resolvers && this.resolvers[resolverType];
                        if (resolverMap) {
                            resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];
                            if (resolve) {
                                resultPromise = Promise.resolve(resolve(rootValue, argumentsObjectFromField(field, variables), execContext.context, { field: field, fragmentMap: execContext.fragmentMap }));
                            }
                        }
                    }
                    return [2, resultPromise.then(function (result) {
                            if (result === void 0) { result = defaultResult; }
                            if (field.directives) {
                                field.directives.forEach(function (directive) {
                                    if (directive.name.value === 'export' && directive.arguments) {
                                        directive.arguments.forEach(function (arg) {
                                            if (arg.name.value === 'as' && arg.value.kind === 'StringValue') {
                                                execContext.exportedVariables[arg.value.value] = result;
                                            }
                                        });
                                    }
                                });
                            }
                            if (!field.selectionSet) {
                                return result;
                            }
                            if (result == null) {
                                return result;
                            }
                            if (Array.isArray(result)) {
                                return _this.resolveSubSelectedArray(field, result, execContext);
                            }
                            if (field.selectionSet) {
                                return _this.resolveSelectionSet(field.selectionSet, result, execContext);
                            }
                        })];
                });
            });
        };
        LocalState.prototype.resolveSubSelectedArray = function (field, result, execContext) {
            var _this = this;
            return Promise.all(result.map(function (item) {
                if (item === null) {
                    return null;
                }
                if (Array.isArray(item)) {
                    return _this.resolveSubSelectedArray(field, item, execContext);
                }
                if (field.selectionSet) {
                    return _this.resolveSelectionSet(field.selectionSet, item, execContext);
                }
            }));
        };
        return LocalState;
    }());

    function multiplex(inner) {
        var observers = new Set();
        var sub = null;
        return new Observable$1(function (observer) {
            observers.add(observer);
            sub = sub || inner.subscribe({
                next: function (value) {
                    observers.forEach(function (obs) { return obs.next && obs.next(value); });
                },
                error: function (error) {
                    observers.forEach(function (obs) { return obs.error && obs.error(error); });
                },
                complete: function () {
                    observers.forEach(function (obs) { return obs.complete && obs.complete(); });
                },
            });
            return function () {
                if (observers.delete(observer) && !observers.size && sub) {
                    sub.unsubscribe();
                    sub = null;
                }
            };
        });
    }
    function asyncMap(observable, mapFn) {
        return new Observable$1(function (observer) {
            var next = observer.next, error = observer.error, complete = observer.complete;
            var activeNextCount = 0;
            var completed = false;
            var handler = {
                next: function (value) {
                    ++activeNextCount;
                    new Promise(function (resolve) {
                        resolve(mapFn(value));
                    }).then(function (result) {
                        --activeNextCount;
                        next && next.call(observer, result);
                        completed && handler.complete();
                    }, function (e) {
                        --activeNextCount;
                        error && error.call(observer, e);
                    });
                },
                error: function (e) {
                    error && error.call(observer, e);
                },
                complete: function () {
                    completed = true;
                    if (!activeNextCount) {
                        complete && complete.call(observer);
                    }
                },
            };
            var sub = observable.subscribe(handler);
            return function () { return sub.unsubscribe(); };
        });
    }

    var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
    var QueryManager = (function () {
        function QueryManager(_a) {
            var link = _a.link, _b = _a.queryDeduplication, queryDeduplication = _b === void 0 ? false : _b, store = _a.store, _c = _a.onBroadcast, onBroadcast = _c === void 0 ? function () { return undefined; } : _c, _d = _a.ssrMode, ssrMode = _d === void 0 ? false : _d, _e = _a.clientAwareness, clientAwareness = _e === void 0 ? {} : _e, localState = _a.localState, assumeImmutableResults = _a.assumeImmutableResults;
            this.mutationStore = new MutationStore();
            this.queryStore = new QueryStore();
            this.clientAwareness = {};
            this.idCounter = 1;
            this.queries = new Map();
            this.fetchQueryRejectFns = new Map();
            this.transformCache = new (canUseWeakMap ? WeakMap : Map)();
            this.inFlightLinkObservables = new Map();
            this.pollingInfoByQueryId = new Map();
            this.link = link;
            this.queryDeduplication = queryDeduplication;
            this.dataStore = store;
            this.onBroadcast = onBroadcast;
            this.clientAwareness = clientAwareness;
            this.localState = localState || new LocalState({ cache: store.getCache() });
            this.ssrMode = ssrMode;
            this.assumeImmutableResults = !!assumeImmutableResults;
        }
        QueryManager.prototype.stop = function () {
            var _this = this;
            this.queries.forEach(function (_info, queryId) {
                _this.stopQueryNoBroadcast(queryId);
            });
            this.fetchQueryRejectFns.forEach(function (reject) {
                reject(process.env.NODE_ENV === "production" ? new InvariantError(8) : new InvariantError('QueryManager stopped while query was in flight'));
            });
        };
        QueryManager.prototype.mutate = function (_a) {
            var mutation = _a.mutation, variables = _a.variables, optimisticResponse = _a.optimisticResponse, updateQueriesByName = _a.updateQueries, _b = _a.refetchQueries, refetchQueries = _b === void 0 ? [] : _b, _c = _a.awaitRefetchQueries, awaitRefetchQueries = _c === void 0 ? false : _c, updateWithProxyFn = _a.update, _d = _a.errorPolicy, errorPolicy = _d === void 0 ? 'none' : _d, fetchPolicy = _a.fetchPolicy, _e = _a.context, context = _e === void 0 ? {} : _e;
            return __awaiter(this, void 0, void 0, function () {
                var mutationId, generateUpdateQueriesInfo, self;
                var _this = this;
                return __generator(this, function (_f) {
                    switch (_f.label) {
                        case 0:
                            process.env.NODE_ENV === "production" ? invariant(mutation, 9) : invariant(mutation, 'mutation option is required. You must specify your GraphQL document in the mutation option.');
                            process.env.NODE_ENV === "production" ? invariant(!fetchPolicy || fetchPolicy === 'no-cache', 10) : invariant(!fetchPolicy || fetchPolicy === 'no-cache', "Mutations only support a 'no-cache' fetchPolicy. If you don't want to disable the cache, remove your fetchPolicy setting to proceed with the default mutation behavior.");
                            mutationId = this.generateQueryId();
                            mutation = this.transform(mutation).document;
                            this.setQuery(mutationId, function () { return ({ document: mutation }); });
                            variables = this.getVariables(mutation, variables);
                            if (!this.transform(mutation).hasClientExports) return [3, 2];
                            return [4, this.localState.addExportedVariables(mutation, variables, context)];
                        case 1:
                            variables = _f.sent();
                            _f.label = 2;
                        case 2:
                            generateUpdateQueriesInfo = function () {
                                var ret = {};
                                if (updateQueriesByName) {
                                    _this.queries.forEach(function (_a, queryId) {
                                        var observableQuery = _a.observableQuery;
                                        if (observableQuery) {
                                            var queryName = observableQuery.queryName;
                                            if (queryName &&
                                                hasOwnProperty$2.call(updateQueriesByName, queryName)) {
                                                ret[queryId] = {
                                                    updater: updateQueriesByName[queryName],
                                                    query: _this.queryStore.get(queryId),
                                                };
                                            }
                                        }
                                    });
                                }
                                return ret;
                            };
                            this.mutationStore.initMutation(mutationId, mutation, variables);
                            this.dataStore.markMutationInit({
                                mutationId: mutationId,
                                document: mutation,
                                variables: variables,
                                updateQueries: generateUpdateQueriesInfo(),
                                update: updateWithProxyFn,
                                optimisticResponse: optimisticResponse,
                            });
                            this.broadcastQueries();
                            self = this;
                            return [2, new Promise(function (resolve, reject) {
                                    var storeResult;
                                    var error;
                                    self.getObservableFromLink(mutation, __assign(__assign({}, context), { optimisticResponse: optimisticResponse }), variables, false).subscribe({
                                        next: function (result) {
                                            if (graphQLResultHasError(result) && errorPolicy === 'none') {
                                                error = new ApolloError({
                                                    graphQLErrors: result.errors,
                                                });
                                                return;
                                            }
                                            self.mutationStore.markMutationResult(mutationId);
                                            if (fetchPolicy !== 'no-cache') {
                                                self.dataStore.markMutationResult({
                                                    mutationId: mutationId,
                                                    result: result,
                                                    document: mutation,
                                                    variables: variables,
                                                    updateQueries: generateUpdateQueriesInfo(),
                                                    update: updateWithProxyFn,
                                                });
                                            }
                                            storeResult = result;
                                        },
                                        error: function (err) {
                                            self.mutationStore.markMutationError(mutationId, err);
                                            self.dataStore.markMutationComplete({
                                                mutationId: mutationId,
                                                optimisticResponse: optimisticResponse,
                                            });
                                            self.broadcastQueries();
                                            self.setQuery(mutationId, function () { return ({ document: null }); });
                                            reject(new ApolloError({
                                                networkError: err,
                                            }));
                                        },
                                        complete: function () {
                                            if (error) {
                                                self.mutationStore.markMutationError(mutationId, error);
                                            }
                                            self.dataStore.markMutationComplete({
                                                mutationId: mutationId,
                                                optimisticResponse: optimisticResponse,
                                            });
                                            self.broadcastQueries();
                                            if (error) {
                                                reject(error);
                                                return;
                                            }
                                            if (typeof refetchQueries === 'function') {
                                                refetchQueries = refetchQueries(storeResult);
                                            }
                                            var refetchQueryPromises = [];
                                            if (isNonEmptyArray(refetchQueries)) {
                                                refetchQueries.forEach(function (refetchQuery) {
                                                    if (typeof refetchQuery === 'string') {
                                                        self.queries.forEach(function (_a) {
                                                            var observableQuery = _a.observableQuery;
                                                            if (observableQuery &&
                                                                observableQuery.queryName === refetchQuery) {
                                                                refetchQueryPromises.push(observableQuery.refetch());
                                                            }
                                                        });
                                                    }
                                                    else {
                                                        var queryOptions = {
                                                            query: refetchQuery.query,
                                                            variables: refetchQuery.variables,
                                                            fetchPolicy: 'network-only',
                                                        };
                                                        if (refetchQuery.context) {
                                                            queryOptions.context = refetchQuery.context;
                                                        }
                                                        refetchQueryPromises.push(self.query(queryOptions));
                                                    }
                                                });
                                            }
                                            Promise.all(awaitRefetchQueries ? refetchQueryPromises : []).then(function () {
                                                self.setQuery(mutationId, function () { return ({ document: null }); });
                                                if (errorPolicy === 'ignore' &&
                                                    storeResult &&
                                                    graphQLResultHasError(storeResult)) {
                                                    delete storeResult.errors;
                                                }
                                                resolve(storeResult);
                                            });
                                        },
                                    });
                                })];
                    }
                });
            });
        };
        QueryManager.prototype.fetchQuery = function (queryId, options, fetchType, fetchMoreForQueryId) {
            return __awaiter(this, void 0, void 0, function () {
                var _a, metadata, _b, fetchPolicy, _c, context, query, variables, storeResult, isNetworkOnly, needToFetch, _d, complete, result, shouldFetch, requestId, cancel, networkResult;
                var _this = this;
                return __generator(this, function (_e) {
                    switch (_e.label) {
                        case 0:
                            _a = options.metadata, metadata = _a === void 0 ? null : _a, _b = options.fetchPolicy, fetchPolicy = _b === void 0 ? 'cache-first' : _b, _c = options.context, context = _c === void 0 ? {} : _c;
                            query = this.transform(options.query).document;
                            variables = this.getVariables(query, options.variables);
                            if (!this.transform(query).hasClientExports) return [3, 2];
                            return [4, this.localState.addExportedVariables(query, variables, context)];
                        case 1:
                            variables = _e.sent();
                            _e.label = 2;
                        case 2:
                            options = __assign(__assign({}, options), { variables: variables });
                            isNetworkOnly = fetchPolicy === 'network-only' || fetchPolicy === 'no-cache';
                            needToFetch = isNetworkOnly;
                            if (!isNetworkOnly) {
                                _d = this.dataStore.getCache().diff({
                                    query: query,
                                    variables: variables,
                                    returnPartialData: true,
                                    optimistic: false,
                                }), complete = _d.complete, result = _d.result;
                                needToFetch = !complete || fetchPolicy === 'cache-and-network';
                                storeResult = result;
                            }
                            shouldFetch = needToFetch && fetchPolicy !== 'cache-only' && fetchPolicy !== 'standby';
                            if (hasDirectives(['live'], query))
                                shouldFetch = true;
                            requestId = this.idCounter++;
                            cancel = fetchPolicy !== 'no-cache'
                                ? this.updateQueryWatch(queryId, query, options)
                                : undefined;
                            this.setQuery(queryId, function () { return ({
                                document: query,
                                lastRequestId: requestId,
                                invalidated: true,
                                cancel: cancel,
                            }); });
                            this.invalidate(fetchMoreForQueryId);
                            this.queryStore.initQuery({
                                queryId: queryId,
                                document: query,
                                storePreviousVariables: shouldFetch,
                                variables: variables,
                                isPoll: fetchType === FetchType.poll,
                                isRefetch: fetchType === FetchType.refetch,
                                metadata: metadata,
                                fetchMoreForQueryId: fetchMoreForQueryId,
                            });
                            this.broadcastQueries();
                            if (shouldFetch) {
                                networkResult = this.fetchRequest({
                                    requestId: requestId,
                                    queryId: queryId,
                                    document: query,
                                    options: options,
                                    fetchMoreForQueryId: fetchMoreForQueryId,
                                }).catch(function (error) {
                                    if (isApolloError(error)) {
                                        throw error;
                                    }
                                    else {
                                        if (requestId >= _this.getQuery(queryId).lastRequestId) {
                                            _this.queryStore.markQueryError(queryId, error, fetchMoreForQueryId);
                                            _this.invalidate(queryId);
                                            _this.invalidate(fetchMoreForQueryId);
                                            _this.broadcastQueries();
                                        }
                                        throw new ApolloError({ networkError: error });
                                    }
                                });
                                if (fetchPolicy !== 'cache-and-network') {
                                    return [2, networkResult];
                                }
                                networkResult.catch(function () { });
                            }
                            this.queryStore.markQueryResultClient(queryId, !shouldFetch);
                            this.invalidate(queryId);
                            this.invalidate(fetchMoreForQueryId);
                            if (this.transform(query).hasForcedResolvers) {
                                return [2, this.localState.runResolvers({
                                        document: query,
                                        remoteResult: { data: storeResult },
                                        context: context,
                                        variables: variables,
                                        onlyRunForcedResolvers: true,
                                    }).then(function (result) {
                                        _this.markQueryResult(queryId, result, options, fetchMoreForQueryId);
                                        _this.broadcastQueries();
                                        return result;
                                    })];
                            }
                            this.broadcastQueries();
                            return [2, { data: storeResult }];
                    }
                });
            });
        };
        QueryManager.prototype.markQueryResult = function (queryId, result, _a, fetchMoreForQueryId) {
            var fetchPolicy = _a.fetchPolicy, variables = _a.variables, errorPolicy = _a.errorPolicy;
            if (fetchPolicy === 'no-cache') {
                this.setQuery(queryId, function () { return ({
                    newData: { result: result.data, complete: true },
                }); });
            }
            else {
                this.dataStore.markQueryResult(result, this.getQuery(queryId).document, variables, fetchMoreForQueryId, errorPolicy === 'ignore' || errorPolicy === 'all');
            }
        };
        QueryManager.prototype.queryListenerForObserver = function (queryId, options, observer) {
            var _this = this;
            function invoke(method, argument) {
                if (observer[method]) {
                    try {
                        observer[method](argument);
                    }
                    catch (e) {
                        process.env.NODE_ENV === "production" || invariant.error(e);
                    }
                }
                else if (method === 'error') {
                    process.env.NODE_ENV === "production" || invariant.error(argument);
                }
            }
            return function (queryStoreValue, newData) {
                _this.invalidate(queryId, false);
                if (!queryStoreValue)
                    return;
                var _a = _this.getQuery(queryId), observableQuery = _a.observableQuery, document = _a.document;
                var fetchPolicy = observableQuery
                    ? observableQuery.options.fetchPolicy
                    : options.fetchPolicy;
                if (fetchPolicy === 'standby')
                    return;
                var loading = isNetworkRequestInFlight(queryStoreValue.networkStatus);
                var lastResult = observableQuery && observableQuery.getLastResult();
                var networkStatusChanged = !!(lastResult &&
                    lastResult.networkStatus !== queryStoreValue.networkStatus);
                var shouldNotifyIfLoading = options.returnPartialData ||
                    (!newData && queryStoreValue.previousVariables) ||
                    (networkStatusChanged && options.notifyOnNetworkStatusChange) ||
                    fetchPolicy === 'cache-only' ||
                    fetchPolicy === 'cache-and-network';
                if (loading && !shouldNotifyIfLoading) {
                    return;
                }
                var hasGraphQLErrors = isNonEmptyArray(queryStoreValue.graphQLErrors);
                var errorPolicy = observableQuery
                    && observableQuery.options.errorPolicy
                    || options.errorPolicy
                    || 'none';
                if (errorPolicy === 'none' && hasGraphQLErrors || queryStoreValue.networkError) {
                    return invoke('error', new ApolloError({
                        graphQLErrors: queryStoreValue.graphQLErrors,
                        networkError: queryStoreValue.networkError,
                    }));
                }
                try {
                    var data = void 0;
                    var isMissing = void 0;
                    if (newData) {
                        if (fetchPolicy !== 'no-cache' && fetchPolicy !== 'network-only') {
                            _this.setQuery(queryId, function () { return ({ newData: null }); });
                        }
                        data = newData.result;
                        isMissing = !newData.complete;
                    }
                    else {
                        var lastError = observableQuery && observableQuery.getLastError();
                        var errorStatusChanged = errorPolicy !== 'none' &&
                            (lastError && lastError.graphQLErrors) !==
                                queryStoreValue.graphQLErrors;
                        if (lastResult && lastResult.data && !errorStatusChanged) {
                            data = lastResult.data;
                            isMissing = false;
                        }
                        else {
                            var diffResult = _this.dataStore.getCache().diff({
                                query: document,
                                variables: queryStoreValue.previousVariables ||
                                    queryStoreValue.variables,
                                returnPartialData: true,
                                optimistic: true,
                            });
                            data = diffResult.result;
                            isMissing = !diffResult.complete;
                        }
                    }
                    var stale = isMissing && !(options.returnPartialData ||
                        fetchPolicy === 'cache-only');
                    var resultFromStore = {
                        data: stale ? lastResult && lastResult.data : data,
                        loading: loading,
                        networkStatus: queryStoreValue.networkStatus,
                        stale: stale,
                    };
                    if (errorPolicy === 'all' && hasGraphQLErrors) {
                        resultFromStore.errors = queryStoreValue.graphQLErrors;
                    }
                    invoke('next', resultFromStore);
                }
                catch (networkError) {
                    invoke('error', new ApolloError({ networkError: networkError }));
                }
            };
        };
        QueryManager.prototype.transform = function (document) {
            var transformCache = this.transformCache;
            if (!transformCache.has(document)) {
                var cache = this.dataStore.getCache();
                var transformed = cache.transformDocument(document);
                var forLink = removeConnectionDirectiveFromDocument(cache.transformForLink(transformed));
                var clientQuery = this.localState.clientQuery(transformed);
                var serverQuery = this.localState.serverQuery(forLink);
                var cacheEntry_1 = {
                    document: transformed,
                    hasClientExports: hasClientExports(transformed),
                    hasForcedResolvers: this.localState.shouldForceResolvers(transformed),
                    clientQuery: clientQuery,
                    serverQuery: serverQuery,
                    defaultVars: getDefaultValues(getOperationDefinition(transformed)),
                };
                var add = function (doc) {
                    if (doc && !transformCache.has(doc)) {
                        transformCache.set(doc, cacheEntry_1);
                    }
                };
                add(document);
                add(transformed);
                add(clientQuery);
                add(serverQuery);
            }
            return transformCache.get(document);
        };
        QueryManager.prototype.getVariables = function (document, variables) {
            return __assign(__assign({}, this.transform(document).defaultVars), variables);
        };
        QueryManager.prototype.watchQuery = function (options, shouldSubscribe) {
            if (shouldSubscribe === void 0) { shouldSubscribe = true; }
            process.env.NODE_ENV === "production" ? invariant(options.fetchPolicy !== 'standby', 11) : invariant(options.fetchPolicy !== 'standby', 'client.watchQuery cannot be called with fetchPolicy set to "standby"');
            options.variables = this.getVariables(options.query, options.variables);
            if (typeof options.notifyOnNetworkStatusChange === 'undefined') {
                options.notifyOnNetworkStatusChange = false;
            }
            var transformedOptions = __assign({}, options);
            return new ObservableQuery({
                queryManager: this,
                options: transformedOptions,
                shouldSubscribe: shouldSubscribe,
            });
        };
        QueryManager.prototype.query = function (options) {
            var _this = this;
            process.env.NODE_ENV === "production" ? invariant(options.query, 12) : invariant(options.query, 'query option is required. You must specify your GraphQL document ' +
                'in the query option.');
            process.env.NODE_ENV === "production" ? invariant(options.query.kind === 'Document', 13) : invariant(options.query.kind === 'Document', 'You must wrap the query string in a "gql" tag.');
            process.env.NODE_ENV === "production" ? invariant(!options.returnPartialData, 14) : invariant(!options.returnPartialData, 'returnPartialData option only supported on watchQuery.');
            process.env.NODE_ENV === "production" ? invariant(!options.pollInterval, 15) : invariant(!options.pollInterval, 'pollInterval option only supported on watchQuery.');
            return new Promise(function (resolve, reject) {
                var watchedQuery = _this.watchQuery(options, false);
                _this.fetchQueryRejectFns.set("query:" + watchedQuery.queryId, reject);
                watchedQuery
                    .result()
                    .then(resolve, reject)
                    .then(function () {
                    return _this.fetchQueryRejectFns.delete("query:" + watchedQuery.queryId);
                });
            });
        };
        QueryManager.prototype.generateQueryId = function () {
            return String(this.idCounter++);
        };
        QueryManager.prototype.stopQueryInStore = function (queryId) {
            this.stopQueryInStoreNoBroadcast(queryId);
            this.broadcastQueries();
        };
        QueryManager.prototype.stopQueryInStoreNoBroadcast = function (queryId) {
            this.stopPollingQuery(queryId);
            this.queryStore.stopQuery(queryId);
            this.invalidate(queryId);
        };
        QueryManager.prototype.addQueryListener = function (queryId, listener) {
            this.setQuery(queryId, function (_a) {
                var listeners = _a.listeners;
                listeners.add(listener);
                return { invalidated: false };
            });
        };
        QueryManager.prototype.updateQueryWatch = function (queryId, document, options) {
            var _this = this;
            var cancel = this.getQuery(queryId).cancel;
            if (cancel)
                cancel();
            var previousResult = function () {
                var previousResult = null;
                var observableQuery = _this.getQuery(queryId).observableQuery;
                if (observableQuery) {
                    var lastResult = observableQuery.getLastResult();
                    if (lastResult) {
                        previousResult = lastResult.data;
                    }
                }
                return previousResult;
            };
            return this.dataStore.getCache().watch({
                query: document,
                variables: options.variables,
                optimistic: true,
                previousResult: previousResult,
                callback: function (newData) {
                    _this.setQuery(queryId, function () { return ({ invalidated: true, newData: newData }); });
                },
            });
        };
        QueryManager.prototype.addObservableQuery = function (queryId, observableQuery) {
            this.setQuery(queryId, function () { return ({ observableQuery: observableQuery }); });
        };
        QueryManager.prototype.removeObservableQuery = function (queryId) {
            var cancel = this.getQuery(queryId).cancel;
            this.setQuery(queryId, function () { return ({ observableQuery: null }); });
            if (cancel)
                cancel();
        };
        QueryManager.prototype.clearStore = function () {
            this.fetchQueryRejectFns.forEach(function (reject) {
                reject(process.env.NODE_ENV === "production" ? new InvariantError(16) : new InvariantError('Store reset while query was in flight (not completed in link chain)'));
            });
            var resetIds = [];
            this.queries.forEach(function (_a, queryId) {
                var observableQuery = _a.observableQuery;
                if (observableQuery)
                    resetIds.push(queryId);
            });
            this.queryStore.reset(resetIds);
            this.mutationStore.reset();
            return this.dataStore.reset();
        };
        QueryManager.prototype.resetStore = function () {
            var _this = this;
            return this.clearStore().then(function () {
                return _this.reFetchObservableQueries();
            });
        };
        QueryManager.prototype.reFetchObservableQueries = function (includeStandby) {
            var _this = this;
            if (includeStandby === void 0) { includeStandby = false; }
            var observableQueryPromises = [];
            this.queries.forEach(function (_a, queryId) {
                var observableQuery = _a.observableQuery;
                if (observableQuery) {
                    var fetchPolicy = observableQuery.options.fetchPolicy;
                    observableQuery.resetLastResults();
                    if (fetchPolicy !== 'cache-only' &&
                        (includeStandby || fetchPolicy !== 'standby')) {
                        observableQueryPromises.push(observableQuery.refetch());
                    }
                    _this.setQuery(queryId, function () { return ({ newData: null }); });
                    _this.invalidate(queryId);
                }
            });
            this.broadcastQueries();
            return Promise.all(observableQueryPromises);
        };
        QueryManager.prototype.observeQuery = function (queryId, options, observer) {
            this.addQueryListener(queryId, this.queryListenerForObserver(queryId, options, observer));
            return this.fetchQuery(queryId, options);
        };
        QueryManager.prototype.startQuery = function (queryId, options, listener) {
            process.env.NODE_ENV === "production" || invariant.warn("The QueryManager.startQuery method has been deprecated");
            this.addQueryListener(queryId, listener);
            this.fetchQuery(queryId, options)
                .catch(function () { return undefined; });
            return queryId;
        };
        QueryManager.prototype.startGraphQLSubscription = function (_a) {
            var _this = this;
            var query = _a.query, fetchPolicy = _a.fetchPolicy, variables = _a.variables;
            query = this.transform(query).document;
            variables = this.getVariables(query, variables);
            var makeObservable = function (variables) {
                return _this.getObservableFromLink(query, {}, variables, false).map(function (result) {
                    if (!fetchPolicy || fetchPolicy !== 'no-cache') {
                        _this.dataStore.markSubscriptionResult(result, query, variables);
                        _this.broadcastQueries();
                    }
                    if (graphQLResultHasError(result)) {
                        throw new ApolloError({
                            graphQLErrors: result.errors,
                        });
                    }
                    return result;
                });
            };
            if (this.transform(query).hasClientExports) {
                var observablePromise_1 = this.localState.addExportedVariables(query, variables).then(makeObservable);
                return new Observable$1(function (observer) {
                    var sub = null;
                    observablePromise_1.then(function (observable) { return sub = observable.subscribe(observer); }, observer.error);
                    return function () { return sub && sub.unsubscribe(); };
                });
            }
            return makeObservable(variables);
        };
        QueryManager.prototype.stopQuery = function (queryId) {
            this.stopQueryNoBroadcast(queryId);
            this.broadcastQueries();
        };
        QueryManager.prototype.stopQueryNoBroadcast = function (queryId) {
            this.stopQueryInStoreNoBroadcast(queryId);
            this.removeQuery(queryId);
        };
        QueryManager.prototype.removeQuery = function (queryId) {
            this.fetchQueryRejectFns.delete("query:" + queryId);
            this.fetchQueryRejectFns.delete("fetchRequest:" + queryId);
            this.getQuery(queryId).subscriptions.forEach(function (x) { return x.unsubscribe(); });
            this.queries.delete(queryId);
        };
        QueryManager.prototype.getCurrentQueryResult = function (observableQuery, optimistic) {
            if (optimistic === void 0) { optimistic = true; }
            var _a = observableQuery.options, variables = _a.variables, query = _a.query, fetchPolicy = _a.fetchPolicy, returnPartialData = _a.returnPartialData;
            var lastResult = observableQuery.getLastResult();
            var newData = this.getQuery(observableQuery.queryId).newData;
            if (newData && newData.complete) {
                return { data: newData.result, partial: false };
            }
            if (fetchPolicy === 'no-cache' || fetchPolicy === 'network-only') {
                return { data: undefined, partial: false };
            }
            var _b = this.dataStore.getCache().diff({
                query: query,
                variables: variables,
                previousResult: lastResult ? lastResult.data : undefined,
                returnPartialData: true,
                optimistic: optimistic,
            }), result = _b.result, complete = _b.complete;
            return {
                data: (complete || returnPartialData) ? result : void 0,
                partial: !complete,
            };
        };
        QueryManager.prototype.getQueryWithPreviousResult = function (queryIdOrObservable) {
            var observableQuery;
            if (typeof queryIdOrObservable === 'string') {
                var foundObserveableQuery = this.getQuery(queryIdOrObservable).observableQuery;
                process.env.NODE_ENV === "production" ? invariant(foundObserveableQuery, 17) : invariant(foundObserveableQuery, "ObservableQuery with this id doesn't exist: " + queryIdOrObservable);
                observableQuery = foundObserveableQuery;
            }
            else {
                observableQuery = queryIdOrObservable;
            }
            var _a = observableQuery.options, variables = _a.variables, query = _a.query;
            return {
                previousResult: this.getCurrentQueryResult(observableQuery, false).data,
                variables: variables,
                document: query,
            };
        };
        QueryManager.prototype.broadcastQueries = function () {
            var _this = this;
            this.onBroadcast();
            this.queries.forEach(function (info, id) {
                if (info.invalidated) {
                    info.listeners.forEach(function (listener) {
                        if (listener) {
                            listener(_this.queryStore.get(id), info.newData);
                        }
                    });
                }
            });
        };
        QueryManager.prototype.getLocalState = function () {
            return this.localState;
        };
        QueryManager.prototype.getObservableFromLink = function (query, context, variables, deduplication) {
            var _this = this;
            if (deduplication === void 0) { deduplication = this.queryDeduplication; }
            var observable;
            var serverQuery = this.transform(query).serverQuery;
            if (serverQuery) {
                var _a = this, inFlightLinkObservables_1 = _a.inFlightLinkObservables, link = _a.link;
                var operation = {
                    query: serverQuery,
                    variables: variables,
                    operationName: getOperationName(serverQuery) || void 0,
                    context: this.prepareContext(__assign(__assign({}, context), { forceFetch: !deduplication })),
                };
                context = operation.context;
                if (deduplication) {
                    var byVariables_1 = inFlightLinkObservables_1.get(serverQuery) || new Map();
                    inFlightLinkObservables_1.set(serverQuery, byVariables_1);
                    var varJson_1 = JSON.stringify(variables);
                    observable = byVariables_1.get(varJson_1);
                    if (!observable) {
                        byVariables_1.set(varJson_1, observable = multiplex(execute(link, operation)));
                        var cleanup = function () {
                            byVariables_1.delete(varJson_1);
                            if (!byVariables_1.size)
                                inFlightLinkObservables_1.delete(serverQuery);
                            cleanupSub_1.unsubscribe();
                        };
                        var cleanupSub_1 = observable.subscribe({
                            next: cleanup,
                            error: cleanup,
                            complete: cleanup,
                        });
                    }
                }
                else {
                    observable = multiplex(execute(link, operation));
                }
            }
            else {
                observable = Observable$1.of({ data: {} });
                context = this.prepareContext(context);
            }
            var clientQuery = this.transform(query).clientQuery;
            if (clientQuery) {
                observable = asyncMap(observable, function (result) {
                    return _this.localState.runResolvers({
                        document: clientQuery,
                        remoteResult: result,
                        context: context,
                        variables: variables,
                    });
                });
            }
            return observable;
        };
        QueryManager.prototype.fetchRequest = function (_a) {
            var _this = this;
            var requestId = _a.requestId, queryId = _a.queryId, document = _a.document, options = _a.options, fetchMoreForQueryId = _a.fetchMoreForQueryId;
            var variables = options.variables, _b = options.errorPolicy, errorPolicy = _b === void 0 ? 'none' : _b, fetchPolicy = options.fetchPolicy;
            var resultFromStore;
            var errorsFromStore;
            return new Promise(function (resolve, reject) {
                var observable = _this.getObservableFromLink(document, options.context, variables);
                var fqrfId = "fetchRequest:" + queryId;
                _this.fetchQueryRejectFns.set(fqrfId, reject);
                var cleanup = function () {
                    _this.fetchQueryRejectFns.delete(fqrfId);
                    _this.setQuery(queryId, function (_a) {
                        var subscriptions = _a.subscriptions;
                        subscriptions.delete(subscription);
                    });
                };
                var subscription = observable.map(function (result) {
                    if (requestId >= _this.getQuery(queryId).lastRequestId) {
                        _this.markQueryResult(queryId, result, options, fetchMoreForQueryId);
                        _this.queryStore.markQueryResult(queryId, result, fetchMoreForQueryId);
                        _this.invalidate(queryId);
                        _this.invalidate(fetchMoreForQueryId);
                        _this.broadcastQueries();
                    }
                    if (errorPolicy === 'none' && isNonEmptyArray(result.errors)) {
                        return reject(new ApolloError({
                            graphQLErrors: result.errors,
                        }));
                    }
                    if (errorPolicy === 'all') {
                        errorsFromStore = result.errors;
                    }
                    if (fetchMoreForQueryId || fetchPolicy === 'no-cache') {
                        resultFromStore = result.data;
                    }
                    else {
                        var _a = _this.dataStore.getCache().diff({
                            variables: variables,
                            query: document,
                            optimistic: false,
                            returnPartialData: true,
                        }), result_1 = _a.result, complete = _a.complete;
                        if (complete || options.returnPartialData) {
                            resultFromStore = result_1;
                        }
                    }
                }).subscribe({
                    error: function (error) {
                        cleanup();
                        reject(error);
                    },
                    complete: function () {
                        cleanup();
                        resolve({
                            data: resultFromStore,
                            errors: errorsFromStore,
                            loading: false,
                            networkStatus: NetworkStatus.ready,
                            stale: false,
                        });
                    },
                });
                _this.setQuery(queryId, function (_a) {
                    var subscriptions = _a.subscriptions;
                    subscriptions.add(subscription);
                });
            });
        };
        QueryManager.prototype.getQuery = function (queryId) {
            return (this.queries.get(queryId) || {
                listeners: new Set(),
                invalidated: false,
                document: null,
                newData: null,
                lastRequestId: 1,
                observableQuery: null,
                subscriptions: new Set(),
            });
        };
        QueryManager.prototype.setQuery = function (queryId, updater) {
            var prev = this.getQuery(queryId);
            var newInfo = __assign(__assign({}, prev), updater(prev));
            this.queries.set(queryId, newInfo);
        };
        QueryManager.prototype.invalidate = function (queryId, invalidated) {
            if (invalidated === void 0) { invalidated = true; }
            if (queryId) {
                this.setQuery(queryId, function () { return ({ invalidated: invalidated }); });
            }
        };
        QueryManager.prototype.prepareContext = function (context) {
            if (context === void 0) { context = {}; }
            var newContext = this.localState.prepareContext(context);
            return __assign(__assign({}, newContext), { clientAwareness: this.clientAwareness });
        };
        QueryManager.prototype.checkInFlight = function (queryId) {
            var query = this.queryStore.get(queryId);
            return (query &&
                query.networkStatus !== NetworkStatus.ready &&
                query.networkStatus !== NetworkStatus.error);
        };
        QueryManager.prototype.startPollingQuery = function (options, queryId, listener) {
            var _this = this;
            var pollInterval = options.pollInterval;
            process.env.NODE_ENV === "production" ? invariant(pollInterval, 18) : invariant(pollInterval, 'Attempted to start a polling query without a polling interval.');
            if (!this.ssrMode) {
                var info = this.pollingInfoByQueryId.get(queryId);
                if (!info) {
                    this.pollingInfoByQueryId.set(queryId, (info = {}));
                }
                info.interval = pollInterval;
                info.options = __assign(__assign({}, options), { fetchPolicy: 'network-only' });
                var maybeFetch_1 = function () {
                    var info = _this.pollingInfoByQueryId.get(queryId);
                    if (info) {
                        if (_this.checkInFlight(queryId)) {
                            poll_1();
                        }
                        else {
                            _this.fetchQuery(queryId, info.options, FetchType.poll).then(poll_1, poll_1);
                        }
                    }
                };
                var poll_1 = function () {
                    var info = _this.pollingInfoByQueryId.get(queryId);
                    if (info) {
                        clearTimeout(info.timeout);
                        info.timeout = setTimeout(maybeFetch_1, info.interval);
                    }
                };
                if (listener) {
                    this.addQueryListener(queryId, listener);
                }
                poll_1();
            }
            return queryId;
        };
        QueryManager.prototype.stopPollingQuery = function (queryId) {
            this.pollingInfoByQueryId.delete(queryId);
        };
        return QueryManager;
    }());

    var DataStore = (function () {
        function DataStore(initialCache) {
            this.cache = initialCache;
        }
        DataStore.prototype.getCache = function () {
            return this.cache;
        };
        DataStore.prototype.markQueryResult = function (result, document, variables, fetchMoreForQueryId, ignoreErrors) {
            if (ignoreErrors === void 0) { ignoreErrors = false; }
            var writeWithErrors = !graphQLResultHasError(result);
            if (ignoreErrors && graphQLResultHasError(result) && result.data) {
                writeWithErrors = true;
            }
            if (!fetchMoreForQueryId && writeWithErrors) {
                this.cache.write({
                    result: result.data,
                    dataId: 'ROOT_QUERY',
                    query: document,
                    variables: variables,
                });
            }
        };
        DataStore.prototype.markSubscriptionResult = function (result, document, variables) {
            if (!graphQLResultHasError(result)) {
                this.cache.write({
                    result: result.data,
                    dataId: 'ROOT_SUBSCRIPTION',
                    query: document,
                    variables: variables,
                });
            }
        };
        DataStore.prototype.markMutationInit = function (mutation) {
            var _this = this;
            if (mutation.optimisticResponse) {
                var optimistic_1;
                if (typeof mutation.optimisticResponse === 'function') {
                    optimistic_1 = mutation.optimisticResponse(mutation.variables);
                }
                else {
                    optimistic_1 = mutation.optimisticResponse;
                }
                this.cache.recordOptimisticTransaction(function (c) {
                    var orig = _this.cache;
                    _this.cache = c;
                    try {
                        _this.markMutationResult({
                            mutationId: mutation.mutationId,
                            result: { data: optimistic_1 },
                            document: mutation.document,
                            variables: mutation.variables,
                            updateQueries: mutation.updateQueries,
                            update: mutation.update,
                        });
                    }
                    finally {
                        _this.cache = orig;
                    }
                }, mutation.mutationId);
            }
        };
        DataStore.prototype.markMutationResult = function (mutation) {
            var _this = this;
            if (!graphQLResultHasError(mutation.result)) {
                var cacheWrites_1 = [{
                        result: mutation.result.data,
                        dataId: 'ROOT_MUTATION',
                        query: mutation.document,
                        variables: mutation.variables,
                    }];
                var updateQueries_1 = mutation.updateQueries;
                if (updateQueries_1) {
                    Object.keys(updateQueries_1).forEach(function (id) {
                        var _a = updateQueries_1[id], query = _a.query, updater = _a.updater;
                        var _b = _this.cache.diff({
                            query: query.document,
                            variables: query.variables,
                            returnPartialData: true,
                            optimistic: false,
                        }), currentQueryResult = _b.result, complete = _b.complete;
                        if (complete) {
                            var nextQueryResult = tryFunctionOrLogError(function () {
                                return updater(currentQueryResult, {
                                    mutationResult: mutation.result,
                                    queryName: getOperationName(query.document) || undefined,
                                    queryVariables: query.variables,
                                });
                            });
                            if (nextQueryResult) {
                                cacheWrites_1.push({
                                    result: nextQueryResult,
                                    dataId: 'ROOT_QUERY',
                                    query: query.document,
                                    variables: query.variables,
                                });
                            }
                        }
                    });
                }
                this.cache.performTransaction(function (c) {
                    cacheWrites_1.forEach(function (write) { return c.write(write); });
                    var update = mutation.update;
                    if (update) {
                        tryFunctionOrLogError(function () { return update(c, mutation.result); });
                    }
                });
            }
        };
        DataStore.prototype.markMutationComplete = function (_a) {
            var mutationId = _a.mutationId, optimisticResponse = _a.optimisticResponse;
            if (optimisticResponse) {
                this.cache.removeOptimistic(mutationId);
            }
        };
        DataStore.prototype.markUpdateQueryResult = function (document, variables, newResult) {
            this.cache.write({
                result: newResult,
                dataId: 'ROOT_QUERY',
                variables: variables,
                query: document,
            });
        };
        DataStore.prototype.reset = function () {
            return this.cache.reset();
        };
        return DataStore;
    }());

    var version = "2.6.8";

    var hasSuggestedDevtools = false;
    var ApolloClient = (function () {
        function ApolloClient(options) {
            var _this = this;
            this.defaultOptions = {};
            this.resetStoreCallbacks = [];
            this.clearStoreCallbacks = [];
            var cache = options.cache, _a = options.ssrMode, ssrMode = _a === void 0 ? false : _a, _b = options.ssrForceFetchDelay, ssrForceFetchDelay = _b === void 0 ? 0 : _b, connectToDevTools = options.connectToDevTools, _c = options.queryDeduplication, queryDeduplication = _c === void 0 ? true : _c, defaultOptions = options.defaultOptions, _d = options.assumeImmutableResults, assumeImmutableResults = _d === void 0 ? false : _d, resolvers = options.resolvers, typeDefs = options.typeDefs, fragmentMatcher = options.fragmentMatcher, clientAwarenessName = options.name, clientAwarenessVersion = options.version;
            var link = options.link;
            if (!link && resolvers) {
                link = ApolloLink.empty();
            }
            if (!link || !cache) {
                throw process.env.NODE_ENV === "production" ? new InvariantError(1) : new InvariantError("In order to initialize Apollo Client, you must specify 'link' and 'cache' properties in the options object.\n" +
                    "These options are part of the upgrade requirements when migrating from Apollo Client 1.x to Apollo Client 2.x.\n" +
                    "For more information, please visit: https://www.apollographql.com/docs/tutorial/client.html#apollo-client-setup");
            }
            this.link = link;
            this.cache = cache;
            this.store = new DataStore(cache);
            this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;
            this.queryDeduplication = queryDeduplication;
            this.defaultOptions = defaultOptions || {};
            this.typeDefs = typeDefs;
            if (ssrForceFetchDelay) {
                setTimeout(function () { return (_this.disableNetworkFetches = false); }, ssrForceFetchDelay);
            }
            this.watchQuery = this.watchQuery.bind(this);
            this.query = this.query.bind(this);
            this.mutate = this.mutate.bind(this);
            this.resetStore = this.resetStore.bind(this);
            this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);
            var defaultConnectToDevTools = process.env.NODE_ENV !== 'production' &&
                typeof window !== 'undefined' &&
                !window.__APOLLO_CLIENT__;
            if (typeof connectToDevTools === 'undefined'
                ? defaultConnectToDevTools
                : connectToDevTools && typeof window !== 'undefined') {
                window.__APOLLO_CLIENT__ = this;
            }
            if (!hasSuggestedDevtools && process.env.NODE_ENV !== 'production') {
                hasSuggestedDevtools = true;
                if (typeof window !== 'undefined' &&
                    window.document &&
                    window.top === window.self) {
                    if (typeof window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
                        if (window.navigator &&
                            window.navigator.userAgent &&
                            window.navigator.userAgent.indexOf('Chrome') > -1) {
                            console.debug('Download the Apollo DevTools ' +
                                'for a better development experience: ' +
                                'https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm');
                        }
                    }
                }
            }
            this.version = version;
            this.localState = new LocalState({
                cache: cache,
                client: this,
                resolvers: resolvers,
                fragmentMatcher: fragmentMatcher,
            });
            this.queryManager = new QueryManager({
                link: this.link,
                store: this.store,
                queryDeduplication: queryDeduplication,
                ssrMode: ssrMode,
                clientAwareness: {
                    name: clientAwarenessName,
                    version: clientAwarenessVersion,
                },
                localState: this.localState,
                assumeImmutableResults: assumeImmutableResults,
                onBroadcast: function () {
                    if (_this.devToolsHookCb) {
                        _this.devToolsHookCb({
                            action: {},
                            state: {
                                queries: _this.queryManager.queryStore.getStore(),
                                mutations: _this.queryManager.mutationStore.getStore(),
                            },
                            dataWithOptimisticResults: _this.cache.extract(true),
                        });
                    }
                },
            });
        }
        ApolloClient.prototype.stop = function () {
            this.queryManager.stop();
        };
        ApolloClient.prototype.watchQuery = function (options) {
            if (this.defaultOptions.watchQuery) {
                options = __assign(__assign({}, this.defaultOptions.watchQuery), options);
            }
            if (this.disableNetworkFetches &&
                (options.fetchPolicy === 'network-only' ||
                    options.fetchPolicy === 'cache-and-network')) {
                options = __assign(__assign({}, options), { fetchPolicy: 'cache-first' });
            }
            return this.queryManager.watchQuery(options);
        };
        ApolloClient.prototype.query = function (options) {
            if (this.defaultOptions.query) {
                options = __assign(__assign({}, this.defaultOptions.query), options);
            }
            process.env.NODE_ENV === "production" ? invariant(options.fetchPolicy !== 'cache-and-network', 2) : invariant(options.fetchPolicy !== 'cache-and-network', 'The cache-and-network fetchPolicy does not work with client.query, because ' +
                'client.query can only return a single result. Please use client.watchQuery ' +
                'to receive multiple results from the cache and the network, or consider ' +
                'using a different fetchPolicy, such as cache-first or network-only.');
            if (this.disableNetworkFetches && options.fetchPolicy === 'network-only') {
                options = __assign(__assign({}, options), { fetchPolicy: 'cache-first' });
            }
            return this.queryManager.query(options);
        };
        ApolloClient.prototype.mutate = function (options) {
            if (this.defaultOptions.mutate) {
                options = __assign(__assign({}, this.defaultOptions.mutate), options);
            }
            return this.queryManager.mutate(options);
        };
        ApolloClient.prototype.subscribe = function (options) {
            return this.queryManager.startGraphQLSubscription(options);
        };
        ApolloClient.prototype.readQuery = function (options, optimistic) {
            if (optimistic === void 0) { optimistic = false; }
            return this.cache.readQuery(options, optimistic);
        };
        ApolloClient.prototype.readFragment = function (options, optimistic) {
            if (optimistic === void 0) { optimistic = false; }
            return this.cache.readFragment(options, optimistic);
        };
        ApolloClient.prototype.writeQuery = function (options) {
            var result = this.cache.writeQuery(options);
            this.queryManager.broadcastQueries();
            return result;
        };
        ApolloClient.prototype.writeFragment = function (options) {
            var result = this.cache.writeFragment(options);
            this.queryManager.broadcastQueries();
            return result;
        };
        ApolloClient.prototype.writeData = function (options) {
            var result = this.cache.writeData(options);
            this.queryManager.broadcastQueries();
            return result;
        };
        ApolloClient.prototype.__actionHookForDevTools = function (cb) {
            this.devToolsHookCb = cb;
        };
        ApolloClient.prototype.__requestRaw = function (payload) {
            return execute(this.link, payload);
        };
        ApolloClient.prototype.initQueryManager = function () {
            process.env.NODE_ENV === "production" || invariant.warn('Calling the initQueryManager method is no longer necessary, ' +
                'and it will be removed from ApolloClient in version 3.0.');
            return this.queryManager;
        };
        ApolloClient.prototype.resetStore = function () {
            var _this = this;
            return Promise.resolve()
                .then(function () { return _this.queryManager.clearStore(); })
                .then(function () { return Promise.all(_this.resetStoreCallbacks.map(function (fn) { return fn(); })); })
                .then(function () { return _this.reFetchObservableQueries(); });
        };
        ApolloClient.prototype.clearStore = function () {
            var _this = this;
            return Promise.resolve()
                .then(function () { return _this.queryManager.clearStore(); })
                .then(function () { return Promise.all(_this.clearStoreCallbacks.map(function (fn) { return fn(); })); });
        };
        ApolloClient.prototype.onResetStore = function (cb) {
            var _this = this;
            this.resetStoreCallbacks.push(cb);
            return function () {
                _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function (c) { return c !== cb; });
            };
        };
        ApolloClient.prototype.onClearStore = function (cb) {
            var _this = this;
            this.clearStoreCallbacks.push(cb);
            return function () {
                _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function (c) { return c !== cb; });
            };
        };
        ApolloClient.prototype.reFetchObservableQueries = function (includeStandby) {
            return this.queryManager.reFetchObservableQueries(includeStandby);
        };
        ApolloClient.prototype.extract = function (optimistic) {
            return this.cache.extract(optimistic);
        };
        ApolloClient.prototype.restore = function (serializedState) {
            return this.cache.restore(serializedState);
        };
        ApolloClient.prototype.addResolvers = function (resolvers) {
            this.localState.addResolvers(resolvers);
        };
        ApolloClient.prototype.setResolvers = function (resolvers) {
            this.localState.setResolvers(resolvers);
        };
        ApolloClient.prototype.getResolvers = function () {
            return this.localState.getResolvers();
        };
        ApolloClient.prototype.setLocalStateFragmentMatcher = function (fragmentMatcher) {
            this.localState.setFragmentMatcher(fragmentMatcher);
        };
        return ApolloClient;
    }());
    //# sourceMappingURL=bundle.esm.js.map

    function queryFromPojo(obj) {
        var op = {
            kind: 'OperationDefinition',
            operation: 'query',
            name: {
                kind: 'Name',
                value: 'GeneratedClientQuery',
            },
            selectionSet: selectionSetFromObj(obj),
        };
        var out = {
            kind: 'Document',
            definitions: [op],
        };
        return out;
    }
    function fragmentFromPojo(obj, typename) {
        var frag = {
            kind: 'FragmentDefinition',
            typeCondition: {
                kind: 'NamedType',
                name: {
                    kind: 'Name',
                    value: typename || '__FakeType',
                },
            },
            name: {
                kind: 'Name',
                value: 'GeneratedClientQuery',
            },
            selectionSet: selectionSetFromObj(obj),
        };
        var out = {
            kind: 'Document',
            definitions: [frag],
        };
        return out;
    }
    function selectionSetFromObj(obj) {
        if (typeof obj === 'number' ||
            typeof obj === 'boolean' ||
            typeof obj === 'string' ||
            typeof obj === 'undefined' ||
            obj === null) {
            return null;
        }
        if (Array.isArray(obj)) {
            return selectionSetFromObj(obj[0]);
        }
        var selections = [];
        Object.keys(obj).forEach(function (key) {
            var nestedSelSet = selectionSetFromObj(obj[key]);
            var field = {
                kind: 'Field',
                name: {
                    kind: 'Name',
                    value: key,
                },
                selectionSet: nestedSelSet || undefined,
            };
            selections.push(field);
        });
        var selectionSet = {
            kind: 'SelectionSet',
            selections: selections,
        };
        return selectionSet;
    }
    var justTypenameQuery = {
        kind: 'Document',
        definitions: [
            {
                kind: 'OperationDefinition',
                operation: 'query',
                name: null,
                variableDefinitions: null,
                directives: [],
                selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                        {
                            kind: 'Field',
                            alias: null,
                            name: {
                                kind: 'Name',
                                value: '__typename',
                            },
                            arguments: [],
                            directives: [],
                            selectionSet: null,
                        },
                    ],
                },
            },
        ],
    };

    var ApolloCache = (function () {
        function ApolloCache() {
        }
        ApolloCache.prototype.transformDocument = function (document) {
            return document;
        };
        ApolloCache.prototype.transformForLink = function (document) {
            return document;
        };
        ApolloCache.prototype.readQuery = function (options, optimistic) {
            if (optimistic === void 0) { optimistic = false; }
            return this.read({
                query: options.query,
                variables: options.variables,
                optimistic: optimistic,
            });
        };
        ApolloCache.prototype.readFragment = function (options, optimistic) {
            if (optimistic === void 0) { optimistic = false; }
            return this.read({
                query: getFragmentQueryDocument(options.fragment, options.fragmentName),
                variables: options.variables,
                rootId: options.id,
                optimistic: optimistic,
            });
        };
        ApolloCache.prototype.writeQuery = function (options) {
            this.write({
                dataId: 'ROOT_QUERY',
                result: options.data,
                query: options.query,
                variables: options.variables,
            });
        };
        ApolloCache.prototype.writeFragment = function (options) {
            this.write({
                dataId: options.id,
                result: options.data,
                variables: options.variables,
                query: getFragmentQueryDocument(options.fragment, options.fragmentName),
            });
        };
        ApolloCache.prototype.writeData = function (_a) {
            var id = _a.id, data = _a.data;
            if (typeof id !== 'undefined') {
                var typenameResult = null;
                try {
                    typenameResult = this.read({
                        rootId: id,
                        optimistic: false,
                        query: justTypenameQuery,
                    });
                }
                catch (e) {
                }
                var __typename = (typenameResult && typenameResult.__typename) || '__ClientData';
                var dataToWrite = Object.assign({ __typename: __typename }, data);
                this.writeFragment({
                    id: id,
                    fragment: fragmentFromPojo(dataToWrite, __typename),
                    data: dataToWrite,
                });
            }
            else {
                this.writeQuery({ query: queryFromPojo(data), data: data });
            }
        };
        return ApolloCache;
    }());
    //# sourceMappingURL=bundle.esm.js.map

    // This currentContext variable will only be used if the makeSlotClass
    // function is called, which happens only if this is the first copy of the
    // @wry/context package to be imported.
    var currentContext = null;
    // This unique internal object is used to denote the absence of a value
    // for a given Slot, and is never exposed to outside code.
    var MISSING_VALUE = {};
    var idCounter = 1;
    // Although we can't do anything about the cost of duplicated code from
    // accidentally bundling multiple copies of the @wry/context package, we can
    // avoid creating the Slot class more than once using makeSlotClass.
    var makeSlotClass = function () { return /** @class */ (function () {
        function Slot() {
            // If you have a Slot object, you can find out its slot.id, but you cannot
            // guess the slot.id of a Slot you don't have access to, thanks to the
            // randomized suffix.
            this.id = [
                "slot",
                idCounter++,
                Date.now(),
                Math.random().toString(36).slice(2),
            ].join(":");
        }
        Slot.prototype.hasValue = function () {
            for (var context_1 = currentContext; context_1; context_1 = context_1.parent) {
                // We use the Slot object iself as a key to its value, which means the
                // value cannot be obtained without a reference to the Slot object.
                if (this.id in context_1.slots) {
                    var value = context_1.slots[this.id];
                    if (value === MISSING_VALUE)
                        break;
                    if (context_1 !== currentContext) {
                        // Cache the value in currentContext.slots so the next lookup will
                        // be faster. This caching is safe because the tree of contexts and
                        // the values of the slots are logically immutable.
                        currentContext.slots[this.id] = value;
                    }
                    return true;
                }
            }
            if (currentContext) {
                // If a value was not found for this Slot, it's never going to be found
                // no matter how many times we look it up, so we might as well cache
                // the absence of the value, too.
                currentContext.slots[this.id] = MISSING_VALUE;
            }
            return false;
        };
        Slot.prototype.getValue = function () {
            if (this.hasValue()) {
                return currentContext.slots[this.id];
            }
        };
        Slot.prototype.withValue = function (value, callback, 
        // Given the prevalence of arrow functions, specifying arguments is likely
        // to be much more common than specifying `this`, hence this ordering:
        args, thisArg) {
            var _a;
            var slots = (_a = {
                    __proto__: null
                },
                _a[this.id] = value,
                _a);
            var parent = currentContext;
            currentContext = { parent: parent, slots: slots };
            try {
                // Function.prototype.apply allows the arguments array argument to be
                // omitted or undefined, so args! is fine here.
                return callback.apply(thisArg, args);
            }
            finally {
                currentContext = parent;
            }
        };
        // Capture the current context and wrap a callback function so that it
        // reestablishes the captured context when called.
        Slot.bind = function (callback) {
            var context = currentContext;
            return function () {
                var saved = currentContext;
                try {
                    currentContext = context;
                    return callback.apply(this, arguments);
                }
                finally {
                    currentContext = saved;
                }
            };
        };
        // Immediately run a callback function without any captured context.
        Slot.noContext = function (callback, 
        // Given the prevalence of arrow functions, specifying arguments is likely
        // to be much more common than specifying `this`, hence this ordering:
        args, thisArg) {
            if (currentContext) {
                var saved = currentContext;
                try {
                    currentContext = null;
                    // Function.prototype.apply allows the arguments array argument to be
                    // omitted or undefined, so args! is fine here.
                    return callback.apply(thisArg, args);
                }
                finally {
                    currentContext = saved;
                }
            }
            else {
                return callback.apply(thisArg, args);
            }
        };
        return Slot;
    }()); };
    // We store a single global implementation of the Slot class as a permanent
    // non-enumerable symbol property of the Array constructor. This obfuscation
    // does nothing to prevent access to the Slot class, but at least it ensures
    // the implementation (i.e. currentContext) cannot be tampered with, and all
    // copies of the @wry/context package (hopefully just one) will share the
    // same Slot implementation. Since the first copy of the @wry/context package
    // to be imported wins, this technique imposes a very high cost for any
    // future breaking changes to the Slot class.
    var globalKey = "@wry/context:Slot";
    var host = Array;
    var Slot = host[globalKey] || function () {
        var Slot = makeSlotClass();
        try {
            Object.defineProperty(host, globalKey, {
                value: host[globalKey] = Slot,
                enumerable: false,
                writable: false,
                configurable: false,
            });
        }
        finally {
            return Slot;
        }
    }();

    var bind$1 = Slot.bind, noContext = Slot.noContext;
    //# sourceMappingURL=context.esm.js.map

    function defaultDispose() { }
    var Cache = /** @class */ (function () {
        function Cache(max, dispose) {
            if (max === void 0) { max = Infinity; }
            if (dispose === void 0) { dispose = defaultDispose; }
            this.max = max;
            this.dispose = dispose;
            this.map = new Map();
            this.newest = null;
            this.oldest = null;
        }
        Cache.prototype.has = function (key) {
            return this.map.has(key);
        };
        Cache.prototype.get = function (key) {
            var entry = this.getEntry(key);
            return entry && entry.value;
        };
        Cache.prototype.getEntry = function (key) {
            var entry = this.map.get(key);
            if (entry && entry !== this.newest) {
                var older = entry.older, newer = entry.newer;
                if (newer) {
                    newer.older = older;
                }
                if (older) {
                    older.newer = newer;
                }
                entry.older = this.newest;
                entry.older.newer = entry;
                entry.newer = null;
                this.newest = entry;
                if (entry === this.oldest) {
                    this.oldest = newer;
                }
            }
            return entry;
        };
        Cache.prototype.set = function (key, value) {
            var entry = this.getEntry(key);
            if (entry) {
                return entry.value = value;
            }
            entry = {
                key: key,
                value: value,
                newer: null,
                older: this.newest
            };
            if (this.newest) {
                this.newest.newer = entry;
            }
            this.newest = entry;
            this.oldest = this.oldest || entry;
            this.map.set(key, entry);
            return entry.value;
        };
        Cache.prototype.clean = function () {
            while (this.oldest && this.map.size > this.max) {
                this.delete(this.oldest.key);
            }
        };
        Cache.prototype.delete = function (key) {
            var entry = this.map.get(key);
            if (entry) {
                if (entry === this.newest) {
                    this.newest = entry.older;
                }
                if (entry === this.oldest) {
                    this.oldest = entry.newer;
                }
                if (entry.newer) {
                    entry.newer.older = entry.older;
                }
                if (entry.older) {
                    entry.older.newer = entry.newer;
                }
                this.map.delete(key);
                this.dispose(entry.value, key);
                return true;
            }
            return false;
        };
        return Cache;
    }());

    var parentEntrySlot = new Slot();

    var reusableEmptyArray = [];
    var emptySetPool = [];
    var POOL_TARGET_SIZE = 100;
    // Since this package might be used browsers, we should avoid using the
    // Node built-in assert module.
    function assert(condition, optionalMessage) {
        if (!condition) {
            throw new Error(optionalMessage || "assertion failure");
        }
    }
    function valueIs(a, b) {
        var len = a.length;
        return (
        // Unknown values are not equal to each other.
        len > 0 &&
            // Both values must be ordinary (or both exceptional) to be equal.
            len === b.length &&
            // The underlying value or exception must be the same.
            a[len - 1] === b[len - 1]);
    }
    function valueGet(value) {
        switch (value.length) {
            case 0: throw new Error("unknown value");
            case 1: return value[0];
            case 2: throw value[1];
        }
    }
    function valueCopy(value) {
        return value.slice(0);
    }
    var Entry = /** @class */ (function () {
        function Entry(fn, args) {
            this.fn = fn;
            this.args = args;
            this.parents = new Set();
            this.childValues = new Map();
            // When this Entry has children that are dirty, this property becomes
            // a Set containing other Entry objects, borrowed from emptySetPool.
            // When the set becomes empty, it gets recycled back to emptySetPool.
            this.dirtyChildren = null;
            this.dirty = true;
            this.recomputing = false;
            this.value = [];
            ++Entry.count;
        }
        // This is the most important method of the Entry API, because it
        // determines whether the cached this.value can be returned immediately,
        // or must be recomputed. The overall performance of the caching system
        // depends on the truth of the following observations: (1) this.dirty is
        // usually false, (2) this.dirtyChildren is usually null/empty, and thus
        // (3) valueGet(this.value) is usually returned without recomputation.
        Entry.prototype.recompute = function () {
            assert(!this.recomputing, "already recomputing");
            if (!rememberParent(this) && maybeReportOrphan(this)) {
                // The recipient of the entry.reportOrphan callback decided to dispose
                // of this orphan entry by calling entry.dispose(), so we don't need to
                // (and should not) proceed with the recomputation.
                return void 0;
            }
            return mightBeDirty(this)
                ? reallyRecompute(this)
                : valueGet(this.value);
        };
        Entry.prototype.setDirty = function () {
            if (this.dirty)
                return;
            this.dirty = true;
            this.value.length = 0;
            reportDirty(this);
            // We can go ahead and unsubscribe here, since any further dirty
            // notifications we receive will be redundant, and unsubscribing may
            // free up some resources, e.g. file watchers.
            maybeUnsubscribe(this);
        };
        Entry.prototype.dispose = function () {
            var _this = this;
            forgetChildren(this).forEach(maybeReportOrphan);
            maybeUnsubscribe(this);
            // Because this entry has been kicked out of the cache (in index.js),
            // we've lost the ability to find out if/when this entry becomes dirty,
            // whether that happens through a subscription, because of a direct call
            // to entry.setDirty(), or because one of its children becomes dirty.
            // Because of this loss of future information, we have to assume the
            // worst (that this entry might have become dirty very soon), so we must
            // immediately mark this entry's parents as dirty. Normally we could
            // just call entry.setDirty() rather than calling parent.setDirty() for
            // each parent, but that would leave this entry in parent.childValues
            // and parent.dirtyChildren, which would prevent the child from being
            // truly forgotten.
            this.parents.forEach(function (parent) {
                parent.setDirty();
                forgetChild(parent, _this);
            });
        };
        Entry.count = 0;
        return Entry;
    }());
    function rememberParent(child) {
        var parent = parentEntrySlot.getValue();
        if (parent) {
            child.parents.add(parent);
            if (!parent.childValues.has(child)) {
                parent.childValues.set(child, []);
            }
            if (mightBeDirty(child)) {
                reportDirtyChild(parent, child);
            }
            else {
                reportCleanChild(parent, child);
            }
            return parent;
        }
    }
    function reallyRecompute(entry) {
        // Since this recomputation is likely to re-remember some of this
        // entry's children, we forget our children here but do not call
        // maybeReportOrphan until after the recomputation finishes.
        var originalChildren = forgetChildren(entry);
        // Set entry as the parent entry while calling recomputeNewValue(entry).
        parentEntrySlot.withValue(entry, recomputeNewValue, [entry]);
        if (maybeSubscribe(entry)) {
            // If we successfully recomputed entry.value and did not fail to
            // (re)subscribe, then this Entry is no longer explicitly dirty.
            setClean(entry);
        }
        // Now that we've had a chance to re-remember any children that were
        // involved in the recomputation, we can safely report any orphan
        // children that remain.
        originalChildren.forEach(maybeReportOrphan);
        return valueGet(entry.value);
    }
    function recomputeNewValue(entry) {
        entry.recomputing = true;
        // Set entry.value as unknown.
        entry.value.length = 0;
        try {
            // If entry.fn succeeds, entry.value will become a normal Value.
            entry.value[0] = entry.fn.apply(null, entry.args);
        }
        catch (e) {
            // If entry.fn throws, entry.value will become exceptional.
            entry.value[1] = e;
        }
        // Either way, this line is always reached.
        entry.recomputing = false;
    }
    function mightBeDirty(entry) {
        return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);
    }
    function setClean(entry) {
        entry.dirty = false;
        if (mightBeDirty(entry)) {
            // This Entry may still have dirty children, in which case we can't
            // let our parents know we're clean just yet.
            return;
        }
        reportClean(entry);
    }
    function reportDirty(child) {
        child.parents.forEach(function (parent) { return reportDirtyChild(parent, child); });
    }
    function reportClean(child) {
        child.parents.forEach(function (parent) { return reportCleanChild(parent, child); });
    }
    // Let a parent Entry know that one of its children may be dirty.
    function reportDirtyChild(parent, child) {
        // Must have called rememberParent(child) before calling
        // reportDirtyChild(parent, child).
        assert(parent.childValues.has(child));
        assert(mightBeDirty(child));
        if (!parent.dirtyChildren) {
            parent.dirtyChildren = emptySetPool.pop() || new Set;
        }
        else if (parent.dirtyChildren.has(child)) {
            // If we already know this child is dirty, then we must have already
            // informed our own parents that we are dirty, so we can terminate
            // the recursion early.
            return;
        }
        parent.dirtyChildren.add(child);
        reportDirty(parent);
    }
    // Let a parent Entry know that one of its children is no longer dirty.
    function reportCleanChild(parent, child) {
        // Must have called rememberChild(child) before calling
        // reportCleanChild(parent, child).
        assert(parent.childValues.has(child));
        assert(!mightBeDirty(child));
        var childValue = parent.childValues.get(child);
        if (childValue.length === 0) {
            parent.childValues.set(child, valueCopy(child.value));
        }
        else if (!valueIs(childValue, child.value)) {
            parent.setDirty();
        }
        removeDirtyChild(parent, child);
        if (mightBeDirty(parent)) {
            return;
        }
        reportClean(parent);
    }
    function removeDirtyChild(parent, child) {
        var dc = parent.dirtyChildren;
        if (dc) {
            dc.delete(child);
            if (dc.size === 0) {
                if (emptySetPool.length < POOL_TARGET_SIZE) {
                    emptySetPool.push(dc);
                }
                parent.dirtyChildren = null;
            }
        }
    }
    // If the given entry has a reportOrphan method, and no remaining parents,
    // call entry.reportOrphan and return true iff it returns true. The
    // reportOrphan function should return true to indicate entry.dispose()
    // has been called, and the entry has been removed from any other caches
    // (see index.js for the only current example).
    function maybeReportOrphan(entry) {
        return entry.parents.size === 0 &&
            typeof entry.reportOrphan === "function" &&
            entry.reportOrphan() === true;
    }
    // Removes all children from this entry and returns an array of the
    // removed children.
    function forgetChildren(parent) {
        var children = reusableEmptyArray;
        if (parent.childValues.size > 0) {
            children = [];
            parent.childValues.forEach(function (_value, child) {
                forgetChild(parent, child);
                children.push(child);
            });
        }
        // After we forget all our children, this.dirtyChildren must be empty
        // and therefore must have been reset to null.
        assert(parent.dirtyChildren === null);
        return children;
    }
    function forgetChild(parent, child) {
        child.parents.delete(parent);
        parent.childValues.delete(child);
        removeDirtyChild(parent, child);
    }
    function maybeSubscribe(entry) {
        if (typeof entry.subscribe === "function") {
            try {
                maybeUnsubscribe(entry); // Prevent double subscriptions.
                entry.unsubscribe = entry.subscribe.apply(null, entry.args);
            }
            catch (e) {
                // If this Entry has a subscribe function and it threw an exception
                // (or an unsubscribe function it previously returned now throws),
                // return false to indicate that we were not able to subscribe (or
                // unsubscribe), and this Entry should remain dirty.
                entry.setDirty();
                return false;
            }
        }
        // Returning true indicates either that there was no entry.subscribe
        // function or that it succeeded.
        return true;
    }
    function maybeUnsubscribe(entry) {
        var unsubscribe = entry.unsubscribe;
        if (typeof unsubscribe === "function") {
            entry.unsubscribe = void 0;
            unsubscribe();
        }
    }

    // A trie data structure that holds object keys weakly, yet can also hold
    // non-object keys, unlike the native `WeakMap`.
    var KeyTrie = /** @class */ (function () {
        function KeyTrie(weakness) {
            this.weakness = weakness;
        }
        KeyTrie.prototype.lookup = function () {
            var array = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                array[_i] = arguments[_i];
            }
            return this.lookupArray(array);
        };
        KeyTrie.prototype.lookupArray = function (array) {
            var node = this;
            array.forEach(function (key) { return node = node.getChildTrie(key); });
            return node.data || (node.data = Object.create(null));
        };
        KeyTrie.prototype.getChildTrie = function (key) {
            var map = this.weakness && isObjRef(key)
                ? this.weak || (this.weak = new WeakMap())
                : this.strong || (this.strong = new Map());
            var child = map.get(key);
            if (!child)
                map.set(key, child = new KeyTrie(this.weakness));
            return child;
        };
        return KeyTrie;
    }());
    function isObjRef(value) {
        switch (typeof value) {
            case "object":
                if (value === null)
                    break;
            // Fall through to return true...
            case "function":
                return true;
        }
        return false;
    }

    // The defaultMakeCacheKey function is remarkably powerful, because it gives
    // a unique object for any shallow-identical list of arguments. If you need
    // to implement a custom makeCacheKey function, you may find it helpful to
    // delegate the final work to defaultMakeCacheKey, which is why we export it
    // here. However, you may want to avoid defaultMakeCacheKey if your runtime
    // does not support WeakMap, or you have the ability to return a string key.
    // In those cases, just write your own custom makeCacheKey functions.
    var keyTrie = new KeyTrie(typeof WeakMap === "function");
    function defaultMakeCacheKey() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return keyTrie.lookupArray(args);
    }
    var caches = new Set();
    function wrap(originalFunction, options) {
        if (options === void 0) { options = Object.create(null); }
        var cache = new Cache(options.max || Math.pow(2, 16), function (entry) { return entry.dispose(); });
        var disposable = !!options.disposable;
        var makeCacheKey = options.makeCacheKey || defaultMakeCacheKey;
        function optimistic() {
            if (disposable && !parentEntrySlot.hasValue()) {
                // If there's no current parent computation, and this wrapped
                // function is disposable (meaning we don't care about entry.value,
                // just dependency tracking), then we can short-cut everything else
                // in this function, because entry.recompute() is going to recycle
                // the entry object without recomputing anything, anyway.
                return void 0;
            }
            var key = makeCacheKey.apply(null, arguments);
            if (key === void 0) {
                return originalFunction.apply(null, arguments);
            }
            var args = Array.prototype.slice.call(arguments);
            var entry = cache.get(key);
            if (entry) {
                entry.args = args;
            }
            else {
                entry = new Entry(originalFunction, args);
                cache.set(key, entry);
                entry.subscribe = options.subscribe;
                if (disposable) {
                    entry.reportOrphan = function () { return cache.delete(key); };
                }
            }
            var value = entry.recompute();
            // Move this entry to the front of the least-recently used queue,
            // since we just finished computing its value.
            cache.set(key, entry);
            caches.add(cache);
            // Clean up any excess entries in the cache, but only if there is no
            // active parent entry, meaning we're not in the middle of a larger
            // computation that might be flummoxed by the cleaning.
            if (!parentEntrySlot.hasValue()) {
                caches.forEach(function (cache) { return cache.clean(); });
                caches.clear();
            }
            // If options.disposable is truthy, the caller of wrap is telling us
            // they don't care about the result of entry.recompute(), so we should
            // avoid returning the value, so it won't be accidentally used.
            return disposable ? void 0 : value;
        }
        optimistic.dirty = function () {
            var key = makeCacheKey.apply(null, arguments);
            var child = key !== void 0 && cache.get(key);
            if (child) {
                child.setDirty();
            }
        };
        return optimistic;
    }
    //# sourceMappingURL=bundle.esm.js.map

    var haveWarned = false;
    function shouldWarn() {
        var answer = !haveWarned;
        if (!isTest()) {
            haveWarned = true;
        }
        return answer;
    }
    var HeuristicFragmentMatcher = (function () {
        function HeuristicFragmentMatcher() {
        }
        HeuristicFragmentMatcher.prototype.ensureReady = function () {
            return Promise.resolve();
        };
        HeuristicFragmentMatcher.prototype.canBypassInit = function () {
            return true;
        };
        HeuristicFragmentMatcher.prototype.match = function (idValue, typeCondition, context) {
            var obj = context.store.get(idValue.id);
            var isRootQuery = idValue.id === 'ROOT_QUERY';
            if (!obj) {
                return isRootQuery;
            }
            var _a = obj.__typename, __typename = _a === void 0 ? isRootQuery && 'Query' : _a;
            if (!__typename) {
                if (shouldWarn()) {
                    process.env.NODE_ENV === "production" || invariant.warn("You're using fragments in your queries, but either don't have the addTypename:\n  true option set in Apollo Client, or you are trying to write a fragment to the store without the __typename.\n   Please turn on the addTypename option and include __typename when writing fragments so that Apollo Client\n   can accurately match fragments.");
                    process.env.NODE_ENV === "production" || invariant.warn('Could not find __typename on Fragment ', typeCondition, obj);
                    process.env.NODE_ENV === "production" || invariant.warn("DEPRECATION WARNING: using fragments without __typename is unsupported behavior " +
                        "and will be removed in future versions of Apollo client. You should fix this and set addTypename to true now.");
                }
                return 'heuristic';
            }
            if (__typename === typeCondition) {
                return true;
            }
            if (shouldWarn()) {
                process.env.NODE_ENV === "production" || invariant.error('You are using the simple (heuristic) fragment matcher, but your ' +
                    'queries contain union or interface types. Apollo Client will not be ' +
                    'able to accurately map fragments. To make this error go away, use ' +
                    'the `IntrospectionFragmentMatcher` as described in the docs: ' +
                    'https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher');
            }
            return 'heuristic';
        };
        return HeuristicFragmentMatcher;
    }());

    var hasOwn = Object.prototype.hasOwnProperty;
    var DepTrackingCache = (function () {
        function DepTrackingCache(data) {
            var _this = this;
            if (data === void 0) { data = Object.create(null); }
            this.data = data;
            this.depend = wrap(function (dataId) { return _this.data[dataId]; }, {
                disposable: true,
                makeCacheKey: function (dataId) {
                    return dataId;
                },
            });
        }
        DepTrackingCache.prototype.toObject = function () {
            return this.data;
        };
        DepTrackingCache.prototype.get = function (dataId) {
            this.depend(dataId);
            return this.data[dataId];
        };
        DepTrackingCache.prototype.set = function (dataId, value) {
            var oldValue = this.data[dataId];
            if (value !== oldValue) {
                this.data[dataId] = value;
                this.depend.dirty(dataId);
            }
        };
        DepTrackingCache.prototype.delete = function (dataId) {
            if (hasOwn.call(this.data, dataId)) {
                delete this.data[dataId];
                this.depend.dirty(dataId);
            }
        };
        DepTrackingCache.prototype.clear = function () {
            this.replace(null);
        };
        DepTrackingCache.prototype.replace = function (newData) {
            var _this = this;
            if (newData) {
                Object.keys(newData).forEach(function (dataId) {
                    _this.set(dataId, newData[dataId]);
                });
                Object.keys(this.data).forEach(function (dataId) {
                    if (!hasOwn.call(newData, dataId)) {
                        _this.delete(dataId);
                    }
                });
            }
            else {
                Object.keys(this.data).forEach(function (dataId) {
                    _this.delete(dataId);
                });
            }
        };
        return DepTrackingCache;
    }());
    function defaultNormalizedCacheFactory(seed) {
        return new DepTrackingCache(seed);
    }

    var StoreReader = (function () {
        function StoreReader(_a) {
            var _this = this;
            var _b = _a === void 0 ? {} : _a, _c = _b.cacheKeyRoot, cacheKeyRoot = _c === void 0 ? new KeyTrie(canUseWeakMap) : _c, _d = _b.freezeResults, freezeResults = _d === void 0 ? false : _d;
            var _e = this, executeStoreQuery = _e.executeStoreQuery, executeSelectionSet = _e.executeSelectionSet, executeSubSelectedArray = _e.executeSubSelectedArray;
            this.freezeResults = freezeResults;
            this.executeStoreQuery = wrap(function (options) {
                return executeStoreQuery.call(_this, options);
            }, {
                makeCacheKey: function (_a) {
                    var query = _a.query, rootValue = _a.rootValue, contextValue = _a.contextValue, variableValues = _a.variableValues, fragmentMatcher = _a.fragmentMatcher;
                    if (contextValue.store instanceof DepTrackingCache) {
                        return cacheKeyRoot.lookup(contextValue.store, query, fragmentMatcher, JSON.stringify(variableValues), rootValue.id);
                    }
                }
            });
            this.executeSelectionSet = wrap(function (options) {
                return executeSelectionSet.call(_this, options);
            }, {
                makeCacheKey: function (_a) {
                    var selectionSet = _a.selectionSet, rootValue = _a.rootValue, execContext = _a.execContext;
                    if (execContext.contextValue.store instanceof DepTrackingCache) {
                        return cacheKeyRoot.lookup(execContext.contextValue.store, selectionSet, execContext.fragmentMatcher, JSON.stringify(execContext.variableValues), rootValue.id);
                    }
                }
            });
            this.executeSubSelectedArray = wrap(function (options) {
                return executeSubSelectedArray.call(_this, options);
            }, {
                makeCacheKey: function (_a) {
                    var field = _a.field, array = _a.array, execContext = _a.execContext;
                    if (execContext.contextValue.store instanceof DepTrackingCache) {
                        return cacheKeyRoot.lookup(execContext.contextValue.store, field, array, JSON.stringify(execContext.variableValues));
                    }
                }
            });
        }
        StoreReader.prototype.readQueryFromStore = function (options) {
            return this.diffQueryAgainstStore(__assign(__assign({}, options), { returnPartialData: false })).result;
        };
        StoreReader.prototype.diffQueryAgainstStore = function (_a) {
            var store = _a.store, query = _a.query, variables = _a.variables, previousResult = _a.previousResult, _b = _a.returnPartialData, returnPartialData = _b === void 0 ? true : _b, _c = _a.rootId, rootId = _c === void 0 ? 'ROOT_QUERY' : _c, fragmentMatcherFunction = _a.fragmentMatcherFunction, config = _a.config;
            var queryDefinition = getQueryDefinition(query);
            variables = assign$1({}, getDefaultValues(queryDefinition), variables);
            var context = {
                store: store,
                dataIdFromObject: config && config.dataIdFromObject,
                cacheRedirects: (config && config.cacheRedirects) || {},
            };
            var execResult = this.executeStoreQuery({
                query: query,
                rootValue: {
                    type: 'id',
                    id: rootId,
                    generated: true,
                    typename: 'Query',
                },
                contextValue: context,
                variableValues: variables,
                fragmentMatcher: fragmentMatcherFunction,
            });
            var hasMissingFields = execResult.missing && execResult.missing.length > 0;
            if (hasMissingFields && !returnPartialData) {
                execResult.missing.forEach(function (info) {
                    if (info.tolerable)
                        return;
                    throw process.env.NODE_ENV === "production" ? new InvariantError(8) : new InvariantError("Can't find field " + info.fieldName + " on object " + JSON.stringify(info.object, null, 2) + ".");
                });
            }
            if (previousResult) {
                if (equal(previousResult, execResult.result)) {
                    execResult.result = previousResult;
                }
            }
            return {
                result: execResult.result,
                complete: !hasMissingFields,
            };
        };
        StoreReader.prototype.executeStoreQuery = function (_a) {
            var query = _a.query, rootValue = _a.rootValue, contextValue = _a.contextValue, variableValues = _a.variableValues, _b = _a.fragmentMatcher, fragmentMatcher = _b === void 0 ? defaultFragmentMatcher : _b;
            var mainDefinition = getMainDefinition(query);
            var fragments = getFragmentDefinitions(query);
            var fragmentMap = createFragmentMap(fragments);
            var execContext = {
                query: query,
                fragmentMap: fragmentMap,
                contextValue: contextValue,
                variableValues: variableValues,
                fragmentMatcher: fragmentMatcher,
            };
            return this.executeSelectionSet({
                selectionSet: mainDefinition.selectionSet,
                rootValue: rootValue,
                execContext: execContext,
            });
        };
        StoreReader.prototype.executeSelectionSet = function (_a) {
            var _this = this;
            var selectionSet = _a.selectionSet, rootValue = _a.rootValue, execContext = _a.execContext;
            var fragmentMap = execContext.fragmentMap, contextValue = execContext.contextValue, variables = execContext.variableValues;
            var finalResult = { result: null };
            var objectsToMerge = [];
            var object = contextValue.store.get(rootValue.id);
            var typename = (object && object.__typename) ||
                (rootValue.id === 'ROOT_QUERY' && 'Query') ||
                void 0;
            function handleMissing(result) {
                var _a;
                if (result.missing) {
                    finalResult.missing = finalResult.missing || [];
                    (_a = finalResult.missing).push.apply(_a, result.missing);
                }
                return result.result;
            }
            selectionSet.selections.forEach(function (selection) {
                var _a;
                if (!shouldInclude(selection, variables)) {
                    return;
                }
                if (isField(selection)) {
                    var fieldResult = handleMissing(_this.executeField(object, typename, selection, execContext));
                    if (typeof fieldResult !== 'undefined') {
                        objectsToMerge.push((_a = {},
                            _a[resultKeyNameFromField(selection)] = fieldResult,
                            _a));
                    }
                }
                else {
                    var fragment = void 0;
                    if (isInlineFragment(selection)) {
                        fragment = selection;
                    }
                    else {
                        fragment = fragmentMap[selection.name.value];
                        if (!fragment) {
                            throw process.env.NODE_ENV === "production" ? new InvariantError(9) : new InvariantError("No fragment named " + selection.name.value);
                        }
                    }
                    var typeCondition = fragment.typeCondition && fragment.typeCondition.name.value;
                    var match = !typeCondition ||
                        execContext.fragmentMatcher(rootValue, typeCondition, contextValue);
                    if (match) {
                        var fragmentExecResult = _this.executeSelectionSet({
                            selectionSet: fragment.selectionSet,
                            rootValue: rootValue,
                            execContext: execContext,
                        });
                        if (match === 'heuristic' && fragmentExecResult.missing) {
                            fragmentExecResult = __assign(__assign({}, fragmentExecResult), { missing: fragmentExecResult.missing.map(function (info) {
                                    return __assign(__assign({}, info), { tolerable: true });
                                }) });
                        }
                        objectsToMerge.push(handleMissing(fragmentExecResult));
                    }
                }
            });
            finalResult.result = mergeDeepArray(objectsToMerge);
            if (this.freezeResults && process.env.NODE_ENV !== 'production') {
                Object.freeze(finalResult.result);
            }
            return finalResult;
        };
        StoreReader.prototype.executeField = function (object, typename, field, execContext) {
            var variables = execContext.variableValues, contextValue = execContext.contextValue;
            var fieldName = field.name.value;
            var args = argumentsObjectFromField(field, variables);
            var info = {
                resultKey: resultKeyNameFromField(field),
                directives: getDirectiveInfoFromField(field, variables),
            };
            var readStoreResult = readStoreResolver(object, typename, fieldName, args, contextValue, info);
            if (Array.isArray(readStoreResult.result)) {
                return this.combineExecResults(readStoreResult, this.executeSubSelectedArray({
                    field: field,
                    array: readStoreResult.result,
                    execContext: execContext,
                }));
            }
            if (!field.selectionSet) {
                assertSelectionSetForIdValue(field, readStoreResult.result);
                if (this.freezeResults && process.env.NODE_ENV !== 'production') {
                    maybeDeepFreeze(readStoreResult);
                }
                return readStoreResult;
            }
            if (readStoreResult.result == null) {
                return readStoreResult;
            }
            return this.combineExecResults(readStoreResult, this.executeSelectionSet({
                selectionSet: field.selectionSet,
                rootValue: readStoreResult.result,
                execContext: execContext,
            }));
        };
        StoreReader.prototype.combineExecResults = function () {
            var execResults = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                execResults[_i] = arguments[_i];
            }
            var missing;
            execResults.forEach(function (execResult) {
                if (execResult.missing) {
                    missing = missing || [];
                    missing.push.apply(missing, execResult.missing);
                }
            });
            return {
                result: execResults.pop().result,
                missing: missing,
            };
        };
        StoreReader.prototype.executeSubSelectedArray = function (_a) {
            var _this = this;
            var field = _a.field, array = _a.array, execContext = _a.execContext;
            var missing;
            function handleMissing(childResult) {
                if (childResult.missing) {
                    missing = missing || [];
                    missing.push.apply(missing, childResult.missing);
                }
                return childResult.result;
            }
            array = array.map(function (item) {
                if (item === null) {
                    return null;
                }
                if (Array.isArray(item)) {
                    return handleMissing(_this.executeSubSelectedArray({
                        field: field,
                        array: item,
                        execContext: execContext,
                    }));
                }
                if (field.selectionSet) {
                    return handleMissing(_this.executeSelectionSet({
                        selectionSet: field.selectionSet,
                        rootValue: item,
                        execContext: execContext,
                    }));
                }
                assertSelectionSetForIdValue(field, item);
                return item;
            });
            if (this.freezeResults && process.env.NODE_ENV !== 'production') {
                Object.freeze(array);
            }
            return { result: array, missing: missing };
        };
        return StoreReader;
    }());
    function assertSelectionSetForIdValue(field, value) {
        if (!field.selectionSet && isIdValue(value)) {
            throw process.env.NODE_ENV === "production" ? new InvariantError(10) : new InvariantError("Missing selection set for object of type " + value.typename + " returned for query field " + field.name.value);
        }
    }
    function defaultFragmentMatcher() {
        return true;
    }
    function readStoreResolver(object, typename, fieldName, args, context, _a) {
        var resultKey = _a.resultKey, directives = _a.directives;
        var storeKeyName = fieldName;
        if (args || directives) {
            storeKeyName = getStoreKeyName(storeKeyName, args, directives);
        }
        var fieldValue = void 0;
        if (object) {
            fieldValue = object[storeKeyName];
            if (typeof fieldValue === 'undefined' &&
                context.cacheRedirects &&
                typeof typename === 'string') {
                var type = context.cacheRedirects[typename];
                if (type) {
                    var resolver = type[fieldName];
                    if (resolver) {
                        fieldValue = resolver(object, args, {
                            getCacheKey: function (storeObj) {
                                var id = context.dataIdFromObject(storeObj);
                                return id && toIdValue({
                                    id: id,
                                    typename: storeObj.__typename,
                                });
                            },
                        });
                    }
                }
            }
        }
        if (typeof fieldValue === 'undefined') {
            return {
                result: fieldValue,
                missing: [{
                        object: object,
                        fieldName: storeKeyName,
                        tolerable: false,
                    }],
            };
        }
        if (isJsonValue(fieldValue)) {
            fieldValue = fieldValue.json;
        }
        return {
            result: fieldValue,
        };
    }

    var ObjectCache = (function () {
        function ObjectCache(data) {
            if (data === void 0) { data = Object.create(null); }
            this.data = data;
        }
        ObjectCache.prototype.toObject = function () {
            return this.data;
        };
        ObjectCache.prototype.get = function (dataId) {
            return this.data[dataId];
        };
        ObjectCache.prototype.set = function (dataId, value) {
            this.data[dataId] = value;
        };
        ObjectCache.prototype.delete = function (dataId) {
            this.data[dataId] = void 0;
        };
        ObjectCache.prototype.clear = function () {
            this.data = Object.create(null);
        };
        ObjectCache.prototype.replace = function (newData) {
            this.data = newData || Object.create(null);
        };
        return ObjectCache;
    }());

    var WriteError = (function (_super) {
        __extends(WriteError, _super);
        function WriteError() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'WriteError';
            return _this;
        }
        return WriteError;
    }(Error));
    function enhanceErrorWithDocument(error, document) {
        var enhancedError = new WriteError("Error writing result to store for query:\n " + JSON.stringify(document));
        enhancedError.message += '\n' + error.message;
        enhancedError.stack = error.stack;
        return enhancedError;
    }
    var StoreWriter = (function () {
        function StoreWriter() {
        }
        StoreWriter.prototype.writeQueryToStore = function (_a) {
            var query = _a.query, result = _a.result, _b = _a.store, store = _b === void 0 ? defaultNormalizedCacheFactory() : _b, variables = _a.variables, dataIdFromObject = _a.dataIdFromObject, fragmentMatcherFunction = _a.fragmentMatcherFunction;
            return this.writeResultToStore({
                dataId: 'ROOT_QUERY',
                result: result,
                document: query,
                store: store,
                variables: variables,
                dataIdFromObject: dataIdFromObject,
                fragmentMatcherFunction: fragmentMatcherFunction,
            });
        };
        StoreWriter.prototype.writeResultToStore = function (_a) {
            var dataId = _a.dataId, result = _a.result, document = _a.document, _b = _a.store, store = _b === void 0 ? defaultNormalizedCacheFactory() : _b, variables = _a.variables, dataIdFromObject = _a.dataIdFromObject, fragmentMatcherFunction = _a.fragmentMatcherFunction;
            var operationDefinition = getOperationDefinition(document);
            try {
                return this.writeSelectionSetToStore({
                    result: result,
                    dataId: dataId,
                    selectionSet: operationDefinition.selectionSet,
                    context: {
                        store: store,
                        processedData: {},
                        variables: assign$1({}, getDefaultValues(operationDefinition), variables),
                        dataIdFromObject: dataIdFromObject,
                        fragmentMap: createFragmentMap(getFragmentDefinitions(document)),
                        fragmentMatcherFunction: fragmentMatcherFunction,
                    },
                });
            }
            catch (e) {
                throw enhanceErrorWithDocument(e, document);
            }
        };
        StoreWriter.prototype.writeSelectionSetToStore = function (_a) {
            var _this = this;
            var result = _a.result, dataId = _a.dataId, selectionSet = _a.selectionSet, context = _a.context;
            var variables = context.variables, store = context.store, fragmentMap = context.fragmentMap;
            selectionSet.selections.forEach(function (selection) {
                var _a;
                if (!shouldInclude(selection, variables)) {
                    return;
                }
                if (isField(selection)) {
                    var resultFieldKey = resultKeyNameFromField(selection);
                    var value = result[resultFieldKey];
                    if (typeof value !== 'undefined') {
                        _this.writeFieldToStore({
                            dataId: dataId,
                            value: value,
                            field: selection,
                            context: context,
                        });
                    }
                    else {
                        var isDefered = false;
                        var isClient = false;
                        if (selection.directives && selection.directives.length) {
                            isDefered = selection.directives.some(function (directive) { return directive.name && directive.name.value === 'defer'; });
                            isClient = selection.directives.some(function (directive) { return directive.name && directive.name.value === 'client'; });
                        }
                        if (!isDefered && !isClient && context.fragmentMatcherFunction) {
                            process.env.NODE_ENV === "production" || invariant.warn("Missing field " + resultFieldKey + " in " + JSON.stringify(result, null, 2).substring(0, 100));
                        }
                    }
                }
                else {
                    var fragment = void 0;
                    if (isInlineFragment(selection)) {
                        fragment = selection;
                    }
                    else {
                        fragment = (fragmentMap || {})[selection.name.value];
                        process.env.NODE_ENV === "production" ? invariant(fragment, 4) : invariant(fragment, "No fragment named " + selection.name.value + ".");
                    }
                    var matches = true;
                    if (context.fragmentMatcherFunction && fragment.typeCondition) {
                        var id = dataId || 'self';
                        var idValue = toIdValue({ id: id, typename: undefined });
                        var fakeContext = {
                            store: new ObjectCache((_a = {}, _a[id] = result, _a)),
                            cacheRedirects: {},
                        };
                        var match = context.fragmentMatcherFunction(idValue, fragment.typeCondition.name.value, fakeContext);
                        if (!isProduction() && match === 'heuristic') {
                            process.env.NODE_ENV === "production" || invariant.error('WARNING: heuristic fragment matching going on!');
                        }
                        matches = !!match;
                    }
                    if (matches) {
                        _this.writeSelectionSetToStore({
                            result: result,
                            selectionSet: fragment.selectionSet,
                            dataId: dataId,
                            context: context,
                        });
                    }
                }
            });
            return store;
        };
        StoreWriter.prototype.writeFieldToStore = function (_a) {
            var _b;
            var field = _a.field, value = _a.value, dataId = _a.dataId, context = _a.context;
            var variables = context.variables, dataIdFromObject = context.dataIdFromObject, store = context.store;
            var storeValue;
            var storeObject;
            var storeFieldName = storeKeyNameFromField(field, variables);
            if (!field.selectionSet || value === null) {
                storeValue =
                    value != null && typeof value === 'object'
                        ?
                            { type: 'json', json: value }
                        :
                            value;
            }
            else if (Array.isArray(value)) {
                var generatedId = dataId + "." + storeFieldName;
                storeValue = this.processArrayValue(value, generatedId, field.selectionSet, context);
            }
            else {
                var valueDataId = dataId + "." + storeFieldName;
                var generated = true;
                if (!isGeneratedId(valueDataId)) {
                    valueDataId = '$' + valueDataId;
                }
                if (dataIdFromObject) {
                    var semanticId = dataIdFromObject(value);
                    process.env.NODE_ENV === "production" ? invariant(!semanticId || !isGeneratedId(semanticId), 5) : invariant(!semanticId || !isGeneratedId(semanticId), 'IDs returned by dataIdFromObject cannot begin with the "$" character.');
                    if (semanticId ||
                        (typeof semanticId === 'number' && semanticId === 0)) {
                        valueDataId = semanticId;
                        generated = false;
                    }
                }
                if (!isDataProcessed(valueDataId, field, context.processedData)) {
                    this.writeSelectionSetToStore({
                        dataId: valueDataId,
                        result: value,
                        selectionSet: field.selectionSet,
                        context: context,
                    });
                }
                var typename = value.__typename;
                storeValue = toIdValue({ id: valueDataId, typename: typename }, generated);
                storeObject = store.get(dataId);
                var escapedId = storeObject && storeObject[storeFieldName];
                if (escapedId !== storeValue && isIdValue(escapedId)) {
                    var hadTypename = escapedId.typename !== undefined;
                    var hasTypename = typename !== undefined;
                    var typenameChanged = hadTypename && hasTypename && escapedId.typename !== typename;
                    process.env.NODE_ENV === "production" ? invariant(!generated || escapedId.generated || typenameChanged, 6) : invariant(!generated || escapedId.generated || typenameChanged, "Store error: the application attempted to write an object with no provided id but the store already contains an id of " + escapedId.id + " for this object. The selectionSet that was trying to be written is:\n" + JSON.stringify(field));
                    process.env.NODE_ENV === "production" ? invariant(!hadTypename || hasTypename, 7) : invariant(!hadTypename || hasTypename, "Store error: the application attempted to write an object with no provided typename but the store already contains an object with typename of " + escapedId.typename + " for the object of id " + escapedId.id + ". The selectionSet that was trying to be written is:\n" + JSON.stringify(field));
                    if (escapedId.generated) {
                        if (typenameChanged) {
                            if (!generated) {
                                store.delete(escapedId.id);
                            }
                        }
                        else {
                            mergeWithGenerated(escapedId.id, storeValue.id, store);
                        }
                    }
                }
            }
            storeObject = store.get(dataId);
            if (!storeObject || !equal(storeValue, storeObject[storeFieldName])) {
                store.set(dataId, __assign(__assign({}, storeObject), (_b = {}, _b[storeFieldName] = storeValue, _b)));
            }
        };
        StoreWriter.prototype.processArrayValue = function (value, generatedId, selectionSet, context) {
            var _this = this;
            return value.map(function (item, index) {
                if (item === null) {
                    return null;
                }
                var itemDataId = generatedId + "." + index;
                if (Array.isArray(item)) {
                    return _this.processArrayValue(item, itemDataId, selectionSet, context);
                }
                var generated = true;
                if (context.dataIdFromObject) {
                    var semanticId = context.dataIdFromObject(item);
                    if (semanticId) {
                        itemDataId = semanticId;
                        generated = false;
                    }
                }
                if (!isDataProcessed(itemDataId, selectionSet, context.processedData)) {
                    _this.writeSelectionSetToStore({
                        dataId: itemDataId,
                        result: item,
                        selectionSet: selectionSet,
                        context: context,
                    });
                }
                return toIdValue({ id: itemDataId, typename: item.__typename }, generated);
            });
        };
        return StoreWriter;
    }());
    function isGeneratedId(id) {
        return id[0] === '$';
    }
    function mergeWithGenerated(generatedKey, realKey, cache) {
        if (generatedKey === realKey) {
            return false;
        }
        var generated = cache.get(generatedKey);
        var real = cache.get(realKey);
        var madeChanges = false;
        Object.keys(generated).forEach(function (key) {
            var value = generated[key];
            var realValue = real[key];
            if (isIdValue(value) &&
                isGeneratedId(value.id) &&
                isIdValue(realValue) &&
                !equal(value, realValue) &&
                mergeWithGenerated(value.id, realValue.id, cache)) {
                madeChanges = true;
            }
        });
        cache.delete(generatedKey);
        var newRealValue = __assign(__assign({}, generated), real);
        if (equal(newRealValue, real)) {
            return madeChanges;
        }
        cache.set(realKey, newRealValue);
        return true;
    }
    function isDataProcessed(dataId, field, processedData) {
        if (!processedData) {
            return false;
        }
        if (processedData[dataId]) {
            if (processedData[dataId].indexOf(field) >= 0) {
                return true;
            }
            else {
                processedData[dataId].push(field);
            }
        }
        else {
            processedData[dataId] = [field];
        }
        return false;
    }

    var defaultConfig = {
        fragmentMatcher: new HeuristicFragmentMatcher(),
        dataIdFromObject: defaultDataIdFromObject,
        addTypename: true,
        resultCaching: true,
        freezeResults: false,
    };
    function defaultDataIdFromObject(result) {
        if (result.__typename) {
            if (result.id !== undefined) {
                return result.__typename + ":" + result.id;
            }
            if (result._id !== undefined) {
                return result.__typename + ":" + result._id;
            }
        }
        return null;
    }
    var hasOwn$1 = Object.prototype.hasOwnProperty;
    var OptimisticCacheLayer = (function (_super) {
        __extends(OptimisticCacheLayer, _super);
        function OptimisticCacheLayer(optimisticId, parent, transaction) {
            var _this = _super.call(this, Object.create(null)) || this;
            _this.optimisticId = optimisticId;
            _this.parent = parent;
            _this.transaction = transaction;
            return _this;
        }
        OptimisticCacheLayer.prototype.toObject = function () {
            return __assign(__assign({}, this.parent.toObject()), this.data);
        };
        OptimisticCacheLayer.prototype.get = function (dataId) {
            return hasOwn$1.call(this.data, dataId)
                ? this.data[dataId]
                : this.parent.get(dataId);
        };
        return OptimisticCacheLayer;
    }(ObjectCache));
    var InMemoryCache = (function (_super) {
        __extends(InMemoryCache, _super);
        function InMemoryCache(config) {
            if (config === void 0) { config = {}; }
            var _this = _super.call(this) || this;
            _this.watches = new Set();
            _this.typenameDocumentCache = new Map();
            _this.cacheKeyRoot = new KeyTrie(canUseWeakMap);
            _this.silenceBroadcast = false;
            _this.config = __assign(__assign({}, defaultConfig), config);
            if (_this.config.customResolvers) {
                process.env.NODE_ENV === "production" || invariant.warn('customResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating customResolvers in the next major version.');
                _this.config.cacheRedirects = _this.config.customResolvers;
            }
            if (_this.config.cacheResolvers) {
                process.env.NODE_ENV === "production" || invariant.warn('cacheResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating cacheResolvers in the next major version.');
                _this.config.cacheRedirects = _this.config.cacheResolvers;
            }
            _this.addTypename = !!_this.config.addTypename;
            _this.data = _this.config.resultCaching
                ? new DepTrackingCache()
                : new ObjectCache();
            _this.optimisticData = _this.data;
            _this.storeWriter = new StoreWriter();
            _this.storeReader = new StoreReader({
                cacheKeyRoot: _this.cacheKeyRoot,
                freezeResults: config.freezeResults,
            });
            var cache = _this;
            var maybeBroadcastWatch = cache.maybeBroadcastWatch;
            _this.maybeBroadcastWatch = wrap(function (c) {
                return maybeBroadcastWatch.call(_this, c);
            }, {
                makeCacheKey: function (c) {
                    if (c.optimistic) {
                        return;
                    }
                    if (c.previousResult) {
                        return;
                    }
                    if (cache.data instanceof DepTrackingCache) {
                        return cache.cacheKeyRoot.lookup(c.query, JSON.stringify(c.variables));
                    }
                }
            });
            return _this;
        }
        InMemoryCache.prototype.restore = function (data) {
            if (data)
                this.data.replace(data);
            return this;
        };
        InMemoryCache.prototype.extract = function (optimistic) {
            if (optimistic === void 0) { optimistic = false; }
            return (optimistic ? this.optimisticData : this.data).toObject();
        };
        InMemoryCache.prototype.read = function (options) {
            if (typeof options.rootId === 'string' &&
                typeof this.data.get(options.rootId) === 'undefined') {
                return null;
            }
            var fragmentMatcher = this.config.fragmentMatcher;
            var fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;
            return this.storeReader.readQueryFromStore({
                store: options.optimistic ? this.optimisticData : this.data,
                query: this.transformDocument(options.query),
                variables: options.variables,
                rootId: options.rootId,
                fragmentMatcherFunction: fragmentMatcherFunction,
                previousResult: options.previousResult,
                config: this.config,
            }) || null;
        };
        InMemoryCache.prototype.write = function (write) {
            var fragmentMatcher = this.config.fragmentMatcher;
            var fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;
            this.storeWriter.writeResultToStore({
                dataId: write.dataId,
                result: write.result,
                variables: write.variables,
                document: this.transformDocument(write.query),
                store: this.data,
                dataIdFromObject: this.config.dataIdFromObject,
                fragmentMatcherFunction: fragmentMatcherFunction,
            });
            this.broadcastWatches();
        };
        InMemoryCache.prototype.diff = function (query) {
            var fragmentMatcher = this.config.fragmentMatcher;
            var fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;
            return this.storeReader.diffQueryAgainstStore({
                store: query.optimistic ? this.optimisticData : this.data,
                query: this.transformDocument(query.query),
                variables: query.variables,
                returnPartialData: query.returnPartialData,
                previousResult: query.previousResult,
                fragmentMatcherFunction: fragmentMatcherFunction,
                config: this.config,
            });
        };
        InMemoryCache.prototype.watch = function (watch) {
            var _this = this;
            this.watches.add(watch);
            return function () {
                _this.watches.delete(watch);
            };
        };
        InMemoryCache.prototype.evict = function (query) {
            throw process.env.NODE_ENV === "production" ? new InvariantError(1) : new InvariantError("eviction is not implemented on InMemory Cache");
        };
        InMemoryCache.prototype.reset = function () {
            this.data.clear();
            this.broadcastWatches();
            return Promise.resolve();
        };
        InMemoryCache.prototype.removeOptimistic = function (idToRemove) {
            var toReapply = [];
            var removedCount = 0;
            var layer = this.optimisticData;
            while (layer instanceof OptimisticCacheLayer) {
                if (layer.optimisticId === idToRemove) {
                    ++removedCount;
                }
                else {
                    toReapply.push(layer);
                }
                layer = layer.parent;
            }
            if (removedCount > 0) {
                this.optimisticData = layer;
                while (toReapply.length > 0) {
                    var layer_1 = toReapply.pop();
                    this.performTransaction(layer_1.transaction, layer_1.optimisticId);
                }
                this.broadcastWatches();
            }
        };
        InMemoryCache.prototype.performTransaction = function (transaction, optimisticId) {
            var _a = this, data = _a.data, silenceBroadcast = _a.silenceBroadcast;
            this.silenceBroadcast = true;
            if (typeof optimisticId === 'string') {
                this.data = this.optimisticData = new OptimisticCacheLayer(optimisticId, this.optimisticData, transaction);
            }
            try {
                transaction(this);
            }
            finally {
                this.silenceBroadcast = silenceBroadcast;
                this.data = data;
            }
            this.broadcastWatches();
        };
        InMemoryCache.prototype.recordOptimisticTransaction = function (transaction, id) {
            return this.performTransaction(transaction, id);
        };
        InMemoryCache.prototype.transformDocument = function (document) {
            if (this.addTypename) {
                var result = this.typenameDocumentCache.get(document);
                if (!result) {
                    result = addTypenameToDocument(document);
                    this.typenameDocumentCache.set(document, result);
                    this.typenameDocumentCache.set(result, result);
                }
                return result;
            }
            return document;
        };
        InMemoryCache.prototype.broadcastWatches = function () {
            var _this = this;
            if (!this.silenceBroadcast) {
                this.watches.forEach(function (c) { return _this.maybeBroadcastWatch(c); });
            }
        };
        InMemoryCache.prototype.maybeBroadcastWatch = function (c) {
            c.callback(this.diff({
                query: c.query,
                variables: c.variables,
                previousResult: c.previousResult && c.previousResult(),
                optimistic: c.optimistic,
            }));
        };
        return InMemoryCache;
    }(ApolloCache));
    //# sourceMappingURL=bundle.esm.js.map

    /**
     * Converts an AST into a string, using one set of reasonable
     * formatting rules.
     */

    function print(ast) {
      return visit(ast, {
        leave: printDocASTReducer
      });
    } // TODO: provide better type coverage in future

    var printDocASTReducer = {
      Name: function Name(node) {
        return node.value;
      },
      Variable: function Variable(node) {
        return '$' + node.name;
      },
      // Document
      Document: function Document(node) {
        return join(node.definitions, '\n\n') + '\n';
      },
      OperationDefinition: function OperationDefinition(node) {
        var op = node.operation;
        var name = node.name;
        var varDefs = wrap$1('(', join(node.variableDefinitions, ', '), ')');
        var directives = join(node.directives, ' ');
        var selectionSet = node.selectionSet; // Anonymous queries with no directives or variable definitions can use
        // the query short form.

        return !name && !directives && !varDefs && op === 'query' ? selectionSet : join([op, join([name, varDefs]), directives, selectionSet], ' ');
      },
      VariableDefinition: function VariableDefinition(_ref) {
        var variable = _ref.variable,
            type = _ref.type,
            defaultValue = _ref.defaultValue,
            directives = _ref.directives;
        return variable + ': ' + type + wrap$1(' = ', defaultValue) + wrap$1(' ', join(directives, ' '));
      },
      SelectionSet: function SelectionSet(_ref2) {
        var selections = _ref2.selections;
        return block(selections);
      },
      Field: function Field(_ref3) {
        var alias = _ref3.alias,
            name = _ref3.name,
            args = _ref3.arguments,
            directives = _ref3.directives,
            selectionSet = _ref3.selectionSet;
        return join([wrap$1('', alias, ': ') + name + wrap$1('(', join(args, ', '), ')'), join(directives, ' '), selectionSet], ' ');
      },
      Argument: function Argument(_ref4) {
        var name = _ref4.name,
            value = _ref4.value;
        return name + ': ' + value;
      },
      // Fragments
      FragmentSpread: function FragmentSpread(_ref5) {
        var name = _ref5.name,
            directives = _ref5.directives;
        return '...' + name + wrap$1(' ', join(directives, ' '));
      },
      InlineFragment: function InlineFragment(_ref6) {
        var typeCondition = _ref6.typeCondition,
            directives = _ref6.directives,
            selectionSet = _ref6.selectionSet;
        return join(['...', wrap$1('on ', typeCondition), join(directives, ' '), selectionSet], ' ');
      },
      FragmentDefinition: function FragmentDefinition(_ref7) {
        var name = _ref7.name,
            typeCondition = _ref7.typeCondition,
            variableDefinitions = _ref7.variableDefinitions,
            directives = _ref7.directives,
            selectionSet = _ref7.selectionSet;
        return (// Note: fragment variable definitions are experimental and may be changed
          // or removed in the future.
          "fragment ".concat(name).concat(wrap$1('(', join(variableDefinitions, ', '), ')'), " ") + "on ".concat(typeCondition, " ").concat(wrap$1('', join(directives, ' '), ' ')) + selectionSet
        );
      },
      // Value
      IntValue: function IntValue(_ref8) {
        var value = _ref8.value;
        return value;
      },
      FloatValue: function FloatValue(_ref9) {
        var value = _ref9.value;
        return value;
      },
      StringValue: function StringValue(_ref10, key) {
        var value = _ref10.value,
            isBlockString = _ref10.block;
        return isBlockString ? printBlockString(value, key === 'description' ? '' : '  ') : JSON.stringify(value);
      },
      BooleanValue: function BooleanValue(_ref11) {
        var value = _ref11.value;
        return value ? 'true' : 'false';
      },
      NullValue: function NullValue() {
        return 'null';
      },
      EnumValue: function EnumValue(_ref12) {
        var value = _ref12.value;
        return value;
      },
      ListValue: function ListValue(_ref13) {
        var values = _ref13.values;
        return '[' + join(values, ', ') + ']';
      },
      ObjectValue: function ObjectValue(_ref14) {
        var fields = _ref14.fields;
        return '{' + join(fields, ', ') + '}';
      },
      ObjectField: function ObjectField(_ref15) {
        var name = _ref15.name,
            value = _ref15.value;
        return name + ': ' + value;
      },
      // Directive
      Directive: function Directive(_ref16) {
        var name = _ref16.name,
            args = _ref16.arguments;
        return '@' + name + wrap$1('(', join(args, ', '), ')');
      },
      // Type
      NamedType: function NamedType(_ref17) {
        var name = _ref17.name;
        return name;
      },
      ListType: function ListType(_ref18) {
        var type = _ref18.type;
        return '[' + type + ']';
      },
      NonNullType: function NonNullType(_ref19) {
        var type = _ref19.type;
        return type + '!';
      },
      // Type System Definitions
      SchemaDefinition: function SchemaDefinition(_ref20) {
        var directives = _ref20.directives,
            operationTypes = _ref20.operationTypes;
        return join(['schema', join(directives, ' '), block(operationTypes)], ' ');
      },
      OperationTypeDefinition: function OperationTypeDefinition(_ref21) {
        var operation = _ref21.operation,
            type = _ref21.type;
        return operation + ': ' + type;
      },
      ScalarTypeDefinition: addDescription(function (_ref22) {
        var name = _ref22.name,
            directives = _ref22.directives;
        return join(['scalar', name, join(directives, ' ')], ' ');
      }),
      ObjectTypeDefinition: addDescription(function (_ref23) {
        var name = _ref23.name,
            interfaces = _ref23.interfaces,
            directives = _ref23.directives,
            fields = _ref23.fields;
        return join(['type', name, wrap$1('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');
      }),
      FieldDefinition: addDescription(function (_ref24) {
        var name = _ref24.name,
            args = _ref24.arguments,
            type = _ref24.type,
            directives = _ref24.directives;
        return name + (hasMultilineItems(args) ? wrap$1('(\n', indent(join(args, '\n')), '\n)') : wrap$1('(', join(args, ', '), ')')) + ': ' + type + wrap$1(' ', join(directives, ' '));
      }),
      InputValueDefinition: addDescription(function (_ref25) {
        var name = _ref25.name,
            type = _ref25.type,
            defaultValue = _ref25.defaultValue,
            directives = _ref25.directives;
        return join([name + ': ' + type, wrap$1('= ', defaultValue), join(directives, ' ')], ' ');
      }),
      InterfaceTypeDefinition: addDescription(function (_ref26) {
        var name = _ref26.name,
            directives = _ref26.directives,
            fields = _ref26.fields;
        return join(['interface', name, join(directives, ' '), block(fields)], ' ');
      }),
      UnionTypeDefinition: addDescription(function (_ref27) {
        var name = _ref27.name,
            directives = _ref27.directives,
            types = _ref27.types;
        return join(['union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');
      }),
      EnumTypeDefinition: addDescription(function (_ref28) {
        var name = _ref28.name,
            directives = _ref28.directives,
            values = _ref28.values;
        return join(['enum', name, join(directives, ' '), block(values)], ' ');
      }),
      EnumValueDefinition: addDescription(function (_ref29) {
        var name = _ref29.name,
            directives = _ref29.directives;
        return join([name, join(directives, ' ')], ' ');
      }),
      InputObjectTypeDefinition: addDescription(function (_ref30) {
        var name = _ref30.name,
            directives = _ref30.directives,
            fields = _ref30.fields;
        return join(['input', name, join(directives, ' '), block(fields)], ' ');
      }),
      DirectiveDefinition: addDescription(function (_ref31) {
        var name = _ref31.name,
            args = _ref31.arguments,
            repeatable = _ref31.repeatable,
            locations = _ref31.locations;
        return 'directive @' + name + (hasMultilineItems(args) ? wrap$1('(\n', indent(join(args, '\n')), '\n)') : wrap$1('(', join(args, ', '), ')')) + (repeatable ? ' repeatable' : '') + ' on ' + join(locations, ' | ');
      }),
      SchemaExtension: function SchemaExtension(_ref32) {
        var directives = _ref32.directives,
            operationTypes = _ref32.operationTypes;
        return join(['extend schema', join(directives, ' '), block(operationTypes)], ' ');
      },
      ScalarTypeExtension: function ScalarTypeExtension(_ref33) {
        var name = _ref33.name,
            directives = _ref33.directives;
        return join(['extend scalar', name, join(directives, ' ')], ' ');
      },
      ObjectTypeExtension: function ObjectTypeExtension(_ref34) {
        var name = _ref34.name,
            interfaces = _ref34.interfaces,
            directives = _ref34.directives,
            fields = _ref34.fields;
        return join(['extend type', name, wrap$1('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');
      },
      InterfaceTypeExtension: function InterfaceTypeExtension(_ref35) {
        var name = _ref35.name,
            directives = _ref35.directives,
            fields = _ref35.fields;
        return join(['extend interface', name, join(directives, ' '), block(fields)], ' ');
      },
      UnionTypeExtension: function UnionTypeExtension(_ref36) {
        var name = _ref36.name,
            directives = _ref36.directives,
            types = _ref36.types;
        return join(['extend union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');
      },
      EnumTypeExtension: function EnumTypeExtension(_ref37) {
        var name = _ref37.name,
            directives = _ref37.directives,
            values = _ref37.values;
        return join(['extend enum', name, join(directives, ' '), block(values)], ' ');
      },
      InputObjectTypeExtension: function InputObjectTypeExtension(_ref38) {
        var name = _ref38.name,
            directives = _ref38.directives,
            fields = _ref38.fields;
        return join(['extend input', name, join(directives, ' '), block(fields)], ' ');
      }
    };

    function addDescription(cb) {
      return function (node) {
        return join([node.description, cb(node)], '\n');
      };
    }
    /**
     * Given maybeArray, print an empty string if it is null or empty, otherwise
     * print all items together separated by separator if provided
     */


    function join(maybeArray, separator) {
      return maybeArray ? maybeArray.filter(function (x) {
        return x;
      }).join(separator || '') : '';
    }
    /**
     * Given array, print each item on its own line, wrapped in an
     * indented "{ }" block.
     */


    function block(array) {
      return array && array.length !== 0 ? '{\n' + indent(join(array, '\n')) + '\n}' : '';
    }
    /**
     * If maybeString is not null or empty, then wrap with start and end, otherwise
     * print an empty string.
     */


    function wrap$1(start, maybeString, end) {
      return maybeString ? start + maybeString + (end || '') : '';
    }

    function indent(maybeString) {
      return maybeString && '  ' + maybeString.replace(/\n/g, '\n  ');
    }

    function isMultiline(string) {
      return string.indexOf('\n') !== -1;
    }

    function hasMultilineItems(maybeArray) {
      return maybeArray && maybeArray.some(isMultiline);
    }

    var defaultHttpOptions = {
        includeQuery: true,
        includeExtensions: false,
    };
    var defaultHeaders = {
        accept: '*/*',
        'content-type': 'application/json',
    };
    var defaultOptions = {
        method: 'POST',
    };
    var fallbackHttpConfig = {
        http: defaultHttpOptions,
        headers: defaultHeaders,
        options: defaultOptions,
    };
    var throwServerError = function (response, result, message) {
        var error = new Error(message);
        error.name = 'ServerError';
        error.response = response;
        error.statusCode = response.status;
        error.result = result;
        throw error;
    };
    var parseAndCheckHttpResponse = function (operations) { return function (response) {
        return (response
            .text()
            .then(function (bodyText) {
            try {
                return JSON.parse(bodyText);
            }
            catch (err) {
                var parseError = err;
                parseError.name = 'ServerParseError';
                parseError.response = response;
                parseError.statusCode = response.status;
                parseError.bodyText = bodyText;
                return Promise.reject(parseError);
            }
        })
            .then(function (result) {
            if (response.status >= 300) {
                throwServerError(response, result, "Response not successful: Received status code " + response.status);
            }
            if (!Array.isArray(result) &&
                !result.hasOwnProperty('data') &&
                !result.hasOwnProperty('errors')) {
                throwServerError(response, result, "Server response was missing for query '" + (Array.isArray(operations)
                    ? operations.map(function (op) { return op.operationName; })
                    : operations.operationName) + "'.");
            }
            return result;
        }));
    }; };
    var checkFetcher = function (fetcher) {
        if (!fetcher && typeof fetch === 'undefined') {
            var library = 'unfetch';
            if (typeof window === 'undefined')
                library = 'node-fetch';
            throw process.env.NODE_ENV === "production" ? new InvariantError(1) : new InvariantError("\nfetch is not found globally and no fetcher passed, to fix pass a fetch for\nyour environment like https://www.npmjs.com/package/" + library + ".\n\nFor example:\nimport fetch from '" + library + "';\nimport { createHttpLink } from 'apollo-link-http';\n\nconst link = createHttpLink({ uri: '/graphql', fetch: fetch });");
        }
    };
    var createSignalIfSupported = function () {
        if (typeof AbortController === 'undefined')
            return { controller: false, signal: false };
        var controller = new AbortController();
        var signal = controller.signal;
        return { controller: controller, signal: signal };
    };
    var selectHttpOptionsAndBody = function (operation, fallbackConfig) {
        var configs = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            configs[_i - 2] = arguments[_i];
        }
        var options = __assign({}, fallbackConfig.options, { headers: fallbackConfig.headers, credentials: fallbackConfig.credentials });
        var http = fallbackConfig.http;
        configs.forEach(function (config) {
            options = __assign({}, options, config.options, { headers: __assign({}, options.headers, config.headers) });
            if (config.credentials)
                options.credentials = config.credentials;
            http = __assign({}, http, config.http);
        });
        var operationName = operation.operationName, extensions = operation.extensions, variables = operation.variables, query = operation.query;
        var body = { operationName: operationName, variables: variables };
        if (http.includeExtensions)
            body.extensions = extensions;
        if (http.includeQuery)
            body.query = print(query);
        return {
            options: options,
            body: body,
        };
    };
    var serializeFetchParameter = function (p, label) {
        var serialized;
        try {
            serialized = JSON.stringify(p);
        }
        catch (e) {
            var parseError = process.env.NODE_ENV === "production" ? new InvariantError(2) : new InvariantError("Network request failed. " + label + " is not serializable: " + e.message);
            parseError.parseError = e;
            throw parseError;
        }
        return serialized;
    };
    var selectURI = function (operation, fallbackURI) {
        var context = operation.getContext();
        var contextURI = context.uri;
        if (contextURI) {
            return contextURI;
        }
        else if (typeof fallbackURI === 'function') {
            return fallbackURI(operation);
        }
        else {
            return fallbackURI || '/graphql';
        }
    };
    //# sourceMappingURL=bundle.esm.js.map

    var createHttpLink = function (linkOptions) {
        if (linkOptions === void 0) { linkOptions = {}; }
        var _a = linkOptions.uri, uri = _a === void 0 ? '/graphql' : _a, fetcher = linkOptions.fetch, includeExtensions = linkOptions.includeExtensions, useGETForQueries = linkOptions.useGETForQueries, requestOptions = __rest(linkOptions, ["uri", "fetch", "includeExtensions", "useGETForQueries"]);
        checkFetcher(fetcher);
        if (!fetcher) {
            fetcher = fetch;
        }
        var linkConfig = {
            http: { includeExtensions: includeExtensions },
            options: requestOptions.fetchOptions,
            credentials: requestOptions.credentials,
            headers: requestOptions.headers,
        };
        return new ApolloLink(function (operation) {
            var chosenURI = selectURI(operation, uri);
            var context = operation.getContext();
            var clientAwarenessHeaders = {};
            if (context.clientAwareness) {
                var _a = context.clientAwareness, name_1 = _a.name, version = _a.version;
                if (name_1) {
                    clientAwarenessHeaders['apollographql-client-name'] = name_1;
                }
                if (version) {
                    clientAwarenessHeaders['apollographql-client-version'] = version;
                }
            }
            var contextHeaders = __assign({}, clientAwarenessHeaders, context.headers);
            var contextConfig = {
                http: context.http,
                options: context.fetchOptions,
                credentials: context.credentials,
                headers: contextHeaders,
            };
            var _b = selectHttpOptionsAndBody(operation, fallbackHttpConfig, linkConfig, contextConfig), options = _b.options, body = _b.body;
            var controller;
            if (!options.signal) {
                var _c = createSignalIfSupported(), _controller = _c.controller, signal = _c.signal;
                controller = _controller;
                if (controller)
                    options.signal = signal;
            }
            var definitionIsMutation = function (d) {
                return d.kind === 'OperationDefinition' && d.operation === 'mutation';
            };
            if (useGETForQueries &&
                !operation.query.definitions.some(definitionIsMutation)) {
                options.method = 'GET';
            }
            if (options.method === 'GET') {
                var _d = rewriteURIForGET(chosenURI, body), newURI = _d.newURI, parseError = _d.parseError;
                if (parseError) {
                    return fromError(parseError);
                }
                chosenURI = newURI;
            }
            else {
                try {
                    options.body = serializeFetchParameter(body, 'Payload');
                }
                catch (parseError) {
                    return fromError(parseError);
                }
            }
            return new Observable(function (observer) {
                fetcher(chosenURI, options)
                    .then(function (response) {
                    operation.setContext({ response: response });
                    return response;
                })
                    .then(parseAndCheckHttpResponse(operation))
                    .then(function (result) {
                    observer.next(result);
                    observer.complete();
                    return result;
                })
                    .catch(function (err) {
                    if (err.name === 'AbortError')
                        return;
                    if (err.result && err.result.errors && err.result.data) {
                        observer.next(err.result);
                    }
                    observer.error(err);
                });
                return function () {
                    if (controller)
                        controller.abort();
                };
            });
        });
    };
    function rewriteURIForGET(chosenURI, body) {
        var queryParams = [];
        var addQueryParam = function (key, value) {
            queryParams.push(key + "=" + encodeURIComponent(value));
        };
        if ('query' in body) {
            addQueryParam('query', body.query);
        }
        if (body.operationName) {
            addQueryParam('operationName', body.operationName);
        }
        if (body.variables) {
            var serializedVariables = void 0;
            try {
                serializedVariables = serializeFetchParameter(body.variables, 'Variables map');
            }
            catch (parseError) {
                return { parseError: parseError };
            }
            addQueryParam('variables', serializedVariables);
        }
        if (body.extensions) {
            var serializedExtensions = void 0;
            try {
                serializedExtensions = serializeFetchParameter(body.extensions, 'Extensions map');
            }
            catch (parseError) {
                return { parseError: parseError };
            }
            addQueryParam('extensions', serializedExtensions);
        }
        var fragment = '', preFragment = chosenURI;
        var fragmentStart = chosenURI.indexOf('#');
        if (fragmentStart !== -1) {
            fragment = chosenURI.substr(fragmentStart);
            preFragment = chosenURI.substr(0, fragmentStart);
        }
        var queryParamsPrefix = preFragment.indexOf('?') === -1 ? '?' : '&';
        var newURI = preFragment + queryParamsPrefix + queryParams.join('&') + fragment;
        return { newURI: newURI };
    }
    var HttpLink = (function (_super) {
        __extends(HttpLink, _super);
        function HttpLink(opts) {
            return _super.call(this, createHttpLink(opts).request) || this;
        }
        return HttpLink;
    }(ApolloLink));
    //# sourceMappingURL=bundle.esm.js.map

    function onError(errorHandler) {
        return new ApolloLink(function (operation, forward) {
            return new Observable(function (observer) {
                var sub;
                var retriedSub;
                var retriedResult;
                try {
                    sub = forward(operation).subscribe({
                        next: function (result) {
                            if (result.errors) {
                                retriedResult = errorHandler({
                                    graphQLErrors: result.errors,
                                    response: result,
                                    operation: operation,
                                    forward: forward,
                                });
                                if (retriedResult) {
                                    retriedSub = retriedResult.subscribe({
                                        next: observer.next.bind(observer),
                                        error: observer.error.bind(observer),
                                        complete: observer.complete.bind(observer),
                                    });
                                    return;
                                }
                            }
                            observer.next(result);
                        },
                        error: function (networkError) {
                            retriedResult = errorHandler({
                                operation: operation,
                                networkError: networkError,
                                graphQLErrors: networkError &&
                                    networkError.result &&
                                    networkError.result.errors,
                                forward: forward,
                            });
                            if (retriedResult) {
                                retriedSub = retriedResult.subscribe({
                                    next: observer.next.bind(observer),
                                    error: observer.error.bind(observer),
                                    complete: observer.complete.bind(observer),
                                });
                                return;
                            }
                            observer.error(networkError);
                        },
                        complete: function () {
                            if (!retriedResult) {
                                observer.complete.bind(observer)();
                            }
                        },
                    });
                }
                catch (e) {
                    errorHandler({ networkError: e, operation: operation, forward: forward });
                    observer.error(e);
                }
                return function () {
                    if (sub)
                        sub.unsubscribe();
                    if (retriedSub)
                        sub.unsubscribe();
                };
            });
        });
    }
    var ErrorLink = (function (_super) {
        __extends(ErrorLink, _super);
        function ErrorLink(errorHandler) {
            var _this = _super.call(this) || this;
            _this.link = onError(errorHandler);
            return _this;
        }
        ErrorLink.prototype.request = function (operation, forward) {
            return this.link.request(operation, forward);
        };
        return ErrorLink;
    }(ApolloLink));
    //# sourceMappingURL=bundle.esm.js.map

    var PRESET_CONFIG_KEYS = [
        'request',
        'uri',
        'credentials',
        'headers',
        'fetch',
        'fetchOptions',
        'clientState',
        'onError',
        'cacheRedirects',
        'cache',
        'name',
        'version',
        'resolvers',
        'typeDefs',
        'fragmentMatcher',
    ];
    var DefaultClient = (function (_super) {
        __extends(DefaultClient, _super);
        function DefaultClient(config) {
            if (config === void 0) { config = {}; }
            var _this = this;
            if (config) {
                var diff = Object.keys(config).filter(function (key) { return PRESET_CONFIG_KEYS.indexOf(key) === -1; });
                if (diff.length > 0) {
                    process.env.NODE_ENV === "production" || invariant.warn('ApolloBoost was initialized with unsupported options: ' +
                        ("" + diff.join(' ')));
                }
            }
            var request = config.request, uri = config.uri, credentials = config.credentials, headers = config.headers, fetch = config.fetch, fetchOptions = config.fetchOptions, clientState = config.clientState, cacheRedirects = config.cacheRedirects, errorCallback = config.onError, name = config.name, version = config.version, resolvers = config.resolvers, typeDefs = config.typeDefs, fragmentMatcher = config.fragmentMatcher;
            var cache = config.cache;
            process.env.NODE_ENV === "production" ? invariant(!cache || !cacheRedirects, 1) : invariant(!cache || !cacheRedirects, 'Incompatible cache configuration. When not providing `cache`, ' +
                'configure the provided instance with `cacheRedirects` instead.');
            if (!cache) {
                cache = cacheRedirects
                    ? new InMemoryCache({ cacheRedirects: cacheRedirects })
                    : new InMemoryCache();
            }
            var errorLink = errorCallback
                ? onError(errorCallback)
                : onError(function (_a) {
                    var graphQLErrors = _a.graphQLErrors, networkError = _a.networkError;
                    if (graphQLErrors) {
                        graphQLErrors.forEach(function (_a) {
                            var message = _a.message, locations = _a.locations, path = _a.path;
                            return process.env.NODE_ENV === "production" || invariant.warn("[GraphQL error]: Message: " + message + ", Location: " +
                                (locations + ", Path: " + path));
                        });
                    }
                    if (networkError) {
                        process.env.NODE_ENV === "production" || invariant.warn("[Network error]: " + networkError);
                    }
                });
            var requestHandler = request
                ? new ApolloLink(function (operation, forward) {
                    return new Observable(function (observer) {
                        var handle;
                        Promise.resolve(operation)
                            .then(function (oper) { return request(oper); })
                            .then(function () {
                            handle = forward(operation).subscribe({
                                next: observer.next.bind(observer),
                                error: observer.error.bind(observer),
                                complete: observer.complete.bind(observer),
                            });
                        })
                            .catch(observer.error.bind(observer));
                        return function () {
                            if (handle) {
                                handle.unsubscribe();
                            }
                        };
                    });
                })
                : false;
            var httpLink = new HttpLink({
                uri: uri || '/graphql',
                fetch: fetch,
                fetchOptions: fetchOptions || {},
                credentials: credentials || 'same-origin',
                headers: headers || {},
            });
            var link = ApolloLink.from([errorLink, requestHandler, httpLink].filter(function (x) { return !!x; }));
            var activeResolvers = resolvers;
            var activeTypeDefs = typeDefs;
            var activeFragmentMatcher = fragmentMatcher;
            if (clientState) {
                if (clientState.defaults) {
                    cache.writeData({
                        data: clientState.defaults,
                    });
                }
                activeResolvers = clientState.resolvers;
                activeTypeDefs = clientState.typeDefs;
                activeFragmentMatcher = clientState.fragmentMatcher;
            }
            _this = _super.call(this, {
                cache: cache,
                link: link,
                name: name,
                version: version,
                resolvers: activeResolvers,
                typeDefs: activeTypeDefs,
                fragmentMatcher: activeFragmentMatcher,
            }) || this;
            return _this;
        }
        return DefaultClient;
    }(ApolloClient));
    //# sourceMappingURL=bundle.esm.js.map

    /* src/App.svelte generated by Svelte v3.18.1 */

    function create_fragment$J(ctx) {
    	let current;

    	const router = new src_6({
    			props: {
    				routes,
    				currentRoute: /*currentRoute*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(router.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(router, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const router_changes = {};
    			if (dirty & /*currentRoute*/ 1) router_changes.currentRoute = /*currentRoute*/ ctx[0];
    			router.$set(router_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(router.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(router.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(router, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$E($$self, $$props, $$invalidate) {
    	const client = new DefaultClient({ uri: "http://localhost:3000/graphql" });
    	setClient(client);
    	let { currentRoute } = $$props;
    	const writable_props = ["currentRoute"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ("currentRoute" in $$props) $$invalidate(0, currentRoute = $$props.currentRoute);
    	};

    	$$self.$capture_state = () => {
    		return { currentRoute, num };
    	};

    	$$self.$inject_state = $$props => {
    		if ("currentRoute" in $$props) $$invalidate(0, currentRoute = $$props.currentRoute);
    		if ("num" in $$props) num = $$props.num;
    	};

    	let num;
    	 num = 0;
    	return [currentRoute];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$E, create_fragment$J, safe_not_equal, { currentRoute: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment$J.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*currentRoute*/ ctx[0] === undefined && !("currentRoute" in props)) {
    			console.warn("<App> was created without expected prop 'currentRoute'");
    		}
    	}

    	get currentRoute() {
    		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set currentRoute(value) {
    		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const app = new App({
    	target: document.body,
    	props: {
    		name: 'world'
    	}
    });

    return app;

}());
//# sourceMappingURL=bundle.js.map
